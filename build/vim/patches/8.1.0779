To: vim_dev@googlegroups.com
Subject: Patch 8.1.0779
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.1.0779
Problem:    Argument for message functions is inconsistent.
Solution:   Make first argument to msg() "char *".
Files:      src/buffer.c, src/crypt.c, src/edit.c, src/ex_cmds.c, src/eval.c,
            src/ex_cmds2.c, src/ex_docmd.c, src/ex_getln.c, src/farsi.c,
            src/if_cscope.c, src/fileio.c, src/getchar.c, src/globals.h,
            src/gui.c, src/if_perl.xs, src/netbeans.c, src/gui_w32.c,
            src/hardcopy.c, src/if_mzsch.c, src/if_py_both.h, src/if_ruby.c,
            src/if_tcl.c, src/mark.c, src/mbyte.c, src/menu.c, src/memline.c,
            src/message.c, src/misc1.c, src/misc2.c, src/normal.c, src/ops.c,
            src/option.c, src/os_amiga.c, src/os_unix.c, src/os_win32.c,
            src/proto/message.pro, src/quickfix.c, src/sign.c, src/regexp.c,
            src/ui.c, src/screen.c, src/search.c, src/spell.c,
            src/spellfile.c, src/syntax.c, src/tag.c, src/term.c, src/undo.c,
            src/userfunc.c, src/version.c, src/vim.h, src/window.c,
            src/proto/eval.pro, src/evalfunc.c, src/ex_eval.c, src/farsi.h


*** ../vim-8.1.0778/src/buffer.c	2019-01-17 15:43:21.753878419 +0100
--- src/buffer.c	2019-01-19 17:28:36.851024977 +0100
***************
*** 1083,1089 ****
  	/* User selected Recover at ATTENTION prompt. */
  	msg_scroll = TRUE;
  	ml_recover();
! 	MSG_PUTS("\n");	/* don't overwrite the last message */
  	cmdline_row = msg_row;
  	do_modelines(0);
  
--- 1083,1089 ----
  	/* User selected Recover at ATTENTION prompt. */
  	msg_scroll = TRUE;
  	ml_recover();
! 	msg_puts("\n");	/* don't overwrite the last message */
  	cmdline_row = msg_row;
  	do_modelines(0);
  
***************
*** 3449,3465 ****
  {
      char_u	*name;
      int		n;
!     char_u	*p;
!     char_u	*buffer;
      size_t	len;
  
!     buffer = alloc(IOSIZE);
      if (buffer == NULL)
  	return;
  
      if (fullname > 1)	    /* 2 CTRL-G: include buffer number */
      {
! 	vim_snprintf((char *)buffer, IOSIZE, "buf %d: ", curbuf->b_fnum);
  	p = buffer + STRLEN(buffer);
      }
      else
--- 3449,3465 ----
  {
      char_u	*name;
      int		n;
!     char	*p;
!     char	*buffer;
      size_t	len;
  
!     buffer = (char *)alloc(IOSIZE);
      if (buffer == NULL)
  	return;
  
      if (fullname > 1)	    /* 2 CTRL-G: include buffer number */
      {
! 	vim_snprintf(buffer, IOSIZE, "buf %d: ", curbuf->b_fnum);
  	p = buffer + STRLEN(buffer);
      }
      else
***************
*** 3467,3484 ****
  
      *p++ = '"';
      if (buf_spname(curbuf) != NULL)
! 	vim_strncpy(p, buf_spname(curbuf), IOSIZE - (p - buffer) - 1);
      else
      {
  	if (!fullname && curbuf->b_fname != NULL)
  	    name = curbuf->b_fname;
  	else
  	    name = curbuf->b_ffname;
! 	home_replace(shorthelp ? curbuf : NULL, name, p,
  					  (int)(IOSIZE - (p - buffer)), TRUE);
      }
  
!     vim_snprintf_add((char *)buffer, IOSIZE, "\"%s%s%s%s%s%s",
  	    curbufIsChanged() ? (shortmess(SHM_MOD)
  					  ?  " [+]" : _(" [Modified]")) : " ",
  	    (curbuf->b_flags & BF_NOTEDITED)
--- 3467,3484 ----
  
      *p++ = '"';
      if (buf_spname(curbuf) != NULL)
! 	vim_strncpy((char_u *)p, buf_spname(curbuf), IOSIZE - (p - buffer) - 1);
      else
      {
  	if (!fullname && curbuf->b_fname != NULL)
  	    name = curbuf->b_fname;
  	else
  	    name = curbuf->b_ffname;
! 	home_replace(shorthelp ? curbuf : NULL, name, (char_u *)p,
  					  (int)(IOSIZE - (p - buffer)), TRUE);
      }
  
!     vim_snprintf_add(buffer, IOSIZE, "\"%s%s%s%s%s%s",
  	    curbufIsChanged() ? (shortmess(SHM_MOD)
  					  ?  " [+]" : _(" [Modified]")) : " ",
  	    (curbuf->b_flags & BF_NOTEDITED)
***************
*** 3506,3534 ****
  	n = (int)(((long)curwin->w_cursor.lnum * 100L) /
  					    (long)curbuf->b_ml.ml_line_count);
      if (curbuf->b_ml.ml_flags & ML_EMPTY)
! 	vim_snprintf_add((char *)buffer, IOSIZE, "%s", _(no_lines_msg));
  #ifdef FEAT_CMDL_INFO
      else if (p_ru)
  	/* Current line and column are already on the screen -- webb */
! 	vim_snprintf_add((char *)buffer, IOSIZE,
  		NGETTEXT("%ld line --%d%%--", "%ld lines --%d%%--",
  						   curbuf->b_ml.ml_line_count),
  		(long)curbuf->b_ml.ml_line_count, n);
  #endif
      else
      {
! 	vim_snprintf_add((char *)buffer, IOSIZE,
  		_("line %ld of %ld --%d%%-- col "),
  		(long)curwin->w_cursor.lnum,
  		(long)curbuf->b_ml.ml_line_count,
  		n);
  	validate_virtcol();
  	len = STRLEN(buffer);
! 	col_print(buffer + len, IOSIZE - len,
  		   (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);
      }
  
!     (void)append_arg_number(curwin, buffer, IOSIZE, !shortmess(SHM_FILE));
  
      if (dont_truncate)
      {
--- 3506,3535 ----
  	n = (int)(((long)curwin->w_cursor.lnum * 100L) /
  					    (long)curbuf->b_ml.ml_line_count);
      if (curbuf->b_ml.ml_flags & ML_EMPTY)
! 	vim_snprintf_add(buffer, IOSIZE, "%s", _(no_lines_msg));
  #ifdef FEAT_CMDL_INFO
      else if (p_ru)
  	/* Current line and column are already on the screen -- webb */
! 	vim_snprintf_add(buffer, IOSIZE,
  		NGETTEXT("%ld line --%d%%--", "%ld lines --%d%%--",
  						   curbuf->b_ml.ml_line_count),
  		(long)curbuf->b_ml.ml_line_count, n);
  #endif
      else
      {
! 	vim_snprintf_add(buffer, IOSIZE,
  		_("line %ld of %ld --%d%%-- col "),
  		(long)curwin->w_cursor.lnum,
  		(long)curbuf->b_ml.ml_line_count,
  		n);
  	validate_virtcol();
  	len = STRLEN(buffer);
! 	col_print((char_u *)buffer + len, IOSIZE - len,
  		   (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);
      }
  
!     (void)append_arg_number(curwin, (char_u *)buffer, IOSIZE,
! 							 !shortmess(SHM_FILE));
  
      if (dont_truncate)
      {
***************
*** 3542,3555 ****
      }
      else
      {
! 	p = msg_trunc_attr(buffer, FALSE, 0);
  	if (restart_edit != 0 || (msg_scrolled && !need_wait_return))
  	    /* Need to repeat the message after redrawing when:
  	     * - When restart_edit is set (otherwise there will be a delay
  	     *   before redrawing).
  	     * - When the screen was scrolled but there is no wait-return
  	     *   prompt. */
! 	    set_keep_msg(p, 0);
      }
  
      vim_free(buffer);
--- 3543,3556 ----
      }
      else
      {
! 	p = (char *)msg_trunc_attr(buffer, FALSE, 0);
  	if (restart_edit != 0 || (msg_scrolled && !need_wait_return))
  	    /* Need to repeat the message after redrawing when:
  	     * - When restart_edit is set (otherwise there will be a delay
  	     *   before redrawing).
  	     * - When the screen was scrolled but there is no wait-return
  	     *   prompt. */
! 	    set_keep_msg((char_u *)p, 0);
      }
  
      vim_free(buffer);
*** ../vim-8.1.0778/src/crypt.c	2019-01-18 22:48:30.900796633 +0100
--- src/crypt.c	2019-01-19 16:02:15.177740710 +0100
***************
*** 513,519 ****
      if (method < CRYPT_M_BF2)
      {
  	msg_scroll = TRUE;
! 	MSG(_("Warning: Using a weak encryption method; see :help 'cm'"));
      }
  }
  
--- 513,519 ----
      if (method < CRYPT_M_BF2)
      {
  	msg_scroll = TRUE;
! 	msg(_("Warning: Using a weak encryption method; see :help 'cm'"));
      }
  }
  
***************
*** 555,561 ****
  	{
  	    if (p2 != NULL && STRCMP(p1, p2) != 0)
  	    {
! 		MSG(_("Keys don't match!"));
  		crypt_free_key(p1);
  		crypt_free_key(p2);
  		p2 = NULL;
--- 555,561 ----
  	{
  	    if (p2 != NULL && STRCMP(p1, p2) != 0)
  	    {
! 		msg(_("Keys don't match!"));
  		crypt_free_key(p1);
  		crypt_free_key(p2);
  		p2 = NULL;
*** ../vim-8.1.0778/src/edit.c	2019-01-17 21:09:02.045706371 +0100
--- src/edit.c	2019-01-19 17:28:55.114910991 +0100
***************
*** 2387,2394 ****
      {
  	ctrl_x_mode = CTRL_X_NORMAL;
  	edit_submode = NULL;
! 	msg_attr(dict_opt ? (char_u *)_("'dictionary' option is empty")
! 			  : (char_u *)_("'thesaurus' option is empty"),
  							      HL_ATTR(HLF_E));
  	if (emsg_silent == 0)
  	{
--- 2387,2394 ----
      {
  	ctrl_x_mode = CTRL_X_NORMAL;
  	edit_submode = NULL;
! 	msg_attr(dict_opt ? _("'dictionary' option is empty")
! 			  : _("'thesaurus' option is empty"),
  							      HL_ATTR(HLF_E));
  	if (emsg_silent == 0)
  	{
***************
*** 3385,3391 ****
  	{
  	    vim_snprintf((char *)IObuff, IOSIZE,
  			      _("Scanning dictionary: %s"), (char *)files[i]);
! 	    (void)msg_trunc_attr(IObuff, TRUE, HL_ATTR(HLF_R));
  	}
  
  	if (fp != NULL)
--- 3385,3391 ----
  	{
  	    vim_snprintf((char *)IObuff, IOSIZE,
  			      _("Scanning dictionary: %s"), (char *)files[i]);
! 	    (void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));
  	}
  
  	if (fp != NULL)
***************
*** 4500,4506 ****
  			    : ins_buf->b_sfname == NULL
  				? ins_buf->b_fname
  				: ins_buf->b_sfname);
! 		(void)msg_trunc_attr(IObuff, TRUE, HL_ATTR(HLF_R));
  	    }
  	    else if (*e_cpt == NUL)
  		break;
--- 4500,4506 ----
  			    : ins_buf->b_sfname == NULL
  				? ins_buf->b_fname
  				: ins_buf->b_sfname);
! 		(void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));
  	    }
  	    else if (*e_cpt == NUL)
  		break;
***************
*** 4530,4536 ****
  		{
  		    type = CTRL_X_TAGS;
  		    vim_snprintf((char *)IObuff, IOSIZE, _("Scanning tags."));
! 		    (void)msg_trunc_attr(IObuff, TRUE, HL_ATTR(HLF_R));
  		}
  		else
  		    type = -1;
--- 4530,4536 ----
  		{
  		    type = CTRL_X_TAGS;
  		    vim_snprintf((char *)IObuff, IOSIZE, _("Scanning tags."));
! 		    (void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));
  		}
  		else
  		    type = -1;
***************
*** 5132,5138 ****
  	    }
  	    vim_snprintf((char *)IObuff, IOSIZE, "%s %s%s", lead,
  				s > compl_shown_match->cp_fname ? "<" : "", s);
! 	    msg(IObuff);
  	    redraw_cmdline = FALSE;	    /* don't overwrite! */
  	}
      }
--- 5132,5138 ----
  	    }
  	    vim_snprintf((char *)IObuff, IOSIZE, "%s %s%s", lead,
  				s > compl_shown_match->cp_fname ? "<" : "", s);
! 	    msg((char *)IObuff);
  	    redraw_cmdline = FALSE;	    /* don't overwrite! */
  	}
      }
***************
*** 5878,5884 ****
  	    if (edit_submode_extra != NULL)
  	    {
  		if (!p_smd)
! 		    msg_attr(edit_submode_extra,
  			    edit_submode_highl < HLF_COUNT
  			    ? HL_ATTR(edit_submode_highl) : 0);
  	    }
--- 5878,5884 ----
  	    if (edit_submode_extra != NULL)
  	    {
  		if (!p_smd)
! 		    msg_attr((char *)edit_submode_extra,
  			    edit_submode_highl < HLF_COUNT
  			    ? HL_ATTR(edit_submode_highl) : 0);
  	    }
***************
*** 8856,8862 ****
      if (reg_recording != 0 || restart_edit != NUL)
  	showmode();
      else if (p_smd)
! 	MSG("");
  
      return TRUE;	    /* exit Insert mode */
  }
--- 8856,8862 ----
      if (reg_recording != 0 || restart_edit != NUL)
  	showmode();
      else if (p_smd)
! 	msg("");
  
      return TRUE;	    /* exit Insert mode */
  }
*** ../vim-8.1.0778/src/ex_cmds.c	2019-01-17 15:43:21.757878392 +0100
--- src/ex_cmds.c	2019-01-19 16:48:21.166931076 +0100
***************
*** 62,68 ****
  	c = gchar_cursor();
      if (c == NUL)
      {
! 	MSG("NUL");
  	return;
      }
  
--- 62,68 ----
  	c = gchar_cursor();
      if (c == NUL)
      {
! 	msg("NUL");
  	return;
      }
  
***************
*** 152,158 ****
      }
  #endif
  
!     msg(IObuff);
  }
  
  /*
--- 152,158 ----
      }
  #endif
  
!     msg((char *)IObuff);
  }
  
  /*
***************
*** 1490,1500 ****
  	{
  	    if (do_in)
  	    {
! 		vim_snprintf((char *)msg_buf, sizeof(msg_buf),
  				    _("%ld lines filtered"), (long)linecount);
  		if (msg(msg_buf) && !msg_scroll)
  		    /* save message to display it after redraw */
! 		    set_keep_msg(msg_buf, 0);
  	    }
  	    else
  		msgmore((long)linecount);
--- 1490,1500 ----
  	{
  	    if (do_in)
  	    {
! 		vim_snprintf(msg_buf, sizeof(msg_buf),
  				    _("%ld lines filtered"), (long)linecount);
  		if (msg(msg_buf) && !msg_scroll)
  		    /* save message to display it after redraw */
! 		    set_keep_msg((char_u *)msg_buf, 0);
  	    }
  	    else
  		msgmore((long)linecount);
***************
*** 1586,1592 ****
  		if (!winstart)
  		    starttermcap();	/* don't want a message box here */
  #endif
! 		MSG_PUTS(_("[No write since last change]\n"));
  #ifdef FEAT_GUI_MSWIN
  		if (!winstart)
  		    stoptermcap();
--- 1586,1592 ----
  		if (!winstart)
  		    starttermcap();	/* don't want a message box here */
  #endif
! 		msg_puts(_("[No write since last change]\n"));
  #ifdef FEAT_GUI_MSWIN
  		if (!winstart)
  		    stoptermcap();
***************
*** 3028,3038 ****
      int		use_number,
      int		list)
  {
!     char_u	numbuf[30];
  
      if (curwin->w_p_nu || use_number)
      {
! 	vim_snprintf((char *)numbuf, sizeof(numbuf),
  				   "%*ld ", number_width(curwin), (long)lnum);
  	msg_puts_attr(numbuf, HL_ATTR(HLF_N));	/* Highlight line nrs */
      }
--- 3028,3038 ----
      int		use_number,
      int		list)
  {
!     char	numbuf[30];
  
      if (curwin->w_p_nu || use_number)
      {
! 	vim_snprintf(numbuf, sizeof(numbuf),
  				   "%*ld ", number_width(curwin), (long)lnum);
  	msg_puts_attr(numbuf, HL_ATTR(HLF_N));	/* Highlight line nrs */
      }
***************
*** 5926,5932 ****
  		    beginline(BL_WHITE | BL_FIX);
  	    }
  	    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)
! 		MSG("");
  	}
  	else
  	    global_need_beginline = TRUE;
--- 5926,5932 ----
  		    beginline(BL_WHITE | BL_FIX);
  	    }
  	    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)
! 		msg("");
  	}
  	else
  	    global_need_beginline = TRUE;
***************
*** 5939,5945 ****
  	if (got_int)		/* interrupted */
  	    emsg(_(e_interr));
  	else if (got_match)	/* did find something but nothing substituted */
! 	    MSG("");
  	else if (subflags.do_error)	/* nothing found */
  	    semsg(_(e_patnotf2), get_search_pat());
      }
--- 5939,5945 ----
  	if (got_int)		/* interrupted */
  	    emsg(_(e_interr));
  	else if (got_match)	/* did find something but nothing substituted */
! 	    msg("");
  	else if (subflags.do_error)	/* nothing found */
  	    semsg(_(e_patnotf2), get_search_pat());
      }
***************
*** 5995,6007 ****
  		    : NGETTEXT("%ld substitution on %ld lines",
  				  "%ld substitutions on %ld lines", sub_nsubs);
  
! 	vim_snprintf_add((char *)msg_buf, sizeof(msg_buf),
  				 NGETTEXT(msg_single, msg_plural, sub_nlines),
  				 sub_nsubs, (long)sub_nlines);
  
  	if (msg(msg_buf))
  	    /* save message to display it after redraw */
! 	    set_keep_msg(msg_buf, 0);
  	return TRUE;
      }
      if (got_int)
--- 5995,6007 ----
  		    : NGETTEXT("%ld substitution on %ld lines",
  				  "%ld substitutions on %ld lines", sub_nsubs);
  
! 	vim_snprintf_add(msg_buf, sizeof(msg_buf),
  				 NGETTEXT(msg_single, msg_plural, sub_nlines),
  				 sub_nsubs, (long)sub_nlines);
  
  	if (msg(msg_buf))
  	    /* save message to display it after redraw */
! 	    set_keep_msg((char_u *)msg_buf, 0);
  	return TRUE;
      }
      if (got_int)
***************
*** 6147,6153 ****
  	 * pass 2: execute the command for each line that has been marked
  	 */
  	if (got_int)
! 	    MSG(_(e_interr));
  	else if (ndone == 0)
  	{
  	    if (type == 'v')
--- 6147,6153 ----
  	 * pass 2: execute the command for each line that has been marked
  	 */
  	if (got_int)
! 	    msg(_(e_interr));
  	else if (ndone == 0)
  	{
  	    if (type == 'v')
***************
*** 7755,7761 ****
      char_u	*fname;
  
      if (l == NULL)
! 	msg((char_u *)_("No old files"));
      else
      {
  	msg_start();
--- 7755,7761 ----
      char_u	*fname;
  
      if (l == NULL)
! 	msg(_("No old files"));
      else
      {
  	msg_start();
***************
*** 7767,7773 ****
  	    if (!message_filtered(fname))
  	    {
  		msg_outnum((long)nr);
! 		MSG_PUTS(": ");
  		msg_outtrans(fname);
  		msg_clr_eos();
  		msg_putchar('\n');
--- 7767,7773 ----
  	    if (!message_filtered(fname))
  	    {
  		msg_outnum((long)nr);
! 		msg_puts(": ");
  		msg_outtrans(fname);
  		msg_clr_eos();
  		msg_putchar('\n');
*** ../vim-8.1.0778/src/eval.c	2019-01-17 17:13:25.916984116 +0100
--- src/eval.c	2019-01-19 17:21:50.285476779 +0100
***************
*** 245,252 ****
  static void check_vars(char_u *name, int len);
  static typval_T *alloc_string_tv(char_u *string);
  static void delete_var(hashtab_T *ht, hashitem_T *hi);
! static void list_one_var(dictitem_T *v, char_u *prefix, int *first);
! static void list_one_var_a(char_u *prefix, char_u *name, int type, char_u *string, int *first);
  static char_u *find_option_end(char_u **arg, int *opt_flags);
  
  /* for VIM_VERSION_ defines */
--- 245,252 ----
  static void check_vars(char_u *name, int len);
  static typval_T *alloc_string_tv(char_u *string);
  static void delete_var(hashtab_T *ht, hashitem_T *hi);
! static void list_one_var(dictitem_T *v, char *prefix, int *first);
! static void list_one_var_a(char *prefix, char_u *name, int type, char_u *string, int *first);
  static char_u *find_option_end(char_u **arg, int *opt_flags);
  
  /* for VIM_VERSION_ defines */
***************
*** 1448,1454 ****
      void
  list_hashtable_vars(
      hashtab_T	*ht,
!     char_u	*prefix,
      int		empty,
      int		*first)
  {
--- 1448,1454 ----
      void
  list_hashtable_vars(
      hashtab_T	*ht,
!     char	*prefix,
      int		empty,
      int		*first)
  {
***************
*** 1466,1473 ****
  	    di = HI2DI(hi);
  
  	    // apply :filter /pat/ to variable name
! 	    vim_strncpy((char_u *) buf, prefix, IOSIZE - 1);
! 	    vim_strcat((char_u *) buf, di->di_key, IOSIZE);
  	    if (message_filtered(buf))
  		continue;
  
--- 1466,1473 ----
  	    di = HI2DI(hi);
  
  	    // apply :filter /pat/ to variable name
! 	    vim_strncpy((char_u *)buf, (char_u *)prefix, IOSIZE - 1);
! 	    vim_strcat((char_u *)buf, di->di_key, IOSIZE);
  	    if (message_filtered(buf))
  		continue;
  
***************
*** 1484,1490 ****
      static void
  list_glob_vars(int *first)
  {
!     list_hashtable_vars(&globvarht, (char_u *)"", TRUE, first);
  }
  
  /*
--- 1484,1490 ----
      static void
  list_glob_vars(int *first)
  {
!     list_hashtable_vars(&globvarht, "", TRUE, first);
  }
  
  /*
***************
*** 1493,1500 ****
      static void
  list_buf_vars(int *first)
  {
!     list_hashtable_vars(&curbuf->b_vars->dv_hashtab, (char_u *)"b:",
! 								 TRUE, first);
  }
  
  /*
--- 1493,1499 ----
      static void
  list_buf_vars(int *first)
  {
!     list_hashtable_vars(&curbuf->b_vars->dv_hashtab, "b:", TRUE, first);
  }
  
  /*
***************
*** 1503,1510 ****
      static void
  list_win_vars(int *first)
  {
!     list_hashtable_vars(&curwin->w_vars->dv_hashtab,
! 						 (char_u *)"w:", TRUE, first);
  }
  
  /*
--- 1502,1508 ----
      static void
  list_win_vars(int *first)
  {
!     list_hashtable_vars(&curwin->w_vars->dv_hashtab, "w:", TRUE, first);
  }
  
  /*
***************
*** 1513,1520 ****
      static void
  list_tab_vars(int *first)
  {
!     list_hashtable_vars(&curtab->tp_vars->dv_hashtab,
! 						 (char_u *)"t:", TRUE, first);
  }
  
  /*
--- 1511,1517 ----
      static void
  list_tab_vars(int *first)
  {
!     list_hashtable_vars(&curtab->tp_vars->dv_hashtab, "t:", TRUE, first);
  }
  
  /*
***************
*** 1523,1529 ****
      static void
  list_vim_vars(int *first)
  {
!     list_hashtable_vars(&vimvarht, (char_u *)"v:", FALSE, first);
  }
  
  /*
--- 1520,1526 ----
      static void
  list_vim_vars(int *first)
  {
!     list_hashtable_vars(&vimvarht, "v:", FALSE, first);
  }
  
  /*
***************
*** 1534,1540 ****
  {
      if (current_sctx.sc_sid > 0 && current_sctx.sc_sid <= ga_scripts.ga_len)
  	list_hashtable_vars(&SCRIPT_VARS(current_sctx.sc_sid),
! 						(char_u *)"s:", FALSE, first);
  }
  
  /*
--- 1531,1537 ----
  {
      if (current_sctx.sc_sid > 0 && current_sctx.sc_sid <= ga_scripts.ga_len)
  	list_hashtable_vars(&SCRIPT_VARS(current_sctx.sc_sid),
! 							   "s:", FALSE, first);
  }
  
  /*
***************
*** 1619,1625 ****
  			    s = echo_string(&tv, &tf, numbuf, 0);
  			    c = *arg;
  			    *arg = NUL;
! 			    list_one_var_a((char_u *)"",
  				    arg == arg_subsc ? name : name_start,
  				    tv.v_type,
  				    s == NULL ? (char_u *)"" : s,
--- 1616,1622 ----
  			    s = echo_string(&tv, &tf, numbuf, 0);
  			    c = *arg;
  			    *arg = NUL;
! 			    list_one_var_a("",
  				    arg == arg_subsc ? name : name_start,
  				    tv.v_type,
  				    s == NULL ? (char_u *)"" : s,
***************
*** 5462,5468 ****
      }
      else if (p_verbose > 0)
      {
! 	verb_msg((char_u *)_("Not enough memory to set references, garbage collection aborted!"));
      }
  
      return did_free;
--- 5459,5465 ----
      }
      else if (p_verbose > 0)
      {
! 	verb_msg(_("Not enough memory to set references, garbage collection aborted!"));
      }
  
      return did_free;
***************
*** 7791,7797 ****
   * List the value of one internal variable.
   */
      static void
! list_one_var(dictitem_T *v, char_u *prefix, int *first)
  {
      char_u	*tofree;
      char_u	*s;
--- 7788,7794 ----
   * List the value of one internal variable.
   */
      static void
! list_one_var(dictitem_T *v, char *prefix, int *first)
  {
      char_u	*tofree;
      char_u	*s;
***************
*** 7805,7811 ****
  
      static void
  list_one_var_a(
!     char_u	*prefix,
      char_u	*name,
      int		type,
      char_u	*string,
--- 7802,7808 ----
  
      static void
  list_one_var_a(
!     char	*prefix,
      char_u	*name,
      int		type,
      char_u	*string,
***************
*** 7815,7821 ****
      msg_start();
      msg_puts(prefix);
      if (name != NULL)	/* "a:" vars don't have a name stored */
! 	msg_puts(name);
      msg_putchar(' ');
      msg_advance(22);
      if (type == VAR_NUMBER)
--- 7812,7818 ----
      msg_start();
      msg_puts(prefix);
      if (name != NULL)	/* "a:" vars don't have a name stored */
! 	msg_puts((char *)name);
      msg_putchar(' ');
      msg_advance(22);
      if (type == VAR_NUMBER)
***************
*** 7840,7846 ****
      msg_outtrans(string);
  
      if (type == VAR_FUNC || type == VAR_PARTIAL)
! 	msg_puts((char_u *)"()");
      if (*first)
      {
  	msg_clr_eos();
--- 7837,7843 ----
      msg_outtrans(string);
  
      if (type == VAR_FUNC || type == VAR_PARTIAL)
! 	msg_puts("()");
      if (*first)
      {
  	msg_clr_eos();
***************
*** 8304,8310 ****
  	    *p = NUL;
  	    msg_start();
  	    msg_clr_eos();
! 	    msg_puts_attr(prompt, echo_attr);
  	    msg_didout = FALSE;
  	    msg_starthere();
  	    *p = c;
--- 8301,8307 ----
  	    *p = NUL;
  	    msg_start();
  	    msg_clr_eos();
! 	    msg_puts_attr((char *)prompt, echo_attr);
  	    msg_didout = FALSE;
  	    msg_starthere();
  	    *p = c;
***************
*** 8422,8428 ****
  		}
  	    }
  	    else if (eap->cmdidx == CMD_echo)
! 		msg_puts_attr((char_u *)" ", echo_attr);
  	    p = echo_string(&rettv, &tofree, numbuf, get_copyID());
  	    if (p != NULL)
  		for ( ; *p != NUL && !got_int; ++p)
--- 8419,8425 ----
  		}
  	    }
  	    else if (eap->cmdidx == CMD_echo)
! 		msg_puts_attr(" ", echo_attr);
  	    p = echo_string(&rettv, &tofree, numbuf, get_copyID());
  	    if (p != NULL)
  		for ( ; *p != NUL && !got_int; ++p)
***************
*** 8546,8552 ****
  
  	if (eap->cmdidx == CMD_echomsg)
  	{
! 	    MSG_ATTR(ga.ga_data, echo_attr);
  	    out_flush();
  	}
  	else if (eap->cmdidx == CMD_echoerr)
--- 8543,8549 ----
  
  	if (eap->cmdidx == CMD_echomsg)
  	{
! 	    msg_attr(ga.ga_data, echo_attr);
  	    out_flush();
  	}
  	else if (eap->cmdidx == CMD_echoerr)
***************
*** 9159,9169 ****
  	if (p != NULL)
  	{
  	    verbose_enter();
! 	    MSG_PUTS(_("\n\tLast set from "));
! 	    MSG_PUTS(p);
  	    if (script_ctx.sc_lnum > 0)
  	    {
! 		MSG_PUTS(_(" line "));
  		msg_outnum((long)script_ctx.sc_lnum);
  	    }
  	    verbose_leave();
--- 9156,9166 ----
  	if (p != NULL)
  	{
  	    verbose_enter();
! 	    msg_puts(_("\n\tLast set from "));
! 	    msg_puts((char *)p);
  	    if (script_ctx.sc_lnum > 0)
  	    {
! 		msg_puts(_(" line "));
  		msg_outnum((long)script_ctx.sc_lnum);
  	    }
  	    verbose_leave();
*** ../vim-8.1.0778/src/ex_cmds2.c	2019-01-13 23:38:33.387773334 +0100
--- src/ex_cmds2.c	2019-01-19 16:03:22.589277848 +0100
***************
*** 143,149 ****
      debug_mode = TRUE;
  
      if (!debug_did_msg)
! 	MSG(_("Entering Debug mode.  Type \"cont\" to continue."));
      if (debug_oldval != NULL)
      {
  	smsg(_("Oldval = \"%s\""), debug_oldval);
--- 143,149 ----
      debug_mode = TRUE;
  
      if (!debug_did_msg)
! 	msg(_("Entering Debug mode.  Type \"cont\" to continue."));
      if (debug_oldval != NULL)
      {
  	smsg(_("Oldval = \"%s\""), debug_oldval);
***************
*** 157,163 ****
  	debug_newval = NULL;
      }
      if (sourcing_name != NULL)
! 	msg(sourcing_name);
      if (sourcing_lnum != 0)
  	smsg(_("line %ld: %s"), (long)sourcing_lnum, cmd);
      else
--- 157,163 ----
  	debug_newval = NULL;
      }
      if (sourcing_name != NULL)
! 	msg((char *)sourcing_name);
      if (sourcing_lnum != 0)
  	smsg(_("line %ld: %s"), (long)sourcing_lnum, cmd);
      else
***************
*** 390,396 ****
      if (debug_backtrace_level < 0)
      {
  	debug_backtrace_level = 0;
! 	MSG(_("frame is zero"));
      }
      else
      {
--- 390,396 ----
      if (debug_backtrace_level < 0)
      {
  	debug_backtrace_level = 0;
! 	msg(_("frame is zero"));
      }
      else
      {
***************
*** 857,863 ****
      int		i;
  
      if (dbg_breakp.ga_len == 0)
! 	MSG(_("No breakpoints defined"));
      else
  	for (i = 0; i < dbg_breakp.ga_len; ++i)
  	{
--- 857,863 ----
      int		i;
  
      if (dbg_breakp.ga_len == 0)
! 	msg(_("No breakpoints defined"));
      else
  	for (i = 0; i < dbg_breakp.ga_len; ++i)
  	{
***************
*** 2430,2436 ****
      if (curbuf != old_curbuf)
      {
  	msg_source(HL_ATTR(HLF_W));
! 	MSG(_("Warning: Entered other buffer unexpectedly (check autocommands)"));
      }
      return retval;
  }
--- 2430,2436 ----
      if (curbuf != old_curbuf)
      {
  	msg_source(HL_ATTR(HLF_W));
! 	msg(_("Warning: Entered other buffer unexpectedly (check autocommands)"));
      }
      return retval;
  }
***************
*** 4112,4118 ****
  	vim_snprintf((char *)IObuff, IOSIZE,
  		_("W20: Required python version 2.x not supported, ignoring file: %s"),
  		fname);
! 	MSG(IObuff);
  # endif
  	return;
      }
--- 4112,4118 ----
  	vim_snprintf((char *)IObuff, IOSIZE,
  		_("W20: Required python version 2.x not supported, ignoring file: %s"),
  		fname);
! 	msg((char *)IObuff);
  # endif
  	return;
      }
***************
*** 4124,4130 ****
  	vim_snprintf((char *)IObuff, IOSIZE,
  		_("W21: Required python version 3.x not supported, ignoring file: %s"),
  		fname);
! 	MSG(IObuff);
  # endif
  	return;
      }
--- 4124,4130 ----
  	vim_snprintf((char *)IObuff, IOSIZE,
  		_("W21: Required python version 3.x not supported, ignoring file: %s"),
  		fname);
! 	msg((char *)IObuff);
  # endif
  	return;
      }
*** ../vim-8.1.0778/src/ex_docmd.c	2019-01-17 15:43:21.757878392 +0100
--- src/ex_docmd.c	2019-01-19 17:03:26.728897747 +0100
***************
*** 562,568 ****
      ++hold_gui_events;
  #endif
  
!     MSG(_("Entering Ex mode.  Type \"visual\" to go to Normal mode."));
      while (exmode_active)
      {
  	/* Check for a ":normal" command and no more characters left. */
--- 562,568 ----
      ++hold_gui_events;
  #endif
  
!     msg(_("Entering Ex mode.  Type \"visual\" to go to Normal mode."));
      while (exmode_active)
      {
  	/* Check for a ":normal" command and no more characters left. */
***************
*** 1019,1025 ****
  	    smsg(_("line %ld: %s"),
  					   (long)sourcing_lnum, cmdline_copy);
  	    if (msg_silent == 0)
! 		msg_puts((char_u *)"\n");   /* don't overwrite this */
  
  	    verbose_leave_scroll();
  	    --no_wait_return;
--- 1019,1025 ----
  	    smsg(_("line %ld: %s"),
  					   (long)sourcing_lnum, cmdline_copy);
  	    if (msg_silent == 0)
! 		msg_puts("\n");   /* don't overwrite this */
  
  	    verbose_leave_scroll();
  	    --no_wait_return;
***************
*** 6043,6049 ****
  
  	    /* Put out the title first time */
  	    if (!found)
! 		MSG_PUTS_TITLE(_("\n    Name        Args       Address   Complete  Definition"));
  	    found = TRUE;
  	    msg_putchar('\n');
  	    if (got_int)
--- 6043,6049 ----
  
  	    /* Put out the title first time */
  	    if (!found)
! 		msg_puts_title(_("\n    Name        Args       Address   Complete  Definition"));
  	    found = TRUE;
  	    msg_putchar('\n');
  	    if (got_int)
***************
*** 6150,6156 ****
      }
  
      if (!found)
! 	MSG(_("No user-defined commands found"));
  }
  
      static char *
--- 6150,6156 ----
      }
  
      if (!found)
! 	msg(_("No user-defined commands found"));
  }
  
      static char *
***************
*** 7239,7251 ****
  	}
  	if (p != NULL)
  	{
! 	    MSG(p);
  	    vim_free(p);
  	}
  	else
! 	    MSG("default");
  #else
! 	MSG(_("unknown"));
  #endif
      }
      else if (load_colors(eap->arg) == FAIL)
--- 7239,7251 ----
  	}
  	if (p != NULL)
  	{
! 	    msg((char *)p);
  	    vim_free(p);
  	}
  	else
! 	    msg("default");
  #else
! 	msg(_("unknown"));
  #endif
      }
      else if (load_colors(eap->arg) == FAIL)
***************
*** 7256,7262 ****
  ex_highlight(exarg_T *eap)
  {
      if (*eap->arg == NUL && eap->cmd[2] == '!')
! 	MSG(_("Greetings, Vim user!"));
      do_highlight(eap->arg, eap->forceit, FALSE);
  }
  
--- 7256,7262 ----
  ex_highlight(exarg_T *eap)
  {
      if (*eap->arg == NUL && eap->cmd[2] == '!')
! 	msg(_("Greetings, Vim user!"));
      do_highlight(eap->arg, eap->forceit, FALSE);
  }
  
***************
*** 7672,7678 ****
      else
  # endif
  	if (first_tabpage->tp_next == NULL)
! 	    MSG(_("Already only one tab page"));
  	else
  	{
  	    tab_number = get_tabpage_arg(eap);
--- 7672,7678 ----
      else
  # endif
  	if (first_tabpage->tp_next == NULL)
! 	    msg(_("Already only one tab page"));
  	else
  	{
  	    tab_number = get_tabpage_arg(eap);
***************
*** 8921,8929 ****
  ex_swapname(exarg_T *eap UNUSED)
  {
      if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)
! 	MSG(_("No swap file"));
      else
! 	msg(curbuf->b_ml.ml_mfp->mf_fname);
  }
  
  /*
--- 8921,8929 ----
  ex_swapname(exarg_T *eap UNUSED)
  {
      if (curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_mfp->mf_fname == NULL)
! 	msg(_("No swap file"));
      else
! 	msg((char *)curbuf->b_ml.ml_mfp->mf_fname);
  }
  
  /*
***************
*** 9221,9227 ****
  #ifdef BACKSLASH_IN_FILENAME
  	slash_adjust(NameBuff);
  #endif
! 	msg(NameBuff);
      }
      else
  	emsg(_("E187: Unknown"));
--- 9221,9227 ----
  #ifdef BACKSLASH_IN_FILENAME
  	slash_adjust(NameBuff);
  #endif
! 	msg((char *)NameBuff);
      }
      else
  	emsg(_("E187: Unknown"));
***************
*** 9402,9408 ****
  #  endif
  	{
  	    sprintf((char *)IObuff, _("Window position: X %d, Y %d"), x, y);
! 	    msg(IObuff);
  	}
  	else
  # endif
--- 9402,9408 ----
  #  endif
  	{
  	    sprintf((char *)IObuff, _("Window position: X %d, Y %d"), x, y);
! 	    msg((char *)IObuff);
  	}
  	else
  # endif
*** ../vim-8.1.0778/src/ex_getln.c	2019-01-13 23:38:33.391773303 +0100
--- src/ex_getln.c	2019-01-19 17:07:38.711194397 +0100
***************
*** 158,164 ****
      VIM_CLEAR(ccline.cmdbuff);
      if (msg_scrolled == 0)
  	compute_cmdrow();
!     MSG("");
      redraw_cmdline = TRUE;
  }
  
--- 158,164 ----
      VIM_CLEAR(ccline.cmdbuff);
      if (msg_scrolled == 0)
  	compute_cmdrow();
!     msg("");
      redraw_cmdline = TRUE;
  }
  
***************
*** 2786,2792 ****
  	while (indent >= 8)
  	{
  	    ga_append(&line_ga, TAB);
! 	    msg_puts((char_u *)"        ");
  	    indent -= 8;
  	}
  	while (indent-- > 0)
--- 2786,2792 ----
  	while (indent >= 8)
  	{
  	    ga_append(&line_ga, TAB);
! 	    msg_puts("        ");
  	    indent -= 8;
  	}
  	while (indent-- > 0)
***************
*** 3769,3775 ****
  	msg_putchar(ccline.cmdfirstc);
      if (ccline.cmdprompt != NULL)
      {
! 	msg_puts_attr(ccline.cmdprompt, ccline.cmdattr);
  	ccline.cmdindent = msg_col + (msg_row - cmdline_row) * Columns;
  	/* do the reverse of set_cmdspos() */
  	if (ccline.cmdfirstc != NUL)
--- 3769,3775 ----
  	msg_putchar(ccline.cmdfirstc);
      if (ccline.cmdprompt != NULL)
      {
! 	msg_puts_attr((char *)ccline.cmdprompt, ccline.cmdattr);
  	ccline.cmdindent = msg_col + (msg_row - cmdline_row) * Columns;
  	/* do the reverse of set_cmdspos() */
  	if (ccline.cmdfirstc != NUL)
***************
*** 3961,3967 ****
  	return FAIL;
      }
  
!     MSG_PUTS("...");	    /* show that we are busy */
      out_flush();
  
      i = (int)(xp->xp_pattern - ccline.cmdbuff);
--- 3961,3967 ----
  	return FAIL;
      }
  
!     msg_puts("...");	    /* show that we are busy */
      out_flush();
  
      i = (int)(xp->xp_pattern - ccline.cmdbuff);
***************
*** 4611,4620 ****
  
  	if (xp->xp_context == EXPAND_TAGS_LISTFILES)
  	{
! 	    MSG_PUTS_ATTR(_("tagname"), HL_ATTR(HLF_T));
  	    msg_clr_eos();
  	    msg_advance(maxlen - 3);
! 	    MSG_PUTS_ATTR(_(" kind file\n"), HL_ATTR(HLF_T));
  	}
  
  	/* list the files line by line */
--- 4611,4620 ----
  
  	if (xp->xp_context == EXPAND_TAGS_LISTFILES)
  	{
! 	    msg_puts_attr(_("tagname"), HL_ATTR(HLF_T));
  	    msg_clr_eos();
  	    msg_advance(maxlen - 3);
! 	    msg_puts_attr(_(" kind file\n"), HL_ATTR(HLF_T));
  	}
  
  	/* list the files line by line */
***************
*** 4628,4636 ****
  		    msg_outtrans_attr(files_found[k], HL_ATTR(HLF_D));
  		    p = files_found[k] + STRLEN(files_found[k]) + 1;
  		    msg_advance(maxlen + 1);
! 		    msg_puts(p);
  		    msg_advance(maxlen + 3);
! 		    msg_puts_long_attr(p + 2, HL_ATTR(HLF_D));
  		    break;
  		}
  		for (j = maxlen - lastlen; --j >= 0; )
--- 4628,4636 ----
  		    msg_outtrans_attr(files_found[k], HL_ATTR(HLF_D));
  		    p = files_found[k] + STRLEN(files_found[k]) + 1;
  		    msg_advance(maxlen + 1);
! 		    msg_puts((char *)p);
  		    msg_advance(maxlen + 3);
! 		    msg_outtrans_long_attr(p + 2, HL_ATTR(HLF_D));
  		    break;
  		}
  		for (j = maxlen - lastlen; --j >= 0; )
***************
*** 6635,6641 ****
  
      if (hislen == 0)
      {
! 	MSG(_("'history' option is zero"));
  	return;
      }
  
--- 6635,6641 ----
  
      if (hislen == 0)
      {
! 	msg(_("'history' option is zero"));
  	return;
      }
  
***************
*** 6678,6684 ****
      {
  	STRCPY(IObuff, "\n      #  ");
  	STRCAT(STRCAT(IObuff, history_names[histype1]), " history");
! 	MSG_PUTS_TITLE(IObuff);
  	idx = hisidx[histype1];
  	hist = history[histype1];
  	j = hisidx1;
--- 6678,6684 ----
      {
  	STRCPY(IObuff, "\n      #  ");
  	STRCAT(STRCAT(IObuff, history_names[histype1]), " history");
! 	msg_puts_title((char *)IObuff);
  	idx = hisidx[histype1];
  	hist = history[histype1];
  	j = hisidx1;
*** ../vim-8.1.0778/src/farsi.c	2017-04-07 13:52:06.000000000 +0200
--- src/farsi.c	2019-01-19 17:17:29.759186522 +0100
***************
*** 1719,1725 ****
  
      /* Assume the screen has been messed up: clear it and redraw. */
      redraw_later(CLEAR);
!     MSG_ATTR(farsi_text_1, HL_ATTR(HLF_S));
  }
  
  /*
--- 1719,1725 ----
  
      /* Assume the screen has been messed up: clear it and redraw. */
      redraw_later(CLEAR);
!     msg_attr(farsi_text_1, HL_ATTR(HLF_S));
  }
  
  /*
***************
*** 1747,1753 ****
  
      /* Assume the screen has been messed up: clear it and redraw. */
      redraw_later(CLEAR);
!     MSG_ATTR(farsi_text_2, HL_ATTR(HLF_S));
  }
  
  /*
--- 1747,1753 ----
  
      /* Assume the screen has been messed up: clear it and redraw. */
      redraw_later(CLEAR);
!     msg_attr(farsi_text_2, HL_ATTR(HLF_S));
  }
  
  /*
***************
*** 2150,2162 ****
  	{
  	    p_fkmap = 0;
  	    do_cmdline_cmd((char_u *)"set norl");
! 	    MSG("");
  	}
  	else
  	{
  	    p_fkmap = 1;
  	    do_cmdline_cmd((char_u *)"set rl");
! 	    MSG("");
  	}
  
  	curwin->w_farsi = curwin->w_farsi ^ W_R_L;
--- 2150,2162 ----
  	{
  	    p_fkmap = 0;
  	    do_cmdline_cmd((char_u *)"set norl");
! 	    msg("");
  	}
  	else
  	{
  	    p_fkmap = 1;
  	    do_cmdline_cmd((char_u *)"set rl");
! 	    msg("");
  	}
  
  	curwin->w_farsi = curwin->w_farsi ^ W_R_L;
*** ../vim-8.1.0778/src/if_cscope.c	2019-01-15 20:19:36.743904434 +0100
--- src/if_cscope.c	2019-01-19 17:17:42.283101491 +0100
***************
*** 212,218 ****
      {
  	if (!cmdp->cansplit)
  	{
! 	    (void)MSG_PUTS(_("This cscope command does not support splitting the window.\n"));
  	    return;
  	}
  	postponed_split = -1;
--- 212,218 ----
      {
  	if (!cmdp->cansplit)
  	{
! 	    (void)msg_puts(_("This cscope command does not support splitting the window.\n"));
  	    return;
  	}
  	postponed_split = -1;
***************
*** 1280,1286 ****
  {
      cscmd_T *cmdp = cs_cmds;
  
!     (void)MSG_PUTS(_("cscope commands:\n"));
      while (cmdp->name != NULL)
      {
  	char *help = _(cmdp->help);
--- 1280,1286 ----
  {
      cscmd_T *cmdp = cs_cmds;
  
!     (void)msg_puts(_("cscope commands:\n"));
      while (cmdp->name != NULL)
      {
  	char *help = _(cmdp->help);
***************
*** 1294,1300 ****
  				      help, space_cnt, " ",
  				      cmdp->usage);
  	if (strcmp(cmdp->name, "find") == 0)
! 	    MSG_PUTS(_("\n"
  		       "       a: Find assignments to this symbol\n"
  		       "       c: Find functions calling this function\n"
  		       "       d: Find functions called by this function\n"
--- 1294,1300 ----
  				      help, space_cnt, " ",
  				      cmdp->usage);
  	if (strcmp(cmdp->name, "find") == 0)
! 	    msg_puts(_("\n"
  		       "       a: Find assignments to this symbol\n"
  		       "       c: Find functions calling this function\n"
  		       "       d: Find functions called by this function\n"
***************
*** 1992,2005 ****
      {
  	bufsize = newsize;
  	(void)sprintf(buf, cstag_msg, ptag);
! 	MSG_PUTS_ATTR(buf, HL_ATTR(HLF_T));
      }
  
      vim_free(tbuf);
  
!     MSG_PUTS_ATTR(_("\n   #   line"), HL_ATTR(HLF_T));    /* strlen is 7 */
      msg_advance(msg_col + 2);
!     MSG_PUTS_ATTR(_("filename / context / line\n"), HL_ATTR(HLF_T));
  
      num = 1;
      for (i = 0; i < num_matches; i++)
--- 1992,2005 ----
      {
  	bufsize = newsize;
  	(void)sprintf(buf, cstag_msg, ptag);
! 	msg_puts_attr(buf, HL_ATTR(HLF_T));
      }
  
      vim_free(tbuf);
  
!     msg_puts_attr(_("\n   #   line"), HL_ATTR(HLF_T));    /* strlen is 7 */
      msg_advance(msg_col + 2);
!     msg_puts_attr(_("filename / context / line\n"), HL_ATTR(HLF_T));
  
      num = 1;
      for (i = 0; i < num_matches; i++)
***************
*** 2043,2051 ****
  	{
  	    /* csfmt_str = "%4d %6s  "; */
  	    (void)sprintf(buf, csfmt_str, num, lno);
! 	    MSG_PUTS_ATTR(buf, HL_ATTR(HLF_CM));
  	}
! 	MSG_PUTS_LONG_ATTR(cs_pathcomponents(fname), HL_ATTR(HLF_CM));
  
  	/* compute the required space for the context */
  	if (cntxts[idx] != NULL)
--- 2043,2052 ----
  	{
  	    /* csfmt_str = "%4d %6s  "; */
  	    (void)sprintf(buf, csfmt_str, num, lno);
! 	    msg_puts_attr(buf, HL_ATTR(HLF_CM));
  	}
! 	msg_outtrans_long_attr((char_u *)cs_pathcomponents(fname),
! 							      HL_ATTR(HLF_CM));
  
  	/* compute the required space for the context */
  	if (cntxts[idx] != NULL)
***************
*** 2074,2086 ****
  	    if (msg_col + (int)strlen(buf) >= (int)Columns)
  		msg_putchar('\n');
  	    msg_advance(12);
! 	    MSG_PUTS_LONG(buf);
  	    msg_putchar('\n');
  	}
  	if (extra != NULL)
  	{
  	    msg_advance(13);
! 	    MSG_PUTS_LONG(extra);
  	}
  
  	vim_free(tbuf); /* only after printing extra due to strtok use */
--- 2075,2087 ----
  	    if (msg_col + (int)strlen(buf) >= (int)Columns)
  		msg_putchar('\n');
  	    msg_advance(12);
! 	    msg_outtrans_long_attr((char_u *)buf, 0);
  	    msg_putchar('\n');
  	}
  	if (extra != NULL)
  	{
  	    msg_advance(13);
! 	    msg_outtrans_long_attr((char_u *)extra, 0);
  	}
  
  	vim_free(tbuf); /* only after printing extra due to strtok use */
***************
*** 2371,2377 ****
  		 * "Added cscope database..."
  		 */
  		sprintf(buf, " (#%d)", i);
! 		MSG_PUTS_ATTR(buf, HL_ATTR(HLF_R));
  	    }
  	}
  	vim_free(dblist[i]);
--- 2372,2378 ----
  		 * "Added cscope database..."
  		 */
  		sprintf(buf, " (#%d)", i);
! 		msg_puts_attr(buf, HL_ATTR(HLF_R));
  	    }
  	}
  	vim_free(dblist[i]);
***************
*** 2383,2389 ****
      vim_free(fllist);
  
      if (p_csverbose)
! 	MSG_ATTR(_("All cscope databases reset"), HL_ATTR(HLF_R) | MSG_HIST);
      return CSCOPE_SUCCESS;
  } /* cs_reset */
  
--- 2384,2390 ----
      vim_free(fllist);
  
      if (p_csverbose)
! 	msg_attr(_("All cscope databases reset"), HL_ATTR(HLF_R) | MSG_HIST);
      return CSCOPE_SUCCESS;
  } /* cs_reset */
  
***************
*** 2464,2473 ****
  {
      short i;
      if (cs_cnt_connections() == 0)
! 	MSG_PUTS(_("no cscope connections\n"));
      else
      {
! 	MSG_PUTS_ATTR(
  	    _(" # pid    database name                       prepend path\n"),
  	    HL_ATTR(HLF_T));
  	for (i = 0; i < csinfo_size; i++)
--- 2465,2474 ----
  {
      short i;
      if (cs_cnt_connections() == 0)
! 	msg_puts(_("no cscope connections\n"));
      else
      {
! 	msg_puts_attr(
  	    _(" # pid    database name                       prepend path\n"),
  	    HL_ATTR(HLF_T));
  	for (i = 0; i < csinfo_size; i++)
*** ../vim-8.1.0778/src/fileio.c	2019-01-18 22:48:30.900796633 +0100
--- src/fileio.c	2019-01-19 17:36:47.831896350 +0100
***************
*** 2586,2592 ****
  		p = msg_may_trunc(FALSE, IObuff);
  	    else
  #endif
! 		p = msg_trunc_attr(IObuff, FALSE, 0);
  	    if (read_stdin || read_buffer || restart_edit != 0
  		    || (msg_scrolled != 0 && !need_wait_return))
  		/* Need to repeat the message after redrawing when:
--- 2586,2592 ----
  		p = msg_may_trunc(FALSE, IObuff);
  	    else
  #endif
! 		p = (char_u *)msg_trunc_attr((char *)IObuff, FALSE, 0);
  	    if (read_stdin || read_buffer || restart_edit != 0
  		    || (msg_scrolled != 0 && !need_wait_return))
  		/* Need to repeat the message after redrawing when:
***************
*** 2902,2929 ****
      int		*fdp)		/* in/out: file descriptor of file */
  {
      char_u	*tmpname;
!     char_u	*errmsg = NULL;
  
      tmpname = vim_tempname('r', FALSE);
      if (tmpname == NULL)
! 	errmsg = (char_u *)_("Can't find temp file for conversion");
      else
      {
  	close(*fdp);		/* close the input file, ignore errors */
  	*fdp = -1;
  	if (eval_charconvert(fenc, enc_utf8 ? (char_u *)"utf-8" : p_enc,
  						      fname, tmpname) == FAIL)
! 	    errmsg = (char_u *)_("Conversion with 'charconvert' failed");
  	if (errmsg == NULL && (*fdp = mch_open((char *)tmpname,
  						  O_RDONLY | O_EXTRA, 0)) < 0)
! 	    errmsg = (char_u *)_("can't read output of 'charconvert'");
      }
  
      if (errmsg != NULL)
      {
  	/* Don't use emsg(), it breaks mappings, the retry with
  	 * another type of conversion might still work. */
! 	MSG(errmsg);
  	if (tmpname != NULL)
  	{
  	    mch_remove(tmpname);	/* delete converted file */
--- 2902,2929 ----
      int		*fdp)		/* in/out: file descriptor of file */
  {
      char_u	*tmpname;
!     char	*errmsg = NULL;
  
      tmpname = vim_tempname('r', FALSE);
      if (tmpname == NULL)
! 	errmsg = _("Can't find temp file for conversion");
      else
      {
  	close(*fdp);		/* close the input file, ignore errors */
  	*fdp = -1;
  	if (eval_charconvert(fenc, enc_utf8 ? (char_u *)"utf-8" : p_enc,
  						      fname, tmpname) == FAIL)
! 	    errmsg = _("Conversion with 'charconvert' failed");
  	if (errmsg == NULL && (*fdp = mch_open((char *)tmpname,
  						  O_RDONLY | O_EXTRA, 0)) < 0)
! 	    errmsg = _("can't read output of 'charconvert'");
      }
  
      if (errmsg != NULL)
      {
  	/* Don't use emsg(), it breaks mappings, the retry with
  	 * another type of conversion might still work. */
! 	msg(errmsg);
  	if (tmpname != NULL)
  	{
  	    mch_remove(tmpname);	/* delete converted file */
***************
*** 4908,4914 ****
  		 * know we got the message. */
  		if (got_int)
  		{
! 		    MSG(_(e_interr));
  		    out_flush();
  		}
  		if ((fd = mch_open((char *)backup, O_RDONLY | O_EXTRA, 0)) >= 0)
--- 4908,4914 ----
  		 * know we got the message. */
  		if (got_int)
  		{
! 		    msg(_(e_interr));
  		    out_flush();
  		}
  		if ((fd = mch_open((char *)backup, O_RDONLY | O_EXTRA, 0)) >= 0)
***************
*** 5007,5013 ****
  		STRCAT(IObuff, shortmess(SHM_WRI) ? _(" [w]") : _(" written"));
  	}
  
! 	set_keep_msg(msg_trunc_attr(IObuff, FALSE, 0), 0);
      }
  
      /* When written everything correctly: reset 'modified'.  Unless not
--- 5007,5013 ----
  		STRCAT(IObuff, shortmess(SHM_WRI) ? _(" [w]") : _(" written"));
  	}
  
! 	set_keep_msg((char_u *)msg_trunc_attr((char *)IObuff, FALSE, 0), 0);
      }
  
      /* When written everything correctly: reset 'modified'.  Unless not
***************
*** 5157,5165 ****
  	retval = FAIL;
  	if (end == 0)
  	{
! 	    MSG_PUTS_ATTR(_("\nWARNING: Original file may be lost or damaged\n"),
  		    attr | MSG_HIST);
! 	    MSG_PUTS_ATTR(_("don't quit the editor until the file is successfully written!"),
  		    attr | MSG_HIST);
  
  	    /* Update the timestamp to avoid an "overwrite changed file"
--- 5157,5165 ----
  	retval = FAIL;
  	if (end == 0)
  	{
! 	    msg_puts_attr(_("\nWARNING: Original file may be lost or damaged\n"),
  		    attr | MSG_HIST);
! 	    msg_puts_attr(_("don't quit the editor until the file is successfully written!"),
  		    attr | MSG_HIST);
  
  	    /* Update the timestamp to avoid an "overwrite changed file"
***************
*** 5372,5378 ****
  	msg_scroll = TRUE;	    /* don't overwrite messages here */
  	msg_silent = 0;		    /* must give this prompt */
  	/* don't use emsg() here, don't want to flush the buffers */
! 	MSG_ATTR(_("WARNING: The file has been changed since reading it!!!"),
  						       HL_ATTR(HLF_E));
  	if (ask_yesno((char_u *)_("Do you really want to write to it"),
  								 TRUE) == 'n')
--- 5372,5378 ----
  	msg_scroll = TRUE;	    /* don't overwrite messages here */
  	msg_silent = 0;		    /* must give this prompt */
  	/* don't use emsg() here, don't want to flush the buffers */
! 	msg_attr(_("WARNING: The file has been changed since reading it!!!"),
  						       HL_ATTR(HLF_E));
  	if (ask_yesno((char_u *)_("Do you really want to write to it"),
  								 TRUE) == 'n')
***************
*** 6807,6813 ****
  	if (need_wait_return && didit == 2)
  	{
  	    /* make sure msg isn't overwritten */
! 	    msg_puts((char_u *)"\n");
  	    out_flush();
  	}
      }
--- 6807,6813 ----
  	if (need_wait_return && didit == 2)
  	{
  	    /* make sure msg isn't overwritten */
! 	    msg_puts("\n");
  	    out_flush();
  	}
      }
***************
*** 7093,7102 ****
  		if (!autocmd_busy)
  		{
  		    msg_start();
! 		    msg_puts_attr((char_u *)tbuf, HL_ATTR(HLF_E) + MSG_HIST);
  		    if (*mesg2 != NUL)
! 			msg_puts_attr((char_u *)mesg2,
! 						   HL_ATTR(HLF_W) + MSG_HIST);
  		    msg_clr_eos();
  		    (void)msg_end();
  		    if (emsg_silent == 0)
--- 7093,7101 ----
  		if (!autocmd_busy)
  		{
  		    msg_start();
! 		    msg_puts_attr(tbuf, HL_ATTR(HLF_E) + MSG_HIST);
  		    if (*mesg2 != NUL)
! 			msg_puts_attr(mesg2, HL_ATTR(HLF_W) + MSG_HIST);
  		    msg_clr_eos();
  		    (void)msg_end();
  		    if (emsg_silent == 0)
***************
*** 7926,7937 ****
  	if (ap->group != AUGROUP_DEFAULT)
  	{
  	    if (AUGROUP_NAME(ap->group) == NULL)
! 		msg_puts_attr(get_deleted_augroup(), HL_ATTR(HLF_E));
  	    else
! 		msg_puts_attr(AUGROUP_NAME(ap->group), HL_ATTR(HLF_T));
! 	    msg_puts((char_u *)"  ");
  	}
! 	msg_puts_attr(event_nr2name(event), HL_ATTR(HLF_T));
  	last_event = event;
  	last_group = ap->group;
  	msg_putchar('\n');
--- 7925,7936 ----
  	if (ap->group != AUGROUP_DEFAULT)
  	{
  	    if (AUGROUP_NAME(ap->group) == NULL)
! 		msg_puts_attr((char *)get_deleted_augroup(), HL_ATTR(HLF_E));
  	    else
! 		msg_puts_attr((char *)AUGROUP_NAME(ap->group), HL_ATTR(HLF_T));
! 	    msg_puts("  ");
  	}
! 	msg_puts_attr((char *)event_nr2name(event), HL_ATTR(HLF_T));
  	last_event = event;
  	last_group = ap->group;
  	msg_putchar('\n');
***************
*** 8210,8217 ****
  	{
  	    if (AUGROUP_NAME(i) != NULL)
  	    {
! 		msg_puts(AUGROUP_NAME(i));
! 		msg_puts((char_u *)"  ");
  	    }
  	}
  	msg_clr_eos();
--- 8209,8216 ----
  	{
  	    if (AUGROUP_NAME(i) != NULL)
  	    {
! 		msg_puts((char *)AUGROUP_NAME(i));
! 		msg_puts("  ");
  	    }
  	}
  	msg_clr_eos();
***************
*** 8535,8541 ****
      if (!forceit && *cmd == NUL)
      {
  	/* Highlight title */
! 	MSG_PUTS_TITLE(_("\n--- Autocommands ---"));
      }
  
      /*
--- 8534,8540 ----
      if (!forceit && *cmd == NUL)
      {
  	/* Highlight title */
! 	msg_puts_title(_("\n--- Autocommands ---"));
      }
  
      /*
***************
*** 8902,8908 ****
  	    nothing_done = FALSE;
  
      if (nothing_done && do_msg)
! 	MSG(_("No matching autocommands"));
      if (did_something != NULL)
  	*did_something = !nothing_done;
  
--- 8901,8907 ----
  	    nothing_done = FALSE;
  
      if (nothing_done && do_msg)
! 	msg(_("No matching autocommands"));
      if (did_something != NULL)
  	*did_something = !nothing_done;
  
***************
*** 9939,9945 ****
      {
  	verbose_enter_scroll();
  	smsg(_("autocommand %s"), ac->cmd);
! 	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  	verbose_leave_scroll();
      }
      retval = vim_strsave(ac->cmd);
--- 9938,9944 ----
      {
  	verbose_enter_scroll();
  	smsg(_("autocommand %s"), ac->cmd);
! 	msg_puts("\n");   /* don't overwrite this either */
  	verbose_leave_scroll();
      }
      retval = vim_strsave(ac->cmd);
*** ../vim-8.1.0778/src/getchar.c	2019-01-13 23:38:33.391773303 +0100
--- src/getchar.c	2019-01-19 16:49:29.026488202 +0100
***************
*** 1942,1948 ****
  }
  
  /*
!  * Get a character:
   * 1. from the stuffbuffer
   *	This is used for abbreviated commands like "D" -> "d$".
   *	Also used to redo a command for ".".
--- 1942,1948 ----
  }
  
  /*
!  * Get a byte:
   * 1. from the stuffbuffer
   *	This is used for abbreviated commands like "D" -> "d$".
   *	Also used to redo a command for ".".
***************
*** 3728,3736 ****
  		)
  	{
  	    if (abbrev)
! 		MSG(_("No abbreviation found"));
  	    else
! 		MSG(_("No mapping found"));
  	}
  	goto theend;			    /* listing finished */
      }
--- 3728,3736 ----
  		)
  	{
  	    if (abbrev)
! 		msg(_("No abbreviation found"));
  	    else
! 		msg(_("No mapping found"));
  	}
  	goto theend;			    /* listing finished */
      }
***************
*** 4047,4053 ****
      mapchars = map_mode_to_chars(mp->m_mode);
      if (mapchars != NULL)
      {
! 	msg_puts(mapchars);
  	len = (int)STRLEN(mapchars);
  	vim_free(mapchars);
      }
--- 4047,4053 ----
      mapchars = map_mode_to_chars(mp->m_mode);
      if (mapchars != NULL)
      {
! 	msg_puts((char *)mapchars);
  	len = (int)STRLEN(mapchars);
  	vim_free(mapchars);
      }
***************
*** 4064,4072 ****
      } while (len < 12);
  
      if (mp->m_noremap == REMAP_NONE)
! 	msg_puts_attr((char_u *)"*", HL_ATTR(HLF_8));
      else if (mp->m_noremap == REMAP_SCRIPT)
! 	msg_puts_attr((char_u *)"&", HL_ATTR(HLF_8));
      else
  	msg_putchar(' ');
  
--- 4064,4072 ----
      } while (len < 12);
  
      if (mp->m_noremap == REMAP_NONE)
! 	msg_puts_attr("*", HL_ATTR(HLF_8));
      else if (mp->m_noremap == REMAP_SCRIPT)
! 	msg_puts_attr("&", HL_ATTR(HLF_8));
      else
  	msg_putchar(' ');
  
***************
*** 4078,4084 ****
      /* Use FALSE below if we only want things like <Up> to show up as such on
       * the rhs, and not M-x etc, TRUE gets both -- webb */
      if (*mp->m_str == NUL)
! 	msg_puts_attr((char_u *)"<Nop>", HL_ATTR(HLF_8));
      else
      {
  	/* Remove escaping of CSI, because "m_str" is in a format to be used
--- 4078,4084 ----
      /* Use FALSE below if we only want things like <Up> to show up as such on
       * the rhs, and not M-x etc, TRUE gets both -- webb */
      if (*mp->m_str == NUL)
! 	msg_puts_attr("<Nop>", HL_ATTR(HLF_8));
      else
      {
  	/* Remove escaping of CSI, because "m_str" is in a format to be used
*** ../vim-8.1.0778/src/globals.h	2019-01-17 15:43:21.761878368 +0100
--- src/globals.h	2019-01-19 15:52:25.737787509 +0100
***************
*** 989,995 ****
  					   size is IOSIZE */
  EXTERN char_u	*NameBuff;		/* file names are expanded in this
  					 * buffer, size is MAXPATHL */
! EXTERN char_u	msg_buf[MSG_BUF_LEN];	/* small buffer for messages */
  
  /* When non-zero, postpone redrawing. */
  EXTERN int	RedrawingDisabled INIT(= 0);
--- 989,995 ----
  					   size is IOSIZE */
  EXTERN char_u	*NameBuff;		/* file names are expanded in this
  					 * buffer, size is MAXPATHL */
! EXTERN char	msg_buf[MSG_BUF_LEN];	/* small buffer for messages */
  
  /* When non-zero, postpone redrawing. */
  EXTERN int	RedrawingDisabled INIT(= 0);
*** ../vim-8.1.0778/src/gui.c	2019-01-17 22:28:18.897373219 +0100
--- src/gui.c	2019-01-19 16:05:35.768363395 +0100
***************
*** 2750,2756 ****
  		    vim_snprintf((char *)IObuff, IOSIZE,
  			    "INTERNAL ERROR: NUL in ScreenLines in row %ld",
  			    (long)gui.row);
! 		    msg(IObuff);
  		}
  	    }
  # ifdef FEAT_GUI_GTK
--- 2750,2756 ----
  		    vim_snprintf((char *)IObuff, IOSIZE,
  			    "INTERNAL ERROR: NUL in ScreenLines in row %ld",
  			    (long)gui.row);
! 		    msg((char *)IObuff);
  		}
  	    }
  # ifdef FEAT_GUI_GTK
***************
*** 5323,5329 ****
  		}
  	    }
  	    else
! 		MSG(_("No match at cursor, finding next"));
  	    vim_regfree(regmatch.regprog);
  	}
      }
--- 5323,5329 ----
  		}
  	    }
  	    else
! 		msg(_("No match at cursor, finding next"));
  	    vim_regfree(regmatch.regprog);
  	}
      }
*** ../vim-8.1.0778/src/if_perl.xs	2019-01-13 23:50:56.358162250 +0100
--- src/if_perl.xs	2019-01-19 17:20:57.041781293 +0100
***************
*** 798,808 ****
      while ((next = strchr(token, '\n')) && !got_int)
      {
  	*next++ = '\0';			/* replace \n with \0 */
! 	msg_attr((char_u *)token, attr);
  	token = next;
      }
      if (*token && !got_int)
! 	msg_attr((char_u *)token, attr);
  }
  
  #ifndef FEAT_EVAL
--- 798,808 ----
      while ((next = strchr(token, '\n')) && !got_int)
      {
  	*next++ = '\0';			/* replace \n with \0 */
! 	msg_attr(token, attr);
  	token = next;
      }
      if (*token && !got_int)
! 	msg_attr(token, attr);
  }
  
  #ifndef FEAT_EVAL
*** ../vim-8.1.0778/src/netbeans.c	2019-01-17 15:43:21.765878343 +0100
--- src/netbeans.c	2019-01-19 17:37:10.875747123 +0100
***************
*** 3437,3443 ****
      /* Now display it */
      VIM_CLEAR(keep_msg);
      msg_scrolled_ign = TRUE;
!     msg_trunc_attr(IObuff, FALSE, 0);
      msg_scrolled_ign = FALSE;
  }
  
--- 3437,3443 ----
      /* Now display it */
      VIM_CLEAR(keep_msg);
      msg_scrolled_ign = TRUE;
!     msg_trunc_attr((char *)IObuff, FALSE, 0);
      msg_scrolled_ign = FALSE;
  }
  
***************
*** 3464,3470 ****
  
  	VIM_CLEAR(keep_msg);
  	msg_scrolled_ign = TRUE;
! 	p = msg_trunc_attr(IObuff, FALSE, 0);
  	if ((msg_scrolled && !need_wait_return) || !buf->initDone)
  	{
  	    /* Need to repeat the message after redrawing when:
--- 3464,3470 ----
  
  	VIM_CLEAR(keep_msg);
  	msg_scrolled_ign = TRUE;
! 	p = (char_u *)msg_trunc_attr((char *)IObuff, FALSE, 0);
  	if ((msg_scrolled && !need_wait_return) || !buf->initDone)
  	{
  	    /* Need to repeat the message after redrawing when:
*** ../vim-8.1.0778/src/gui_w32.c	2019-01-13 23:38:33.395773275 +0100
--- src/gui_w32.c	2019-01-19 15:55:22.836571742 +0100
***************
*** 5128,5134 ****
  		    && GetMenuState(s_menuBar, pMenu->id, MF_BYCOMMAND) != -1)
  	    {
  		++msg_hist_off;
! 		msg(pMenu->strings[MENU_INDEX_TIP]);
  		--msg_hist_off;
  		setcursor();
  		out_flush();
--- 5128,5134 ----
  		    && GetMenuState(s_menuBar, pMenu->id, MF_BYCOMMAND) != -1)
  	    {
  		++msg_hist_off;
! 		msg((char *)pMenu->strings[MENU_INDEX_TIP]);
  		--msg_hist_off;
  		setcursor();
  		out_flush();
*** ../vim-8.1.0778/src/hardcopy.c	2019-01-13 23:38:33.395773275 +0100
--- src/hardcopy.c	2019-01-19 16:06:04.652165068 +0100
***************
*** 657,663 ****
  	bytes_to_print += (long_u)STRLEN(skipwhite(ml_get(lnum)));
      if (bytes_to_print == 0)
      {
! 	MSG(_("No text to be printed"));
  	goto print_fail_no_begin;
      }
  
--- 657,663 ----
  	bytes_to_print += (long_u)STRLEN(skipwhite(ml_get(lnum)));
      if (bytes_to_print == 0)
      {
! 	msg(_("No text to be printed"));
  	goto print_fail_no_begin;
      }
  
*** ../vim-8.1.0778/src/if_mzsch.c	2019-01-13 23:38:33.395773275 +0100
--- src/if_mzsch.c	2019-01-19 16:06:17.244078604 +0100
***************
*** 1574,1580 ****
  	if (error)
  	    emsg(prev);
  	else
! 	    MSG(prev);
  	prev = p + 1;
  	p = strchr(prev, '\n');
      }
--- 1574,1580 ----
  	if (error)
  	    emsg(prev);
  	else
! 	    msg(prev);
  	prev = p + 1;
  	p = strchr(prev, '\n');
      }
***************
*** 1582,1588 ****
      if (error)
  	emsg(prev);
      else
! 	MSG(prev);
  }
  
      static void
--- 1582,1588 ----
      if (error)
  	emsg(prev);
      else
! 	msg(prev);
  }
  
      static void
*** ../vim-8.1.0778/src/if_py_both.h	2019-01-13 23:50:56.358162250 +0100
--- src/if_py_both.h	2019-01-19 16:14:19.076790269 +0100
***************
*** 410,421 ****
  }
  
      static int
- msg_wrapper(char *text)
- {
-     return msg((char_u *)text);
- }
- 
-     static int
  write_output(OutputObject *self, PyObject *string)
  {
      Py_ssize_t	len = 0;
--- 410,415 ----
***************
*** 427,433 ****
  
      Py_BEGIN_ALLOW_THREADS
      Python_Lock_Vim();
!     writer((writefn)(error ? emsg : msg_wrapper), (char_u *)str, len);
      Python_Release_Vim();
      Py_END_ALLOW_THREADS
      PyMem_Free(str);
--- 421,427 ----
  
      Py_BEGIN_ALLOW_THREADS
      Python_Lock_Vim();
!     writer((writefn)(error ? emsg : msg), (char_u *)str, len);
      Python_Release_Vim();
      Py_END_ALLOW_THREADS
      PyMem_Free(str);
*** ../vim-8.1.0778/src/if_ruby.c	2019-01-13 23:38:33.395773275 +0100
--- src/if_ruby.c	2019-01-19 17:18:53.658616834 +0100
***************
*** 1057,1067 ****
  # ifdef RUBY21_OR_LATER
  	bt = rb_funcallv(error, rb_intern("backtrace"), 0, 0);
  	for (i = 0; i < RARRAY_LEN(bt); i++)
! 	    msg_attr((char_u *)RSTRING_PTR(RARRAY_AREF(bt, i)), attr);
  # else
  	bt = rb_funcall2(error, rb_intern("backtrace"), 0, 0);
  	for (i = 0; i < RARRAY_LEN(bt); i++)
! 	    msg_attr((char_u *)RSTRING_PTR(RARRAY_PTR(bt)[i]), attr);
  # endif
  	break;
      default:
--- 1057,1067 ----
  # ifdef RUBY21_OR_LATER
  	bt = rb_funcallv(error, rb_intern("backtrace"), 0, 0);
  	for (i = 0; i < RARRAY_LEN(bt); i++)
! 	    msg_attr(RSTRING_PTR(RARRAY_AREF(bt, i)), attr);
  # else
  	bt = rb_funcall2(error, rb_intern("backtrace"), 0, 0);
  	for (i = 0; i < RARRAY_LEN(bt); i++)
! 	    msg_attr(RSTRING_PTR(RARRAY_PTR(bt)[i]), attr);
  # endif
  	break;
      default:
***************
*** 1083,1093 ****
  	strcpy(buff, RSTRING_PTR(str));
  	p = strchr(buff, '\n');
  	if (p) *p = '\0';
! 	MSG(buff);
      }
      else
      {
! 	MSG("");
      }
      return Qnil;
  }
--- 1083,1093 ----
  	strcpy(buff, RSTRING_PTR(str));
  	p = strchr(buff, '\n');
  	if (p) *p = '\0';
! 	msg(buff);
      }
      else
      {
! 	msg("");
      }
      return Qnil;
  }
***************
*** 1641,1647 ****
  	if (i > 0) rb_str_cat(str, ", ", 2);
  	rb_str_concat(str, rb_inspect(argv[i]));
      }
!     MSG(RSTRING_PTR(str));
  
      if (argc == 1)
  	ret = argv[0];
--- 1641,1647 ----
  	if (i > 0) rb_str_cat(str, ", ", 2);
  	rb_str_concat(str, rb_inspect(argv[i]));
      }
!     msg(RSTRING_PTR(str));
  
      if (argc == 1)
  	ret = argv[0];
*** ../vim-8.1.0778/src/if_tcl.c	2019-01-13 23:38:33.399773248 +0100
--- src/if_tcl.c	2019-01-19 16:06:49.403857782 +0100
***************
*** 1832,1842 ****
      while ((next=strchr(text, '\n')))
      {
  	*next++ = '\0';
! 	MSG(text);
  	text = next;
      }
      if (*text)
! 	MSG(text);
  }
  
      static void
--- 1832,1842 ----
      while ((next=strchr(text, '\n')))
      {
  	*next++ = '\0';
! 	msg(text);
  	text = next;
      }
      if (*text)
! 	msg(text);
  }
  
      static void
*** ../vim-8.1.0778/src/mark.c	2019-01-13 23:38:33.399773248 +0100
--- src/mark.c	2019-01-19 17:04:07.020625726 +0100
***************
*** 761,767 ****
  	else
  	{
  	    if (arg == NULL)
! 		MSG(_("No marks set"));
  	    else
  		semsg(_("E283: No marks matching \"%s\""), arg);
  	}
--- 761,767 ----
  	else
  	{
  	    if (arg == NULL)
! 		msg(_("No marks set"));
  	    else
  		semsg(_("E283: No marks matching \"%s\""), arg);
  	}
***************
*** 774,780 ****
  	if (!did_title)
  	{
  	    /* Highlight title */
! 	    MSG_PUTS_TITLE(_("\nmark line  col file/text"));
  	    did_title = TRUE;
  	}
  	msg_putchar('\n');
--- 774,780 ----
  	if (!did_title)
  	{
  	    /* Highlight title */
! 	    msg_puts_title(_("\nmark line  col file/text"));
  	    did_title = TRUE;
  	}
  	msg_putchar('\n');
***************
*** 895,901 ****
      cleanup_jumplist(curwin, TRUE);
  
      /* Highlight title */
!     MSG_PUTS_TITLE(_("\n jump line  col file/text"));
      for (i = 0; i < curwin->w_jumplistlen && !got_int; ++i)
      {
  	if (curwin->w_jumplist[i].fmark.mark.lnum != 0)
--- 895,901 ----
      cleanup_jumplist(curwin, TRUE);
  
      /* Highlight title */
!     msg_puts_title(_("\n jump line  col file/text"));
      for (i = 0; i < curwin->w_jumplistlen && !got_int; ++i)
      {
  	if (curwin->w_jumplist[i].fmark.mark.lnum != 0)
***************
*** 928,934 ****
  	out_flush();
      }
      if (curwin->w_jumplistidx == curwin->w_jumplistlen)
! 	MSG_PUTS("\n>");
  }
  
      void
--- 928,934 ----
  	out_flush();
      }
      if (curwin->w_jumplistidx == curwin->w_jumplistlen)
! 	msg_puts("\n>");
  }
  
      void
***************
*** 949,955 ****
      char_u	*name;
  
      /* Highlight title */
!     MSG_PUTS_TITLE(_("\nchange line  col text"));
  
      for (i = 0; i < curbuf->b_changelistlen && !got_int; ++i)
      {
--- 949,955 ----
      char_u	*name;
  
      /* Highlight title */
!     msg_puts_title(_("\nchange line  col text"));
  
      for (i = 0; i < curbuf->b_changelistlen && !got_int; ++i)
      {
***************
*** 975,981 ****
  	out_flush();
      }
      if (curwin->w_changelistidx == curbuf->b_changelistlen)
! 	MSG_PUTS("\n>");
  }
  #endif
  
--- 975,981 ----
  	out_flush();
      }
      if (curwin->w_changelistidx == curbuf->b_changelistlen)
! 	msg_puts("\n>");
  }
  #endif
  
*** ../vim-8.1.0778/src/mbyte.c	2019-01-14 20:16:37.203631334 +0100
--- src/mbyte.c	2019-01-19 16:07:10.763711114 +0100
***************
*** 3745,3751 ****
      len = utfc_ptr2len(line);
      if (len == 0)
      {
! 	MSG("NUL");
  	return;
      }
  
--- 3745,3751 ----
      len = utfc_ptr2len(line);
      if (len == 0)
      {
! 	msg("NUL");
  	return;
      }
  
***************
*** 3770,3776 ****
  	    break;
      }
  
!     msg(IObuff);
  }
  
  /*
--- 3770,3776 ----
  	    break;
      }
  
!     msg((char *)IObuff);
  }
  
  /*
*** ../vim-8.1.0778/src/menu.c	2019-01-13 23:38:33.399773248 +0100
--- src/menu.c	2019-01-19 17:04:14.740573590 +0100
***************
*** 1151,1157 ****
  
      /* Now we have found the matching menu, and we list the mappings */
  						    /* Highlight title */
!     MSG_PUTS_TITLE(_("\n--- Menus ---"));
  
      show_menus_recursive(parent, modes, 0);
      return OK;
--- 1151,1157 ----
  
      /* Now we have found the matching menu, and we list the mappings */
  						    /* Highlight title */
!     msg_puts_title(_("\n--- Menus ---"));
  
      show_menus_recursive(parent, modes, 0);
      return OK;
***************
*** 1175,1185 ****
  	if (got_int)		/* "q" hit for "--more--" */
  	    return;
  	for (i = 0; i < depth; i++)
! 	    MSG_PUTS("  ");
  	if (menu->priority)
  	{
  	    msg_outnum((long)menu->priority);
! 	    MSG_PUTS(" ");
  	}
  				/* Same highlighting as for directories!? */
  	msg_outtrans_attr(menu->name, HL_ATTR(HLF_D));
--- 1175,1185 ----
  	if (got_int)		/* "q" hit for "--more--" */
  	    return;
  	for (i = 0; i < depth; i++)
! 	    msg_puts("  ");
  	if (menu->priority)
  	{
  	    msg_outnum((long)menu->priority);
! 	    msg_puts(" ");
  	}
  				/* Same highlighting as for directories!? */
  	msg_outtrans_attr(menu->name, HL_ATTR(HLF_D));
***************
*** 1194,1201 ****
  		if (got_int)		/* "q" hit for "--more--" */
  		    return;
  		for (i = 0; i < depth + 2; i++)
! 		    MSG_PUTS("  ");
! 		msg_puts((char_u*)menu_mode_chars[bit]);
  		if (menu->noremap[bit] == REMAP_NONE)
  		    msg_putchar('*');
  		else if (menu->noremap[bit] == REMAP_SCRIPT)
--- 1194,1201 ----
  		if (got_int)		/* "q" hit for "--more--" */
  		    return;
  		for (i = 0; i < depth + 2; i++)
! 		    msg_puts("  ");
! 		msg_puts(menu_mode_chars[bit]);
  		if (menu->noremap[bit] == REMAP_NONE)
  		    msg_putchar('*');
  		else if (menu->noremap[bit] == REMAP_SCRIPT)
***************
*** 1210,1218 ****
  		    msg_putchar('-');
  		else
  		    msg_putchar(' ');
! 		MSG_PUTS(" ");
  		if (*menu->strings[bit] == NUL)
! 		    msg_puts_attr((char_u *)"<Nop>", HL_ATTR(HLF_8));
  		else
  		    msg_outtrans_special(menu->strings[bit], FALSE);
  	    }
--- 1210,1218 ----
  		    msg_putchar('-');
  		else
  		    msg_putchar(' ');
! 		msg_puts(" ");
  		if (*menu->strings[bit] == NUL)
! 		    msg_puts_attr("<Nop>", HL_ATTR(HLF_8));
  		else
  		    msg_outtrans_special(menu->strings[bit], FALSE);
  	    }
*** ../vim-8.1.0778/src/memline.c	2019-01-13 23:38:33.399773248 +0100
--- src/memline.c	2019-01-19 16:58:49.306765668 +0100
***************
*** 1174,1180 ****
  	    /* list the names of the swap files */
  	    (void)recover_names(fname, TRUE, 0, NULL);
  	    msg_putchar('\n');
! 	    MSG_PUTS(_("Enter number of swap file to use (0 to quit): "));
  	    i = get_number(FALSE, NULL);
  	    if (i < 1 || i > len)
  		goto theend;
--- 1174,1180 ----
  	    /* list the names of the swap files */
  	    (void)recover_names(fname, TRUE, 0, NULL);
  	    msg_putchar('\n');
! 	    msg_puts(_("Enter number of swap file to use (0 to quit): "));
  	    i = get_number(FALSE, NULL);
  	    if (i < 1 || i > len)
  		goto theend;
***************
*** 1243,1251 ****
      if ((hp = mf_get(mfp, (blocknr_T)0, 1)) == NULL)
      {
  	msg_start();
! 	MSG_PUTS_ATTR(_("Unable to read block 0 from "), attr | MSG_HIST);
  	msg_outtrans_attr(mfp->mf_fname, attr | MSG_HIST);
! 	MSG_PUTS_ATTR(_("\nMaybe no changes were made or Vim did not update the swap file."),
  		attr | MSG_HIST);
  	msg_end();
  	goto theend;
--- 1243,1251 ----
      if ((hp = mf_get(mfp, (blocknr_T)0, 1)) == NULL)
      {
  	msg_start();
! 	msg_puts_attr(_("Unable to read block 0 from "), attr | MSG_HIST);
  	msg_outtrans_attr(mfp->mf_fname, attr | MSG_HIST);
! 	msg_puts_attr(_("\nMaybe no changes were made or Vim did not update the swap file."),
  		attr | MSG_HIST);
  	msg_end();
  	goto theend;
***************
*** 1255,1263 ****
      {
  	msg_start();
  	msg_outtrans_attr(mfp->mf_fname, MSG_HIST);
! 	MSG_PUTS_ATTR(_(" cannot be used with this version of Vim.\n"),
  								    MSG_HIST);
! 	MSG_PUTS_ATTR(_("Use Vim version 3.0.\n"), MSG_HIST);
  	msg_end();
  	goto theend;
      }
--- 1255,1263 ----
      {
  	msg_start();
  	msg_outtrans_attr(mfp->mf_fname, MSG_HIST);
! 	msg_puts_attr(_(" cannot be used with this version of Vim.\n"),
  								    MSG_HIST);
! 	msg_puts_attr(_("Use Vim version 3.0.\n"), MSG_HIST);
  	msg_end();
  	goto theend;
      }
***************
*** 1272,1288 ****
  	msg_outtrans_attr(mfp->mf_fname, attr | MSG_HIST);
  #if defined(MSWIN)
  	if (STRNCMP(b0p->b0_hname, "PC ", 3) == 0)
! 	    MSG_PUTS_ATTR(_(" cannot be used with this version of Vim.\n"),
  							     attr | MSG_HIST);
  	else
  #endif
! 	    MSG_PUTS_ATTR(_(" cannot be used on this computer.\n"),
  							     attr | MSG_HIST);
! 	MSG_PUTS_ATTR(_("The file was created on "), attr | MSG_HIST);
  	/* avoid going past the end of a corrupted hostname */
  	b0p->b0_fname[0] = NUL;
! 	MSG_PUTS_ATTR(b0p->b0_hname, attr | MSG_HIST);
! 	MSG_PUTS_ATTR(_(",\nor the file has been damaged."), attr | MSG_HIST);
  	msg_end();
  	goto theend;
      }
--- 1272,1288 ----
  	msg_outtrans_attr(mfp->mf_fname, attr | MSG_HIST);
  #if defined(MSWIN)
  	if (STRNCMP(b0p->b0_hname, "PC ", 3) == 0)
! 	    msg_puts_attr(_(" cannot be used with this version of Vim.\n"),
  							     attr | MSG_HIST);
  	else
  #endif
! 	    msg_puts_attr(_(" cannot be used on this computer.\n"),
  							     attr | MSG_HIST);
! 	msg_puts_attr(_("The file was created on "), attr | MSG_HIST);
  	/* avoid going past the end of a corrupted hostname */
  	b0p->b0_fname[0] = NUL;
! 	msg_puts_attr((char *)b0p->b0_hname, attr | MSG_HIST);
! 	msg_puts_attr(_(",\nor the file has been damaged."), attr | MSG_HIST);
  	msg_end();
  	goto theend;
      }
***************
*** 1315,1321 ****
  	{
  	    msg_start();
  	    msg_outtrans_attr(mfp->mf_fname, attr | MSG_HIST);
! 	    MSG_PUTS_ATTR(_(" has been damaged (page size is smaller than minimum value).\n"),
  			attr | MSG_HIST);
  	    msg_end();
  	    goto theend;
--- 1315,1321 ----
  	{
  	    msg_start();
  	    msg_outtrans_attr(mfp->mf_fname, attr | MSG_HIST);
! 	    msg_puts_attr(_(" has been damaged (page size is smaller than minimum value).\n"),
  			attr | MSG_HIST);
  	    msg_end();
  	    goto theend;
***************
*** 1413,1422 ****
  	if (*curbuf->b_p_key != NUL)
  	{
  	    smsg(_("Swap file is encrypted: \"%s\""), fname_used);
! 	    MSG_PUTS(_("\nIf you entered a new crypt key but did not write the text file,"));
! 	    MSG_PUTS(_("\nenter the new crypt key."));
! 	    MSG_PUTS(_("\nIf you wrote the text file after changing the crypt key press enter"));
! 	    MSG_PUTS(_("\nto use the same key for text file and swap file"));
  	}
  	else
  	    smsg(_(need_key_msg), fname_used);
--- 1413,1422 ----
  	if (*curbuf->b_p_key != NUL)
  	{
  	    smsg(_("Swap file is encrypted: \"%s\""), fname_used);
! 	    msg_puts(_("\nIf you entered a new crypt key but did not write the text file,"));
! 	    msg_puts(_("\nenter the new crypt key."));
! 	    msg_puts(_("\nIf you wrote the text file after changing the crypt key press enter"));
! 	    msg_puts(_("\nto use the same key for text file and swap file"));
  	}
  	else
  	    smsg(_(need_key_msg), fname_used);
***************
*** 1681,1709 ****
      else if (error)
      {
  	++no_wait_return;
! 	MSG(">>>>>>>>>>>>>");
  	emsg(_("E312: Errors detected while recovering; look for lines starting with ???"));
  	--no_wait_return;
! 	MSG(_("See \":help E312\" for more information."));
! 	MSG(">>>>>>>>>>>>>");
      }
      else
      {
  	if (curbuf->b_changed)
  	{
! 	    MSG(_("Recovery completed. You should check if everything is OK."));
! 	    MSG_PUTS(_("\n(You might want to write out this file under another name\n"));
! 	    MSG_PUTS(_("and run diff with the original file to check for changes)"));
  	}
  	else
! 	    MSG(_("Recovery completed. Buffer contents equals file contents."));
! 	MSG_PUTS(_("\nYou may want to delete the .swp file now.\n\n"));
  	cmdline_row = msg_row;
      }
  #ifdef FEAT_CRYPT
      if (*buf->b_p_key != NUL && STRCMP(curbuf->b_p_key, buf->b_p_key) != 0)
      {
! 	MSG_PUTS(_("Using crypt key from swap file for the text file.\n"));
  	set_option_value((char_u *)"key", 0L, buf->b_p_key, OPT_LOCAL);
      }
  #endif
--- 1681,1709 ----
      else if (error)
      {
  	++no_wait_return;
! 	msg(">>>>>>>>>>>>>");
  	emsg(_("E312: Errors detected while recovering; look for lines starting with ???"));
  	--no_wait_return;
! 	msg(_("See \":help E312\" for more information."));
! 	msg(">>>>>>>>>>>>>");
      }
      else
      {
  	if (curbuf->b_changed)
  	{
! 	    msg(_("Recovery completed. You should check if everything is OK."));
! 	    msg_puts(_("\n(You might want to write out this file under another name\n"));
! 	    msg_puts(_("and run diff with the original file to check for changes)"));
  	}
  	else
! 	    msg(_("Recovery completed. Buffer contents equals file contents."));
! 	msg_puts(_("\nYou may want to delete the .swp file now.\n\n"));
  	cmdline_row = msg_row;
      }
  #ifdef FEAT_CRYPT
      if (*buf->b_p_key != NUL && STRCMP(curbuf->b_p_key, buf->b_p_key) != 0)
      {
! 	msg_puts(_("Using crypt key from swap file for the text file.\n"));
  	set_option_value((char_u *)"key", 0L, buf->b_p_key, OPT_LOCAL);
      }
  #endif
***************
*** 1785,1791 ****
      if (list)
      {
  	/* use msg() to start the scrolling properly */
! 	msg((char_u *)_("Swap files found:"));
  	msg_putchar('\n');
      }
  
--- 1785,1791 ----
      if (list)
      {
  	/* use msg() to start the scrolling properly */
! 	msg(_("Swap files found:"));
  	msg_putchar('\n');
      }
  
***************
*** 1966,1980 ****
  	    if (dir_name[0] == '.' && dir_name[1] == NUL)
  	    {
  		if (fname == NULL)
! 		    MSG_PUTS(_("   In current directory:\n"));
  		else
! 		    MSG_PUTS(_("   Using specified name:\n"));
  	    }
  	    else
  	    {
! 		MSG_PUTS(_("   In directory "));
  		msg_home_replace(dir_name);
! 		MSG_PUTS(":\n");
  	    }
  
  	    if (num_files)
--- 1966,1980 ----
  	    if (dir_name[0] == '.' && dir_name[1] == NUL)
  	    {
  		if (fname == NULL)
! 		    msg_puts(_("   In current directory:\n"));
  		else
! 		    msg_puts(_("   Using specified name:\n"));
  	    }
  	    else
  	    {
! 		msg_puts(_("   In directory "));
  		msg_home_replace(dir_name);
! 		msg_puts(":\n");
  	    }
  
  	    if (num_files)
***************
*** 1983,1996 ****
  		{
  		    /* print the swap file name */
  		    msg_outnum((long)++file_count);
! 		    MSG_PUTS(".    ");
! 		    msg_puts(gettail(files[i]));
  		    msg_putchar('\n');
  		    (void)swapfile_info(files[i]);
  		}
  	    }
  	    else
! 		MSG_PUTS(_("      -- none --\n"));
  	    out_flush();
  	}
  	else
--- 1983,1996 ----
  		{
  		    /* print the swap file name */
  		    msg_outnum((long)++file_count);
! 		    msg_puts(".    ");
! 		    msg_puts((char *)gettail(files[i]));
  		    msg_putchar('\n');
  		    (void)swapfile_info(files[i]);
  		}
  	    }
  	    else
! 		msg_puts(_("      -- none --\n"));
  	    out_flush();
  	}
  	else
***************
*** 2106,2124 ****
  	/* print name of owner of the file */
  	if (mch_get_uname(st.st_uid, uname, B0_UNAME_SIZE) == OK)
  	{
! 	    MSG_PUTS(_("          owned by: "));
  	    msg_outtrans(uname);
! 	    MSG_PUTS(_("   dated: "));
  	}
  	else
  #endif
! 	    MSG_PUTS(_("             dated: "));
  	x = st.st_mtime;		    /* Manx C can't do &st.st_mtime */
  	p = ctime(&x);			    /* includes '\n' */
  	if (p == NULL)
! 	    MSG_PUTS("(invalid)\n");
  	else
! 	    MSG_PUTS(p);
      }
  
      /*
--- 2106,2124 ----
  	/* print name of owner of the file */
  	if (mch_get_uname(st.st_uid, uname, B0_UNAME_SIZE) == OK)
  	{
! 	    msg_puts(_("          owned by: "));
  	    msg_outtrans(uname);
! 	    msg_puts(_("   dated: "));
  	}
  	else
  #endif
! 	    msg_puts(_("             dated: "));
  	x = st.st_mtime;		    /* Manx C can't do &st.st_mtime */
  	p = ctime(&x);			    /* includes '\n' */
  	if (p == NULL)
! 	    msg_puts("(invalid)\n");
  	else
! 	    msg_puts(p);
      }
  
      /*
***************
*** 2131,2177 ****
  	{
  	    if (STRNCMP(b0.b0_version, "VIM 3.0", 7) == 0)
  	    {
! 		MSG_PUTS(_("         [from Vim version 3.0]"));
  	    }
  	    else if (ml_check_b0_id(&b0) == FAIL)
  	    {
! 		MSG_PUTS(_("         [does not look like a Vim swap file]"));
  	    }
  	    else
  	    {
! 		MSG_PUTS(_("         file name: "));
  		if (b0.b0_fname[0] == NUL)
! 		    MSG_PUTS(_("[No Name]"));
  		else
  		    msg_outtrans(b0.b0_fname);
  
! 		MSG_PUTS(_("\n          modified: "));
! 		MSG_PUTS(b0.b0_dirty ? _("YES") : _("no"));
  
  		if (*(b0.b0_uname) != NUL)
  		{
! 		    MSG_PUTS(_("\n         user name: "));
  		    msg_outtrans(b0.b0_uname);
  		}
  
  		if (*(b0.b0_hname) != NUL)
  		{
  		    if (*(b0.b0_uname) != NUL)
! 			MSG_PUTS(_("   host name: "));
  		    else
! 			MSG_PUTS(_("\n         host name: "));
  		    msg_outtrans(b0.b0_hname);
  		}
  
  		if (char_to_long(b0.b0_pid) != 0L)
  		{
! 		    MSG_PUTS(_("\n        process ID: "));
  		    msg_outnum(char_to_long(b0.b0_pid));
  #if defined(UNIX)
  		    /* EMX kill() not working correctly, it seems */
  		    if (kill((pid_t)char_to_long(b0.b0_pid), 0) == 0)
  		    {
! 			MSG_PUTS(_(" (STILL RUNNING)"));
  # if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
  			process_still_running = TRUE;
  # endif
--- 2131,2177 ----
  	{
  	    if (STRNCMP(b0.b0_version, "VIM 3.0", 7) == 0)
  	    {
! 		msg_puts(_("         [from Vim version 3.0]"));
  	    }
  	    else if (ml_check_b0_id(&b0) == FAIL)
  	    {
! 		msg_puts(_("         [does not look like a Vim swap file]"));
  	    }
  	    else
  	    {
! 		msg_puts(_("         file name: "));
  		if (b0.b0_fname[0] == NUL)
! 		    msg_puts(_("[No Name]"));
  		else
  		    msg_outtrans(b0.b0_fname);
  
! 		msg_puts(_("\n          modified: "));
! 		msg_puts(b0.b0_dirty ? _("YES") : _("no"));
  
  		if (*(b0.b0_uname) != NUL)
  		{
! 		    msg_puts(_("\n         user name: "));
  		    msg_outtrans(b0.b0_uname);
  		}
  
  		if (*(b0.b0_hname) != NUL)
  		{
  		    if (*(b0.b0_uname) != NUL)
! 			msg_puts(_("   host name: "));
  		    else
! 			msg_puts(_("\n         host name: "));
  		    msg_outtrans(b0.b0_hname);
  		}
  
  		if (char_to_long(b0.b0_pid) != 0L)
  		{
! 		    msg_puts(_("\n        process ID: "));
  		    msg_outnum(char_to_long(b0.b0_pid));
  #if defined(UNIX)
  		    /* EMX kill() not working correctly, it seems */
  		    if (kill((pid_t)char_to_long(b0.b0_pid), 0) == 0)
  		    {
! 			msg_puts(_(" (STILL RUNNING)"));
  # if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
  			process_still_running = TRUE;
  # endif
***************
*** 2183,2201 ****
  		{
  #if defined(MSWIN)
  		    if (STRNCMP(b0.b0_hname, "PC ", 3) == 0)
! 			MSG_PUTS(_("\n         [not usable with this version of Vim]"));
  		    else
  #endif
! 			MSG_PUTS(_("\n         [not usable on this computer]"));
  		}
  	    }
  	}
  	else
! 	    MSG_PUTS(_("         [cannot be read]"));
  	close(fd);
      }
      else
! 	MSG_PUTS(_("         [cannot be opened]"));
      msg_putchar('\n');
  
      return x;
--- 2183,2201 ----
  		{
  #if defined(MSWIN)
  		    if (STRNCMP(b0.b0_hname, "PC ", 3) == 0)
! 			msg_puts(_("\n         [not usable with this version of Vim]"));
  		    else
  #endif
! 			msg_puts(_("\n         [not usable on this computer]"));
  		}
  	    }
  	}
  	else
! 	    msg_puts(_("         [cannot be read]"));
  	close(fd);
      }
      else
! 	msg_puts(_("         [cannot be opened]"));
      msg_putchar('\n');
  
      return x;
***************
*** 2414,2420 ****
      if (message)
      {
  	if (status == OK)
! 	    MSG(_("File preserved"));
  	else
  	    emsg(_("E314: Preserve failed"));
      }
--- 2414,2420 ----
      if (message)
      {
  	if (status == OK)
! 	    msg(_("File preserved"));
  	else
  	    emsg(_("E314: Preserve failed"));
      }
***************
*** 4373,4411 ****
  
      ++no_wait_return;
      (void)emsg(_("E325: ATTENTION"));
!     MSG_PUTS(_("\nFound a swap file by the name \""));
      msg_home_replace(fname);
!     MSG_PUTS("\"\n");
      sx = swapfile_info(fname);
!     MSG_PUTS(_("While opening file \""));
      msg_outtrans(buf->b_fname);
!     MSG_PUTS("\"\n");
      if (mch_stat((char *)buf->b_fname, &st) == -1)
      {
! 	MSG_PUTS(_("      CANNOT BE FOUND"));
      }
      else
      {
! 	MSG_PUTS(_("             dated: "));
  	x = st.st_mtime;    /* Manx C can't do &st.st_mtime */
  	p = ctime(&x);			    /* includes '\n' */
  	if (p == NULL)
! 	    MSG_PUTS("(invalid)\n");
  	else
! 	    MSG_PUTS(p);
  	if (sx != 0 && x > sx)
! 	    MSG_PUTS(_("      NEWER than swap file!\n"));
      }
      /* Some of these messages are long to allow translation to
       * other languages. */
!     MSG_PUTS(_("\n(1) Another program may be editing the same file.  If this is the case,\n    be careful not to end up with two different instances of the same\n    file when making changes.  Quit, or continue with caution.\n"));
!     MSG_PUTS(_("(2) An edit session for this file crashed.\n"));
!     MSG_PUTS(_("    If this is the case, use \":recover\" or \"vim -r "));
      msg_outtrans(buf->b_fname);
!     MSG_PUTS(_("\"\n    to recover the changes (see \":help recovery\").\n"));
!     MSG_PUTS(_("    If you did this already, delete the swap file \""));
      msg_outtrans(fname);
!     MSG_PUTS(_("\"\n    to avoid this message.\n"));
      cmdline_row = msg_row;
      --no_wait_return;
  }
--- 4373,4411 ----
  
      ++no_wait_return;
      (void)emsg(_("E325: ATTENTION"));
!     msg_puts(_("\nFound a swap file by the name \""));
      msg_home_replace(fname);
!     msg_puts("\"\n");
      sx = swapfile_info(fname);
!     msg_puts(_("While opening file \""));
      msg_outtrans(buf->b_fname);
!     msg_puts("\"\n");
      if (mch_stat((char *)buf->b_fname, &st) == -1)
      {
! 	msg_puts(_("      CANNOT BE FOUND"));
      }
      else
      {
! 	msg_puts(_("             dated: "));
  	x = st.st_mtime;    /* Manx C can't do &st.st_mtime */
  	p = ctime(&x);			    /* includes '\n' */
  	if (p == NULL)
! 	    msg_puts("(invalid)\n");
  	else
! 	    msg_puts(p);
  	if (sx != 0 && x > sx)
! 	    msg_puts(_("      NEWER than swap file!\n"));
      }
      /* Some of these messages are long to allow translation to
       * other languages. */
!     msg_puts(_("\n(1) Another program may be editing the same file.  If this is the case,\n    be careful not to end up with two different instances of the same\n    file when making changes.  Quit, or continue with caution.\n"));
!     msg_puts(_("(2) An edit session for this file crashed.\n"));
!     msg_puts(_("    If this is the case, use \":recover\" or \"vim -r "));
      msg_outtrans(buf->b_fname);
!     msg_puts(_("\"\n    to recover the changes (see \":help recovery\").\n"));
!     msg_puts(_("    If you did this already, delete the swap file \""));
      msg_outtrans(fname);
!     msg_puts(_("\"\n    to avoid this message.\n"));
      cmdline_row = msg_row;
      --no_wait_return;
  }
***************
*** 4890,4896 ****
  		    else
  #endif
  		    {
! 			MSG_PUTS("\n");
  			if (msg_silent == 0)
  			    /* call wait_return() later */
  			    need_wait_return = TRUE;
--- 4890,4896 ----
  		    else
  #endif
  		    {
! 			msg_puts("\n");
  			if (msg_silent == 0)
  			    /* call wait_return() later */
  			    need_wait_return = TRUE;
*** ../vim-8.1.0778/src/message.c	2019-01-16 22:41:50.091917818 +0100
--- src/message.c	2019-01-19 17:34:24.996817618 +0100
***************
*** 19,25 ****
  static void add_msg_hist(char_u *s, int len, int attr);
  static void hit_return_msg(void);
  static void msg_home_replace_attr(char_u *fname, int attr);
! static void msg_puts_attr_len(char_u *str, int maxlen, int attr);
  static void msg_puts_display(char_u *str, int maxlen, int attr, int recurse);
  static void msg_scroll_up(void);
  static void inc_msg_scrolled(void);
--- 19,25 ----
  static void add_msg_hist(char_u *s, int len, int attr);
  static void hit_return_msg(void);
  static void msg_home_replace_attr(char_u *fname, int attr);
! static void msg_puts_attr_len(char *str, int maxlen, int attr);
  static void msg_puts_display(char_u *str, int maxlen, int attr, int recurse);
  static void msg_scroll_up(void);
  static void inc_msg_scrolled(void);
***************
*** 96,102 ****
   * return TRUE if wait_return not called
   */
      int
! msg(char_u *s)
  {
      return msg_attr_keep(s, 0, FALSE);
  }
--- 96,102 ----
   * return TRUE if wait_return not called
   */
      int
! msg(char *s)
  {
      return msg_attr_keep(s, 0, FALSE);
  }
***************
*** 107,113 ****
   * Like msg() but keep it silent when 'verbosefile' is set.
   */
      int
! verb_msg(char_u *s)
  {
      int		n;
  
--- 107,113 ----
   * Like msg() but keep it silent when 'verbosefile' is set.
   */
      int
! verb_msg(char *s)
  {
      int		n;
  
***************
*** 120,133 ****
  #endif
  
      int
! msg_attr(char_u *s, int attr)
  {
      return msg_attr_keep(s, attr, FALSE);
  }
  
      int
  msg_attr_keep(
!     char_u	*s,
      int		attr,
      int		keep)	    /* TRUE: set keep_msg if it doesn't scroll */
  {
--- 120,133 ----
  #endif
  
      int
! msg_attr(char *s, int attr)
  {
      return msg_attr_keep(s, attr, FALSE);
  }
  
      int
  msg_attr_keep(
!     char	*s,
      int		attr,
      int		keep)	    /* TRUE: set keep_msg if it doesn't scroll */
  {
***************
*** 137,148 ****
  
      /* Skip messages not matching ":filter pattern".
       * Don't filter when there is an error. */
!     if (!emsg_on_display && message_filtered(s))
  	return TRUE;
  
  #ifdef FEAT_EVAL
      if (attr == 0)
! 	set_vim_var_string(VV_STATUSMSG, s, -1);
  #endif
  
      /*
--- 137,148 ----
  
      /* Skip messages not matching ":filter pattern".
       * Don't filter when there is an error. */
!     if (!emsg_on_display && message_filtered((char_u *)s))
  	return TRUE;
  
  #ifdef FEAT_EVAL
      if (attr == 0)
! 	set_vim_var_string(VV_STATUSMSG, (char_u *)s, -1);
  #endif
  
      /*
***************
*** 156,167 ****
  
      /* Add message to history (unless it's a repeated kept message or a
       * truncated message) */
!     if (s != keep_msg
  	    || (*s != '<'
  		&& last_msg_hist != NULL
  		&& last_msg_hist->msg != NULL
  		&& STRCMP(s, last_msg_hist->msg)))
! 	add_msg_hist(s, -1, attr);
  
  #ifdef FEAT_JOB_CHANNEL
      if (emsg_to_channel_log)
--- 156,167 ----
  
      /* Add message to history (unless it's a repeated kept message or a
       * truncated message) */
!     if ((char_u *)s != keep_msg
  	    || (*s != '<'
  		&& last_msg_hist != NULL
  		&& last_msg_hist->msg != NULL
  		&& STRCMP(s, last_msg_hist->msg)))
! 	add_msg_hist((char_u *)s, -1, attr);
  
  #ifdef FEAT_JOB_CHANNEL
      if (emsg_to_channel_log)
***************
*** 171,192 ****
  
      /* When displaying keep_msg, don't let msg_start() free it, caller must do
       * that. */
!     if (s == keep_msg)
  	keep_msg = NULL;
  
      /* Truncate the message if needed. */
      msg_start();
!     buf = msg_strtrunc(s, FALSE);
      if (buf != NULL)
! 	s = buf;
  
!     msg_outtrans_attr(s, attr);
      msg_clr_eos();
      retval = msg_end();
  
!     if (keep && retval && vim_strsize(s) < (int)(Rows - cmdline_row - 1)
! 							   * Columns + sc_col)
! 	set_keep_msg(s, 0);
  
      vim_free(buf);
      --entered;
--- 171,192 ----
  
      /* When displaying keep_msg, don't let msg_start() free it, caller must do
       * that. */
!     if ((char_u *)s == keep_msg)
  	keep_msg = NULL;
  
      /* Truncate the message if needed. */
      msg_start();
!     buf = msg_strtrunc((char_u *)s, FALSE);
      if (buf != NULL)
! 	s = (char *)buf;
  
!     msg_outtrans_attr((char_u *)s, attr);
      msg_clr_eos();
      retval = msg_end();
  
!     if (keep && retval && vim_strsize((char_u *)s)
! 			    < (int)(Rows - cmdline_row - 1) * Columns + sc_col)
! 	set_keep_msg((char_u *)s, 0);
  
      vim_free(buf);
      --entered;
***************
*** 376,382 ****
      va_start(arglist, s);
      vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);
      va_end(arglist);
!     return msg(IObuff);
  }
  
      int
--- 376,382 ----
      va_start(arglist, s);
      vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);
      va_end(arglist);
!     return msg((char *)IObuff);
  }
  
      int
***************
*** 390,396 ****
      va_start(arglist, s);
      vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);
      va_end(arglist);
!     return msg_attr(IObuff, attr);
  }
  
      int
--- 390,396 ----
      va_start(arglist, s);
      vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);
      va_end(arglist);
!     return msg_attr((char *)IObuff, attr);
  }
  
      int
***************
*** 404,410 ****
      va_start(arglist, s);
      vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);
      va_end(arglist);
!     return msg_attr_keep(IObuff, attr, TRUE);
  }
  
  #endif
--- 404,410 ----
      va_start(arglist, s);
      vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);
      va_end(arglist);
!     return msg_attr_keep((char *)IObuff, attr, TRUE);
  }
  
  #endif
***************
*** 502,514 ****
      p = get_emsg_source();
      if (p != NULL)
      {
! 	msg_attr(p, attr);
  	vim_free(p);
      }
      p = get_emsg_lnum();
      if (p != NULL)
      {
! 	msg_attr(p, HL_ATTR(HLF_N));
  	vim_free(p);
  	last_sourcing_lnum = sourcing_lnum;  /* only once for each line */
      }
--- 502,514 ----
      p = get_emsg_source();
      if (p != NULL)
      {
! 	msg_attr((char *)p, attr);
  	vim_free(p);
      }
      p = get_emsg_lnum();
      if (p != NULL)
      {
! 	msg_attr((char *)p, HL_ATTR(HLF_N));
  	vim_free(p);
  	last_sourcing_lnum = sourcing_lnum;  /* only once for each line */
      }
***************
*** 611,617 ****
      /* When testing some errors are turned into a normal message. */
      if (ignore_error(s))
  	/* don't call msg() if it results in a dialog */
! 	return msg_use_printf() ? FALSE : msg(s);
  #endif
  
      called_emsg = TRUE;
--- 611,617 ----
      /* When testing some errors are turned into a normal message. */
      if (ignore_error(s))
  	/* don't call msg() if it results in a dialog */
! 	return msg_use_printf() ? FALSE : msg((char *)s);
  #endif
  
      called_emsg = TRUE;
***************
*** 716,722 ****
       * Display the error message itself.
       */
      msg_nowait = FALSE;			/* wait for this msg */
!     r = msg_attr(s, attr);
  
  #ifdef FEAT_JOB_CHANNEL
      emsg_to_channel_log = FALSE;
--- 716,722 ----
       * Display the error message itself.
       */
      msg_nowait = FALSE;			/* wait for this msg */
!     r = msg_attr((char *)s, attr);
  
  #ifdef FEAT_JOB_CHANNEL
      emsg_to_channel_log = FALSE;
***************
*** 817,838 ****
   * Careful: The string may be changed by msg_may_trunc()!
   * Returns a pointer to the printed message, if wait_return() not called.
   */
!     char_u *
! msg_trunc_attr(char_u *s, int force, int attr)
  {
      int		n;
  
      /* Add message to history before truncating */
!     add_msg_hist(s, -1, attr);
  
!     s = msg_may_trunc(force, s);
  
      msg_hist_off = TRUE;
!     n = msg_attr(s, attr);
      msg_hist_off = FALSE;
  
      if (n)
! 	return s;
      return NULL;
  }
  
--- 817,839 ----
   * Careful: The string may be changed by msg_may_trunc()!
   * Returns a pointer to the printed message, if wait_return() not called.
   */
!     char *
! msg_trunc_attr(char *s, int force, int attr)
  {
      int		n;
+     char	*ts;
  
      /* Add message to history before truncating */
!     add_msg_hist((char_u *)s, -1, attr);
  
!     ts = (char *)msg_may_trunc(force, (char_u *)s);
  
      msg_hist_off = TRUE;
!     n = msg_attr(ts, attr);
      msg_hist_off = FALSE;
  
      if (n)
! 	return ts;
      return NULL;
  }
  
***************
*** 983,989 ****
  	if (s != NULL && *s != NUL)
  	    // The next comment is extracted by xgettext and put in po file for
  	    // translators to read.
! 	    msg_attr((char_u *)
  		    // Translator: Please replace the name and email address
  		    // with the appropriate text for your translation.
  		    _("Messages maintainer: Bram Moolenaar <Bram@vim.org>"),
--- 984,990 ----
  	if (s != NULL && *s != NUL)
  	    // The next comment is extracted by xgettext and put in po file for
  	    // translators to read.
! 	    msg_attr(
  		    // Translator: Please replace the name and email address
  		    // with the appropriate text for your translation.
  		    _("Messages maintainer: Bram Moolenaar <Bram@vim.org>"),
***************
*** 993,999 ****
      /* Display what was not skipped. */
      for (; p != NULL && !got_int; p = p->next)
  	if (p->msg != NULL)
! 	    msg_attr(p->msg, p->attr);
  
      msg_hist_off = FALSE;
  }
--- 994,1000 ----
      /* Display what was not skipped. */
      for (; p != NULL && !got_int; p = p->next)
  	if (p->msg != NULL)
! 	    msg_attr((char *)p->msg, p->attr);
  
      msg_hist_off = FALSE;
  }
***************
*** 1016,1025 ****
  #endif
  
  /*
!  * wait for the user to hit a key (normally a return)
!  * if 'redraw' is TRUE, clear and redraw the screen
!  * if 'redraw' is FALSE, just redraw the screen
!  * if 'redraw' is -1, don't redraw at all
   */
      void
  wait_return(int redraw)
--- 1017,1026 ----
  #endif
  
  /*
!  * Wait for the user to hit a key (normally Enter).
!  * If "redraw" is TRUE, clear and redraw the screen.
!  * If "redraw" is FALSE, just redraw the screen.
!  * If "redraw" is -1, don't redraw at all.
   */
      void
  wait_return(int redraw)
***************
*** 1065,1071 ****
      }
      else if (exmode_active)
      {
! 	MSG_PUTS(" ");		/* make sure the cursor is on the right line */
  	c = CAR;		/* no need for a return in ex mode */
  	got_int = FALSE;
      }
--- 1066,1072 ----
      }
      else if (exmode_active)
      {
! 	msg_puts(" ");		/* make sure the cursor is on the right line */
  	c = CAR;		/* no need for a return in ex mode */
  	got_int = FALSE;
      }
***************
*** 1281,1289 ****
      if (msg_didout)	/* start on a new line */
  	msg_putchar('\n');
      if (got_int)
! 	MSG_PUTS(_("Interrupt: "));
  
!     MSG_PUTS_ATTR(_("Press ENTER or type command to continue"), HL_ATTR(HLF_R));
      if (!msg_use_printf())
  	msg_clr_eos();
      p_more = save_p_more;
--- 1282,1290 ----
      if (msg_didout)	/* start on a new line */
  	msg_putchar('\n');
      if (got_int)
! 	msg_puts(_("Interrupt: "));
  
!     msg_puts_attr(_("Press ENTER or type command to continue"), HL_ATTR(HLF_R));
      if (!msg_use_printf())
  	msg_clr_eos();
      p_more = save_p_more;
***************
*** 1388,1396 ****
  msg_putchar_attr(int c, int attr)
  {
  #ifdef FEAT_MBYTE
!     char_u	buf[MB_MAXBYTES + 1];
  #else
!     char_u	buf[4];
  #endif
  
      if (IS_SPECIAL(c))
--- 1389,1397 ----
  msg_putchar_attr(int c, int attr)
  {
  #ifdef FEAT_MBYTE
!     char	buf[MB_MAXBYTES + 1];
  #else
!     char	buf[4];
  #endif
  
      if (IS_SPECIAL(c))
***************
*** 1403,1409 ****
      else
      {
  #ifdef FEAT_MBYTE
! 	buf[(*mb_char2bytes)(c, buf)] = NUL;
  #else
  	buf[0] = c;
  	buf[1] = NUL;
--- 1404,1410 ----
      else
      {
  #ifdef FEAT_MBYTE
! 	buf[(*mb_char2bytes)(c, (char_u *)buf)] = NUL;
  #else
  	buf[0] = c;
  	buf[1] = NUL;
***************
*** 1415,1423 ****
      void
  msg_outnum(long n)
  {
!     char_u	buf[20];
  
!     sprintf((char *)buf, "%ld", n);
      msg_puts(buf);
  }
  
--- 1416,1424 ----
      void
  msg_outnum(long n)
  {
!     char	buf[20];
  
!     sprintf(buf, "%ld", n);
      msg_puts(buf);
  }
  
***************
*** 1486,1492 ****
  	return p + l;
      }
  #endif
!     msg_puts_attr(transchar_byte(*p), attr);
      return p + 1;
  }
  
--- 1487,1493 ----
  	return p + l;
      }
  #endif
!     msg_puts_attr((char *)transchar_byte(*p), attr);
      return p + 1;
  }
  
***************
*** 1513,1519 ****
      /* If the string starts with a composing character first draw a space on
       * which the composing char can be drawn. */
      if (enc_utf8 && utf_iscomposing(utf_ptr2char(msgstr)))
! 	msg_puts_attr((char_u *)" ", attr);
  #endif
  
      /*
--- 1514,1520 ----
      /* If the string starts with a composing character first draw a space on
       * which the composing char can be drawn. */
      if (enc_utf8 && utf_iscomposing(utf_ptr2char(msgstr)))
! 	msg_puts_attr(" ", attr);
  #endif
  
      /*
***************
*** 1541,1550 ****
  		/* unprintable multi-byte char: print the printable chars so
  		 * far and the translation of the unprintable char. */
  		if (str > plain_start)
! 		    msg_puts_attr_len(plain_start, (int)(str - plain_start),
! 									attr);
  		plain_start = str + mb_l;
! 		msg_puts_attr(transchar(c), attr == 0 ? HL_ATTR(HLF_8) : attr);
  		retval += char2cells(c);
  	    }
  	    len -= mb_l - 1;
--- 1542,1552 ----
  		/* unprintable multi-byte char: print the printable chars so
  		 * far and the translation of the unprintable char. */
  		if (str > plain_start)
! 		    msg_puts_attr_len((char *)plain_start,
! 					       (int)(str - plain_start), attr);
  		plain_start = str + mb_l;
! 		msg_puts_attr((char *)transchar(c),
! 					    attr == 0 ? HL_ATTR(HLF_8) : attr);
  		retval += char2cells(c);
  	    }
  	    len -= mb_l - 1;
***************
*** 1559,1568 ****
  		/* unprintable char: print the printable chars so far and the
  		 * translation of the unprintable char. */
  		if (str > plain_start)
! 		    msg_puts_attr_len(plain_start, (int)(str - plain_start),
! 									attr);
  		plain_start = str + 1;
! 		msg_puts_attr(s, attr == 0 ? HL_ATTR(HLF_8) : attr);
  		retval += (int)STRLEN(s);
  	    }
  	    else
--- 1561,1570 ----
  		/* unprintable char: print the printable chars so far and the
  		 * translation of the unprintable char. */
  		if (str > plain_start)
! 		    msg_puts_attr_len((char *)plain_start,
! 					       (int)(str - plain_start), attr);
  		plain_start = str + 1;
! 		msg_puts_attr((char *)s, attr == 0 ? HL_ATTR(HLF_8) : attr);
  		retval += (int)STRLEN(s);
  	    }
  	    else
***************
*** 1573,1579 ****
  
      if (str > plain_start)
  	/* print the printable chars at the end */
! 	msg_puts_attr_len(plain_start, (int)(str - plain_start), attr);
  
      return retval;
  }
--- 1575,1581 ----
  
      if (str > plain_start)
  	/* print the printable chars at the end */
! 	msg_puts_attr_len((char *)plain_start, (int)(str - plain_start), attr);
  
      return retval;
  }
***************
*** 1619,1625 ****
  {
      char_u	*str = strstart;
      int		retval = 0;
!     char_u	*string;
      int		attr;
      int		len;
  
--- 1621,1627 ----
  {
      char_u	*str = strstart;
      int		retval = 0;
!     char	*text;
      int		attr;
      int		len;
  
***************
*** 1629,1644 ****
  	/* Leading and trailing spaces need to be displayed in <> form. */
  	if ((str == strstart || str[1] == NUL) && *str == ' ')
  	{
! 	    string = (char_u *)"<Space>";
  	    ++str;
  	}
  	else
! 	    string = str2special(&str, from);
! 	len = vim_strsize(string);
  	/* Highlight special keys */
! 	msg_puts_attr(string, len > 1
  #ifdef FEAT_MBYTE
! 		&& (*mb_ptr2len)(string) <= 1
  #endif
  		? attr : 0);
  	retval += len;
--- 1631,1646 ----
  	/* Leading and trailing spaces need to be displayed in <> form. */
  	if ((str == strstart || str[1] == NUL) && *str == ' ')
  	{
! 	    text = "<Space>";
  	    ++str;
  	}
  	else
! 	    text = (char *)str2special(&str, from);
! 	len = vim_strsize((char_u *)text);
  	/* Highlight special keys */
! 	msg_puts_attr(text, len > 1
  #ifdef FEAT_MBYTE
! 		&& (*mb_ptr2len)((char_u *)text) <= 1
  #endif
  		? attr : 0);
  	retval += len;
***************
*** 1825,1831 ****
  		mch_memmove(buf, s, (size_t)l);
  		buf[l] = NUL;
  	    }
! 	    msg_puts(buf);
  	    s += l;
  	    continue;
  	}
--- 1827,1833 ----
  		mch_memmove(buf, s, (size_t)l);
  		buf[l] = NUL;
  	    }
! 	    msg_puts((char *)buf);
  	    s += l;
  	    continue;
  	}
***************
*** 1957,1970 ****
   * Update msg_row and msg_col for the next message.
   */
      void
! msg_puts(char_u *s)
  {
      msg_puts_attr(s, 0);
  }
  
      void
! msg_puts_title(
!     char_u	*s)
  {
      msg_puts_attr(s, HL_ATTR(HLF_T));
  }
--- 1959,1971 ----
   * Update msg_row and msg_col for the next message.
   */
      void
! msg_puts(char *s)
  {
      msg_puts_attr(s, 0);
  }
  
      void
! msg_puts_title(char *s)
  {
      msg_puts_attr(s, HL_ATTR(HLF_T));
  }
***************
*** 1975,1987 ****
   * Does not handle multi-byte characters!
   */
      void
! msg_puts_long_attr(char_u *longstr, int attr)
  {
!     msg_puts_long_len_attr(longstr, (int)STRLEN(longstr), attr);
  }
  
      void
! msg_puts_long_len_attr(char_u *longstr, int len, int attr)
  {
      int		slen = len;
      int		room;
--- 1976,1988 ----
   * Does not handle multi-byte characters!
   */
      void
! msg_outtrans_long_attr(char_u *longstr, int attr)
  {
!     msg_outtrans_long_len_attr(longstr, (int)STRLEN(longstr), attr);
  }
  
      void
! msg_outtrans_long_len_attr(char_u *longstr, int len, int attr)
  {
      int		slen = len;
      int		room;
***************
*** 1991,1997 ****
      {
  	slen = (room - 3) / 2;
  	msg_outtrans_len_attr(longstr, slen, attr);
! 	msg_puts_attr((char_u *)"...", HL_ATTR(HLF_8));
      }
      msg_outtrans_len_attr(longstr + len - slen, slen, attr);
  }
--- 1992,1998 ----
      {
  	slen = (room - 3) / 2;
  	msg_outtrans_len_attr(longstr, slen, attr);
! 	msg_puts_attr("...", HL_ATTR(HLF_8));
      }
      msg_outtrans_len_attr(longstr + len - slen, slen, attr);
  }
***************
*** 2000,2006 ****
   * Basic function for writing a message with highlight attributes.
   */
      void
! msg_puts_attr(char_u *s, int attr)
  {
      msg_puts_attr_len(s, -1, attr);
  }
--- 2001,2007 ----
   * Basic function for writing a message with highlight attributes.
   */
      void
! msg_puts_attr(char *s, int attr)
  {
      msg_puts_attr_len(s, -1, attr);
  }
***************
*** 2011,2022 ****
   * When "maxlen" is >= 0 the message is not put in the history.
   */
      static void
! msg_puts_attr_len(char_u *str, int maxlen, int attr)
  {
      /*
       * If redirection is on, also write to the redirection file.
       */
!     redir_write(str, maxlen);
  
      /*
       * Don't print anything when using ":silent cmd".
--- 2012,2023 ----
   * When "maxlen" is >= 0 the message is not put in the history.
   */
      static void
! msg_puts_attr_len(char *str, int maxlen, int attr)
  {
      /*
       * If redirection is on, also write to the redirection file.
       */
!     redir_write((char_u *)str, maxlen);
  
      /*
       * Don't print anything when using ":silent cmd".
***************
*** 2027,2033 ****
      /* if MSG_HIST flag set, add message to history */
      if ((attr & MSG_HIST) && maxlen < 0)
      {
! 	add_msg_hist(str, -1, attr);
  	attr &= ~MSG_HIST;
      }
  
--- 2028,2034 ----
      /* if MSG_HIST flag set, add message to history */
      if ((attr & MSG_HIST) && maxlen < 0)
      {
! 	add_msg_hist((char_u *)str, -1, attr);
  	attr &= ~MSG_HIST;
      }
  
***************
*** 2049,2057 ****
       * cursor is.
       */
      if (msg_use_printf())
! 	msg_puts_printf(str, maxlen);
      else
! 	msg_puts_display(str, maxlen, attr, FALSE);
  }
  
  /*
--- 2050,2058 ----
       * cursor is.
       */
      if (msg_use_printf())
! 	msg_puts_printf((char_u *)str, maxlen);
      else
! 	msg_puts_display((char_u *)str, maxlen, attr, FALSE);
  }
  
  /*
***************
*** 3497,3503 ****
  	keep_msg_attr = HL_ATTR(HLF_W);
      else
  	keep_msg_attr = 0;
!     if (msg_attr(message, keep_msg_attr) && msg_scrolled == 0)
  	set_keep_msg(message, keep_msg_attr);
      msg_didout = FALSE;	    /* overwrite this message */
      msg_nowait = TRUE;	    /* don't wait for this message */
--- 3498,3504 ----
  	keep_msg_attr = HL_ATTR(HLF_W);
      else
  	keep_msg_attr = 0;
!     if (msg_attr((char *)message, keep_msg_attr) && msg_scrolled == 0)
  	set_keep_msg(message, keep_msg_attr);
      msg_didout = FALSE;	    /* overwrite this message */
      msg_nowait = TRUE;	    /* don't wait for this message */
***************
*** 3891,3897 ****
      /* avoid that 'q' at the more prompt truncates the message here */
      ++confirm_msg_used;
      if (confirm_msg != NULL)
! 	msg_puts_attr(confirm_msg, HL_ATTR(HLF_M));
      --confirm_msg_used;
  }
  
--- 3892,3898 ----
      /* avoid that 'q' at the more prompt truncates the message here */
      ++confirm_msg_used;
      if (confirm_msg != NULL)
! 	msg_puts_attr((char *)confirm_msg, HL_ATTR(HLF_M));
      --confirm_msg_used;
  }
  
*** ../vim-8.1.0778/src/misc1.c	2019-01-17 22:28:18.901373188 +0100
--- src/misc1.c	2019-01-19 17:20:14.550067462 +0100
***************
*** 3468,3474 ****
  	if (msg_row == Rows - 1)
  	    msg_col = col;
  	msg_source(HL_ATTR(HLF_W));
! 	MSG_PUTS_ATTR(_(w_readonly), HL_ATTR(HLF_W) | MSG_HIST);
  #ifdef FEAT_EVAL
  	set_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_readonly), -1);
  #endif
--- 3468,3474 ----
  	if (msg_row == Rows - 1)
  	    msg_col = col;
  	msg_source(HL_ATTR(HLF_W));
! 	msg_puts_attr(_(w_readonly), HL_ATTR(HLF_W) | MSG_HIST);
  #ifdef FEAT_EVAL
  	set_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_readonly), -1);
  #endif
***************
*** 3742,3748 ****
  	{
  	    if (typed > 0)
  	    {
! 		MSG_PUTS("\b \b");
  		--typed;
  	    }
  	    n /= 10;
--- 3742,3748 ----
  	{
  	    if (typed > 0)
  	    {
! 		msg_puts("\b \b");
  		--typed;
  	    }
  	    n /= 10;
***************
*** 3786,3794 ****
  
      /* When using ":silent" assume that <CR> was entered. */
      if (mouse_used != NULL)
! 	MSG_PUTS(_("Type number and <Enter> or click with mouse (empty cancels): "));
      else
! 	MSG_PUTS(_("Type number and <Enter> (empty cancels): "));
  
      // Set the state such that text can be selected/copied/pasted and we still
      // get mouse events. redraw_after_callback() will not redraw if cmdline_row
--- 3786,3794 ----
  
      /* When using ":silent" assume that <CR> was entered. */
      if (mouse_used != NULL)
! 	msg_puts(_("Type number and <Enter> or click with mouse (empty cancels): "));
      else
! 	msg_puts(_("Type number and <Enter> (empty cancels): "));
  
      // Set the state such that text can be selected/copied/pasted and we still
      // get mouse events. redraw_after_callback() will not redraw if cmdline_row
***************
*** 3846,3861 ****
      if (pn > p_report)
      {
  	if (n > 0)
! 	    vim_snprintf((char *)msg_buf, MSG_BUF_LEN,
  		    NGETTEXT("%ld more line", "%ld more lines", pn), pn);
  	else
! 	    vim_snprintf((char *)msg_buf, MSG_BUF_LEN,
  		    NGETTEXT("%ld line less", "%ld fewer lines", pn), pn);
  	if (got_int)
! 	    vim_strcat(msg_buf, (char_u *)_(" (Interrupted)"), MSG_BUF_LEN);
  	if (msg(msg_buf))
  	{
! 	    set_keep_msg(msg_buf, 0);
  	    keep_msg_more = TRUE;
  	}
      }
--- 3846,3862 ----
      if (pn > p_report)
      {
  	if (n > 0)
! 	    vim_snprintf(msg_buf, MSG_BUF_LEN,
  		    NGETTEXT("%ld more line", "%ld more lines", pn), pn);
  	else
! 	    vim_snprintf(msg_buf, MSG_BUF_LEN,
  		    NGETTEXT("%ld line less", "%ld fewer lines", pn), pn);
  	if (got_int)
! 	    vim_strcat((char_u *)msg_buf, (char_u *)_(" (Interrupted)"),
! 								  MSG_BUF_LEN);
  	if (msg(msg_buf))
  	{
! 	    set_keep_msg((char_u *)msg_buf, 0);
  	    keep_msg_more = TRUE;
  	}
      }
***************
*** 3936,3942 ****
  	if (vim_strchr(p_debug, 'e') != NULL)
  	{
  	    msg_source(HL_ATTR(HLF_W));
! 	    msg_attr((char_u *)_("Beep!"), HL_ATTR(HLF_W));
  	}
      }
  }
--- 3937,3943 ----
  	if (vim_strchr(p_debug, 'e') != NULL)
  	{
  	    msg_source(HL_ATTR(HLF_W));
! 	    msg_attr(_("Beep!"), HL_ATTR(HLF_W));
  	}
      }
  }
*** ../vim-8.1.0778/src/misc2.c	2019-01-17 15:43:21.761878368 +0100
--- src/misc2.c	2019-01-19 16:29:12.954740959 +0100
***************
*** 4670,4676 ****
  		    smsg("Already Searched: %s (%s)",
  				   stackp->ffs_fix_path, stackp->ffs_wc_path);
  		    /* don't overwrite this either */
! 		    msg_puts((char_u *)"\n");
  		    verbose_leave_scroll();
  		}
  #endif
--- 4670,4676 ----
  		    smsg("Already Searched: %s (%s)",
  				   stackp->ffs_fix_path, stackp->ffs_wc_path);
  		    /* don't overwrite this either */
! 		    msg_puts("\n");
  		    verbose_leave_scroll();
  		}
  #endif
***************
*** 4684,4690 ****
  		smsg("Searching: %s (%s)",
  				   stackp->ffs_fix_path, stackp->ffs_wc_path);
  		/* don't overwrite this either */
! 		msg_puts((char_u *)"\n");
  		verbose_leave_scroll();
  	    }
  #endif
--- 4684,4690 ----
  		smsg("Searching: %s (%s)",
  				   stackp->ffs_fix_path, stackp->ffs_wc_path);
  		/* don't overwrite this either */
! 		msg_puts("\n");
  		verbose_leave_scroll();
  	    }
  #endif
***************
*** 4903,4909 ****
  					smsg("Already: %s",
  								   file_path);
  					/* don't overwrite this either */
! 					msg_puts((char_u *)"\n");
  					verbose_leave_scroll();
  				    }
  				    continue;
--- 4903,4909 ----
  					smsg("Already: %s",
  								   file_path);
  					/* don't overwrite this either */
! 					msg_puts("\n");
  					verbose_leave_scroll();
  				    }
  				    continue;
***************
*** 4930,4936 ****
  				    verbose_enter_scroll();
  				    smsg("HIT: %s", file_path);
  				    /* don't overwrite this either */
! 				    msg_puts((char_u *)"\n");
  				    verbose_leave_scroll();
  				}
  #endif
--- 4930,4936 ----
  				    verbose_enter_scroll();
  				    smsg("HIT: %s", file_path);
  				    /* don't overwrite this either */
! 				    msg_puts("\n");
  				    verbose_leave_scroll();
  				}
  #endif
***************
*** 5131,5137 ****
  		    smsg("ff_get_visited_list: FOUND list for %s",
  								    filename);
  		    /* don't overwrite this either */
! 		    msg_puts((char_u *)"\n");
  		    verbose_leave_scroll();
  		}
  #endif
--- 5131,5137 ----
  		    smsg("ff_get_visited_list: FOUND list for %s",
  								    filename);
  		    /* don't overwrite this either */
! 		    msg_puts("\n");
  		    verbose_leave_scroll();
  		}
  #endif
***************
*** 5147,5153 ****
  	verbose_enter_scroll();
  	smsg("ff_get_visited_list: new list for %s", filename);
  	/* don't overwrite this either */
! 	msg_puts((char_u *)"\n");
  	verbose_leave_scroll();
      }
  #endif
--- 5147,5153 ----
  	verbose_enter_scroll();
  	smsg("ff_get_visited_list: new list for %s", filename);
  	/* don't overwrite this either */
! 	msg_puts("\n");
  	verbose_leave_scroll();
      }
  #endif
*** ../vim-8.1.0778/src/normal.c	2019-01-13 23:38:33.403773217 +0100
--- src/normal.c	2019-01-19 17:20:24.649998864 +0100
***************
*** 1207,1213 ****
  	    update_screen(0);
  	    /* now reset it, otherwise it's put in the history again */
  	    keep_msg = kmsg;
! 	    msg_attr(kmsg, keep_msg_attr);
  	    vim_free(kmsg);
  	}
  	setcursor();
--- 1207,1213 ----
  	    update_screen(0);
  	    /* now reset it, otherwise it's put in the history again */
  	    keep_msg = kmsg;
! 	    msg_attr((char *)kmsg, keep_msg_attr);
  	    vim_free(kmsg);
  	}
  	setcursor();
***************
*** 3274,3280 ****
      if (full_screen)
      {
  	if (!did_check && HL_ATTR(HLF_V) == 0)
! 	    MSG(_("Warning: terminal cannot highlight"));
  	did_check = TRUE;
      }
  }
--- 3274,3280 ----
      if (full_screen)
      {
  	if (!did_check && HL_ATTR(HLF_V) == 0)
! 	    msg(_("Warning: terminal cannot highlight"));
  	did_check = TRUE;
      }
  }
***************
*** 6468,6474 ****
      cap->oap->inclusive = FALSE;
      old_pos = curwin->w_cursor;
  #ifdef FEAT_VIRTUALEDIT
!     curwin->w_cursor.coladd = 0;	    /* TODO: don't do this for an error. */
  #endif
  
  #ifdef FEAT_SEARCHPATH
--- 6468,6474 ----
      cap->oap->inclusive = FALSE;
      old_pos = curwin->w_cursor;
  #ifdef FEAT_VIRTUALEDIT
!     curwin->w_cursor.coladd = 0;    // TODO: don't do this for an error.
  #endif
  
  #ifdef FEAT_SEARCHPATH
***************
*** 6491,6501 ****
       * define	      "]d"  "[d"   "]D"  "[D"	"]^D"  "[^D"
       */
      if (vim_strchr((char_u *)
! #ifdef EBCDIC
  		"iI\005dD\067",
! #else
  		"iI\011dD\004",
! #endif
  		cap->nchar) != NULL)
      {
  	char_u	*ptr;
--- 6491,6501 ----
       * define	      "]d"  "[d"   "]D"  "[D"	"]^D"  "[^D"
       */
      if (vim_strchr((char_u *)
! # ifdef EBCDIC
  		"iI\005dD\067",
! # else
  		"iI\011dD\004",
! # endif
  		cap->nchar) != NULL)
      {
  	char_u	*ptr;
***************
*** 9027,9033 ****
  #endif
  		&& !VIsual_active
  		&& no_reason)
! 	    MSG(_("Type  :qa!  and press <Enter> to abandon all changes and exit Vim"));
  
  	/* Don't reset "restart_edit" when 'insertmode' is set, it won't be
  	 * set again below when halfway a mapping. */
--- 9027,9033 ----
  #endif
  		&& !VIsual_active
  		&& no_reason)
! 	    msg(_("Type  :qa!  and press <Enter> to abandon all changes and exit Vim"));
  
  	/* Don't reset "restart_edit" when 'insertmode' is set, it won't be
  	 * set again below when halfway a mapping. */
*** ../vim-8.1.0778/src/ops.c	2019-01-17 17:13:25.924984061 +0100
--- src/ops.c	2019-01-19 17:04:24.104510342 +0100
***************
*** 302,308 ****
  	vim_snprintf((char *)IObuff, IOSIZE,
  		NGETTEXT(msg_line_single, msg_line_plural, oap->line_count),
  		oap->line_count, op, amount);
! 	msg(IObuff);
      }
  
      /*
--- 302,308 ----
  	vim_snprintf((char *)IObuff, IOSIZE,
  		NGETTEXT(msg_line_single, msg_line_plural, oap->line_count),
  		oap->line_count, op, amount);
! 	msg((char *)IObuff);
      }
  
      /*
***************
*** 1112,1118 ****
  	 * adds the escaping back later.
  	 */
  	reg_recording = 0;
! 	MSG("");
  	p = get_recorded();
  	if (p == NULL)
  	    retval = FAIL;
--- 1112,1118 ----
  	 * adds the escaping back later.
  	 */
  	reg_recording = 0;
! 	msg("");
  	p = get_recorded();
  	if (p == NULL)
  	    retval = FAIL;
***************
*** 3049,3055 ****
  	VIM_CLEAR(y_current->y_array);
  #ifdef AMIGA
  	if (n >= 1000)
! 	    MSG("");
  #endif
      }
  }
--- 3049,3055 ----
  	VIM_CLEAR(y_current->y_array);
  #ifdef AMIGA
  	if (n >= 1000)
! 	    msg("");
  #endif
      }
  }
***************
*** 4285,4291 ****
      attr = HL_ATTR(HLF_8);
  
      /* Highlight title */
!     MSG_PUTS_TITLE(_("\n--- Registers ---"));
      for (i = -1; i < NUM_REGISTERS && !got_int; ++i)
      {
  	name = get_register_name(i);
--- 4285,4291 ----
      attr = HL_ATTR(HLF_8);
  
      /* Highlight title */
!     msg_puts_title(_("\n--- Registers ---"));
      for (i = -1; i < NUM_REGISTERS && !got_int; ++i)
      {
  	name = get_register_name(i);
***************
*** 4327,4340 ****
  	    msg_putchar('\n');
  	    msg_putchar('"');
  	    msg_putchar(name);
! 	    MSG_PUTS("   ");
  
  	    n = (int)Columns - 6;
  	    for (j = 0; j < yb->y_size && n > 1; ++j)
  	    {
  		if (j)
  		{
! 		    MSG_PUTS_ATTR("^J", attr);
  		    n -= 2;
  		}
  		for (p = yb->y_array[j]; *p && (n -= ptr2cells(p)) >= 0; ++p)
--- 4327,4340 ----
  	    msg_putchar('\n');
  	    msg_putchar('"');
  	    msg_putchar(name);
! 	    msg_puts("   ");
  
  	    n = (int)Columns - 6;
  	    for (j = 0; j < yb->y_size && n > 1; ++j)
  	    {
  		if (j)
  		{
! 		    msg_puts_attr("^J", attr);
  		    n -= 2;
  		}
  		for (p = yb->y_array[j]; *p && (n -= ptr2cells(p)) >= 0; ++p)
***************
*** 4349,4355 ****
  		}
  	    }
  	    if (n > 1 && yb->y_type == MLINE)
! 		MSG_PUTS_ATTR("^J", attr);
  	    out_flush();		    /* show one line at a time */
  	}
  	ui_breakcheck();
--- 4349,4355 ----
  		}
  	    }
  	    if (n > 1 && yb->y_type == MLINE)
! 		msg_puts_attr("^J", attr);
  	    out_flush();		    /* show one line at a time */
  	}
  	ui_breakcheck();
***************
*** 4361,4367 ****
      if ((p = get_last_insert()) != NULL
  		 && (arg == NULL || vim_strchr(arg, '.') != NULL) && !got_int)
      {
! 	MSG_PUTS("\n\".   ");
  	dis_msg(p, TRUE);
      }
  
--- 4361,4367 ----
      if ((p = get_last_insert()) != NULL
  		 && (arg == NULL || vim_strchr(arg, '.') != NULL) && !got_int)
      {
! 	msg_puts("\n\".   ");
  	dis_msg(p, TRUE);
      }
  
***************
*** 4371,4377 ****
      if (last_cmdline != NULL && (arg == NULL || vim_strchr(arg, ':') != NULL)
  								  && !got_int)
      {
! 	MSG_PUTS("\n\":   ");
  	dis_msg(last_cmdline, FALSE);
      }
  
--- 4371,4377 ----
      if (last_cmdline != NULL && (arg == NULL || vim_strchr(arg, ':') != NULL)
  								  && !got_int)
      {
! 	msg_puts("\n\":   ");
  	dis_msg(last_cmdline, FALSE);
      }
  
***************
*** 4381,4387 ****
      if (curbuf->b_fname != NULL
  	    && (arg == NULL || vim_strchr(arg, '%') != NULL) && !got_int)
      {
! 	MSG_PUTS("\n\"%   ");
  	dis_msg(curbuf->b_fname, FALSE);
      }
  
--- 4381,4387 ----
      if (curbuf->b_fname != NULL
  	    && (arg == NULL || vim_strchr(arg, '%') != NULL) && !got_int)
      {
! 	msg_puts("\n\"%   ");
  	dis_msg(curbuf->b_fname, FALSE);
      }
  
***************
*** 4395,4401 ****
  
  	if (buflist_name_nr(0, &fname, &dummy) != FAIL)
  	{
! 	    MSG_PUTS("\n\"#   ");
  	    dis_msg(fname, FALSE);
  	}
      }
--- 4395,4401 ----
  
  	if (buflist_name_nr(0, &fname, &dummy) != FAIL)
  	{
! 	    msg_puts("\n\"#   ");
  	    dis_msg(fname, FALSE);
  	}
      }
***************
*** 4406,4412 ****
      if (last_search_pat() != NULL
  		 && (arg == NULL || vim_strchr(arg, '/') != NULL) && !got_int)
      {
! 	MSG_PUTS("\n\"/   ");
  	dis_msg(last_search_pat(), FALSE);
      }
  
--- 4406,4412 ----
      if (last_search_pat() != NULL
  		 && (arg == NULL || vim_strchr(arg, '/') != NULL) && !got_int)
      {
! 	msg_puts("\n\"/   ");
  	dis_msg(last_search_pat(), FALSE);
      }
  
***************
*** 4417,4423 ****
      if (expr_line != NULL && (arg == NULL || vim_strchr(arg, '=') != NULL)
  								  && !got_int)
      {
! 	MSG_PUTS("\n\"=   ");
  	dis_msg(expr_line, FALSE);
      }
  #endif
--- 4417,4423 ----
      if (expr_line != NULL && (arg == NULL || vim_strchr(arg, '=') != NULL)
  								  && !got_int)
      {
! 	msg_puts("\n\"=   ");
  	dis_msg(expr_line, FALSE);
      }
  #endif
***************
*** 7401,7407 ****
      {
  	if (dict == NULL)
  	{
! 	    MSG(_(no_lines_msg));
  	    return;
  	}
      }
--- 7401,7407 ----
      {
  	if (dict == NULL)
  	{
! 	    msg(_(no_lines_msg));
  	    return;
  	}
      }
***************
*** 7615,7621 ****
  	    /* Don't shorten this message, the user asked for it. */
  	    p = p_shm;
  	    p_shm = (char_u *)"";
! 	    msg(IObuff);
  	    p_shm = p;
  	}
      }
--- 7615,7621 ----
  	    /* Don't shorten this message, the user asked for it. */
  	    p = p_shm;
  	    p_shm = (char_u *)"";
! 	    msg((char *)IObuff);
  	    p_shm = p;
  	}
      }
*** ../vim-8.1.0778/src/option.c	2019-01-16 22:41:50.095917784 +0100
--- src/option.c	2019-01-19 17:17:51.487038996 +0100
***************
*** 8885,8891 ****
  		static char *w_arabic = N_("W17: Arabic requires UTF-8, do ':set encoding=utf-8'");
  
  		msg_source(HL_ATTR(HLF_W));
! 		MSG_ATTR(_(w_arabic), HL_ATTR(HLF_W));
  #ifdef FEAT_EVAL
  		set_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_arabic), -1);
  #endif
--- 8885,8891 ----
  		static char *w_arabic = N_("W17: Arabic requires UTF-8, do ':set encoding=utf-8'");
  
  		msg_source(HL_ATTR(HLF_W));
! 		msg_attr(_(w_arabic), HL_ATTR(HLF_W));
  #ifdef FEAT_EVAL
  		set_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_arabic), -1);
  #endif
***************
*** 10152,10164 ****
  
      /* Highlight title */
      if (all == 2)
! 	MSG_PUTS_TITLE(_("\n--- Terminal codes ---"));
      else if (opt_flags & OPT_GLOBAL)
! 	MSG_PUTS_TITLE(_("\n--- Global option values ---"));
      else if (opt_flags & OPT_LOCAL)
! 	MSG_PUTS_TITLE(_("\n--- Local option values ---"));
      else
! 	MSG_PUTS_TITLE(_("\n--- Options ---"));
  
      /*
       * do the loop two times:
--- 10152,10164 ----
  
      /* Highlight title */
      if (all == 2)
! 	msg_puts_title(_("\n--- Terminal codes ---"));
      else if (opt_flags & OPT_GLOBAL)
! 	msg_puts_title(_("\n--- Global option values ---"));
      else if (opt_flags & OPT_LOCAL)
! 	msg_puts_title(_("\n--- Local option values ---"));
      else
! 	msg_puts_title(_("\n--- Options ---"));
  
      /*
       * do the loop two times:
***************
*** 10276,10287 ****
      /* for 'modified' we also need to check if 'ff' or 'fenc' changed. */
      if ((p->flags & P_BOOL) && ((int *)varp == &curbuf->b_changed
  					? !curbufIsChanged() : !*(int *)varp))
! 	MSG_PUTS("no");
      else if ((p->flags & P_BOOL) && *(int *)varp < 0)
! 	MSG_PUTS("--");
      else
! 	MSG_PUTS("  ");
!     MSG_PUTS(p->fullname);
      if (!(p->flags & P_BOOL))
      {
  	msg_putchar('=');
--- 10276,10287 ----
      /* for 'modified' we also need to check if 'ff' or 'fenc' changed. */
      if ((p->flags & P_BOOL) && ((int *)varp == &curbuf->b_changed
  					? !curbufIsChanged() : !*(int *)varp))
! 	msg_puts("no");
      else if ((p->flags & P_BOOL) && *(int *)varp < 0)
! 	msg_puts("--");
      else
! 	msg_puts("  ");
!     msg_puts(p->fullname);
      if (!(p->flags & P_BOOL))
      {
  	msg_putchar('=');
*** ../vim-8.1.0778/src/os_amiga.c	2019-01-13 23:38:33.403773217 +0100
--- src/os_amiga.c	2019-01-19 16:39:12.026651479 +0100
***************
*** 1230,1239 ****
      if (x < 0)
  # endif
      {
! 	MSG_PUTS(_("Cannot execute "));
  	if (cmd == NULL)
  	{
! 	    MSG_PUTS(_("shell "));
  	    msg_outtrans(p_sh);
  	}
  	else
--- 1230,1239 ----
      if (x < 0)
  # endif
      {
! 	msg_puts(_("Cannot execute "));
  	if (cmd == NULL)
  	{
! 	    msg_puts(_("shell "));
  	    msg_outtrans(p_sh);
  	}
  	else
***************
*** 1253,1259 ****
  	    {
  		msg_putchar('\n');
  		msg_outnum((long)x);
! 		MSG_PUTS(_(" returned\n"));
  	    }
  	    retval = x;
  	}
--- 1253,1259 ----
  	    {
  		msg_putchar('\n');
  		msg_outnum((long)x);
! 		msg_puts(_(" returned\n"));
  	    }
  	    retval = x;
  	}
***************
*** 1320,1326 ****
      if (x < 0)
  # endif
      {
! 	MSG_PUTS(_("Cannot execute "));
  	if (use_execute)
  	{
  	    if (cmd == NULL)
--- 1320,1326 ----
      if (x < 0)
  # endif
      {
! 	msg_puts(_("Cannot execute "));
  	if (use_execute)
  	{
  	    if (cmd == NULL)
***************
*** 1330,1336 ****
  	}
  	else
  	{
! 	    MSG_PUTS(_("shell "));
  	    msg_outtrans(shellcmd);
  	}
  	msg_putchar('\n');
--- 1330,1336 ----
  	}
  	else
  	{
! 	    msg_puts(_("shell "));
  	    msg_outtrans(shellcmd);
  	}
  	msg_putchar('\n');
***************
*** 1355,1361 ****
  	    {
  		msg_putchar('\n');
  		msg_outnum((long)x);
! 		MSG_PUTS(_(" returned\n"));
  	    }
  	    retval = x;
  	}
--- 1355,1361 ----
  	    {
  		msg_putchar('\n');
  		msg_outnum((long)x);
! 		msg_puts(_(" returned\n"));
  	    }
  	    retval = x;
  	}
*** ../vim-8.1.0778/src/os_unix.c	2019-01-17 22:28:18.901373188 +0100
--- src/os_unix.c	2019-01-19 17:22:30.673242601 +0100
***************
*** 1790,1796 ****
      (void)XSetErrorHandler(old_handler);
  
      if (p_verbose > 0 && got_x_error)
! 	verb_msg((char_u *)_("Testing the X display failed"));
  
      return (got_x_error ? FAIL : OK);
  }
--- 1790,1796 ----
      (void)XSetErrorHandler(old_handler);
  
      if (p_verbose > 0 && got_x_error)
! 	verb_msg(_("Testing the X display failed"));
  
      return (got_x_error ? FAIL : OK);
  }
***************
*** 2660,2666 ****
  		if (p_verbose >= 5)
  		{
  		    verbose_enter();
! 		    MSG("fchdir() to previous dir");
  		    verbose_leave();
  		}
  		l = fchdir(fd);
--- 2660,2666 ----
  		if (p_verbose >= 5)
  		{
  		    verbose_enter();
! 		    msg("fchdir() to previous dir");
  		    verbose_leave();
  		}
  		l = fchdir(fd);
***************
*** 2869,2882 ****
  	    if (errno == EOPNOTSUPP)
  		return;
  
! 	    MSG_PUTS(_("\nCould not get security context for "));
  	    msg_outtrans(from_file);
  	    msg_putchar('\n');
  	    return;
  	}
  	if (getfilecon((char *)to_file, &to_context) < 0)
  	{
! 	    MSG_PUTS(_("\nCould not get security context for "));
  	    msg_outtrans(to_file);
  	    msg_putchar('\n');
  	    freecon (from_context);
--- 2869,2882 ----
  	    if (errno == EOPNOTSUPP)
  		return;
  
! 	    msg_puts(_("\nCould not get security context for "));
  	    msg_outtrans(from_file);
  	    msg_putchar('\n');
  	    return;
  	}
  	if (getfilecon((char *)to_file, &to_context) < 0)
  	{
! 	    msg_puts(_("\nCould not get security context for "));
  	    msg_outtrans(to_file);
  	    msg_putchar('\n');
  	    freecon (from_context);
***************
*** 2886,2892 ****
  	{
  	    if (setfilecon((char *)to_file, from_context) < 0)
  	    {
! 		MSG_PUTS(_("\nCould not set security context for "));
  		msg_outtrans(to_file);
  		msg_putchar('\n');
  	    }
--- 2886,2892 ----
  	{
  	    if (setfilecon((char *)to_file, from_context) < 0)
  	    {
! 		msg_puts(_("\nCould not set security context for "));
  		msg_outtrans(to_file);
  		msg_putchar('\n');
  	    }
***************
*** 2957,2963 ****
  		     vim_snprintf((char *)IObuff, IOSIZE,
  			    _("Could not get security context %s for %s. Removing it!"),
  			    name, from_file);
! 		    msg_puts(IObuff);
  		    msg_putchar('\n');
  		    /* FALLTHROUGH to remove the attribute */
  
--- 2957,2963 ----
  		     vim_snprintf((char *)IObuff, IOSIZE,
  			    _("Could not get security context %s for %s. Removing it!"),
  			    name, from_file);
! 		    msg_puts((char *)IObuff);
  		    msg_putchar('\n');
  		    /* FALLTHROUGH to remove the attribute */
  
***************
*** 4505,4514 ****
      if (emsg_silent)
  	;
      else if (x == 127)
! 	MSG_PUTS(_("\nCannot execute shell sh\n"));
      else if (x && !(options & SHELL_SILENT))
      {
! 	MSG_PUTS(_("\nshell returned "));
  	msg_outnum((long)x);
  	msg_putchar('\n');
      }
--- 4505,4514 ----
      if (emsg_silent)
  	;
      else if (x == 127)
! 	msg_puts(_("\nCannot execute shell sh\n"));
      else if (x && !(options & SHELL_SILENT))
      {
! 	msg_puts(_("\nshell returned "));
  	msg_outnum((long)x);
  	msg_putchar('\n');
      }
***************
*** 4605,4611 ****
  	    }
  	    if (pipe_error)
  	    {
! 		MSG_PUTS(_("\nCannot create pipes\n"));
  		out_flush();
  	    }
  	}
--- 4605,4611 ----
  	    }
  	    if (pipe_error)
  	    {
! 		msg_puts(_("\nCannot create pipes\n"));
  		out_flush();
  	    }
  	}
***************
*** 4625,4631 ****
  	{
  	    UNBLOCK_SIGNALS(&curset);
  
! 	    MSG_PUTS(_("\nCannot fork\n"));
  	    if ((options & (SHELL_READ|SHELL_WRITE))
  # ifdef FEAT_GUI
  		|| (gui.in_use && show_shell_mess)
--- 4625,4631 ----
  	{
  	    UNBLOCK_SIGNALS(&curset);
  
! 	    msg_puts(_("\nCannot fork\n"));
  	    if ((options & (SHELL_READ|SHELL_WRITE))
  # ifdef FEAT_GUI
  		|| (gui.in_use && show_shell_mess)
***************
*** 4877,4883 ****
  		     * external program. */
  		    if ((wpid = fork()) == -1)
  		    {
! 			MSG_PUTS(_("\nCannot fork\n"));
  		    }
  		    else if (wpid == 0) /* child */
  		    {
--- 4877,4883 ----
  		     * external program. */
  		    if ((wpid = fork()) == -1)
  		    {
! 			msg_puts(_("\nCannot fork\n"));
  		    }
  		    else if (wpid == 0) /* child */
  		    {
***************
*** 5166,5172 ****
  			    }
  			    c = *p;
  			    *p = NUL;
! 			    msg_puts(buffer);
  			    if (p < buffer + len)
  			    {
  				*p = c;
--- 5166,5172 ----
  			    }
  			    c = *p;
  			    *p = NUL;
! 			    msg_puts((char *)buffer);
  			    if (p < buffer + len)
  			    {
  				*p = c;
***************
*** 5180,5186 ****
  			else
  			{
  			    buffer[len] = NUL;
! 			    msg_puts(buffer);
  			}
  
  			windgoto(msg_row, msg_col);
--- 5180,5186 ----
  			else
  			{
  			    buffer[len] = NUL;
! 			    msg_puts((char *)buffer);
  			}
  
  			windgoto(msg_row, msg_col);
***************
*** 5360,5379 ****
  		{
  		    if (retval == EXEC_FAILED)
  		    {
! 			MSG_PUTS(_("\nCannot execute shell "));
  			msg_outtrans(p_sh);
  			msg_putchar('\n');
  		    }
  		    else if (!(options & SHELL_SILENT))
  		    {
! 			MSG_PUTS(_("\nshell returned "));
  			msg_outnum((long)retval);
  			msg_putchar('\n');
  		    }
  		}
  	    }
  	    else
! 		MSG_PUTS(_("\nCommand terminated\n"));
  	}
      }
  
--- 5360,5379 ----
  		{
  		    if (retval == EXEC_FAILED)
  		    {
! 			msg_puts(_("\nCannot execute shell "));
  			msg_outtrans(p_sh);
  			msg_putchar('\n');
  		    }
  		    else if (!(options & SHELL_SILENT))
  		    {
! 			msg_puts(_("\nshell returned "));
  			msg_outnum((long)retval);
  			msg_putchar('\n');
  		    }
  		}
  	    }
  	    else
! 		msg_puts(_("\nCommand terminated\n"));
  	}
      }
  
***************
*** 6196,6202 ****
  	    else if (fds[xsmp_idx].revents & POLLHUP)
  	    {
  		if (p_verbose > 0)
! 		    verb_msg((char_u *)_("XSMP lost ICE connection"));
  		xsmp_close();
  	    }
  	    if (--ret == 0)
--- 6196,6202 ----
  	    else if (fds[xsmp_idx].revents & POLLHUP)
  	    {
  		if (p_verbose > 0)
! 		    verb_msg(_("XSMP lost ICE connection"));
  		xsmp_close();
  	    }
  	    if (--ret == 0)
***************
*** 6354,6360 ****
  	    if (FD_ISSET(xsmp_icefd, &efds))
  	    {
  		if (p_verbose > 0)
! 		    verb_msg((char_u *)_("XSMP lost ICE connection"));
  		xsmp_close();
  		if (--ret == 0)
  		    finished = FALSE;   /* keep going if event was only one */
--- 6354,6360 ----
  	    if (FD_ISSET(xsmp_icefd, &efds))
  	    {
  		if (p_verbose > 0)
! 		    verb_msg(_("XSMP lost ICE connection"));
  		xsmp_close();
  		if (--ret == 0)
  		    finished = FALSE;   /* keep going if event was only one */
***************
*** 6714,6720 ****
  	    if (!(flags & EW_SILENT))
  #endif
  	    {
! 		MSG(_(e_wildexpand));
  		msg_start();		/* don't overwrite this message */
  	    }
  	}
--- 6714,6720 ----
  	    if (!(flags & EW_SILENT))
  #endif
  	    {
! 		msg(_(e_wildexpand));
  		msg_start();		/* don't overwrite this message */
  	    }
  	}
***************
*** 6734,6740 ****
  	/* Something went wrong, perhaps a file name with a special char. */
  	if (!(flags & EW_SILENT))
  	{
! 	    MSG(_(e_wildexpand));
  	    msg_start();		/* don't overwrite this message */
  	}
  	vim_free(tempname);
--- 6734,6740 ----
  	/* Something went wrong, perhaps a file name with a special char. */
  	if (!(flags & EW_SILENT))
  	{
! 	    msg(_(e_wildexpand));
  	    msg_start();		/* don't overwrite this message */
  	}
  	vim_free(tempname);
***************
*** 7534,7540 ****
  	if (xterm_dpy == NULL)
  	{
  	    if (p_verbose > 0)
! 		verb_msg((char_u *)_("Opening the X display failed"));
  	    return;
  	}
  
--- 7534,7540 ----
  	if (xterm_dpy == NULL)
  	{
  	    if (p_verbose > 0)
! 		verb_msg(_("Opening the X display failed"));
  	    return;
  	}
  
***************
*** 7872,7878 ****
      ml_sync_all(FALSE, FALSE);	/* preserve all swap files */
  
      if (p_verbose > 0)
! 	verb_msg((char_u *)_("XSMP handling save-yourself request"));
  
  # if defined(FEAT_GUI) && defined(USE_XSMP_INTERACT)
      /* Now see if we can ask about unsaved files */
--- 7872,7878 ----
      ml_sync_all(FALSE, FALSE);	/* preserve all swap files */
  
      if (p_verbose > 0)
! 	verb_msg(_("XSMP handling save-yourself request"));
  
  # if defined(FEAT_GUI) && defined(USE_XSMP_INTERACT)
      /* Now see if we can ask about unsaved files */
***************
*** 7961,7967 ****
      {
  	/* Lost ICE */
  	if (p_verbose > 0)
! 	    verb_msg((char_u *)_("XSMP lost ICE connection"));
  	xsmp_close();
  	return FAIL;
      }
--- 7961,7967 ----
      {
  	/* Lost ICE */
  	if (p_verbose > 0)
! 	    verb_msg(_("XSMP lost ICE connection"));
  	xsmp_close();
  	return FAIL;
      }
***************
*** 7984,7990 ****
  #endif
  
      if (p_verbose > 0)
! 	verb_msg((char_u *)_("XSMP opening connection"));
  
      xsmp.save_yourself = xsmp.shutdown = False;
  
--- 7984,7990 ----
  #endif
  
      if (p_verbose > 0)
! 	verb_msg(_("XSMP opening connection"));
  
      xsmp.save_yourself = xsmp.shutdown = False;
  
***************
*** 8003,8009 ****
      if (IceAddConnectionWatch(xsmp_ice_connection, &dummy) == 0)
      {
  	if (p_verbose > 0)
! 	    verb_msg((char_u *)_("XSMP ICE connection watch failed"));
  	return;
      }
  
--- 8003,8009 ----
      if (IceAddConnectionWatch(xsmp_ice_connection, &dummy) == 0)
      {
  	if (p_verbose > 0)
! 	    verb_msg(_("XSMP ICE connection watch failed"));
  	return;
      }
  
***************
*** 8028,8034 ****
  	{
  	    vim_snprintf(errorreport, sizeof(errorreport),
  			 _("XSMP SmcOpenConnection failed: %s"), errorstring);
! 	    verb_msg((char_u *)errorreport);
  	}
  	return;
      }
--- 8028,8034 ----
  	{
  	    vim_snprintf(errorreport, sizeof(errorreport),
  			 _("XSMP SmcOpenConnection failed: %s"), errorstring);
! 	    verb_msg(errorreport);
  	}
  	return;
      }
*** ../vim-8.1.0778/src/os_win32.c	2019-01-19 14:36:56.796683378 +0100
--- src/os_win32.c	2019-01-19 16:39:35.414491642 +0100
***************
*** 4534,4540 ****
  	    }
  	    c = *p;
  	    *p = NUL;
! 	    msg_puts(buffer);
  	    if (p < buffer + len)
  	    {
  		*p = c;
--- 4534,4540 ----
  	    }
  	    c = *p;
  	    *p = NUL;
! 	    msg_puts((char *)buffer);
  	    if (p < buffer + len)
  	    {
  		*p = c;
***************
*** 4548,4554 ****
  	else
  	{
  	    buffer[len] = NUL;
! 	    msg_puts(buffer);
  	}
  
  	windgoto(msg_row, msg_col);
--- 4548,4554 ----
  	else
  	{
  	    buffer[len] = NUL;
! 	    msg_puts((char *)buffer);
  	}
  
  	windgoto(msg_row, msg_col);
***************
*** 4607,4613 ****
  	CloseHandle(g_hChildStd_IN_Wr);
  	CloseHandle(g_hChildStd_OUT_Rd);
  	CloseHandle(g_hChildStd_OUT_Wr);
! 	MSG_PUTS(_("\nCannot create pipes\n"));
      }
  
      si.cb = sizeof(si);
--- 4607,4613 ----
  	CloseHandle(g_hChildStd_IN_Wr);
  	CloseHandle(g_hChildStd_OUT_Rd);
  	CloseHandle(g_hChildStd_OUT_Wr);
! 	msg_puts(_("\nCannot create pipes\n"));
      }
  
      si.cb = sizeof(si);
*** ../vim-8.1.0778/src/proto/message.pro	2019-01-15 20:19:36.743904434 +0100
--- src/proto/message.pro	2019-01-19 17:34:34.636755665 +0100
***************
*** 1,8 ****
  /* message.c */
! int msg(char_u *s);
! int verb_msg(char_u *s);
! int msg_attr(char_u *s, int attr);
! int msg_attr_keep(char_u *s, int attr, int keep);
  char_u *msg_strtrunc(char_u *s, int force);
  void trunc_string(char_u *s, char_u *buf, int room_in, int buflen);
  void reset_last_sourcing(void);
--- 1,8 ----
  /* message.c */
! int msg(char *s);
! int verb_msg(char *s);
! int msg_attr(char *s, int attr);
! int msg_attr_keep(char *s, int attr, int keep);
  char_u *msg_strtrunc(char_u *s, int force);
  void trunc_string(char_u *s, char_u *buf, int room_in, int buflen);
  void reset_last_sourcing(void);
***************
*** 11,31 ****
  void ignore_error_for_testing(char_u *error);
  void do_perror(char *msg);
  int emsg(char *s);
! 
! int semsg(const char *s, ...)
! #ifdef USE_PRINTF_FORMAT_ATTRIBUTE
!     __attribute__((format(printf, 1, 2)))
! #endif
! ;
  void iemsg(char *s);
! void siemsg(const char *s, ...)
! #ifdef USE_PRINTF_FORMAT_ATTRIBUTE
!     __attribute__((format(printf, 1, 2)))
! #endif
! ;
  void internal_error(char *where);
  void emsg_invreg(int name);
! char_u *msg_trunc_attr(char_u *s, int force, int attr);
  char_u *msg_may_trunc(int force, char_u *s);
  int delete_first_msg(void);
  void ex_messages(exarg_T *eap);
--- 11,22 ----
  void ignore_error_for_testing(char_u *error);
  void do_perror(char *msg);
  int emsg(char *s);
! int semsg(const char *s, ...);
  void iemsg(char *s);
! void siemsg(const char *s, ...);
  void internal_error(char *where);
  void emsg_invreg(int name);
! char *msg_trunc_attr(char *s, int force, int attr);
  char_u *msg_may_trunc(int force, char_u *s);
  int delete_first_msg(void);
  void ex_messages(exarg_T *eap);
***************
*** 51,61 ****
  char_u *str2special(char_u **sp, int from);
  void str2specialbuf(char_u *sp, char_u *buf, int len);
  void msg_prt_line(char_u *s, int list);
! void msg_puts(char_u *s);
! void msg_puts_title(char_u *s);
! void msg_puts_long_attr(char_u *longstr, int attr);
! void msg_puts_long_len_attr(char_u *longstr, int len, int attr);
! void msg_puts_attr(char_u *s, int attr);
  int message_filtered(char_u *msg);
  void may_clear_sb_text(void);
  void sb_text_start_cmdline(void);
--- 42,52 ----
  char_u *str2special(char_u **sp, int from);
  void str2specialbuf(char_u *sp, char_u *buf, int len);
  void msg_prt_line(char_u *s, int list);
! void msg_puts(char *s);
! void msg_puts_title(char *s);
! void msg_outtrans_long_attr(char_u *longstr, int attr);
! void msg_outtrans_long_len_attr(char_u *longstr, int len, int attr);
! void msg_puts_attr(char *s, int attr);
  int message_filtered(char_u *msg);
  void may_clear_sb_text(void);
  void sb_text_start_cmdline(void);
*** ../vim-8.1.0778/src/quickfix.c	2019-01-15 20:19:36.743904434 +0100
--- src/quickfix.c	2019-01-19 17:36:56.459840497 +0100
***************
*** 3149,3155 ****
  	msg_scroll = TRUE;
      else if (!msg_scrolled && shortmess(SHM_OVERALL))
  	msg_scroll = FALSE;
!     msg_attr_keep(IObuff, 0, TRUE);
      msg_scroll = i;
  }
  
--- 3149,3155 ----
  	msg_scroll = TRUE;
      else if (!msg_scrolled && shortmess(SHM_OVERALL))
  	msg_scroll = FALSE;
!     msg_attr_keep((char *)IObuff, 0, TRUE);
      msg_scroll = i;
  }
  
***************
*** 3422,3428 ****
      msg_outtrans_attr(IObuff, cursel ? HL_ATTR(HLF_QFL) : qfFileAttr);
  
      if (qfp->qf_lnum != 0)
! 	msg_puts_attr((char_u *)":", qfSepAttr);
      if (qfp->qf_lnum == 0)
  	IObuff[0] = NUL;
      else if (qfp->qf_col == 0)
--- 3422,3428 ----
      msg_outtrans_attr(IObuff, cursel ? HL_ATTR(HLF_QFL) : qfFileAttr);
  
      if (qfp->qf_lnum != 0)
! 	msg_puts_attr(":", qfSepAttr);
      if (qfp->qf_lnum == 0)
  	IObuff[0] = NUL;
      else if (qfp->qf_col == 0)
***************
*** 3432,3446 ****
  		qfp->qf_lnum, qfp->qf_col);
      sprintf((char *)IObuff + STRLEN(IObuff), "%s",
  	    (char *)qf_types(qfp->qf_type, qfp->qf_nr));
!     msg_puts_attr(IObuff, qfLineAttr);
!     msg_puts_attr((char_u *)":", qfSepAttr);
      if (qfp->qf_pattern != NULL)
      {
  	qf_fmt_text(qfp->qf_pattern, IObuff, IOSIZE);
! 	msg_puts(IObuff);
! 	msg_puts_attr((char_u *)":", qfSepAttr);
      }
!     msg_puts((char_u *)" ");
  
      // Remove newlines and leading whitespace from the text.  For an
      // unrecognized line keep the indent, the compiler may mark a word
--- 3432,3446 ----
  		qfp->qf_lnum, qfp->qf_col);
      sprintf((char *)IObuff + STRLEN(IObuff), "%s",
  	    (char *)qf_types(qfp->qf_type, qfp->qf_nr));
!     msg_puts_attr((char *)IObuff, qfLineAttr);
!     msg_puts_attr(":", qfSepAttr);
      if (qfp->qf_pattern != NULL)
      {
  	qf_fmt_text(qfp->qf_pattern, IObuff, IOSIZE);
! 	msg_puts((char *)IObuff);
! 	msg_puts_attr(":", qfSepAttr);
      }
!     msg_puts(" ");
  
      // Remove newlines and leading whitespace from the text.  For an
      // unrecognized line keep the indent, the compiler may mark a word
***************
*** 3601,3607 ****
  	vim_strcat(buf, (char_u *)title, IOSIZE);
      }
      trunc_string(buf, buf, Columns - 1, IOSIZE);
!     msg(buf);
  }
  
  /*
--- 3601,3607 ----
  	vim_strcat(buf, (char_u *)title, IOSIZE);
      }
      trunc_string(buf, buf, Columns - 1, IOSIZE);
!     msg((char *)buf);
  }
  
  /*
***************
*** 3667,3673 ****
      if (is_loclist_cmd(eap->cmdidx))
  	qi = GET_LOC_LIST(curwin);
      if (qf_stack_empty(qi))
! 	MSG(_("No entries"));
      else
  	for (i = 0; i < qi->qf_listcount; ++i)
  	    qf_msg(qi, i, i == qi->qf_curlist ? "> " : "  ");
--- 3667,3673 ----
      if (is_loclist_cmd(eap->cmdidx))
  	qi = GET_LOC_LIST(curwin);
      if (qf_stack_empty(qi))
! 	msg(_("No entries"));
      else
  	for (i = 0; i < qi->qf_listcount; ++i)
  	    qf_msg(qi, i, i == qi->qf_curlist ? "> " : "  ");
***************
*** 4653,4659 ****
      if (msg_col == 0)
  	msg_didout = FALSE;
      msg_start();
!     MSG_PUTS(":!");
      msg_outtrans(cmd);		// show what we are doing
  
      return cmd;
--- 4653,4659 ----
      if (msg_col == 0)
  	msg_didout = FALSE;
      msg_start();
!     msg_puts(":!");
      msg_outtrans(cmd);		// show what we are doing
  
      return cmd;
*** ../vim-8.1.0778/src/sign.c	2019-01-18 22:01:39.017406155 +0100
--- src/sign.c	2019-01-19 17:04:49.608338047 +0100
***************
*** 611,617 ****
      char	lbuf[MSG_BUF_LEN];
      char	group[MSG_BUF_LEN];
  
!     MSG_PUTS_TITLE(_("\n--- Signs ---"));
      msg_putchar('\n');
      if (rbuf == NULL)
  	buf = firstbuf;
--- 611,617 ----
      char	lbuf[MSG_BUF_LEN];
      char	group[MSG_BUF_LEN];
  
!     msg_puts_title(_("\n--- Signs ---"));
      msg_putchar('\n');
      if (rbuf == NULL)
  	buf = firstbuf;
***************
*** 622,628 ****
  	if (buf->b_signlist != NULL)
  	{
  	    vim_snprintf(lbuf, MSG_BUF_LEN, _("Signs for %s:"), buf->b_fname);
! 	    MSG_PUTS_ATTR(lbuf, HL_ATTR(HLF_D));
  	    msg_putchar('\n');
  	}
  	FOR_ALL_SIGNS_IN_BUF(buf, sign)
--- 622,628 ----
  	if (buf->b_signlist != NULL)
  	{
  	    vim_snprintf(lbuf, MSG_BUF_LEN, _("Signs for %s:"), buf->b_fname);
! 	    msg_puts_attr(lbuf, HL_ATTR(HLF_D));
  	    msg_putchar('\n');
  	}
  	FOR_ALL_SIGNS_IN_BUF(buf, sign)
***************
*** 640,646 ****
  			   _("    line=%ld  id=%d%s  name=%s  priority=%d"),
  			   (long)sign->lnum, sign->id, group,
  			   sign_typenr2name(sign->typenr), sign->priority);
! 	    MSG_PUTS(lbuf);
  	    msg_putchar('\n');
  	}
  	if (rbuf != NULL)
--- 640,646 ----
  			   _("    line=%ld  id=%d%s  name=%s  priority=%d"),
  			   (long)sign->lnum, sign->id, group,
  			   sign_typenr2name(sign->typenr), sign->priority);
! 	    msg_puts(lbuf);
  	    msg_putchar('\n');
  	}
  	if (rbuf != NULL)
***************
*** 1640,1676 ****
      smsg("sign %s", sp->sn_name);
      if (sp->sn_icon != NULL)
      {
! 	MSG_PUTS(" icon=");
  	msg_outtrans(sp->sn_icon);
  # ifdef FEAT_SIGN_ICONS
  	if (sp->sn_image == NULL)
! 	    MSG_PUTS(_(" (NOT FOUND)"));
  # else
! 	MSG_PUTS(_(" (not supported)"));
  # endif
      }
      if (sp->sn_text != NULL)
      {
! 	MSG_PUTS(" text=");
  	msg_outtrans(sp->sn_text);
      }
      if (sp->sn_line_hl > 0)
      {
! 	MSG_PUTS(" linehl=");
  	p = get_highlight_name_ext(NULL, sp->sn_line_hl - 1, FALSE);
  	if (p == NULL)
! 	    MSG_PUTS("NONE");
  	else
! 	    msg_puts(p);
      }
      if (sp->sn_text_hl > 0)
      {
! 	MSG_PUTS(" texthl=");
  	p = get_highlight_name_ext(NULL, sp->sn_text_hl - 1, FALSE);
  	if (p == NULL)
! 	    MSG_PUTS("NONE");
  	else
! 	    msg_puts(p);
      }
  }
  
--- 1640,1676 ----
      smsg("sign %s", sp->sn_name);
      if (sp->sn_icon != NULL)
      {
! 	msg_puts(" icon=");
  	msg_outtrans(sp->sn_icon);
  # ifdef FEAT_SIGN_ICONS
  	if (sp->sn_image == NULL)
! 	    msg_puts(_(" (NOT FOUND)"));
  # else
! 	msg_puts(_(" (not supported)"));
  # endif
      }
      if (sp->sn_text != NULL)
      {
! 	msg_puts(" text=");
  	msg_outtrans(sp->sn_text);
      }
      if (sp->sn_line_hl > 0)
      {
! 	msg_puts(" linehl=");
  	p = get_highlight_name_ext(NULL, sp->sn_line_hl - 1, FALSE);
  	if (p == NULL)
! 	    msg_puts("NONE");
  	else
! 	    msg_puts((char *)p);
      }
      if (sp->sn_text_hl > 0)
      {
! 	msg_puts(" texthl=");
  	p = get_highlight_name_ext(NULL, sp->sn_text_hl - 1, FALSE);
  	if (p == NULL)
! 	    msg_puts("NONE");
  	else
! 	    msg_puts((char *)p);
      }
  }
  
*** ../vim-8.1.0778/src/regexp.c	2019-01-14 22:46:11.965663420 +0100
--- src/regexp.c	2019-01-19 16:39:51.774379828 +0100
***************
*** 8199,8206 ****
      if (p_verbose > 0)
      {
  	verbose_enter();
! 	MSG_PUTS(_("Switching to backtracking RE engine for pattern: "));
! 	MSG_PUTS(pat);
  	verbose_leave();
      }
  }
--- 8199,8206 ----
      if (p_verbose > 0)
      {
  	verbose_enter();
! 	msg_puts(_("Switching to backtracking RE engine for pattern: "));
! 	msg_puts((char *)pat);
  	verbose_leave();
      }
  }
*** ../vim-8.1.0778/src/ui.c	2019-01-17 15:43:21.765878343 +0100
--- src/ui.c	2019-01-19 17:22:51.013123699 +0100
***************
*** 340,346 ****
  	emsg(_(e_shellempty));
      else
      {
! 	MSG_PUTS(_("new shell started\n"));
  	do_shell(NULL, 0);
      }
  }
--- 340,346 ----
  	emsg(_(e_shellempty));
      else
      {
! 	msg_puts(_("new shell started\n"));
  	do_shell(NULL, 0);
      }
  }
***************
*** 2626,2632 ****
  	if (p_verbose > 0)
  	{
  	    verbose_enter();
! 	    verb_msg((char_u *)_("Used CUT_BUFFER0 instead of empty selection"));
  	    verbose_leave();
  	}
      }
--- 2626,2632 ----
  	if (p_verbose > 0)
  	{
  	    verbose_enter();
! 	    verb_msg(_("Used CUT_BUFFER0 instead of empty selection"));
  	    verbose_leave();
  	}
      }
*** ../vim-8.1.0778/src/screen.c	2019-01-17 21:09:02.049706334 +0100
--- src/screen.c	2019-01-19 16:57:05.395462330 +0100
***************
*** 10438,10444 ****
  	attr = HL_ATTR(HLF_CM);			/* Highlight mode */
  	if (do_mode)
  	{
! 	    MSG_PUTS_ATTR("--", attr);
  #if defined(FEAT_XIM)
  	    if (
  # ifdef FEAT_GUI_GTK
--- 10438,10444 ----
  	attr = HL_ATTR(HLF_CM);			/* Highlight mode */
  	if (do_mode)
  	{
! 	    msg_puts_attr("--", attr);
  #if defined(FEAT_XIM)
  	    if (
  # ifdef FEAT_GUI_GTK
***************
*** 10448,10456 ****
  # endif
  	       )
  # ifdef FEAT_GUI_GTK /* most of the time, it's not XIM being used */
! 		MSG_PUTS_ATTR(" IM", attr);
  # else
! 		MSG_PUTS_ATTR(" XIM", attr);
  # endif
  #endif
  #if defined(FEAT_HANGULIN) && defined(FEAT_GUI)
--- 10448,10456 ----
  # endif
  	       )
  # ifdef FEAT_GUI_GTK /* most of the time, it's not XIM being used */
! 		msg_puts_attr(" IM", attr);
  # else
! 		msg_puts_attr(" XIM", attr);
  # endif
  #endif
  #if defined(FEAT_HANGULIN) && defined(FEAT_GUI)
***************
*** 10460,10468 ****
  		{
  		    /* HANGUL */
  		    if (enc_utf8)
! 			MSG_PUTS_ATTR(" \355\225\234\352\270\200", attr);
  		    else
! 			MSG_PUTS_ATTR(" \307\321\261\333", attr);
  		}
  	    }
  #endif
--- 10460,10468 ----
  		{
  		    /* HANGUL */
  		    if (enc_utf8)
! 			msg_puts_attr(" \355\225\234\352\270\200", attr);
  		    else
! 			msg_puts_attr(" \307\321\261\333", attr);
  		}
  	    }
  #endif
***************
*** 10482,10498 ****
  		    if (length - vim_strsize(edit_submode) > 0)
  		    {
  			if (edit_submode_pre != NULL)
! 			    msg_puts_attr(edit_submode_pre, attr);
! 			msg_puts_attr(edit_submode, attr);
  		    }
  		    if (edit_submode_extra != NULL)
  		    {
! 			MSG_PUTS_ATTR(" ", attr);  /* add a space in between */
  			if ((int)edit_submode_highl < (int)HLF_COUNT)
  			    sub_attr = HL_ATTR(edit_submode_highl);
  			else
  			    sub_attr = attr;
! 			msg_puts_attr(edit_submode_extra, sub_attr);
  		    }
  		}
  	    }
--- 10482,10498 ----
  		    if (length - vim_strsize(edit_submode) > 0)
  		    {
  			if (edit_submode_pre != NULL)
! 			    msg_puts_attr((char *)edit_submode_pre, attr);
! 			msg_puts_attr((char *)edit_submode, attr);
  		    }
  		    if (edit_submode_extra != NULL)
  		    {
! 			msg_puts_attr(" ", attr);  /* add a space in between */
  			if ((int)edit_submode_highl < (int)HLF_COUNT)
  			    sub_attr = HL_ATTR(edit_submode_highl);
  			else
  			    sub_attr = attr;
! 			msg_puts_attr((char *)edit_submode_extra, sub_attr);
  		    }
  		}
  	    }
***************
*** 10500,10528 ****
  #endif
  	    {
  		if (State & VREPLACE_FLAG)
! 		    MSG_PUTS_ATTR(_(" VREPLACE"), attr);
  		else if (State & REPLACE_FLAG)
! 		    MSG_PUTS_ATTR(_(" REPLACE"), attr);
  		else if (State & INSERT)
  		{
  #ifdef FEAT_RIGHTLEFT
  		    if (p_ri)
! 			MSG_PUTS_ATTR(_(" REVERSE"), attr);
  #endif
! 		    MSG_PUTS_ATTR(_(" INSERT"), attr);
  		}
  		else if (restart_edit == 'I' || restart_edit == 'A')
! 		    MSG_PUTS_ATTR(_(" (insert)"), attr);
  		else if (restart_edit == 'R')
! 		    MSG_PUTS_ATTR(_(" (replace)"), attr);
  		else if (restart_edit == 'V')
! 		    MSG_PUTS_ATTR(_(" (vreplace)"), attr);
  #ifdef FEAT_RIGHTLEFT
  		if (p_hkmap)
! 		    MSG_PUTS_ATTR(_(" Hebrew"), attr);
  # ifdef FEAT_FKMAP
  		if (p_fkmap)
! 		    MSG_PUTS_ATTR(farsi_text_5, attr);
  # endif
  #endif
  #ifdef FEAT_KEYMAP
--- 10500,10528 ----
  #endif
  	    {
  		if (State & VREPLACE_FLAG)
! 		    msg_puts_attr(_(" VREPLACE"), attr);
  		else if (State & REPLACE_FLAG)
! 		    msg_puts_attr(_(" REPLACE"), attr);
  		else if (State & INSERT)
  		{
  #ifdef FEAT_RIGHTLEFT
  		    if (p_ri)
! 			msg_puts_attr(_(" REVERSE"), attr);
  #endif
! 		    msg_puts_attr(_(" INSERT"), attr);
  		}
  		else if (restart_edit == 'I' || restart_edit == 'A')
! 		    msg_puts_attr(_(" (insert)"), attr);
  		else if (restart_edit == 'R')
! 		    msg_puts_attr(_(" (replace)"), attr);
  		else if (restart_edit == 'V')
! 		    msg_puts_attr(_(" (vreplace)"), attr);
  #ifdef FEAT_RIGHTLEFT
  		if (p_hkmap)
! 		    msg_puts_attr(_(" Hebrew"), attr);
  # ifdef FEAT_FKMAP
  		if (p_fkmap)
! 		    msg_puts_attr(farsi_text_5, attr);
  # endif
  #endif
  #ifdef FEAT_KEYMAP
***************
*** 10530,10545 ****
  		{
  # ifdef FEAT_ARABIC
  		    if (curwin->w_p_arab)
! 			MSG_PUTS_ATTR(_(" Arabic"), attr);
  		    else
  # endif
  			if (get_keymap_str(curwin, (char_u *)" (%s)",
  							   NameBuff, MAXPATHL))
! 			    MSG_PUTS_ATTR(NameBuff, attr);
  		}
  #endif
  		if ((State & INSERT) && p_paste)
! 		    MSG_PUTS_ATTR(_(" (paste)"), attr);
  
  		if (VIsual_active)
  		{
--- 10530,10545 ----
  		{
  # ifdef FEAT_ARABIC
  		    if (curwin->w_p_arab)
! 			msg_puts_attr(_(" Arabic"), attr);
  		    else
  # endif
  			if (get_keymap_str(curwin, (char_u *)" (%s)",
  							   NameBuff, MAXPATHL))
! 			    msg_puts_attr((char *)NameBuff, attr);
  		}
  #endif
  		if ((State & INSERT) && p_paste)
! 		    msg_puts_attr(_(" (paste)"), attr);
  
  		if (VIsual_active)
  		{
***************
*** 10558,10566 ****
  			case 5: p = N_(" SELECT LINE"); break;
  			default: p = N_(" SELECT BLOCK"); break;
  		    }
! 		    MSG_PUTS_ATTR(_(p), attr);
  		}
! 		MSG_PUTS_ATTR(" --", attr);
  	    }
  
  	    need_clear = TRUE;
--- 10558,10566 ----
  			case 5: p = N_(" SELECT LINE"); break;
  			default: p = N_(" SELECT BLOCK"); break;
  		    }
! 		    msg_puts_attr(_(p), attr);
  		}
! 		msg_puts_attr(" --", attr);
  	    }
  
  	    need_clear = TRUE;
***************
*** 10651,10662 ****
      static void
  recording_mode(int attr)
  {
!     MSG_PUTS_ATTR(_("recording"), attr);
      if (!shortmess(SHM_RECORDING))
      {
! 	char_u s[4];
! 	sprintf((char *)s, " @%c", reg_recording);
! 	MSG_PUTS_ATTR(s, attr);
      }
  }
  
--- 10651,10663 ----
      static void
  recording_mode(int attr)
  {
!     msg_puts_attr(_("recording"), attr);
      if (!shortmess(SHM_RECORDING))
      {
! 	char s[4];
! 
! 	sprintf(s, " @%c", reg_recording);
! 	msg_puts_attr(s, attr);
      }
  }
  
*** ../vim-8.1.0778/src/search.c	2019-01-13 23:38:33.407773189 +0100
--- src/search.c	2019-01-19 17:29:54.298539992 +0100
***************
*** 5059,5065 ****
  						       message */
  			    {
  				msg_home_replace_hl(new_fname);
! 				MSG_PUTS(_(" (includes previously listed match)"));
  				prev_fname = NULL;
  			    }
  			}
--- 5059,5065 ----
  						       message */
  			    {
  				msg_home_replace_hl(new_fname);
! 				msg_puts(_(" (includes previously listed match)"));
  				prev_fname = NULL;
  			    }
  			}
***************
*** 5078,5102 ****
  		else
  		{
  		    gotocmdline(TRUE);	    /* cursor at status line */
! 		    MSG_PUTS_TITLE(_("--- Included files "));
  		    if (action != ACTION_SHOW_ALL)
! 			MSG_PUTS_TITLE(_("not found "));
! 		    MSG_PUTS_TITLE(_("in path ---\n"));
  		}
  		did_show = TRUE;
  		while (depth_displayed < depth && !got_int)
  		{
  		    ++depth_displayed;
  		    for (i = 0; i < depth_displayed; i++)
! 			MSG_PUTS("  ");
  		    msg_home_replace(files[depth_displayed].name);
! 		    MSG_PUTS(" -->\n");
  		}
  		if (!got_int)		    /* don't display if 'q' typed
  					       for "--more--" message */
  		{
  		    for (i = 0; i <= depth_displayed; i++)
! 			MSG_PUTS("  ");
  		    if (new_fname != NULL)
  		    {
  			/* using "new_fname" is more reliable, e.g., when
--- 5078,5102 ----
  		else
  		{
  		    gotocmdline(TRUE);	    /* cursor at status line */
! 		    msg_puts_title(_("--- Included files "));
  		    if (action != ACTION_SHOW_ALL)
! 			msg_puts_title(_("not found "));
! 		    msg_puts_title(_("in path ---\n"));
  		}
  		did_show = TRUE;
  		while (depth_displayed < depth && !got_int)
  		{
  		    ++depth_displayed;
  		    for (i = 0; i < depth_displayed; i++)
! 			msg_puts("  ");
  		    msg_home_replace(files[depth_displayed].name);
! 		    msg_puts(" -->\n");
  		}
  		if (!got_int)		    /* don't display if 'q' typed
  					       for "--more--" message */
  		{
  		    for (i = 0; i <= depth_displayed; i++)
! 			msg_puts("  ");
  		    if (new_fname != NULL)
  		    {
  			/* using "new_fname" is more reliable, e.g., when
***************
*** 5154,5162 ****
  		    if (new_fname == NULL && action == ACTION_SHOW_ALL)
  		    {
  			if (already_searched)
! 			    MSG_PUTS(_("  (Already listed)"));
  			else
! 			    MSG_PUTS(_("  NOT FOUND"));
  		    }
  		}
  		out_flush();	    /* output each line directly */
--- 5154,5162 ----
  		    if (new_fname == NULL && action == ACTION_SHOW_ALL)
  		    {
  			if (already_searched)
! 			    msg_puts(_("  (Already listed)"));
  			else
! 			    msg_puts(_("  NOT FOUND"));
  		    }
  		}
  		out_flush();	    /* output each line directly */
***************
*** 5212,5218 ****
  			vim_snprintf((char*)IObuff, IOSIZE,
  				_("Scanning included file: %s"),
  				(char *)new_fname);
! 			msg_trunc_attr(IObuff, TRUE, HL_ATTR(HLF_R));
  		    }
  		    else
  #endif
--- 5212,5218 ----
  			vim_snprintf((char*)IObuff, IOSIZE,
  				_("Scanning included file: %s"),
  				(char *)new_fname);
! 			msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));
  		    }
  		    else
  #endif
***************
*** 5593,5601 ****
  	if (!did_show)
  	{
  	    if (action != ACTION_SHOW_ALL)
! 		MSG(_("All included files were found"));
  	    else
! 		MSG(_("No included files"));
  	}
      }
      else if (!found
--- 5593,5601 ----
  	if (!did_show)
  	{
  	    if (action != ACTION_SHOW_ALL)
! 		msg(_("All included files were found"));
  	    else
! 		msg(_("No included files"));
  	}
      }
      else if (!found
***************
*** 5658,5668 ****
  	if (action == ACTION_SHOW_ALL)
  	{
  	    sprintf((char *)IObuff, "%3ld: ", count);	/* show match nr */
! 	    msg_puts(IObuff);
  	    sprintf((char *)IObuff, "%4ld", *lnum);	/* show line nr */
  						/* Highlight line numbers */
! 	    msg_puts_attr(IObuff, HL_ATTR(HLF_N));
! 	    MSG_PUTS(" ");
  	}
  	msg_prt_line(line, FALSE);
  	out_flush();			/* show one line at a time */
--- 5658,5668 ----
  	if (action == ACTION_SHOW_ALL)
  	{
  	    sprintf((char *)IObuff, "%3ld: ", count);	/* show match nr */
! 	    msg_puts((char *)IObuff);
  	    sprintf((char *)IObuff, "%4ld", *lnum);	/* show line nr */
  						/* Highlight line numbers */
! 	    msg_puts_attr((char *)IObuff, HL_ATTR(HLF_N));
! 	    msg_puts(" ");
  	}
  	msg_prt_line(line, FALSE);
  	out_flush();			/* show one line at a time */
*** ../vim-8.1.0778/src/spell.c	2019-01-13 23:38:33.411773162 +0100
--- src/spell.c	2019-01-19 16:32:13.585509178 +0100
***************
*** 3375,3381 ****
  							TRUE, need_cap, TRUE);
  
      if (sug.su_ga.ga_len == 0)
! 	MSG(_("Sorry, no suggestions"));
      else if (count > 0)
      {
  	if (count > sug.su_ga.ga_len)
--- 3375,3381 ----
  							TRUE, need_cap, TRUE);
  
      if (sug.su_ga.ga_len == 0)
! 	msg(_("Sorry, no suggestions"));
      else if (count > 0)
      {
  	if (count > sug.su_ga.ga_len)
***************
*** 3409,3415 ****
  						sug.su_badlen, sug.su_badptr);
  	}
  #endif
! 	msg_puts(IObuff);
  	msg_clr_eos();
  	msg_putchar('\n');
  
--- 3409,3415 ----
  						sug.su_badlen, sug.su_badptr);
  	}
  #endif
! 	msg_puts((char *)IObuff);
  	msg_clr_eos();
  	msg_putchar('\n');
  
***************
*** 3430,3446 ****
  	    if (cmdmsg_rl)
  		rl_mirror(IObuff);
  #endif
! 	    msg_puts(IObuff);
  
  	    vim_snprintf((char *)IObuff, IOSIZE, " \"%s\"", wcopy);
! 	    msg_puts(IObuff);
  
  	    /* The word may replace more than "su_badlen". */
  	    if (sug.su_badlen < stp->st_orglen)
  	    {
  		vim_snprintf((char *)IObuff, IOSIZE, _(" < \"%.*s\""),
  					       stp->st_orglen, sug.su_badptr);
! 		msg_puts(IObuff);
  	    }
  
  	    if (p_verbose > 0)
--- 3430,3446 ----
  	    if (cmdmsg_rl)
  		rl_mirror(IObuff);
  #endif
! 	    msg_puts((char *)IObuff);
  
  	    vim_snprintf((char *)IObuff, IOSIZE, " \"%s\"", wcopy);
! 	    msg_puts((char *)IObuff);
  
  	    /* The word may replace more than "su_badlen". */
  	    if (sug.su_badlen < stp->st_orglen)
  	    {
  		vim_snprintf((char *)IObuff, IOSIZE, _(" < \"%.*s\""),
  					       stp->st_orglen, sug.su_badptr);
! 		msg_puts((char *)IObuff);
  	    }
  
  	    if (p_verbose > 0)
***************
*** 3459,3465 ****
  		    rl_mirror(IObuff + 1);
  #endif
  		msg_advance(30);
! 		msg_puts(IObuff);
  	    }
  	    msg_putchar('\n');
  	}
--- 3459,3465 ----
  		    rl_mirror(IObuff + 1);
  #endif
  		msg_advance(30);
! 		msg_puts((char *)IObuff);
  	    }
  	    msg_putchar('\n');
  	}
***************
*** 8458,8470 ****
      for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len && !got_int; ++lpi)
      {
  	lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);
! 	msg_puts((char_u *)"file: ");
! 	msg_puts(lp->lp_slang->sl_fname);
  	msg_putchar('\n');
  	p = lp->lp_slang->sl_info;
  	if (p != NULL)
  	{
! 	    msg_puts(p);
  	    msg_putchar('\n');
  	}
      }
--- 8458,8470 ----
      for (lpi = 0; lpi < curwin->w_s->b_langp.ga_len && !got_int; ++lpi)
      {
  	lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);
! 	msg_puts("file: ");
! 	msg_puts((char *)lp->lp_slang->sl_fname);
  	msg_putchar('\n');
  	p = lp->lp_slang->sl_info;
  	if (p != NULL)
  	{
! 	    msg_puts((char *)p);
  	    msg_putchar('\n');
  	}
      }
*** ../vim-8.1.0778/src/spellfile.c	2019-01-15 20:19:36.747904404 +0100
--- src/spellfile.c	2019-01-19 17:07:59.295055062 +0100
***************
*** 2114,2122 ****
  	PRINTSOME(line1, depth, "(%d)", node->wn_nr, 0);
  	PRINTSOME(line2, depth, "    ", 0, 0);
  	PRINTSOME(line3, depth, "    ", 0, 0);
! 	msg((char_u *)line1);
! 	msg((char_u *)line2);
! 	msg((char_u *)line3);
      }
      else
      {
--- 2114,2122 ----
  	PRINTSOME(line1, depth, "(%d)", node->wn_nr, 0);
  	PRINTSOME(line2, depth, "    ", 0, 0);
  	PRINTSOME(line3, depth, "    ", 0, 0);
! 	msg(line1);
! 	msg(line2);
! 	msg(line3);
      }
      else
      {
***************
*** 2142,2150 ****
  
  	if (node->wn_byte == NUL)
  	{
! 	    msg((char_u *)line1);
! 	    msg((char_u *)line2);
! 	    msg((char_u *)line3);
  	}
  
  	/* do the children */
--- 2142,2150 ----
  
  	if (node->wn_byte == NUL)
  	{
! 	    msg(line1);
! 	    msg(line2);
! 	    msg(line3);
  	}
  
  	/* do the children */
***************
*** 3085,3095 ****
      if (spin->si_newcompID < spin->si_newprefID)
      {
  	if (spin->si_newcompID == 127 || spin->si_newcompID == 255)
! 	    MSG(_("Too many postponed prefixes"));
  	else if (spin->si_newprefID == 0 || spin->si_newprefID == 127)
! 	    MSG(_("Too many compound flags"));
  	else
! 	    MSG(_("Too many postponed prefixes and/or compound flags"));
      }
  
      if (syllable != NULL)
--- 3085,3095 ----
      if (spin->si_newcompID < spin->si_newprefID)
      {
  	if (spin->si_newcompID == 127 || spin->si_newcompID == 255)
! 	    msg(_("Too many postponed prefixes"));
  	else if (spin->si_newprefID == 0 || spin->si_newprefID == 127)
! 	    msg(_("Too many compound flags"));
  	else
! 	    msg(_("Too many postponed prefixes and/or compound flags"));
      }
  
      if (syllable != NULL)
***************
*** 3640,3646 ****
  		    _("line %6d, word %6ld - %s"),
  		       lnum, spin->si_foldwcount + spin->si_keepwcount, w);
  	    msg_start();
! 	    msg_puts_long_attr(message, 0);
  	    msg_clr_eos();
  	    msg_didout = FALSE;
  	    msg_col = 0;
--- 3640,3646 ----
  		    _("line %6d, word %6ld - %s"),
  		       lnum, spin->si_foldwcount + spin->si_keepwcount, w);
  	    msg_start();
! 	    msg_outtrans_long_attr(message, 0);
  	    msg_clr_eos();
  	    msg_didout = FALSE;
  	    msg_col = 0;
***************
*** 4618,4624 ****
  	if (spin->si_verbose)
  	{
  	    msg_start();
! 	    msg_puts((char_u *)_(msg_compressing));
  	    msg_clr_eos();
  	    msg_didout = FALSE;
  	    msg_col = 0;
--- 4618,4624 ----
  	if (spin->si_verbose)
  	{
  	    msg_start();
! 	    msg_puts(_(msg_compressing));
  	    msg_clr_eos();
  	    msg_didout = FALSE;
  	    msg_col = 0;
***************
*** 6119,6125 ****
  	}
  
  	if (spin.si_compflags != NULL && spin.si_nobreak)
! 	    MSG(_("Warning: both compounding and NOBREAK specified"));
  
  	if (!error && !got_int)
  	{
--- 6119,6125 ----
  	}
  
  	if (spin.si_compflags != NULL && spin.si_nobreak)
! 	    msg(_("Warning: both compounding and NOBREAK specified"));
  
  	if (!error && !got_int)
  	{
***************
*** 6197,6203 ****
      {
  	if (!spin->si_verbose)
  	    verbose_enter();
! 	MSG(str);
  	out_flush();
  	if (!spin->si_verbose)
  	    verbose_leave();
--- 6197,6203 ----
      {
  	if (!spin->si_verbose)
  	    verbose_enter();
! 	msg((char *)str);
  	out_flush();
  	if (!spin->si_verbose)
  	    verbose_leave();
*** ../vim-8.1.0778/src/syntax.c	2019-01-13 23:38:33.411773162 +0100
--- src/syntax.c	2019-01-19 17:04:55.576297722 +0100
***************
*** 3313,3319 ****
      if (timed_out && !syn_win->w_s->b_syn_slow)
      {
  	syn_win->w_s->b_syn_slow = TRUE;
! 	MSG(_("'redrawtime' exceeded, syntax highlighting disabled"));
      }
  #endif
  
--- 3313,3319 ----
      if (timed_out && !syn_win->w_s->b_syn_slow)
      {
  	syn_win->w_s->b_syn_slow = TRUE;
! 	msg(_("'redrawtime' exceeded, syntax highlighting disabled"));
      }
  #endif
  
***************
*** 3435,3443 ****
      if (*arg == NUL)
      {
  	if (curwin->w_s->b_syn_conceal)
! 	    MSG(_("syntax conceal on"));
  	else
! 	    MSG(_("syntax conceal off"));
      }
      else if (STRNICMP(arg, "on", 2) == 0 && next - arg == 2)
  	curwin->w_s->b_syn_conceal = TRUE;
--- 3435,3443 ----
      if (*arg == NUL)
      {
  	if (curwin->w_s->b_syn_conceal)
! 	    msg(_("syntax conceal on"));
  	else
! 	    msg(_("syntax conceal off"));
      }
      else if (STRNICMP(arg, "on", 2) == 0 && next - arg == 2)
  	curwin->w_s->b_syn_conceal = TRUE;
***************
*** 3465,3473 ****
      if (*arg == NUL)
      {
  	if (curwin->w_s->b_syn_ic)
! 	    MSG(_("syntax case ignore"));
  	else
! 	    MSG(_("syntax case match"));
      }
      else if (STRNICMP(arg, "match", 5) == 0 && next - arg == 5)
  	curwin->w_s->b_syn_ic = FALSE;
--- 3465,3473 ----
      if (*arg == NUL)
      {
  	if (curwin->w_s->b_syn_ic)
! 	    msg(_("syntax case ignore"));
  	else
! 	    msg(_("syntax case match"));
      }
      else if (STRNICMP(arg, "match", 5) == 0 && next - arg == 5)
  	curwin->w_s->b_syn_ic = FALSE;
***************
*** 3494,3504 ****
      if (*arg == NUL)
      {
  	if (curwin->w_s->b_syn_spell == SYNSPL_TOP)
! 	    MSG(_("syntax spell toplevel"));
  	else if (curwin->w_s->b_syn_spell == SYNSPL_NOTOP)
! 	    MSG(_("syntax spell notoplevel"));
  	else
! 	    MSG(_("syntax spell default"));
      }
      else if (STRNICMP(arg, "toplevel", 8) == 0 && next - arg == 8)
  	curwin->w_s->b_syn_spell = SYNSPL_TOP;
--- 3494,3504 ----
      if (*arg == NUL)
      {
  	if (curwin->w_s->b_syn_spell == SYNSPL_TOP)
! 	    msg(_("syntax spell toplevel"));
  	else if (curwin->w_s->b_syn_spell == SYNSPL_NOTOP)
! 	    msg(_("syntax spell notoplevel"));
  	else
! 	    msg(_("syntax spell default"));
      }
      else if (STRNICMP(arg, "toplevel", 8) == 0 && next - arg == 8)
  	curwin->w_s->b_syn_spell = SYNSPL_TOP;
***************
*** 3532,3541 ****
      arg = skipwhite(arg);
      if (*arg == NUL)
      {
! 	MSG_PUTS("\n");
  	if (curwin->w_s->b_syn_isk != empty_option)
  	{
! 	    MSG_PUTS(_("syntax iskeyword "));
  	    msg_outtrans(curwin->w_s->b_syn_isk);
  	}
  	else
--- 3532,3541 ----
      arg = skipwhite(arg);
      if (*arg == NUL)
      {
! 	msg_puts("\n");
  	if (curwin->w_s->b_syn_isk != empty_option)
  	{
! 	    msg_puts(_("syntax iskeyword "));
  	    msg_outtrans(curwin->w_s->b_syn_isk);
  	}
  	else
***************
*** 3909,3915 ****
  
      if (!syntax_present(curwin))
      {
! 	MSG(_(msg_no_items));
  	return;
      }
  
--- 3909,3915 ----
  
      if (!syntax_present(curwin))
      {
! 	msg(_(msg_no_items));
  	return;
      }
  
***************
*** 3917,3923 ****
      {
  	if (curwin->w_s->b_syn_sync_flags & SF_CCOMMENT)
  	{
! 	    MSG_PUTS(_("syncing on C-style comments"));
  	    syn_lines_msg();
  	    syn_match_msg();
  	    return;
--- 3917,3923 ----
      {
  	if (curwin->w_s->b_syn_sync_flags & SF_CCOMMENT)
  	{
! 	    msg_puts(_("syncing on C-style comments"));
  	    syn_lines_msg();
  	    syn_match_msg();
  	    return;
***************
*** 3925,3952 ****
  	else if (!(curwin->w_s->b_syn_sync_flags & SF_MATCH))
  	{
  	    if (curwin->w_s->b_syn_sync_minlines == 0)
! 		MSG_PUTS(_("no syncing"));
  	    else
  	    {
! 		MSG_PUTS(_("syncing starts "));
  		msg_outnum(curwin->w_s->b_syn_sync_minlines);
! 		MSG_PUTS(_(" lines before top line"));
  		syn_match_msg();
  	    }
  	    return;
  	}
! 	MSG_PUTS_TITLE(_("\n--- Syntax sync items ---"));
  	if (curwin->w_s->b_syn_sync_minlines > 0
  		|| curwin->w_s->b_syn_sync_maxlines > 0
  		|| curwin->w_s->b_syn_sync_linebreaks > 0)
  	{
! 	    MSG_PUTS(_("\nsyncing on items"));
  	    syn_lines_msg();
  	    syn_match_msg();
  	}
      }
      else
! 	MSG_PUTS_TITLE(_("\n--- Syntax items ---"));
      if (ends_excmd(*arg))
      {
  	/*
--- 3925,3952 ----
  	else if (!(curwin->w_s->b_syn_sync_flags & SF_MATCH))
  	{
  	    if (curwin->w_s->b_syn_sync_minlines == 0)
! 		msg_puts(_("no syncing"));
  	    else
  	    {
! 		msg_puts(_("syncing starts "));
  		msg_outnum(curwin->w_s->b_syn_sync_minlines);
! 		msg_puts(_(" lines before top line"));
  		syn_match_msg();
  	    }
  	    return;
  	}
! 	msg_puts_title(_("\n--- Syntax sync items ---"));
  	if (curwin->w_s->b_syn_sync_minlines > 0
  		|| curwin->w_s->b_syn_sync_maxlines > 0
  		|| curwin->w_s->b_syn_sync_linebreaks > 0)
  	{
! 	    msg_puts(_("\nsyncing on items"));
  	    syn_lines_msg();
  	    syn_match_msg();
  	}
      }
      else
! 	msg_puts_title(_("\n--- Syntax items ---"));
      if (ends_excmd(*arg))
      {
  	/*
***************
*** 3993,4012 ****
      if (curwin->w_s->b_syn_sync_maxlines > 0
  				      || curwin->w_s->b_syn_sync_minlines > 0)
      {
! 	MSG_PUTS("; ");
  	if (curwin->w_s->b_syn_sync_minlines > 0)
  	{
! 	    MSG_PUTS(_("minimal "));
  	    msg_outnum(curwin->w_s->b_syn_sync_minlines);
  	    if (curwin->w_s->b_syn_sync_maxlines)
! 		MSG_PUTS(", ");
  	}
  	if (curwin->w_s->b_syn_sync_maxlines > 0)
  	{
! 	    MSG_PUTS(_("maximal "));
  	    msg_outnum(curwin->w_s->b_syn_sync_maxlines);
  	}
! 	MSG_PUTS(_(" lines before top line"));
      }
  }
  
--- 3993,4012 ----
      if (curwin->w_s->b_syn_sync_maxlines > 0
  				      || curwin->w_s->b_syn_sync_minlines > 0)
      {
! 	msg_puts("; ");
  	if (curwin->w_s->b_syn_sync_minlines > 0)
  	{
! 	    msg_puts(_("minimal "));
  	    msg_outnum(curwin->w_s->b_syn_sync_minlines);
  	    if (curwin->w_s->b_syn_sync_maxlines)
! 		msg_puts(", ");
  	}
  	if (curwin->w_s->b_syn_sync_maxlines > 0)
  	{
! 	    msg_puts(_("maximal "));
  	    msg_outnum(curwin->w_s->b_syn_sync_maxlines);
  	}
! 	msg_puts(_(" lines before top line"));
      }
  }
  
***************
*** 4015,4023 ****
  {
      if (curwin->w_s->b_syn_sync_linebreaks > 0)
      {
! 	MSG_PUTS(_("; match "));
  	msg_outnum(curwin->w_s->b_syn_sync_linebreaks);
! 	MSG_PUTS(_(" line breaks"));
      }
  }
  
--- 4015,4023 ----
  {
      if (curwin->w_s->b_syn_sync_linebreaks > 0)
      {
! 	msg_puts(_("; match "));
  	msg_outnum(curwin->w_s->b_syn_sync_linebreaks);
! 	msg_puts(_(" line breaks"));
      }
  }
  
***************
*** 4122,4136 ****
  	if (spp->sp_flags & (HL_SYNC_HERE|HL_SYNC_THERE))
  	{
  	    if (spp->sp_flags & HL_SYNC_HERE)
! 		msg_puts_attr((char_u *)"grouphere", attr);
  	    else
! 		msg_puts_attr((char_u *)"groupthere", attr);
  	    msg_putchar(' ');
  	    if (spp->sp_sync_idx >= 0)
  		msg_outtrans(HL_TABLE()[SYN_ITEMS(curwin->w_s)
  				   [spp->sp_sync_idx].sp_syn.id - 1].sg_name);
  	    else
! 		MSG_PUTS("NONE");
  	    msg_putchar(' ');
  	}
      }
--- 4122,4136 ----
  	if (spp->sp_flags & (HL_SYNC_HERE|HL_SYNC_THERE))
  	{
  	    if (spp->sp_flags & HL_SYNC_HERE)
! 		msg_puts_attr("grouphere", attr);
  	    else
! 		msg_puts_attr("groupthere", attr);
  	    msg_putchar(' ');
  	    if (spp->sp_sync_idx >= 0)
  		msg_outtrans(HL_TABLE()[SYN_ITEMS(curwin->w_s)
  				   [spp->sp_sync_idx].sp_syn.id - 1].sg_name);
  	    else
! 		msg_puts("NONE");
  	    msg_putchar(' ');
  	}
      }
***************
*** 4139,4145 ****
      if (HL_TABLE()[id - 1].sg_link && (did_header || link_only) && !got_int)
      {
  	(void)syn_list_header(did_header, 999, id);
! 	msg_puts_attr((char_u *)"links to", attr);
  	msg_putchar(' ');
  	msg_outtrans(HL_TABLE()[HL_TABLE()[id - 1].sg_link - 1].sg_name);
      }
--- 4139,4145 ----
      if (HL_TABLE()[id - 1].sg_link && (did_header || link_only) && !got_int)
      {
  	(void)syn_list_header(did_header, 999, id);
! 	msg_puts_attr("links to", attr);
  	msg_putchar(' ');
  	msg_outtrans(HL_TABLE()[HL_TABLE()[id - 1].sg_link - 1].sg_name);
      }
***************
*** 4153,4159 ****
      for (i = 0; nlist[i].flag != 0; ++i)
  	if (flags & nlist[i].flag)
  	{
! 	    msg_puts_attr((char_u *)nlist[i].name, attr);
  	    msg_putchar(' ');
  	}
  }
--- 4153,4159 ----
      for (i = 0; nlist[i].flag != 0; ++i)
  	if (flags & nlist[i].flag)
  	{
! 	    msg_puts_attr(nlist[i].name, attr);
  	    msg_putchar(' ');
  	}
  }
***************
*** 4183,4190 ****
      }
      else
      {
! 	msg_puts_attr((char_u *)"cluster", HL_ATTR(HLF_D));
! 	msg_puts((char_u *)"=NONE");
      }
  }
  
--- 4183,4190 ----
      }
      else
      {
! 	msg_puts_attr("cluster", HL_ATTR(HLF_D));
! 	msg_puts("=NONE");
      }
  }
  
***************
*** 4193,4216 ****
  {
      short		*p;
  
!     msg_puts_attr(name, attr);
      msg_putchar('=');
      for (p = list; *p; ++p)
      {
  	if (*p >= SYNID_ALLBUT && *p < SYNID_TOP)
  	{
  	    if (p[1])
! 		MSG_PUTS("ALLBUT");
  	    else
! 		MSG_PUTS("ALL");
  	}
  	else if (*p >= SYNID_TOP && *p < SYNID_CONTAINED)
  	{
! 	    MSG_PUTS("TOP");
  	}
  	else if (*p >= SYNID_CONTAINED && *p < SYNID_CLUSTER)
  	{
! 	    MSG_PUTS("CONTAINED");
  	}
  	else if (*p >= SYNID_CLUSTER)
  	{
--- 4193,4216 ----
  {
      short		*p;
  
!     msg_puts_attr((char *)name, attr);
      msg_putchar('=');
      for (p = list; *p; ++p)
      {
  	if (*p >= SYNID_ALLBUT && *p < SYNID_TOP)
  	{
  	    if (p[1])
! 		msg_puts("ALLBUT");
  	    else
! 		msg_puts("ALL");
  	}
  	else if (*p >= SYNID_TOP && *p < SYNID_CONTAINED)
  	{
! 	    msg_puts("TOP");
  	}
  	else if (*p >= SYNID_CONTAINED && *p < SYNID_CLUSTER)
  	{
! 	    msg_puts("CONTAINED");
  	}
  	else if (*p >= SYNID_CLUSTER)
  	{
***************
*** 4244,4250 ****
      if (last_matchgroup != spp->sp_syn_match_id)
      {
  	last_matchgroup = spp->sp_syn_match_id;
! 	msg_puts_attr((char_u *)"matchgroup", attr);
  	msg_putchar('=');
  	if (last_matchgroup == 0)
  	    msg_outtrans((char_u *)"NONE");
--- 4244,4250 ----
      if (last_matchgroup != spp->sp_syn_match_id)
      {
  	last_matchgroup = spp->sp_syn_match_id;
! 	msg_puts_attr("matchgroup", attr);
  	msg_putchar('=');
  	if (last_matchgroup == 0)
  	    msg_outtrans((char_u *)"NONE");
***************
*** 4254,4260 ****
      }
  
      /* output the name of the pattern and an '=' or ' ' */
!     msg_puts_attr((char_u *)s, attr);
      msg_putchar(c);
  
      /* output the pattern, in between a char that is not in the pattern */
--- 4254,4260 ----
      }
  
      /* output the name of the pattern and an '=' or ' ' */
!     msg_puts_attr(s, attr);
      msg_putchar(c);
  
      /* output the pattern, in between a char that is not in the pattern */
***************
*** 4277,4283 ****
  	{
  	    if (!first)
  		msg_putchar(',');	/* separate with commas */
! 	    msg_puts((char_u *)spo_name_tab[i]);
  	    n = spp->sp_offsets[i];
  	    if (i != SPO_LC_OFF)
  	    {
--- 4277,4283 ----
  	{
  	    if (!first)
  		msg_putchar(',');	/* separate with commas */
! 	    msg_puts(spo_name_tab[i]);
  	    n = spp->sp_offsets[i];
  	    if (i != SPO_LC_OFF)
  	    {
***************
*** 4354,4360 ****
  		    did_header = TRUE;
  		    if (prev_contained != (kp->flags & HL_CONTAINED))
  		    {
! 			msg_puts_attr((char_u *)"contained", attr);
  			msg_putchar(' ');
  			prev_contained = (kp->flags & HL_CONTAINED);
  		    }
--- 4354,4360 ----
  		    did_header = TRUE;
  		    if (prev_contained != (kp->flags & HL_CONTAINED))
  		    {
! 			msg_puts_attr("contained", attr);
  			msg_putchar(' ');
  			prev_contained = (kp->flags & HL_CONTAINED);
  		    }
***************
*** 4372,4390 ****
  			prev_next_list = kp->next_list;
  			if (kp->flags & HL_SKIPNL)
  			{
! 			    msg_puts_attr((char_u *)"skipnl", attr);
  			    msg_putchar(' ');
  			    prev_skipnl = (kp->flags & HL_SKIPNL);
  			}
  			if (kp->flags & HL_SKIPWHITE)
  			{
! 			    msg_puts_attr((char_u *)"skipwhite", attr);
  			    msg_putchar(' ');
  			    prev_skipwhite = (kp->flags & HL_SKIPWHITE);
  			}
  			if (kp->flags & HL_SKIPEMPTY)
  			{
! 			    msg_puts_attr((char_u *)"skipempty", attr);
  			    msg_putchar(' ');
  			    prev_skipempty = (kp->flags & HL_SKIPEMPTY);
  			}
--- 4372,4390 ----
  			prev_next_list = kp->next_list;
  			if (kp->flags & HL_SKIPNL)
  			{
! 			    msg_puts_attr("skipnl", attr);
  			    msg_putchar(' ');
  			    prev_skipnl = (kp->flags & HL_SKIPNL);
  			}
  			if (kp->flags & HL_SKIPWHITE)
  			{
! 			    msg_puts_attr("skipwhite", attr);
  			    msg_putchar(' ');
  			    prev_skipwhite = (kp->flags & HL_SKIPWHITE);
  			}
  			if (kp->flags & HL_SKIPEMPTY)
  			{
! 			    msg_puts_attr("skipempty", attr);
  			    msg_putchar(' ');
  			    prev_skipempty = (kp->flags & HL_SKIPEMPTY);
  			}
***************
*** 6671,6677 ****
  
      if (!syntax_present(curwin))
      {
! 	MSG(_(msg_no_items));
  	return;
      }
      for (idx = 0; idx < curwin->w_s->b_syn_patterns.ga_len; ++idx)
--- 6671,6677 ----
  
      if (!syntax_present(curwin))
      {
! 	msg(_(msg_no_items));
  	return;
      }
      for (idx = 0; idx < curwin->w_s->b_syn_patterns.ga_len; ++idx)
***************
*** 6742,6748 ****
  
      if (!syntax_present(curwin))
      {
! 	MSG(_(msg_no_items));
  	return;
      }
  
--- 6742,6748 ----
  
      if (!syntax_present(curwin))
      {
! 	msg(_(msg_no_items));
  	return;
      }
  
***************
*** 6777,6807 ****
  	qsort(ga.ga_data, (size_t)ga.ga_len, sizeof(time_entry_T),
  							 syn_compare_syntime);
  
!     MSG_PUTS_TITLE(_("  TOTAL      COUNT  MATCH   SLOWEST     AVERAGE   NAME               PATTERN"));
!     MSG_PUTS("\n");
      for (idx = 0; idx < ga.ga_len && !got_int; ++idx)
      {
  	p = ((time_entry_T *)ga.ga_data) + idx;
  
! 	MSG_PUTS(profile_msg(&p->total));
! 	MSG_PUTS(" "); /* make sure there is always a separating space */
  	msg_advance(13);
  	msg_outnum(p->count);
! 	MSG_PUTS(" ");
  	msg_advance(20);
  	msg_outnum(p->match);
! 	MSG_PUTS(" ");
  	msg_advance(26);
! 	MSG_PUTS(profile_msg(&p->slowest));
! 	MSG_PUTS(" ");
  	msg_advance(38);
  # ifdef FEAT_FLOAT
! 	MSG_PUTS(profile_msg(&p->average));
! 	MSG_PUTS(" ");
  # endif
  	msg_advance(50);
  	msg_outtrans(HL_TABLE()[p->id - 1].sg_name);
! 	MSG_PUTS(" ");
  
  	msg_advance(69);
  	if (Columns < 80)
--- 6777,6807 ----
  	qsort(ga.ga_data, (size_t)ga.ga_len, sizeof(time_entry_T),
  							 syn_compare_syntime);
  
!     msg_puts_title(_("  TOTAL      COUNT  MATCH   SLOWEST     AVERAGE   NAME               PATTERN"));
!     msg_puts("\n");
      for (idx = 0; idx < ga.ga_len && !got_int; ++idx)
      {
  	p = ((time_entry_T *)ga.ga_data) + idx;
  
! 	msg_puts(profile_msg(&p->total));
! 	msg_puts(" "); /* make sure there is always a separating space */
  	msg_advance(13);
  	msg_outnum(p->count);
! 	msg_puts(" ");
  	msg_advance(20);
  	msg_outnum(p->match);
! 	msg_puts(" ");
  	msg_advance(26);
! 	msg_puts(profile_msg(&p->slowest));
! 	msg_puts(" ");
  	msg_advance(38);
  # ifdef FEAT_FLOAT
! 	msg_puts(profile_msg(&p->average));
! 	msg_puts(" ");
  # endif
  	msg_advance(50);
  	msg_outtrans(HL_TABLE()[p->id - 1].sg_name);
! 	msg_puts(" ");
  
  	msg_advance(69);
  	if (Columns < 80)
***************
*** 6811,6826 ****
  	if (len > (int)STRLEN(p->pattern))
  	    len = (int)STRLEN(p->pattern);
  	msg_outtrans_len(p->pattern, len);
! 	MSG_PUTS("\n");
      }
      ga_clear(&ga);
      if (!got_int)
      {
! 	MSG_PUTS("\n");
! 	MSG_PUTS(profile_msg(&total_total));
  	msg_advance(13);
  	msg_outnum(total_count);
! 	MSG_PUTS("\n");
      }
  }
  #endif
--- 6811,6826 ----
  	if (len > (int)STRLEN(p->pattern))
  	    len = (int)STRLEN(p->pattern);
  	msg_outtrans_len(p->pattern, len);
! 	msg_puts("\n");
      }
      ga_clear(&ga);
      if (!got_int)
      {
! 	msg_puts("\n");
! 	msg_puts(profile_msg(&total_total));
  	msg_advance(13);
  	msg_outnum(total_count);
! 	msg_puts("\n");
      }
  }
  #endif
***************
*** 9227,9233 ****
      {
  	(void)syn_list_header(didh, 9999, id);
  	didh = TRUE;
! 	msg_puts_attr((char_u *)"links to", HL_ATTR(HLF_D));
  	msg_putchar(' ');
  	msg_outtrans(HL_TABLE()[HL_TABLE()[id - 1].sg_link - 1].sg_name);
      }
--- 9227,9233 ----
      {
  	(void)syn_list_header(didh, 9999, id);
  	didh = TRUE;
! 	msg_puts_attr("links to", HL_ATTR(HLF_D));
  	msg_putchar(' ');
  	msg_outtrans(HL_TABLE()[HL_TABLE()[id - 1].sg_link - 1].sg_name);
      }
***************
*** 9284,9291 ****
  	{
  	    if (*name != NUL)
  	    {
! 		MSG_PUTS_ATTR(name, HL_ATTR(HLF_D));
! 		MSG_PUTS_ATTR("=", HL_ATTR(HLF_D));
  	    }
  	    msg_outtrans(ts);
  	}
--- 9284,9291 ----
  	{
  	    if (*name != NUL)
  	    {
! 		msg_puts_attr(name, HL_ATTR(HLF_D));
! 		msg_puts_attr("=", HL_ATTR(HLF_D));
  	    }
  	    msg_outtrans(ts);
  	}
***************
*** 9484,9490 ****
      /* Show "xxx" with the attributes. */
      if (!did_header)
      {
! 	msg_puts_attr((char_u *)"xxx", syn_id2attr(id));
  	msg_putchar(' ');
      }
  
--- 9484,9490 ----
      /* Show "xxx" with the attributes. */
      if (!did_header)
      {
! 	msg_puts_attr("xxx", syn_id2attr(id));
  	msg_putchar(' ');
      }
  
***************
*** 9725,9731 ****
  	    /* This is an error, but since there previously was no check only
  	     * give a warning. */
  	    msg_source(HL_ATTR(HLF_W));
! 	    MSG(_("W18: Invalid character in group name"));
  	    break;
  	}
      }
--- 9725,9731 ----
  	    /* This is an error, but since there previously was no check only
  	     * give a warning. */
  	    msg_source(HL_ATTR(HLF_W));
! 	    msg(_("W18: Invalid character in group name"));
  	    break;
  	}
      }
***************
*** 10264,10270 ****
      static void
  highlight_list_two(int cnt, int attr)
  {
!     msg_puts_attr((char_u *)&("N \bI \b!  \b"[cnt / 11]), attr);
      msg_clr_eos();
      out_flush();
      ui_delay(cnt == 99 ? 40L : (long)cnt * 50L, FALSE);
--- 10264,10270 ----
      static void
  highlight_list_two(int cnt, int attr)
  {
!     msg_puts_attr(&("N \bI \b!  \b"[cnt / 11]), attr);
      msg_clr_eos();
      out_flush();
      ui_delay(cnt == 99 ? 40L : (long)cnt * 50L, FALSE);
*** ../vim-8.1.0778/src/tag.c	2019-01-13 23:38:33.411773162 +0100
--- src/tag.c	2019-01-19 17:20:35.533924938 +0100
***************
*** 605,614 ****
  		if (msg_col == 0)
  		    msg_didout = FALSE;	/* overwrite previous message */
  		msg_start();
! 		MSG_PUTS_ATTR(_("  # pri kind tag"), HL_ATTR(HLF_T));
  		msg_clr_eos();
  		taglen_advance(taglen);
! 		MSG_PUTS_ATTR(_("file\n"), HL_ATTR(HLF_T));
  
  		for (i = 0; i < num_matches && !got_int; ++i)
  		{
--- 605,614 ----
  		if (msg_col == 0)
  		    msg_didout = FALSE;	/* overwrite previous message */
  		msg_start();
! 		msg_puts_attr(_("  # pri kind tag"), HL_ATTR(HLF_T));
  		msg_clr_eos();
  		taglen_advance(taglen);
! 		msg_puts_attr(_("file\n"), HL_ATTR(HLF_T));
  
  		for (i = 0; i < num_matches && !got_int; ++i)
  		{
***************
*** 626,632 ****
  		    vim_snprintf((char *)IObuff + 1, IOSIZE - 1,
  			    "%2d %s ", i + 1,
  					   mt_names[matches[i][0] & MT_MASK]);
! 		    msg_puts(IObuff);
  		    if (tagp.tagkind != NULL)
  			msg_outtrans_len(tagp.tagkind,
  				      (int)(tagp.tagkind_end - tagp.tagkind));
--- 626,632 ----
  		    vim_snprintf((char *)IObuff + 1, IOSIZE - 1,
  			    "%2d %s ", i + 1,
  					   mt_names[matches[i][0] & MT_MASK]);
! 		    msg_puts((char *)IObuff);
  		    if (tagp.tagkind != NULL)
  			msg_outtrans_len(tagp.tagkind,
  				      (int)(tagp.tagkind_end - tagp.tagkind));
***************
*** 642,648 ****
  		    p = tag_full_fname(&tagp);
  		    if (p != NULL)
  		    {
! 			msg_puts_long_attr(p, HL_ATTR(HLF_D));
  			vim_free(p);
  		    }
  		    if (msg_col > 0)
--- 642,648 ----
  		    p = tag_full_fname(&tagp);
  		    if (p != NULL)
  		    {
! 			msg_outtrans_long_attr(p, HL_ATTR(HLF_D));
  			vim_free(p);
  		    }
  		    if (msg_col > 0)
***************
*** 690,696 ****
  				p = msg_outtrans_one(p, attr);
  				if (*p == TAB)
  				{
! 				    msg_puts_attr((char_u *)" ", attr);
  				    break;
  				}
  				if (*p == ':')
--- 690,696 ----
  				p = msg_outtrans_one(p, attr);
  				if (*p == TAB)
  				{
! 				    msg_puts_attr(" ", attr);
  				    break;
  				}
  				if (*p == ':')
***************
*** 1003,1011 ****
  							   && num_matches > 1)
  		{
  		    if (ic)
! 			msg_attr(IObuff, HL_ATTR(HLF_W));
  		    else
! 			msg(IObuff);
  		    msg_scroll = TRUE;	/* don't overwrite this message */
  		}
  		else
--- 1003,1011 ----
  							   && num_matches > 1)
  		{
  		    if (ic)
! 			msg_attr((char *)IObuff, HL_ATTR(HLF_W));
  		    else
! 			msg((char *)IObuff);
  		    msg_scroll = TRUE;	/* don't overwrite this message */
  		}
  		else
***************
*** 1119,1125 ****
      int		tagstacklen = curwin->w_tagstacklen;
  
      /* Highlight title */
!     MSG_PUTS_TITLE(_("\n  # TO tag         FROM line  in file/text"));
      for (i = 0; i < tagstacklen; ++i)
      {
  	if (tagstack[i].tagname != NULL)
--- 1119,1125 ----
      int		tagstacklen = curwin->w_tagstacklen;
  
      /* Highlight title */
!     msg_puts_title(_("\n  # TO tag         FROM line  in file/text"));
      for (i = 0; i < tagstacklen; ++i)
      {
  	if (tagstack[i].tagname != NULL)
***************
*** 1143,1149 ****
  	out_flush();		    /* show one line at a time */
      }
      if (tagstackidx == tagstacklen)	/* idx at top of stack */
! 	MSG_PUTS("\n>");
  }
  
  /* When not using a CR for line separator, use vim_fgets() to read tag lines.
--- 1143,1149 ----
  	out_flush();		    /* show one line at a time */
      }
      if (tagstackidx == tagstacklen)	/* idx at top of stack */
! 	msg_puts("\n>");
  }
  
  /* When not using a CR for line separator, use vim_fgets() to read tag lines.
***************
*** 1962,1968 ****
  			if (p_verbose >= 5)
  			{
  			    verbose_enter();
! 			    MSG(_("Ignoring long line in tags file"));
  			    verbose_leave();
  			}
  #ifdef FEAT_TAG_BINS
--- 1962,1968 ----
  			if (p_verbose >= 5)
  			{
  			    verbose_enter();
! 			    msg(_("Ignoring long line in tags file"));
  			    verbose_leave();
  			}
  #ifdef FEAT_TAG_BINS
***************
*** 2818,2824 ****
  		if (p_verbose >= 5)
  		{
  		    verbose_enter();
! 		    MSG(_("Ignoring long line in tags file"));
  		    verbose_leave();
  		}
  		tagp->command = lbuf;
--- 2818,2824 ----
  		if (p_verbose >= 5)
  		{
  		    verbose_enter();
! 		    msg(_("Ignoring long line in tags file"));
  		    verbose_leave();
  		}
  		tagp->command = lbuf;
***************
*** 3381,3387 ****
  		     */
  		    if (found == 2 || !save_p_ic)
  		    {
! 			MSG(_("E435: Couldn't find tag, just guessing!"));
  			if (!msg_scrolled && msg_silent == 0)
  			{
  			    out_flush();
--- 3381,3387 ----
  		     */
  		    if (found == 2 || !save_p_ic)
  		    {
! 			msg(_("E435: Couldn't find tag, just guessing!"));
  			if (!msg_scrolled && msg_silent == 0)
  			{
  			    out_flush();
*** ../vim-8.1.0778/src/term.c	2019-01-13 23:38:33.411773162 +0100
--- src/term.c	2019-01-19 17:22:38.377197640 +0100
***************
*** 6373,6379 ****
  	return;
  
      /* Highlight title */
!     MSG_PUTS_TITLE(_("\n--- Terminal keys ---"));
  
      /*
       * do the loop two times:
--- 6373,6379 ----
  	return;
  
      /* Highlight title */
!     msg_puts_title(_("\n--- Terminal keys ---"));
  
      /*
       * do the loop two times:
***************
*** 6475,6483 ****
  
      if (printit)
      {
! 	msg_puts(IObuff);
  	if (code == NULL)
! 	    msg_puts((char_u *)"NULL");
  	else
  	    msg_outtrans(code);
      }
--- 6475,6483 ----
  
      if (printit)
      {
! 	msg_puts((char *)IObuff);
  	if (code == NULL)
! 	    msg_puts("NULL");
  	else
  	    msg_outtrans(code);
      }
***************
*** 7013,7019 ****
  	if (fd == NULL)
  	{
  	    if (p_verbose > 1)
! 		verb_msg((char_u *)_("Cannot open $VIMRUNTIME/rgb.txt"));
  	    return INVALCOLOR;
  	}
  
--- 7013,7019 ----
  	if (fd == NULL)
  	{
  	    if (p_verbose > 1)
! 		verb_msg(_("Cannot open $VIMRUNTIME/rgb.txt"));
  	    return INVALCOLOR;
  	}
  
*** ../vim-8.1.0778/src/undo.c	2019-01-13 23:38:33.415773131 +0100
--- src/undo.c	2019-01-19 17:22:59.157075919 +0100
***************
*** 1641,1647 ****
      if (buf->b_u_numhead == 0 && buf->b_u_line_ptr.ul_line == NULL)
      {
  	if (p_verbose > 0)
! 	    verb_msg((char_u *)_("Skipping undo file write, nothing to undo"));
  	goto theend;
      }
  
--- 1641,1647 ----
      if (buf->b_u_numhead == 0 && buf->b_u_line_ptr.ul_line == NULL)
      {
  	if (p_verbose > 0)
! 	    verb_msg(_("Skipping undo file write, nothing to undo"));
  	goto theend;
      }
  
***************
*** 2232,2238 ****
  		beep_flush();
  		if (count == startcount - 1)
  		{
! 		    MSG(_("Already at oldest change"));
  		    return;
  		}
  		break;
--- 2232,2238 ----
  		beep_flush();
  		if (count == startcount - 1)
  		{
! 		    msg(_("Already at oldest change"));
  		    return;
  		}
  		break;
***************
*** 2247,2253 ****
  		beep_flush();	/* nothing to redo */
  		if (count == startcount - 1)
  		{
! 		    MSG(_("Already at newest change"));
  		    return;
  		}
  		break;
--- 2247,2253 ----
  		beep_flush();	/* nothing to redo */
  		if (count == startcount - 1)
  		{
! 		    msg(_("Already at newest change"));
  		    return;
  		}
  		break;
***************
*** 2495,2503 ****
  	if (closest == closest_start)
  	{
  	    if (step < 0)
! 		MSG(_("Already at oldest change"));
  	    else
! 		MSG(_("Already at newest change"));
  	    return;
  	}
  
--- 2495,2503 ----
  	if (closest == closest_start)
  	{
  	    if (step < 0)
! 		msg(_("Already at oldest change"));
  	    else
! 		msg(_("Already at newest change"));
  	    return;
  	}
  
***************
*** 3104,3123 ****
      }
  
      if (ga.ga_len == 0)
! 	MSG(_("Nothing to undo"));
      else
      {
  	sort_strings((char_u **)ga.ga_data, ga.ga_len);
  
  	msg_start();
! 	msg_puts_attr((char_u *)_("number changes  when               saved"),
  							      HL_ATTR(HLF_T));
  	for (i = 0; i < ga.ga_len && !got_int; ++i)
  	{
  	    msg_putchar('\n');
  	    if (got_int)
  		break;
! 	    msg_puts(((char_u **)ga.ga_data)[i]);
  	}
  	msg_end();
  
--- 3104,3123 ----
      }
  
      if (ga.ga_len == 0)
! 	msg(_("Nothing to undo"));
      else
      {
  	sort_strings((char_u **)ga.ga_data, ga.ga_len);
  
  	msg_start();
! 	msg_puts_attr(_("number changes  when               saved"),
  							      HL_ATTR(HLF_T));
  	for (i = 0; i < ga.ga_len && !got_int; ++i)
  	{
  	    msg_putchar('\n');
  	    if (got_int)
  		break;
! 	    msg_puts(((char **)ga.ga_data)[i]);
  	}
  	msg_end();
  
*** ../vim-8.1.0778/src/userfunc.c	2019-01-13 23:38:33.415773131 +0100
--- src/userfunc.c	2019-01-19 16:58:10.347027099 +0100
***************
*** 893,903 ****
  		char_u	*tofree;
  		char_u	*s;
  
! 		msg_puts((char_u *)"(");
  		for (i = 0; i < argcount; ++i)
  		{
  		    if (i > 0)
! 			msg_puts((char_u *)", ");
  		    if (argvars[i].v_type == VAR_NUMBER)
  			msg_outnum((long)argvars[i].vval.v_number);
  		    else
--- 893,903 ----
  		char_u	*tofree;
  		char_u	*s;
  
! 		msg_puts("(");
  		for (i = 0; i < argcount; ++i)
  		{
  		    if (i > 0)
! 			msg_puts(", ");
  		    if (argvars[i].v_type == VAR_NUMBER)
  			msg_outnum((long)argvars[i].vval.v_number);
  		    else
***************
*** 913,926 ****
  				trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);
  				s = buf;
  			    }
! 			    msg_puts(s);
  			    vim_free(tofree);
  			}
  		    }
  		}
! 		msg_puts((char_u *)")");
  	    }
! 	    msg_puts((char_u *)"\n");   /* don't overwrite this either */
  
  	    verbose_leave_scroll();
  	    --no_wait_return;
--- 913,926 ----
  				trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);
  				s = buf;
  			    }
! 			    msg_puts((char *)s);
  			    vim_free(tofree);
  			}
  		    }
  		}
! 		msg_puts(")");
  	    }
! 	    msg_puts("\n");   /* don't overwrite this either */
  
  	    verbose_leave_scroll();
  	    --no_wait_return;
***************
*** 1018,1024 ****
  		vim_free(tofree);
  	    }
  	}
! 	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  
  	verbose_leave_scroll();
  	--no_wait_return;
--- 1018,1024 ----
  		vim_free(tofree);
  	    }
  	}
! 	msg_puts("\n");   /* don't overwrite this either */
  
  	verbose_leave_scroll();
  	--no_wait_return;
***************
*** 1041,1047 ****
  	verbose_enter_scroll();
  
  	smsg(_("continuing in %s"), sourcing_name);
! 	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  
  	verbose_leave_scroll();
  	--no_wait_return;
--- 1041,1047 ----
  	verbose_enter_scroll();
  
  	smsg(_("continuing in %s"), sourcing_name);
! 	msg_puts("\n");   /* don't overwrite this either */
  
  	verbose_leave_scroll();
  	--no_wait_return;
***************
*** 1571,1607 ****
  
      msg_start();
      if (indent)
! 	MSG_PUTS("   ");
!     MSG_PUTS("function ");
      if (fp->uf_name[0] == K_SPECIAL)
      {
! 	MSG_PUTS_ATTR("<SNR>", HL_ATTR(HLF_8));
! 	msg_puts(fp->uf_name + 3);
      }
      else
! 	msg_puts(fp->uf_name);
      msg_putchar('(');
      for (j = 0; j < fp->uf_args.ga_len; ++j)
      {
  	if (j)
! 	    MSG_PUTS(", ");
! 	msg_puts(FUNCARG(fp, j));
      }
      if (fp->uf_varargs)
      {
  	if (j)
! 	    MSG_PUTS(", ");
! 	MSG_PUTS("...");
      }
      msg_putchar(')');
      if (fp->uf_flags & FC_ABORT)
! 	MSG_PUTS(" abort");
      if (fp->uf_flags & FC_RANGE)
! 	MSG_PUTS(" range");
      if (fp->uf_flags & FC_DICT)
! 	MSG_PUTS(" dict");
      if (fp->uf_flags & FC_CLOSURE)
! 	MSG_PUTS(" closure");
      msg_clr_eos();
      if (p_verbose > 0)
  	last_set_msg(fp->uf_script_ctx);
--- 1571,1607 ----
  
      msg_start();
      if (indent)
! 	msg_puts("   ");
!     msg_puts("function ");
      if (fp->uf_name[0] == K_SPECIAL)
      {
! 	msg_puts_attr("<SNR>", HL_ATTR(HLF_8));
! 	msg_puts((char *)fp->uf_name + 3);
      }
      else
! 	msg_puts((char *)fp->uf_name);
      msg_putchar('(');
      for (j = 0; j < fp->uf_args.ga_len; ++j)
      {
  	if (j)
! 	    msg_puts(", ");
! 	msg_puts((char *)FUNCARG(fp, j));
      }
      if (fp->uf_varargs)
      {
  	if (j)
! 	    msg_puts(", ");
! 	msg_puts("...");
      }
      msg_putchar(')');
      if (fp->uf_flags & FC_ABORT)
! 	msg_puts(" abort");
      if (fp->uf_flags & FC_RANGE)
! 	msg_puts(" range");
      if (fp->uf_flags & FC_DICT)
! 	msg_puts(" dict");
      if (fp->uf_flags & FC_CLOSURE)
! 	msg_puts(" closure");
      msg_clr_eos();
      if (p_verbose > 0)
  	last_set_msg(fp->uf_script_ctx);
***************
*** 2010,2016 ****
  		if (!got_int)
  		{
  		    msg_putchar('\n');
! 		    msg_puts((char_u *)"   endfunction");
  		}
  	    }
  	    else
--- 2010,2016 ----
  		if (!got_int)
  		{
  		    msg_putchar('\n');
! 		    msg_puts("   endfunction");
  		}
  	    }
  	    else
***************
*** 3731,3737 ****
  {
      if (current_funccal != NULL)
  	list_hashtable_vars(&current_funccal->l_vars.dv_hashtab,
! 						(char_u *)"l:", FALSE, first);
  }
  
  /*
--- 3731,3737 ----
  {
      if (current_funccal != NULL)
  	list_hashtable_vars(&current_funccal->l_vars.dv_hashtab,
! 							   "l:", FALSE, first);
  }
  
  /*
*** ../vim-8.1.0778/src/version.c	2019-01-19 15:27:04.644211477 +0100
--- src/version.c	2019-01-19 16:54:30.716495119 +0100
***************
*** 2421,2430 ****
      if (!got_int)
      {
  	if (wrap)
! 	    MSG_PUTS("[");
! 	MSG_PUTS(s);
  	if (wrap)
! 	    MSG_PUTS("]");
      }
  }
  
--- 2423,2432 ----
      if (!got_int)
      {
  	if (wrap)
! 	    msg_puts("[");
! 	msg_puts((char *)s);
  	if (wrap)
! 	    msg_puts("]");
      }
  }
  
***************
*** 2502,2511 ****
  		msg_putchar('[');
  #ifdef FEAT_SYN_HL
  	    if (use_highlight && items[idx][0] == '-')
! 		msg_puts_attr(items[idx], HL_ATTR(HLF_W));
  	    else
  #endif
! 		msg_puts(items[idx]);
  	    if (idx == current)
  		msg_putchar(']');
  	    if (last_col)
--- 2504,2513 ----
  		msg_putchar('[');
  #ifdef FEAT_SYN_HL
  	    if (use_highlight && items[idx][0] == '-')
! 		msg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));
  	    else
  #endif
! 		msg_puts((char *)items[idx]);
  	    if (idx == current)
  		msg_putchar(']');
  	    if (last_col)
***************
*** 2539,2578 ****
       * internal variables in eval.c!
       */
      init_longVersion();
!     MSG(longVersion);
  #ifdef WIN3264
  # ifdef FEAT_GUI_W32
  #  ifdef _WIN64
!     MSG_PUTS(_("\nMS-Windows 64-bit GUI version"));
  #  else
!     MSG_PUTS(_("\nMS-Windows 32-bit GUI version"));
  #  endif
  # ifdef FEAT_OLE
!     MSG_PUTS(_(" with OLE support"));
  # endif
  # else
  #  ifdef _WIN64
!     MSG_PUTS(_("\nMS-Windows 64-bit console version"));
  #  else
!     MSG_PUTS(_("\nMS-Windows 32-bit console version"));
  #  endif
  # endif
  #endif
  #if defined(MACOS_X)
  # if defined(MACOS_X_DARWIN)
!     MSG_PUTS(_("\nmacOS version"));
  # else
!     MSG_PUTS(_("\nmacOS version w/o darwin feat."));
  # endif
  #endif
  
  #ifdef VMS
!     MSG_PUTS(_("\nOpenVMS version"));
  # ifdef HAVE_PATHDEF
      if (*compiled_arch != NUL)
      {
! 	MSG_PUTS(" - ");
! 	MSG_PUTS(compiled_arch);
      }
  # endif
  
--- 2541,2580 ----
       * internal variables in eval.c!
       */
      init_longVersion();
!     msg(longVersion);
  #ifdef WIN3264
  # ifdef FEAT_GUI_W32
  #  ifdef _WIN64
!     msg_puts(_("\nMS-Windows 64-bit GUI version"));
  #  else
!     msg_puts(_("\nMS-Windows 32-bit GUI version"));
  #  endif
  # ifdef FEAT_OLE
!     msg_puts(_(" with OLE support"));
  # endif
  # else
  #  ifdef _WIN64
!     msg_puts(_("\nMS-Windows 64-bit console version"));
  #  else
!     msg_puts(_("\nMS-Windows 32-bit console version"));
  #  endif
  # endif
  #endif
  #if defined(MACOS_X)
  # if defined(MACOS_X_DARWIN)
!     msg_puts(_("\nmacOS version"));
  # else
!     msg_puts(_("\nmacOS version w/o darwin feat."));
  # endif
  #endif
  
  #ifdef VMS
!     msg_puts(_("\nOpenVMS version"));
  # ifdef HAVE_PATHDEF
      if (*compiled_arch != NUL)
      {
! 	msg_puts(" - ");
! 	msg_puts((char *)compiled_arch);
      }
  # endif
  
***************
*** 2582,2588 ****
      /* Print a range when patches are consecutive: "1-10, 12, 15-40, 42-45" */
      if (included_patches[0] != 0)
      {
! 	MSG_PUTS(_("\nIncluded patches: "));
  	first = -1;
  	/* find last one */
  	for (i = 0; included_patches[i] != 0; ++i)
--- 2584,2590 ----
      /* Print a range when patches are consecutive: "1-10, 12, 15-40, 42-45" */
      if (included_patches[0] != 0)
      {
! 	msg_puts(_("\nIncluded patches: "));
  	first = -1;
  	/* find last one */
  	for (i = 0; included_patches[i] != 0; ++i)
***************
*** 2593,2604 ****
  		first = included_patches[i];
  	    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)
  	    {
! 		MSG_PUTS(s);
  		s = ", ";
  		msg_outnum((long)first);
  		if (first != included_patches[i])
  		{
! 		    MSG_PUTS("-");
  		    msg_outnum((long)included_patches[i]);
  		}
  		first = -1;
--- 2595,2606 ----
  		first = included_patches[i];
  	    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)
  	    {
! 		msg_puts(s);
  		s = ", ";
  		msg_outnum((long)first);
  		if (first != included_patches[i])
  		{
! 		    msg_puts("-");
  		    msg_outnum((long)included_patches[i]);
  		}
  		first = -1;
***************
*** 2609,2699 ****
      /* Print the list of extra patch descriptions if there is at least one. */
      if (extra_patches[0] != NULL)
      {
! 	MSG_PUTS(_("\nExtra patches: "));
  	s = "";
  	for (i = 0; extra_patches[i] != NULL; ++i)
  	{
! 	    MSG_PUTS(s);
  	    s = ", ";
! 	    MSG_PUTS(extra_patches[i]);
  	}
      }
  
  #ifdef MODIFIED_BY
!     MSG_PUTS("\n");
!     MSG_PUTS(_("Modified by "));
!     MSG_PUTS(MODIFIED_BY);
  #endif
  
  #ifdef HAVE_PATHDEF
      if (*compiled_user != NUL || *compiled_sys != NUL)
      {
! 	MSG_PUTS(_("\nCompiled "));
  	if (*compiled_user != NUL)
  	{
! 	    MSG_PUTS(_("by "));
! 	    MSG_PUTS(compiled_user);
  	}
  	if (*compiled_sys != NUL)
  	{
! 	    MSG_PUTS("@");
! 	    MSG_PUTS(compiled_sys);
  	}
      }
  #endif
  
  #ifdef FEAT_HUGE
!     MSG_PUTS(_("\nHuge version "));
  #else
  # ifdef FEAT_BIG
!     MSG_PUTS(_("\nBig version "));
  # else
  #  ifdef FEAT_NORMAL
!     MSG_PUTS(_("\nNormal version "));
  #  else
  #   ifdef FEAT_SMALL
!     MSG_PUTS(_("\nSmall version "));
  #   else
!     MSG_PUTS(_("\nTiny version "));
  #   endif
  #  endif
  # endif
  #endif
  #ifndef FEAT_GUI
!     MSG_PUTS(_("without GUI."));
  #else
  # ifdef FEAT_GUI_GTK
  #  ifdef USE_GTK3
!     MSG_PUTS(_("with GTK3 GUI."));
  #  else
  #   ifdef FEAT_GUI_GNOME
!      MSG_PUTS(_("with GTK2-GNOME GUI."));
  #   else
!      MSG_PUTS(_("with GTK2 GUI."));
  #   endif
  # endif
  # else
  #  ifdef FEAT_GUI_MOTIF
!     MSG_PUTS(_("with X11-Motif GUI."));
  #  else
  #   ifdef FEAT_GUI_ATHENA
  #    ifdef FEAT_GUI_NEXTAW
!     MSG_PUTS(_("with X11-neXtaw GUI."));
  #    else
!     MSG_PUTS(_("with X11-Athena GUI."));
  #    endif
  #   else
  #     ifdef FEAT_GUI_PHOTON
!     MSG_PUTS(_("with Photon GUI."));
  #     else
  #      if defined(MSWIN)
!     MSG_PUTS(_("with GUI."));
  #      else
  #	if defined(TARGET_API_MAC_CARBON) && TARGET_API_MAC_CARBON
!     MSG_PUTS(_("with Carbon GUI."));
  #	else
  #	 if defined(TARGET_API_MAC_OSX) && TARGET_API_MAC_OSX
!     MSG_PUTS(_("with Cocoa GUI."));
  #	 else
  #	 endif
  #	endif
--- 2611,2701 ----
      /* Print the list of extra patch descriptions if there is at least one. */
      if (extra_patches[0] != NULL)
      {
! 	msg_puts(_("\nExtra patches: "));
  	s = "";
  	for (i = 0; extra_patches[i] != NULL; ++i)
  	{
! 	    msg_puts(s);
  	    s = ", ";
! 	    msg_puts(extra_patches[i]);
  	}
      }
  
  #ifdef MODIFIED_BY
!     msg_puts("\n");
!     msg_puts(_("Modified by "));
!     msg_puts(MODIFIED_BY);
  #endif
  
  #ifdef HAVE_PATHDEF
      if (*compiled_user != NUL || *compiled_sys != NUL)
      {
! 	msg_puts(_("\nCompiled "));
  	if (*compiled_user != NUL)
  	{
! 	    msg_puts(_("by "));
! 	    msg_puts((char *)compiled_user);
  	}
  	if (*compiled_sys != NUL)
  	{
! 	    msg_puts("@");
! 	    msg_puts((char *)compiled_sys);
  	}
      }
  #endif
  
  #ifdef FEAT_HUGE
!     msg_puts(_("\nHuge version "));
  #else
  # ifdef FEAT_BIG
!     msg_puts(_("\nBig version "));
  # else
  #  ifdef FEAT_NORMAL
!     msg_puts(_("\nNormal version "));
  #  else
  #   ifdef FEAT_SMALL
!     msg_puts(_("\nSmall version "));
  #   else
!     msg_puts(_("\nTiny version "));
  #   endif
  #  endif
  # endif
  #endif
  #ifndef FEAT_GUI
!     msg_puts(_("without GUI."));
  #else
  # ifdef FEAT_GUI_GTK
  #  ifdef USE_GTK3
!     msg_puts(_("with GTK3 GUI."));
  #  else
  #   ifdef FEAT_GUI_GNOME
!      msg_puts(_("with GTK2-GNOME GUI."));
  #   else
!      msg_puts(_("with GTK2 GUI."));
  #   endif
  # endif
  # else
  #  ifdef FEAT_GUI_MOTIF
!     msg_puts(_("with X11-Motif GUI."));
  #  else
  #   ifdef FEAT_GUI_ATHENA
  #    ifdef FEAT_GUI_NEXTAW
!     msg_puts(_("with X11-neXtaw GUI."));
  #    else
!     msg_puts(_("with X11-Athena GUI."));
  #    endif
  #   else
  #     ifdef FEAT_GUI_PHOTON
!     msg_puts(_("with Photon GUI."));
  #     else
  #      if defined(MSWIN)
!     msg_puts(_("with GUI."));
  #      else
  #	if defined(TARGET_API_MAC_CARBON) && TARGET_API_MAC_CARBON
!     msg_puts(_("with Carbon GUI."));
  #	else
  #	 if defined(TARGET_API_MAC_OSX) && TARGET_API_MAC_OSX
!     msg_puts(_("with Cocoa GUI."));
  #	 else
  #	 endif
  #	endif
*** ../vim-8.1.0778/src/vim.h	2019-01-17 22:28:18.901373188 +0100
--- src/vim.h	2019-01-19 17:34:53.468634537 +0100
***************
*** 1630,1644 ****
  # define vim_strpbrk(s, cs) (char_u *)strpbrk((char *)(s), (char *)(cs))
  #endif
  
- #define MSG(s)			    msg((char_u *)(s))
- #define MSG_ATTR(s, attr)	    msg_attr((char_u *)(s), (attr))
  #define OUT_STR(s)		    out_str((char_u *)(s))
  #define OUT_STR_NF(s)		    out_str_nf((char_u *)(s))
- #define MSG_PUTS(s)		    msg_puts((char_u *)(s))
- #define MSG_PUTS_ATTR(s, a)	    msg_puts_attr((char_u *)(s), (a))
- #define MSG_PUTS_TITLE(s)	    msg_puts_title((char_u *)(s))
- #define MSG_PUTS_LONG(s)	    msg_puts_long_attr((char_u *)(s), 0)
- #define MSG_PUTS_LONG_ATTR(s, a)    msg_puts_long_attr((char_u *)(s), (a))
  
  #ifdef FEAT_GUI
  # ifdef FEAT_TERMGUICOLORS
--- 1630,1637 ----
*** ../vim-8.1.0778/src/window.c	2019-01-15 20:19:36.747904404 +0100
--- src/window.c	2019-01-19 16:11:10.102067682 +0100
***************
*** 310,316 ****
  /* move window to new tab page */
      case 'T':
  		if (one_window())
! 		    MSG(_(m_onlyone));
  		else
  		{
  		    tabpage_T	*oldtab = curtab;
--- 310,316 ----
  /* move window to new tab page */
      case 'T':
  		if (one_window())
! 		    msg(_(m_onlyone));
  		else
  		{
  		    tabpage_T	*oldtab = curtab;
***************
*** 3379,3385 ****
      if (one_window())
      {
  	if (message && !autocmd_busy)
! 	    MSG(_(m_onlyone));
  	return;
      }
  
--- 3379,3385 ----
      if (one_window())
      {
  	if (message && !autocmd_busy)
! 	    msg(_(m_onlyone));
  	return;
      }
  
*** ../vim-8.1.0778/src/proto/eval.pro	2018-12-22 13:27:59.115503998 +0100
--- src/proto/eval.pro	2019-01-19 16:23:33.345051440 +0100
***************
*** 25,31 ****
  void *call_func_retlist(char_u *func, int argc, typval_T *argv);
  int eval_foldexpr(char_u *arg, int *cp);
  void ex_let(exarg_T *eap);
! void list_hashtable_vars(hashtab_T *ht, char_u *prefix, int empty, int *first);
  char_u *get_lval(char_u *name, typval_T *rettv, lval_T *lp, int unlet, int skip, int flags, int fne_flags);
  void clear_lval(lval_T *lp);
  void *eval_for_line(char_u *arg, int *errp, char_u **nextcmdp, int skip);
--- 25,31 ----
  void *call_func_retlist(char_u *func, int argc, typval_T *argv);
  int eval_foldexpr(char_u *arg, int *cp);
  void ex_let(exarg_T *eap);
! void list_hashtable_vars(hashtab_T *ht, char *prefix, int empty, int *first);
  char_u *get_lval(char_u *name, typval_T *rettv, lval_T *lp, int unlet, int skip, int flags, int fne_flags);
  void clear_lval(lval_T *lp);
  void *eval_for_line(char_u *arg, int *errp, char_u **nextcmdp, int skip);
*** ../vim-8.1.0778/src/evalfunc.c	2019-01-17 15:43:21.757878392 +0100
--- src/evalfunc.c	2019-01-19 17:21:57.281436404 +0100
***************
*** 7169,7175 ****
  
      for (li = argvars[0].vval.v_list->lv_first; li != NULL; li = li->li_next)
      {
! 	msg_puts(tv_get_string(&li->li_tv));
  	msg_putchar('\n');
      }
  
--- 7169,7175 ----
  
      for (li = argvars[0].vval.v_list->lv_first; li != NULL; li = li->li_next)
      {
! 	msg_puts((char *)tv_get_string(&li->li_tv));
  	msg_putchar('\n');
      }
  
***************
*** 7198,7204 ****
      }
      else if (p_verbose > 1)
      {
! 	verb_msg((char_u *)_("called inputrestore() more often than inputsave()"));
  	rettv->vval.v_number = 1; /* Failed */
      }
  }
--- 7198,7204 ----
      }
      else if (p_verbose > 1)
      {
! 	verb_msg(_("called inputrestore() more often than inputsave()"));
  	rettv->vval.v_number = 1; /* Failed */
      }
  }
*** ../vim-8.1.0778/src/ex_eval.c	2019-01-13 23:38:33.387773334 +0100
--- src/ex_eval.c	2019-01-19 16:26:28.487860978 +0100
***************
*** 556,562 ****
  	    msg_scroll = TRUE;	    /* always scroll up, don't overwrite */
  
  	smsg(_("Exception thrown: %s"), excp->value);
! 	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  
  	if (debug_break_level > 0 || *p_vfile == NUL)
  	    cmdline_row = msg_row;
--- 556,562 ----
  	    msg_scroll = TRUE;	    /* always scroll up, don't overwrite */
  
  	smsg(_("Exception thrown: %s"), excp->value);
! 	msg_puts("\n");   /* don't overwrite this either */
  
  	if (debug_break_level > 0 || *p_vfile == NUL)
  	    cmdline_row = msg_row;
***************
*** 610,616 ****
  		    ? _("Exception finished: %s")
  		    : _("Exception discarded: %s"),
  		excp->value);
! 	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  	if (debug_break_level > 0 || *p_vfile == NUL)
  	    cmdline_row = msg_row;
  	--no_wait_return;
--- 610,616 ----
  		    ? _("Exception finished: %s")
  		    : _("Exception discarded: %s"),
  		excp->value);
! 	msg_puts("\n");   /* don't overwrite this either */
  	if (debug_break_level > 0 || *p_vfile == NUL)
  	    cmdline_row = msg_row;
  	--no_wait_return;
***************
*** 679,685 ****
  	    msg_scroll = TRUE;	    /* always scroll up, don't overwrite */
  
  	smsg(_("Exception caught: %s"), excp->value);
! 	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  
  	if (debug_break_level > 0 || *p_vfile == NUL)
  	    cmdline_row = msg_row;
--- 679,685 ----
  	    msg_scroll = TRUE;	    /* always scroll up, don't overwrite */
  
  	smsg(_("Exception caught: %s"), excp->value);
! 	msg_puts("\n");   /* don't overwrite this either */
  
  	if (debug_break_level > 0 || *p_vfile == NUL)
  	    cmdline_row = msg_row;
***************
*** 806,812 ****
      ++no_wait_return;
      msg_scroll = TRUE;		/* always scroll up, don't overwrite */
      smsg(mesg, s);
!     msg_puts((char_u *)"\n");   /* don't overwrite this either */
      cmdline_row = msg_row;
      --no_wait_return;
      if (debug_break_level > 0)
--- 806,812 ----
      ++no_wait_return;
      msg_scroll = TRUE;		/* always scroll up, don't overwrite */
      smsg(mesg, s);
!     msg_puts("\n");   /* don't overwrite this either */
      cmdline_row = msg_row;
      --no_wait_return;
      if (debug_break_level > 0)
*** ../vim-8.1.0778/src/farsi.h	2019-01-13 23:38:33.391773303 +0100
--- src/farsi.h	2019-01-19 17:17:21.303243929 +0100
***************
*** 186,192 ****
  
  /* special Farsi text messages */
  
! EXTERN char_u farsi_text_1[]
  #ifdef DO_INIT
  		= { YE_, _SIN, RE, ALEF_, _FE, ' ', 'V', 'I', 'M',
  		    ' ', F_HE, _BE, ' ', SHIN, RE, _GAF, DAL,' ', NOON,
--- 186,192 ----
  
  /* special Farsi text messages */
  
! EXTERN char farsi_text_1[]
  #ifdef DO_INIT
  		= { YE_, _SIN, RE, ALEF_, _FE, ' ', 'V', 'I', 'M',
  		    ' ', F_HE, _BE, ' ', SHIN, RE, _GAF, DAL,' ', NOON,
***************
*** 194,200 ****
  #endif
  		     ;
  
! EXTERN char_u farsi_text_2[]
  #ifdef DO_INIT
  		= { YE_, _SIN, RE, ALEF_, _FE, ' ', FARSI_3, FARSI_3,
  		    FARSI_4, FARSI_2, ' ', DAL, RE, ALEF, DAL, _NOON,
--- 194,200 ----
  #endif
  		     ;
  
! EXTERN char farsi_text_2[]
  #ifdef DO_INIT
  		= { YE_, _SIN, RE, ALEF_, _FE, ' ', FARSI_3, FARSI_3,
  		    FARSI_4, FARSI_2, ' ', DAL, RE, ALEF, DAL, _NOON,
***************
*** 227,233 ****
  		    ;
  #endif
  
! EXTERN char_u farsi_text_5[]
  #ifdef DO_INIT
  		= { ' ', YE_, _SIN, RE, ALEF_, _FE, '\0'}
  #endif
--- 227,233 ----
  		    ;
  #endif
  
! EXTERN char farsi_text_5[]
  #ifdef DO_INIT
  		= { ' ', YE_, _SIN, RE, ALEF_, _FE, '\0'}
  #endif
*** ../vim-8.1.0778/src/version.c	2019-01-19 15:27:04.644211477 +0100
--- src/version.c	2019-01-19 16:54:30.716495119 +0100
***************
*** 793,794 ****
--- 793,796 ----
  {   /* Add new patch number below this line */
+ /**/
+     779,
  /**/

-- 
Did you hear about the new 3 million dollar West Virginia State Lottery?
The winner gets 3 dollars a year for a million years.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
