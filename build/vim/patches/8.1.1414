To: vim_dev@googlegroups.com
Subject: Patch 8.1.1414
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.1.1414
Problem:    Alloc() returning "char_u *" causes a lot of type casts.
Solution:   Have it return "void *". (Mike Williams)  Define ALLOC_ONE() to
            check the simple allocations.
Files:	    src/autocmd.c, src/blob.c, src/blowfish.c, src/buffer.c,
            src/change.c, src/channel.c, src/crypt.c, src/crypt_zip.c,
            src/dict.c, src/diff.c, src/eval.c, src/evalfunc.c, src/ex_cmds.c,
            src/ex_cmds2.c, src/ex_docmd.c, src/ex_eval.c, src/ex_getln.c,
            src/fileio.c, src/findfile.c, src/getchar.c, src/gui_gtk.c,
            src/gui_gtk_x11.c, src/gui_mac.c, src/gui_motif.c,
            src/gui_photon.c, src/gui_w32.c, src/gui_x11.c, src/hardcopy.c,
            src/hashtab.c, src/if_cscope.c, src/if_mzsch.c, src/if_perlsfio.c,
            src/if_py_both.h, src/if_python3.c, src/if_xcmdsrv.c,
            src/insexpand.c, src/list.c, src/mark.c, src/mbyte.c,
            src/memfile.c, src/memfile_test.c, src/memline.c, src/message.c,
            src/misc2.c, src/netbeans.c, src/normal.c, src/ops.c,
            src/option.c, src/os_amiga.c, src/os_mac_conv.c, src/os_mswin.c,
            src/os_unix.c, src/os_vms.c, src/os_win32.c, src/popupmnu.c,
            src/proto/misc2.pro, src/quickfix.c, src/regexp.c,
            src/regexp_nfa.c, src/screen.c, src/search.c, src/sign.c,
            src/spell.c, src/spellfile.c, src/syntax.c, src/tag.c, src/term.c,
            src/terminal.c, src/textprop.c, src/ui.c, src/undo.c,
            src/userfunc.c, src/version.c, src/winclip.c, src/window.c,
            src/vim.h, src/testdir/test_cscope.vim


*** ../vim-8.1.1413/src/autocmd.c	2019-05-25 19:51:03.772408479 +0200
--- src/autocmd.c	2019-05-28 20:21:48.986994247 +0200
***************
*** 1193,1199 ****
  		    return FAIL;
  		}
  
! 		ap = (AutoPat *)alloc(sizeof(AutoPat));
  		if (ap == NULL)
  		    return FAIL;
  		ap->pat = vim_strnsave(pat, patlen);
--- 1193,1199 ----
  		    return FAIL;
  		}
  
! 		ap = ALLOC_ONE(AutoPat);
  		if (ap == NULL)
  		    return FAIL;
  		ap->pat = vim_strnsave(pat, patlen);
***************
*** 1242,1248 ****
  	    prev_ac = &(ap->cmds);
  	    while ((ac = *prev_ac) != NULL)
  		prev_ac = &ac->next;
! 	    ac = (AutoCmd *)alloc(sizeof(AutoCmd));
  	    if (ac == NULL)
  		return FAIL;
  	    ac->cmd = vim_strsave(cmd);
--- 1242,1248 ----
  	    prev_ac = &(ap->cmds);
  	    while ((ac = *prev_ac) != NULL)
  		prev_ac = &ac->next;
! 	    ac = ALLOC_ONE(AutoCmd);
  	    if (ac == NULL)
  		return FAIL;
  	    ac->cmd = vim_strsave(cmd);
*** ../vim-8.1.1413/src/blob.c	2019-03-19 23:03:24.199294996 +0100
--- src/blob.c	2019-05-28 20:25:38.305454964 +0200
***************
*** 22,28 ****
      blob_T *
  blob_alloc(void)
  {
!     blob_T *blob = (blob_T *)alloc_clear(sizeof(blob_T));
  
      if (blob != NULL)
  	ga_init2(&blob->bv_ga, 1, 100);
--- 22,28 ----
      blob_T *
  blob_alloc(void)
  {
!     blob_T *blob = ALLOC_CLEAR_ONE(blob_T);
  
      if (blob != NULL)
  	ga_init2(&blob->bv_ga, 1, 100);
*** ../vim-8.1.1413/src/blowfish.c	2019-04-27 22:06:33.348200718 +0200
--- src/blowfish.c	2019-05-28 20:25:42.853425601 +0200
***************
*** 645,651 ****
      char_u*		seed,
      int			seed_len)
  {
!     bf_state_T	*bfs = (bf_state_T *)alloc_clear(sizeof(bf_state_T));
  
      if (bfs == NULL)
  	return FAIL;
--- 645,651 ----
      char_u*		seed,
      int			seed_len)
  {
!     bf_state_T	*bfs = ALLOC_CLEAR_ONE(bf_state_T);
  
      if (bfs == NULL)
  	return FAIL;
*** ../vim-8.1.1413/src/buffer.c	2019-05-25 19:51:03.772408479 +0200
--- src/buffer.c	2019-05-28 20:57:42.675360224 +0200
***************
*** 1958,1964 ****
      }
      if (buf != curbuf || curbuf == NULL)
      {
! 	buf = (buf_T *)alloc_clear(sizeof(buf_T));
  	if (buf == NULL)
  	{
  	    vim_free(ffname);
--- 1958,1964 ----
      }
      if (buf != curbuf || curbuf == NULL)
      {
! 	buf = ALLOC_CLEAR_ONE(buf_T);
  	if (buf == NULL)
  	{
  	    vim_free(ffname);
***************
*** 1985,1991 ****
      }
  
      clear_wininfo(buf);
!     buf->b_wininfo = (wininfo_T *)alloc_clear(sizeof(wininfo_T));
  
      if ((ffname != NULL && (buf->b_ffname == NULL || buf->b_sfname == NULL))
  	    || buf->b_wininfo == NULL)
--- 1985,1991 ----
      }
  
      clear_wininfo(buf);
!     buf->b_wininfo = ALLOC_CLEAR_ONE(wininfo_T);
  
      if ((ffname != NULL && (buf->b_ffname == NULL || buf->b_sfname == NULL))
  	    || buf->b_wininfo == NULL)
***************
*** 2634,2640 ****
  		break;
  	    if (round == 1)
  	    {
! 		*file = (char_u **)alloc(count * sizeof(char_u *));
  		if (*file == NULL)
  		{
  		    vim_regfree(regmatch.regprog);
--- 2634,2640 ----
  		break;
  	    if (round == 1)
  	    {
! 		*file = ALLOC_MULT(char_u *, count);
  		if (*file == NULL)
  		{
  		    vim_regfree(regmatch.regprog);
***************
*** 2771,2777 ****
      if (wip == NULL)
      {
  	/* allocate a new entry */
! 	wip = (wininfo_T *)alloc_clear(sizeof(wininfo_T));
  	if (wip == NULL)
  	    return;
  	wip->wi_win = win;
--- 2771,2777 ----
      if (wip == NULL)
      {
  	/* allocate a new entry */
! 	wip = ALLOC_CLEAR_ONE(wininfo_T);
  	if (wip == NULL)
  	    return;
  	wip->wi_win = win;
***************
*** 3430,3436 ****
      char	*buffer;
      size_t	len;
  
!     buffer = (char *)alloc(IOSIZE);
      if (buffer == NULL)
  	return;
  
--- 3430,3436 ----
      char	*buffer;
      size_t	len;
  
!     buffer = alloc(IOSIZE);
      if (buffer == NULL)
  	return;
  
*** ../vim-8.1.1413/src/change.c	2019-05-24 21:39:23.893950022 +0200
--- src/change.c	2019-05-28 20:25:58.745323280 +0200
***************
*** 286,292 ****
  	    return;
      }
  
!     lnr = (listener_T *)alloc_clear(sizeof(listener_T));
      if (lnr == NULL)
      {
  	free_callback(callback, partial);
--- 286,292 ----
  	    return;
      }
  
!     lnr = ALLOC_CLEAR_ONE(listener_T);
      if (lnr == NULL)
      {
  	free_callback(callback, partial);
*** ../vim-8.1.1413/src/channel.c	2019-05-25 20:21:24.669951062 +0200
--- src/channel.c	2019-05-28 20:59:49.218995026 +0200
***************
*** 294,300 ****
  add_channel(void)
  {
      ch_part_T	part;
!     channel_T	*channel = (channel_T *)alloc_clear(sizeof(channel_T));
  
      if (channel == NULL)
  	return NULL;
--- 294,300 ----
  add_channel(void)
  {
      ch_part_T	part;
!     channel_T	*channel = ALLOC_CLEAR_ONE(channel_T);
  
      if (channel == NULL)
  	return NULL;
***************
*** 1354,1360 ****
  	int	    id)
  {
      cbq_T *head = &channel->ch_part[part].ch_cb_head;
!     cbq_T *item = (cbq_T *)alloc(sizeof(cbq_T));
  
      if (item != NULL)
      {
--- 1354,1360 ----
  	int	    id)
  {
      cbq_T *head = &channel->ch_part[part].ch_cb_head;
!     cbq_T *item = ALLOC_ONE(cbq_T);
  
      if (item != NULL)
      {
***************
*** 1875,1881 ****
      char_u  *p;
      int	    i;
  
!     node = (readq_T *)alloc(sizeof(readq_T));
      if (node == NULL)
  	return FAIL;	    /* out of memory */
      /* A NUL is added at the end, because netbeans code expects that.
--- 1875,1881 ----
      char_u  *p;
      int	    i;
  
!     node = ALLOC_ONE(readq_T);
      if (node == NULL)
  	return FAIL;	    /* out of memory */
      /* A NUL is added at the end, because netbeans code expects that.
***************
*** 2024,2030 ****
  	}
  	else
  	{
! 	    item = (jsonq_T *)alloc(sizeof(jsonq_T));
  	    if (item == NULL)
  		clear_tv(&listtv);
  	    else
--- 2024,2030 ----
  	}
  	else
  	{
! 	    item = ALLOC_ONE(jsonq_T);
  	    if (item == NULL)
  		clear_tv(&listtv);
  	    else
***************
*** 2223,2229 ****
  	/* append after the last item that was pushed back */
  	item = item->jq_next;
  
!     newitem = (jsonq_T *)alloc(sizeof(jsonq_T));
      if (newitem == NULL)
  	clear_tv(rettv);
      else
--- 2223,2229 ----
  	/* append after the last item that was pushed back */
  	item = item->jq_next;
  
!     newitem = ALLOC_ONE(jsonq_T);
      if (newitem == NULL)
  	clear_tv(rettv);
      else
***************
*** 3921,3927 ****
  		}
  		else
  		{
! 		    writeq_T *last = (writeq_T *)alloc(sizeof(writeq_T));
  
  		    if (last != NULL)
  		    {
--- 3921,3927 ----
  		}
  		else
  		{
! 		    writeq_T *last = ALLOC_ONE(writeq_T);
  
  		    if (last != NULL)
  		    {
***************
*** 5593,5599 ****
  {
      job_T *job;
  
!     job = (job_T *)alloc_clear(sizeof(job_T));
      if (job != NULL)
      {
  	job->jv_refcount = 1;
--- 5593,5599 ----
  {
      job_T *job;
  
!     job = ALLOC_CLEAR_ONE(job_T);
      if (job != NULL)
      {
  	job->jv_refcount = 1;
***************
*** 5822,5828 ****
  	/* Make a copy of argv_arg for job->jv_argv. */
  	for (i = 0; argv_arg[i] != NULL; i++)
  	    argc++;
! 	argv = (char **)alloc(sizeof(char *) * (argc + 1));
  	if (argv == NULL)
  	    goto theend;
  	for (i = 0; i < argc; i++)
--- 5822,5828 ----
  	/* Make a copy of argv_arg for job->jv_argv. */
  	for (i = 0; argv_arg[i] != NULL; i++)
  	    argc++;
! 	argv = ALLOC_MULT(char *, argc + 1);
  	if (argv == NULL)
  	    goto theend;
  	for (i = 0; i < argc; i++)
*** ../vim-8.1.1413/src/crypt.c	2019-05-25 20:21:24.669951062 +0200
--- src/crypt.c	2019-05-28 20:22:10.606843504 +0200
***************
*** 254,260 ****
      char_u	*seed,
      int		seed_len)
  {
!     cryptstate_T *state = (cryptstate_T *)alloc(sizeof(cryptstate_T));
  
      if (state == NULL)
  	return state;
--- 254,260 ----
      char_u	*seed,
      int		seed_len)
  {
!     cryptstate_T *state = ALLOC_ONE(cryptstate_T);
  
      if (state == NULL)
  	return state;
*** ../vim-8.1.1413/src/crypt_zip.c	2019-04-27 22:06:33.348200718 +0200
--- src/crypt_zip.c	2019-05-28 20:22:16.514802540 +0200
***************
*** 90,96 ****
      char_u	*p;
      zip_state_T	*zs;
  
!     zs = (zip_state_T *)alloc(sizeof(zip_state_T));
      if (zs == NULL)
  	return FAIL;
      state->method_state = zs;
--- 90,96 ----
      char_u	*p;
      zip_state_T	*zs;
  
!     zs = ALLOC_ONE(zip_state_T);
      if (zs == NULL)
  	return FAIL;
      state->method_state = zs;
*** ../vim-8.1.1413/src/dict.c	2019-05-25 20:21:24.669951062 +0200
--- src/dict.c	2019-05-28 20:22:27.666725503 +0200
***************
*** 28,34 ****
  {
      dict_T *d;
  
!     d = (dict_T *)alloc(sizeof(dict_T));
      if (d != NULL)
      {
  	/* Add the dict to the list of dicts for garbage collection. */
--- 28,34 ----
  {
      dict_T *d;
  
!     d = ALLOC_ONE(dict_T);
      if (d != NULL)
      {
  	/* Add the dict to the list of dicts for garbage collection. */
***************
*** 210,216 ****
  {
      dictitem_T *di;
  
!     di = (dictitem_T *)alloc(sizeof(dictitem_T) + STRLEN(key));
      if (di != NULL)
      {
  	STRCPY(di->di_key, key);
--- 210,216 ----
  {
      dictitem_T *di;
  
!     di = alloc(sizeof(dictitem_T) + STRLEN(key));
      if (di != NULL)
      {
  	STRCPY(di->di_key, key);
***************
*** 228,234 ****
  {
      dictitem_T *di;
  
!     di = (dictitem_T *)alloc(sizeof(dictitem_T) + STRLEN(org->di_key));
      if (di != NULL)
      {
  	STRCPY(di->di_key, org->di_key);
--- 228,234 ----
  {
      dictitem_T *di;
  
!     di = alloc(sizeof(dictitem_T) + STRLEN(org->di_key));
      if (di != NULL)
      {
  	STRCPY(di->di_key, org->di_key);
*** ../vim-8.1.1413/src/diff.c	2019-05-26 21:03:19.940073927 +0200
--- src/diff.c	2019-05-28 20:22:34.462678728 +0200
***************
*** 537,543 ****
  {
      diff_T	*dnew;
  
!     dnew = (diff_T *)alloc(sizeof(diff_T));
      if (dnew != NULL)
      {
  	dnew->df_next = dp;
--- 537,543 ----
  {
      diff_T	*dnew;
  
!     dnew = ALLOC_ONE(diff_T);
      if (dnew != NULL)
      {
  	dnew->df_next = dp;
*** ../vim-8.1.1413/src/eval.c	2019-05-26 18:48:09.402542633 +0200
--- src/eval.c	2019-05-28 20:26:19.661189306 +0200
***************
*** 491,497 ****
      if (redir_varname == NULL)
  	return FAIL;
  
!     redir_lval = (lval_T *)alloc_clear(sizeof(lval_T));
      if (redir_lval == NULL)
      {
  	var_redir_stop();
--- 491,497 ----
      if (redir_varname == NULL)
  	return FAIL;
  
!     redir_lval = ALLOC_CLEAR_ONE(lval_T);
      if (redir_lval == NULL)
      {
  	var_redir_stop();
***************
*** 1063,1069 ****
  {
      typval_T	*tv;
  
!     tv = (typval_T *)alloc(sizeof(typval_T));
      if (tv != NULL && eval0(arg, tv, nextcmd, TRUE) == FAIL)
  	VIM_CLEAR(tv);
  
--- 1063,1069 ----
  {
      typval_T	*tv;
  
!     tv = ALLOC_ONE(typval_T);
      if (tv != NULL && eval0(arg, tv, nextcmd, TRUE) == FAIL)
  	VIM_CLEAR(tv);
  
***************
*** 2769,2775 ****
  
      *errp = TRUE;	/* default: there is an error */
  
!     fi = (forinfo_T *)alloc_clear(sizeof(forinfo_T));
      if (fi == NULL)
  	return NULL;
  
--- 2769,2775 ----
  
      *errp = TRUE;	/* default: there is an error */
  
!     fi = ALLOC_CLEAR_ONE(forinfo_T);
      if (fi == NULL)
  	return NULL;
  
***************
*** 7297,7303 ****
      typval_T *
  alloc_tv(void)
  {
!     return (typval_T *)alloc_clear(sizeof(typval_T));
  }
  
  /*
--- 7297,7303 ----
      typval_T *
  alloc_tv(void)
  {
!     return ALLOC_CLEAR_ONE(typval_T);
  }
  
  /*
***************
*** 7883,7889 ****
  	while (ga_scripts.ga_len < id)
  	{
  	    sv = SCRIPT_SV(ga_scripts.ga_len + 1) =
! 		(scriptvar_T *)alloc_clear(sizeof(scriptvar_T));
  	    init_var_dict(&sv->sv_dict, &sv->sv_var, VAR_SCOPE);
  	    ++ga_scripts.ga_len;
  	}
--- 7883,7889 ----
  	while (ga_scripts.ga_len < id)
  	{
  	    sv = SCRIPT_SV(ga_scripts.ga_len + 1) =
! 		ALLOC_CLEAR_ONE(scriptvar_T);
  	    init_var_dict(&sv->sv_dict, &sv->sv_var, VAR_SCOPE);
  	    ++ga_scripts.ga_len;
  	}
***************
*** 8139,8145 ****
  	if (!valid_varname(varname))
  	    return;
  
! 	v = (dictitem_T *)alloc(sizeof(dictitem_T) + STRLEN(varname));
  	if (v == NULL)
  	    return;
  	STRCPY(v->di_key, varname);
--- 8139,8145 ----
  	if (!valid_varname(varname))
  	    return;
  
! 	v = alloc(sizeof(dictitem_T) + STRLEN(varname));
  	if (v == NULL)
  	    return;
  	STRCPY(v->di_key, varname);
*** ../vim-8.1.1413/src/evalfunc.c	2019-05-27 21:53:53.986229323 +0200
--- src/evalfunc.c	2019-05-28 22:07:06.292349825 +0200
***************
*** 4465,4471 ****
  	}
  	if (dict_idx > 0 || arg_idx > 0 || arg_pt != NULL || is_funcref)
  	{
! 	    partial_T	*pt = (partial_T *)alloc_clear(sizeof(partial_T));
  
  	    /* result is a VAR_PARTIAL */
  	    if (pt == NULL)
--- 4465,4471 ----
  	}
  	if (dict_idx > 0 || arg_idx > 0 || arg_pt != NULL || is_funcref)
  	{
! 	    partial_T	*pt = ALLOC_CLEAR_ONE(partial_T);
  
  	    /* result is a VAR_PARTIAL */
  	    if (pt == NULL)
***************
*** 4484,4491 ****
  		    if (list != NULL)
  			lv_len = list->lv_len;
  		    pt->pt_argc = arg_len + lv_len;
! 		    pt->pt_argv = (typval_T *)alloc(
! 					      sizeof(typval_T) * pt->pt_argc);
  		    if (pt->pt_argv == NULL)
  		    {
  			vim_free(pt);
--- 4484,4490 ----
  		    if (list != NULL)
  			lv_len = list->lv_len;
  		    pt->pt_argc = arg_len + lv_len;
! 		    pt->pt_argv = ALLOC_MULT(typval_T, pt->pt_argc);
  		    if (pt->pt_argv == NULL)
  		    {
  			vim_free(pt);
***************
*** 9615,9622 ****
  		    long growmin  = (long)((p - start) * 2 + prevlen);
  		    prevsize = grow50pc > growmin ? grow50pc : growmin;
  		}
! 		newprev = prev == NULL ? alloc(prevsize)
! 						: vim_realloc(prev, prevsize);
  		if (newprev == NULL)
  		{
  		    do_outofmem_msg((long_u)prevsize);
--- 9614,9620 ----
  		    long growmin  = (long)((p - start) * 2 + prevlen);
  		    prevsize = grow50pc > growmin ? grow50pc : growmin;
  		}
! 		newprev = vim_realloc(prev, prevsize);
  		if (newprev == NULL)
  		{
  		    do_outofmem_msg((long_u)prevsize);
***************
*** 11788,11794 ****
  
  	/* First half: use for pointers to result lines; second half: use for
  	 * pointers to allocated copies. */
! 	lstval = (char_u **)alloc(sizeof(char_u *) * ((len + 1) * 2));
  	if (lstval == NULL)
  	    return;
  	curval = lstval;
--- 11786,11792 ----
  
  	/* First half: use for pointers to result lines; second half: use for
  	 * pointers to allocated copies. */
! 	lstval = ALLOC_MULT(char_u *, (len + 1) * 2);
  	if (lstval == NULL)
  	    return;
  	curval = lstval;
***************
*** 12674,12680 ****
  	}
  
  	/* Make an array with each entry pointing to an item in the List. */
! 	ptrs = (sortItem_T *)alloc(len * sizeof(sortItem_T));
  	if (ptrs == NULL)
  	    goto theend;
  
--- 12672,12678 ----
  	}
  
  	/* Make an array with each entry pointing to an item in the List. */
! 	ptrs = ALLOC_MULT(sortItem_T, len);
  	if (ptrs == NULL)
  	    goto theend;
  
*** ../vim-8.1.1413/src/ex_cmds.c	2019-05-25 20:21:24.673951038 +0200
--- src/ex_cmds.c	2019-05-28 21:03:41.510193976 +0200
***************
*** 397,403 ****
      sortbuf1 = NULL;
      sortbuf2 = NULL;
      regmatch.regprog = NULL;
!     nrs = (sorti_T *)alloc(count * sizeof(sorti_T));
      if (nrs == NULL)
  	goto sortend;
  
--- 397,403 ----
      sortbuf1 = NULL;
      sortbuf2 = NULL;
      regmatch.regprog = NULL;
!     nrs = ALLOC_MULT(sorti_T, count);
      if (nrs == NULL)
  	goto sortend;
  
*** ../vim-8.1.1413/src/ex_cmds2.c	2019-05-25 20:21:24.673951038 +0200
--- src/ex_cmds2.c	2019-05-28 21:04:40.233971110 +0200
***************
*** 293,299 ****
      timer_T *
  create_timer(long msec, int repeat)
  {
!     timer_T	*timer = (timer_T *)alloc_clear(sizeof(timer_T));
      long	prev_id = last_timer_id;
  
      if (timer == NULL)
--- 293,299 ----
      timer_T *
  create_timer(long msec, int repeat)
  {
!     timer_T	*timer = ALLOC_CLEAR_ONE(timer_T);
      long	prev_id = last_timer_id;
  
      if (timer == NULL)
***************
*** 444,450 ****
  	    bevalexpr_due_set = FALSE;
  	    if (balloonEval == NULL)
  	    {
! 		balloonEval = (BalloonEval *)alloc_clear(sizeof(BalloonEval));
  		balloonEvalForTerm = TRUE;
  	    }
  	    if (balloonEval != NULL)
--- 444,450 ----
  	    bevalexpr_due_set = FALSE;
  	    if (balloonEval == NULL)
  	    {
! 		balloonEval = ALLOC_CLEAR_ONE(BalloonEval);
  		balloonEvalForTerm = TRUE;
  	    }
  	    if (balloonEval != NULL)
***************
*** 1312,1318 ****
      if (bufcount == 0)
  	return FALSE;
  
!     bufnrs = (int *)alloc(sizeof(int) * bufcount);
      if (bufnrs == NULL)
  	return FALSE;
  
--- 1312,1318 ----
      if (bufcount == 0)
  	return FALSE;
  
!     bufnrs = ALLOC_MULT(int, bufcount);
      if (bufnrs == NULL)
  	return FALSE;
  
***************
*** 1783,1789 ****
  	 */
  	if (ARGCOUNT > 0)
  	{
! 	    char_u **items = (char_u **)alloc(sizeof(char_u *) * ARGCOUNT);
  
  	    if (items != NULL)
  	    {
--- 1783,1789 ----
  	 */
  	if (ARGCOUNT > 0)
  	{
! 	    char_u **items = ALLOC_MULT(char_u *, ARGCOUNT);
  
  	    if (items != NULL)
  	    {
***************
*** 2994,3000 ****
  	    continue;
  
  	len = (int)STRLEN(plugpat) + (int)STRLEN(eap->arg) + 5;
! 	pat = (char *)alloc(len);
  	if (pat == NULL)
  	    return;
  	vim_snprintf(pat, len, plugpat, round == 1 ? "start" : "opt", eap->arg);
--- 2994,3000 ----
  	    continue;
  
  	len = (int)STRLEN(plugpat) + (int)STRLEN(eap->arg) + 5;
! 	pat = alloc(len);
  	if (pat == NULL)
  	    return;
  	vim_snprintf(pat, len, plugpat, round == 1 ? "start" : "opt", eap->arg);
*** ../vim-8.1.1413/src/ex_docmd.c	2019-05-25 20:21:24.673951038 +0200
--- src/ex_docmd.c	2019-05-28 21:05:33.701762543 +0200
***************
*** 6550,6556 ****
      void
  alist_new(void)
  {
!     curwin->w_alist = (alist_T *)alloc(sizeof(alist_T));
      if (curwin->w_alist == NULL)
      {
  	curwin->w_alist = &global_alist;
--- 6550,6556 ----
      void
  alist_new(void)
  {
!     curwin->w_alist = ALLOC_ONE(alist_T);
      if (curwin->w_alist == NULL)
      {
  	curwin->w_alist = &global_alist;
***************
*** 6584,6590 ****
       * expansion.  Also, the vimrc file isn't read yet, thus the user
       * can't set the options. */
      p_su = empty_option;
!     old_arg_files = (char_u **)alloc(sizeof(char_u *) * GARGCOUNT);
      if (old_arg_files != NULL)
      {
  	for (i = 0; i < GARGCOUNT; ++i)
--- 6584,6590 ----
       * expansion.  Also, the vimrc file isn't read yet, thus the user
       * can't set the options. */
      p_su = empty_option;
!     old_arg_files = ALLOC_MULT(char_u *, GARGCOUNT);
      if (old_arg_files != NULL)
      {
  	for (i = 0; i < GARGCOUNT; ++i)
*** ../vim-8.1.1413/src/ex_eval.c	2019-05-24 18:48:36.758128504 +0200
--- src/ex_eval.c	2019-05-28 21:06:39.401499652 +0200
***************
*** 251,257 ****
  	    while (*plist != NULL)
  		plist = &(*plist)->next;
  
! 	    elem = (struct msglist *)alloc(sizeof(struct msglist));
  	    if (elem == NULL)
  	    {
  		suppress_errthrow = TRUE;
--- 251,257 ----
  	    while (*plist != NULL)
  		plist = &(*plist)->next;
  
! 	    elem = ALLOC_ONE(struct msglist);
  	    if (elem == NULL)
  	    {
  		suppress_errthrow = TRUE;
***************
*** 519,525 ****
  	}
      }
  
!     excp = (except_T *)alloc(sizeof(except_T));
      if (excp == NULL)
  	goto nomem;
  
--- 519,525 ----
  	}
      }
  
!     excp = ALLOC_ONE(except_T);
      if (excp == NULL)
  	goto nomem;
  
***************
*** 1441,1447 ****
  	    {
  		eslist_T	*elem;
  
! 		elem = (eslist_T *)alloc(sizeof(struct eslist_elem));
  		if (elem == NULL)
  		    emsg(_(e_outofmem));
  		else
--- 1441,1447 ----
  	    {
  		eslist_T	*elem;
  
! 		elem = ALLOC_ONE(struct eslist_elem);
  		if (elem == NULL)
  		    emsg(_(e_outofmem));
  		else
*** ../vim-8.1.1413/src/ex_getln.c	2019-05-25 20:21:24.673951038 +0200
--- src/ex_getln.c	2019-05-28 21:09:26.244804696 +0200
***************
*** 5294,5300 ****
  	    if (count == 0)
  		return OK;
  	    *num_file = count;
! 	    *file = (char_u **)alloc(count * sizeof(char_u *));
  	    if (*file == NULL)
  	    {
  		*file = (char_u **)"";
--- 5294,5300 ----
  	    if (count == 0)
  		return OK;
  	    *num_file = count;
! 	    *file = ALLOC_MULT(char_u *, count);
  	    if (*file == NULL)
  	    {
  		*file = (char_u **)"";
***************
*** 5914,5920 ****
  	{
  	    if (newlen)
  	    {
! 		temp = (histentry_T *)alloc(newlen * sizeof(histentry_T));
  		if (temp == NULL)   /* out of memory! */
  		{
  		    if (type == 0)  /* first one: just keep the old length */
--- 5914,5920 ----
  	{
  	    if (newlen)
  	    {
! 		temp = ALLOC_MULT(histentry_T, newlen);
  		if (temp == NULL)   /* out of memory! */
  		{
  		    if (type == 0)  /* first one: just keep the old length */
***************
*** 6653,6660 ****
  	if (len <= 0)
  	    viminfo_history[type] = NULL;
  	else
! 	    viminfo_history[type] = (histentry_T *)lalloc(
! 					    len * sizeof(histentry_T), FALSE);
  	if (viminfo_history[type] == NULL)
  	    len = 0;
  	viminfo_hislen[type] = len;
--- 6653,6659 ----
  	if (len <= 0)
  	    viminfo_history[type] = NULL;
  	else
! 	    viminfo_history[type] = LALLOC_MULT(histentry_T, len);
  	if (viminfo_history[type] == NULL)
  	    len = 0;
  	viminfo_hislen[type] = len;
***************
*** 6873,6880 ****
  
      /* Make one long list with all entries. */
      max_len = hislen + viminfo_hisidx[type];
!     tot_hist = (histentry_T **)alloc(max_len * (int)sizeof(histentry_T *));
!     new_hist = (histentry_T *)alloc(hislen * (int)sizeof(histentry_T));
      if (tot_hist == NULL || new_hist == NULL)
      {
  	vim_free(tot_hist);
--- 6872,6879 ----
  
      /* Make one long list with all entries. */
      max_len = hislen + viminfo_hisidx[type];
!     tot_hist = ALLOC_MULT(histentry_T *, max_len);
!     new_hist = ALLOC_MULT(histentry_T, hislen );
      if (tot_hist == NULL || new_hist == NULL)
      {
  	vim_free(tot_hist);
*** ../vim-8.1.1413/src/fileio.c	2019-05-25 20:21:24.673951038 +0200
--- src/fileio.c	2019-05-28 20:12:03.766451351 +0200
***************
*** 6533,6539 ****
  	return -1;
      }
  
!     buffer = (char *)alloc(BUFSIZE);
      if (buffer == NULL)
      {
  	close(fd_out);
--- 6533,6539 ----
  	return -1;
      }
  
!     buffer = alloc(BUFSIZE);
      if (buffer == NULL)
      {
  	close(fd_out);
***************
*** 6890,6897 ****
  	{
  	    if (!helpmesg)
  		mesg2 = "";
! 	    tbuf = (char *)alloc(STRLEN(path) + STRLEN(mesg)
! 							  + STRLEN(mesg2) + 2);
  	    sprintf(tbuf, mesg, path);
  #ifdef FEAT_EVAL
  	    /* Set warningmsg here, before the unimportant and output-specific
--- 6890,6896 ----
  	{
  	    if (!helpmesg)
  		mesg2 = "";
! 	    tbuf = alloc(STRLEN(path) + STRLEN(mesg) + STRLEN(mesg2) + 2);
  	    sprintf(tbuf, mesg, path);
  #ifdef FEAT_EVAL
  	    /* Set warningmsg here, before the unimportant and output-specific
*** ../vim-8.1.1413/src/findfile.c	2019-05-25 20:21:24.677951017 +0200
--- src/findfile.c	2019-05-28 21:15:38.291158787 +0200
***************
*** 319,325 ****
  	search_ctx = search_ctx_arg;
      else
      {
! 	search_ctx = (ff_search_ctx_T*)alloc(sizeof(ff_search_ctx_T));
  	if (search_ctx == NULL)
  	    goto error_return;
  	vim_memset(search_ctx, 0, sizeof(ff_search_ctx_T));
--- 319,325 ----
  	search_ctx = search_ctx_arg;
      else
      {
! 	search_ctx = ALLOC_ONE(ff_search_ctx_T);
  	if (search_ctx == NULL)
  	    goto error_return;
  	vim_memset(search_ctx, 0, sizeof(ff_search_ctx_T));
***************
*** 350,356 ****
  
      if (ff_expand_buffer == NULL)
      {
! 	ff_expand_buffer = (char_u*)alloc(MAXPATHL);
  	if (ff_expand_buffer == NULL)
  	    goto error_return;
      }
--- 350,356 ----
  
      if (ff_expand_buffer == NULL)
      {
! 	ff_expand_buffer = alloc(MAXPATHL);
  	if (ff_expand_buffer == NULL)
  	    goto error_return;
      }
***************
*** 430,436 ****
  	    walker++;
  
  	dircount = 1;
! 	search_ctx->ffsc_stopdirs_v = (char_u **)alloc(sizeof(char_u *));
  
  	if (search_ctx->ffsc_stopdirs_v != NULL)
  	{
--- 430,436 ----
  	    walker++;
  
  	dircount = 1;
! 	search_ctx->ffsc_stopdirs_v = ALLOC_ONE(char_u *);
  
  	if (search_ctx->ffsc_stopdirs_v != NULL)
  	{
***************
*** 925,931 ****
  		 */
  		if (path_with_url(dirptrs[0]))
  		{
! 		    stackp->ffs_filearray = (char_u **)alloc(sizeof(char *));
  		    if (stackp->ffs_filearray != NULL
  			    && (stackp->ffs_filearray[0]
  				= vim_strsave(dirptrs[0])) != NULL)
--- 925,931 ----
  		 */
  		if (path_with_url(dirptrs[0]))
  		{
! 		    stackp->ffs_filearray = ALLOC_ONE(char_u *);
  		    if (stackp->ffs_filearray != NULL
  			    && (stackp->ffs_filearray[0]
  				= vim_strsave(dirptrs[0])) != NULL)
***************
*** 1283,1289 ****
      /*
       * if we reach this we didn't find a list and we have to allocate new list
       */
!     retptr = (ff_visited_list_hdr_T*)alloc(sizeof(*retptr));
      if (retptr == NULL)
  	return NULL;
  
--- 1283,1289 ----
      /*
       * if we reach this we didn't find a list and we have to allocate new list
       */
!     retptr = ALLOC_ONE(ff_visited_list_hdr_T);
      if (retptr == NULL)
  	return NULL;
  
***************
*** 1411,1417 ****
      /*
       * New file/dir.  Add it to the list of visited files/dirs.
       */
!     vp = (ff_visited_T *)alloc(sizeof(ff_visited_T) + STRLEN(ff_expand_buffer));
  
      if (vp != NULL)
      {
--- 1411,1417 ----
      /*
       * New file/dir.  Add it to the list of visited files/dirs.
       */
!     vp = alloc(sizeof(ff_visited_T) + STRLEN(ff_expand_buffer));
  
      if (vp != NULL)
      {
***************
*** 1459,1465 ****
  {
      ff_stack_T	*new;
  
!     new = (ff_stack_T *)alloc(sizeof(ff_stack_T));
      if (new == NULL)
  	return NULL;
  
--- 1459,1465 ----
  {
      ff_stack_T	*new;
  
!     new = ALLOC_ONE(ff_stack_T);
      if (new == NULL)
  	return NULL;
  
***************
*** 2429,2435 ****
      mch_dirname(curdir, MAXPATHL);
      expand_path_option(curdir, &path_ga);
  
!     in_curdir = (char_u **)alloc_clear(gap->ga_len * sizeof(char_u *));
      if (in_curdir == NULL)
  	goto theend;
  
--- 2429,2435 ----
      mch_dirname(curdir, MAXPATHL);
      expand_path_option(curdir, &path_ga);
  
!     in_curdir = ALLOC_CLEAR_MULT(char_u *, gap->ga_len);
      if (in_curdir == NULL)
  	goto theend;
  
*** ../vim-8.1.1413/src/getchar.c	2019-05-24 19:38:59.100545522 +0200
--- src/getchar.c	2019-05-28 21:14:06.095575993 +0200
***************
*** 258,264 ****
  	    len = MINIMAL_SIZE;
  	else
  	    len = slen;
! 	p = (buffblock_T *)alloc(sizeof(buffblock_T) + len);
  	if (p == NULL)
  	    return; /* no space, just forget it */
  	buf->bh_space = (int)(len - slen);
--- 258,264 ----
  	    len = MINIMAL_SIZE;
  	else
  	    len = slen;
! 	p = alloc(sizeof(buffblock_T) + len);
  	if (p == NULL)
  	    return; /* no space, just forget it */
  	buf->bh_space = (int)(len - slen);
***************
*** 3730,3736 ****
      /*
       * Get here when adding a new entry to the maphash[] list or abbrlist.
       */
!     mp = (mapblock_T *)alloc(sizeof(mapblock_T));
      if (mp == NULL)
      {
  	retval = 4;	    /* no mem */
--- 3730,3736 ----
      /*
       * Get here when adding a new entry to the maphash[] list or abbrlist.
       */
!     mp = ALLOC_ONE(mapblock_T);
      if (mp == NULL)
      {
  	retval = 4;	    /* no mem */
***************
*** 4374,4380 ****
  
  	if (round == 1)
  	{
! 	    *file = (char_u **)alloc(count * sizeof(char_u *));
  	    if (*file == NULL)
  		return FAIL;
  	}
--- 4374,4380 ----
  
  	if (round == 1)
  	{
! 	    *file = ALLOC_MULT(char_u *, count);
  	    if (*file == NULL)
  		return FAIL;
  	}
*** ../vim-8.1.1413/src/gui_gtk.c	2019-05-24 18:48:36.758128504 +0200
--- src/gui_gtk.c	2019-05-28 21:14:46.895391980 +0200
***************
*** 1452,1458 ****
  	if (*p == DLG_BUTTON_SEP)
  	    ++count;
  
!     array = (char **)alloc((count + 1) * sizeof(char *));
      count = 0;
  
      if (array != NULL)
--- 1452,1458 ----
  	if (*p == DLG_BUTTON_SEP)
  	    ++count;
  
!     array = ALLOC_MULT(char *, count + 1);
      count = 0;
  
      if (array != NULL)
*** ../vim-8.1.1413/src/gui_gtk_x11.c	2019-05-24 18:48:36.762128482 +0200
--- src/gui_gtk_x11.c	2019-05-28 21:39:21.064527997 +0200
***************
*** 429,435 ****
       * into gui_argv.  Freed later in gui_mch_init().
       */
      gui_argc = 0;
!     gui_argv = (char **)alloc((*argc + 1) * sizeof(char *));
  
      g_return_if_fail(gui_argv != NULL);
  
--- 429,435 ----
       * into gui_argv.  Freed later in gui_mch_init().
       */
      gui_argc = 0;
!     gui_argv = ALLOC_MULT(char *, *argc + 1);
  
      g_return_if_fail(gui_argv != NULL);
  
***************
*** 2157,2166 ****
      char_u  *tmp    = NULL;
      char_u  **array = NULL;
  
!     if (data != NULL && len > 0 && (tmp = (char_u *)alloc(len + 1)) != NULL)
      {
  	n = count_and_decode_uri_list(tmp, data, len);
! 	if (n > 0 && (array = (char_u **)alloc(n * sizeof(char_u *))) != NULL)
  	    n = filter_uri_list(array, n, tmp);
      }
      vim_free(tmp);
--- 2157,2166 ----
      char_u  *tmp    = NULL;
      char_u  **array = NULL;
  
!     if (data != NULL && len > 0 && (tmp = alloc(len + 1)) != NULL)
      {
  	n = count_and_decode_uri_list(tmp, data, len);
! 	if (n > 0 && (array = ALLOC_MULT(char_u *, n)) != NULL)
  	    n = filter_uri_list(array, n, tmp);
      }
      vim_free(tmp);
***************
*** 2512,2518 ****
  	    if (i == count)
  	    {
  		/* allocate an Atoms array which is one item longer */
! 		new_atoms = (Atom *)alloc((count + 1) * sizeof(Atom));
  		if (new_atoms != NULL)
  		{
  		    memcpy(new_atoms, existing_atoms, count * sizeof(Atom));
--- 2512,2518 ----
  	    if (i == count)
  	    {
  		/* allocate an Atoms array which is one item longer */
! 		new_atoms = ALLOC_MULT(Atom, count + 1);
  		if (new_atoms != NULL)
  		{
  		    memcpy(new_atoms, existing_atoms, count * sizeof(Atom));
*** ../vim-8.1.1413/src/gui_mac.c	2019-05-24 19:38:59.104545491 +0200
--- src/gui_mac.c	2019-05-28 21:40:26.760217482 +0200
***************
*** 536,542 ****
  	return fnames;
  
      /* Allocate the pointer list */
!     fnames = (char_u **) alloc(*numFiles * sizeof(char_u *));
  
      /* Empty out the list */
      for (fileCount = 0; fileCount < *numFiles; fileCount++)
--- 536,542 ----
  	return fnames;
  
      /* Allocate the pointer list */
!     fnames = ALLOC_MULT(char_u *, *numFiles);
  
      /* Empty out the list */
      for (fileCount = 0; fileCount < *numFiles; fileCount++)
***************
*** 2105,2111 ****
  		typeUnicodeText, NULL, 0, &actualSize, NULL))
  	return eventNotHandledErr;
  
!     text = (UniChar *)alloc(actualSize);
      if (!text)
  	return eventNotHandledErr;
  
--- 2105,2111 ----
  		typeUnicodeText, NULL, 0, &actualSize, NULL))
  	return eventNotHandledErr;
  
!     text = alloc(actualSize);
      if (!text)
  	return eventNotHandledErr;
  
***************
*** 2975,2981 ****
  	count = countItem;
      }
  
!     fnames = (char_u **)alloc(count * sizeof(char_u *));
      if (fnames == NULL)
  	return dragNotAcceptedErr;
  
--- 2975,2981 ----
  	count = countItem;
      }
  
!     fnames = ALLOC_MULT(char_u *, count);
      if (fnames == NULL)
  	return dragNotAcceptedErr;
  
*** ../vim-8.1.1413/src/gui_motif.c	2019-05-24 18:48:36.762128482 +0200
--- src/gui_motif.c	2019-05-28 21:40:53.168092569 +0200
***************
*** 2538,2544 ****
      for (p = buts; *p; ++p)
  	if (*p == DLG_BUTTON_SEP)
  	    ++butcount;
!     buttons = (Widget *)alloc(butcount * sizeof(Widget));
      if (buttons == NULL)
      {
  	vim_free(buts);
--- 2538,2544 ----
      for (p = buts; *p; ++p)
  	if (*p == DLG_BUTTON_SEP)
  	    ++butcount;
!     buttons = ALLOC_MULT(Widget, butcount);
      if (buttons == NULL)
      {
  	vim_free(buts);
*** ../vim-8.1.1413/src/gui_photon.c	2019-03-30 18:46:57.352077376 +0100
--- src/gui_photon.c	2019-05-28 21:42:54.203519137 +0200
***************
*** 976,982 ****
  {
      char **new_titles = NULL;
  
!     new_titles = (char **) alloc((num_panels + 1) * sizeof(char **));
      if (new_titles != NULL)
      {
  	if (num_panels > 0)
--- 976,982 ----
  {
      char **new_titles = NULL;
  
!     new_titles = ALLOC_MULT(char *, (num_panels + 1));
      if (new_titles != NULL)
      {
  	if (num_panels > 0)
***************
*** 1001,1007 ****
      /* If there is only 1 panel, we just use the temporary place holder */
      if (num_panels > 1)
      {
! 	new_titles = (char **) alloc((num_panels - 1) * sizeof(char **));
  	if (new_titles != NULL)
  	{
  	    char **s = new_titles;
--- 1001,1007 ----
      /* If there is only 1 panel, we just use the temporary place holder */
      if (num_panels > 1)
      {
! 	new_titles = ALLOC_MULT(char *, num_panels - 1);
  	if (new_titles != NULL)
  	{
  	    char **s = new_titles;
***************
*** 1108,1114 ****
      PhDim_t	window_size = {100, 100}; /* Arbitrary values */
      PhPoint_t	pos = {0, 0};
  
!     gui.event_buffer = (PhEvent_t *) alloc(EVENT_BUFFER_SIZE);
      if (gui.event_buffer == NULL)
  	return FAIL;
  
--- 1108,1114 ----
      PhDim_t	window_size = {100, 100}; /* Arbitrary values */
      PhPoint_t	pos = {0, 0};
  
!     gui.event_buffer = alloc(EVENT_BUFFER_SIZE);
      if (gui.event_buffer == NULL)
  	return FAIL;
  
***************
*** 1519,1525 ****
  	title = "Vim";
  
      buttons_copy = alloc(len + 1);
!     button_array = (char_u **) alloc(button_count * sizeof(char_u *));
      if (buttons_copy != NULL && button_array != NULL)
      {
  	STRCPY(buttons_copy, buttons);
--- 1519,1525 ----
  	title = "Vim";
  
      buttons_copy = alloc(len + 1);
!     button_array = ALLOC_MULT(char_u *, button_count);
      if (buttons_copy != NULL && button_array != NULL)
      {
  	STRCPY(buttons_copy, buttons);
*** ../vim-8.1.1413/src/gui_w32.c	2019-05-24 19:38:59.104545491 +0200
--- src/gui_w32.c	2019-05-28 21:51:15.093135702 +0200
***************
*** 3120,3126 ****
      charset_name = charset_id2name((int)lf.lfCharSet);
      quality_name = quality_id2name((int)lf.lfQuality);
  
!     res = (char *)alloc(strlen(font_name) + 30
  		    + (charset_name == NULL ? 0 : strlen(charset_name) + 2)
  		    + (quality_name == NULL ? 0 : strlen(quality_name) + 2));
      if (res != NULL)
--- 3120,3126 ----
      charset_name = charset_id2name((int)lf.lfCharSet);
      quality_name = quality_id2name((int)lf.lfQuality);
  
!     res = alloc(strlen(font_name) + 30
  		    + (charset_name == NULL ? 0 : strlen(charset_name) + 2)
  		    + (quality_name == NULL ? 0 : strlen(quality_name) + 2));
      if (res != NULL)
***************
*** 3639,3645 ****
  
      reset_VIsual();
  
!     fnames = (char_u **)alloc(cFiles * sizeof(char_u *));
  
      if (fnames != NULL)
  	for (i = 0; i < cFiles; ++i)
--- 3639,3645 ----
  
      reset_VIsual();
  
!     fnames = ALLOC_MULT(char_u *, cFiles);
  
      if (fnames != NULL)
  	for (i = 0; i < cFiles; ++i)
***************
*** 4916,4922 ****
  	if (wsession == NULL)
  	    goto error;
  	len = (int)wcslen(wsession) * 2 + 27 + 1;
! 	cmd = (LPWSTR)alloc(len * (int)sizeof(WCHAR));
  	if (cmd == NULL)
  	{
  	    vim_free(wsession);
--- 4916,4922 ----
  	if (wsession == NULL)
  	    goto error;
  	len = (int)wcslen(wsession) * 2 + 27 + 1;
! 	cmd = ALLOC_MULT(WCHAR, len);
  	if (cmd == NULL)
  	{
  	    vim_free(wsession);
***************
*** 4942,4948 ****
  
      // Set up the new command line.
      len = (int)wcslen(name) + (int)wcslen(cmd) + (int)wcslen(warg) + 4;
!     newcmd = (LPWSTR)alloc(len * (int)sizeof(WCHAR));
      if (newcmd == NULL)
  	goto error;
      _snwprintf(newcmd, len, L"\"%s\"%s %s", name, cmd, warg);
--- 4942,4948 ----
  
      // Set up the new command line.
      len = (int)wcslen(name) + (int)wcslen(cmd) + (int)wcslen(warg) + 4;
!     newcmd = ALLOC_MULT(WCHAR, len);
      if (newcmd == NULL)
  	goto error;
      _snwprintf(newcmd, len, L"\"%s\"%s %s", name, cmd, warg);
***************
*** 5293,5303 ****
  
      /* Initialise the struct */
      s_findrep_struct.lStructSize = sizeof(s_findrep_struct);
!     s_findrep_struct.lpstrFindWhat =
! 			      (LPWSTR)alloc(MSWIN_FR_BUFSIZE * sizeof(WCHAR));
      s_findrep_struct.lpstrFindWhat[0] = NUL;
!     s_findrep_struct.lpstrReplaceWith =
! 			      (LPWSTR)alloc(MSWIN_FR_BUFSIZE * sizeof(WCHAR));
      s_findrep_struct.lpstrReplaceWith[0] = NUL;
      s_findrep_struct.wFindWhatLen = MSWIN_FR_BUFSIZE;
      s_findrep_struct.wReplaceWithLen = MSWIN_FR_BUFSIZE;
--- 5293,5301 ----
  
      /* Initialise the struct */
      s_findrep_struct.lStructSize = sizeof(s_findrep_struct);
!     s_findrep_struct.lpstrFindWhat = ALLOC_MULT(WCHAR, MSWIN_FR_BUFSIZE);
      s_findrep_struct.lpstrFindWhat[0] = NUL;
!     s_findrep_struct.lpstrReplaceWith = ALLOC_MULT(WCHAR, MSWIN_FR_BUFSIZE);
      s_findrep_struct.lpstrReplaceWith[0] = NUL;
      s_findrep_struct.wFindWhatLen = MSWIN_FR_BUFSIZE;
      s_findrep_struct.wReplaceWithLen = MSWIN_FR_BUFSIZE;
***************
*** 5613,5619 ****
      if (ret > 0)
      {
  	/* Allocate the requested buffer plus space for the NUL character. */
! 	wbuf = (LPWSTR)alloc(ret + sizeof(WCHAR));
  	if (wbuf != NULL)
  	{
  	    pImmGetCompositionStringW(hIMC, GCS, wbuf, ret);
--- 5611,5617 ----
      if (ret > 0)
      {
  	/* Allocate the requested buffer plus space for the NUL character. */
! 	wbuf = alloc(ret + sizeof(WCHAR));
  	if (wbuf != NULL)
  	{
  	    pImmGetCompositionStringW(hIMC, GCS, wbuf, ret);
***************
*** 6058,6064 ****
  
  	/* Don't give an out-of-memory message here, it would call us
  	 * recursively. */
! 	padding = (int *)lalloc(pad_size * sizeof(int), FALSE);
  	if (padding != NULL)
  	    for (i = 0; i < pad_size; i++)
  		padding[i] = gui.char_width;
--- 6056,6062 ----
  
  	/* Don't give an out-of-memory message here, it would call us
  	 * recursively. */
! 	padding = LALLOC_MULT(sizeof(int), pad_size);
  	if (padding != NULL)
  	    for (i = 0; i < pad_size; i++)
  		padding[i] = gui.char_width;
***************
*** 6095,6104 ****
  	    && (unicodebuf == NULL || len > unibuflen))
      {
  	vim_free(unicodebuf);
! 	unicodebuf = (WCHAR *)lalloc(len * sizeof(WCHAR), FALSE);
  
  	vim_free(unicodepdy);
! 	unicodepdy = (int *)lalloc(len * sizeof(int), FALSE);
  
  	unibuflen = len;
      }
--- 6093,6102 ----
  	    && (unicodebuf == NULL || len > unibuflen))
      {
  	vim_free(unicodebuf);
! 	unicodebuf = LALLOC_MULT(WCHAR, len);
  
  	vim_free(unicodepdy);
! 	unicodepdy = LALLOC_MULT(int, len);
  
  	unibuflen = len;
      }
***************
*** 6654,6660 ****
  	/* If the edit box exists, copy the string. */
  	if (s_textfield != NULL)
  	{
! 	    WCHAR  *wp = (WCHAR *)alloc(IOSIZE * sizeof(WCHAR));
  	    char_u *p;
  
  	    GetDlgItemTextW(hwnd, DLG_NONBUTTON_CONTROL + 2, wp, IOSIZE);
--- 6652,6658 ----
  	/* If the edit box exists, copy the string. */
  	if (s_textfield != NULL)
  	{
! 	    WCHAR  *wp = ALLOC_MULT(WCHAR, IOSIZE);
  	    char_u *p;
  
  	    GetDlgItemTextW(hwnd, DLG_NONBUTTON_CONTROL + 2, wp, IOSIZE);
***************
*** 6803,6814 ****
  	dfltbutton = -1;
  
      /* Allocate array to hold the width of each button */
!     buttonWidths = (int *)alloc(numButtons * sizeof(int));
      if (buttonWidths == NULL)
  	return -1;
  
      /* Allocate array to hold the X position of each button */
!     buttonPositions = (int *)alloc(numButtons * sizeof(int));
      if (buttonPositions == NULL)
  	return -1;
  
--- 6801,6812 ----
  	dfltbutton = -1;
  
      /* Allocate array to hold the width of each button */
!     buttonWidths = ALLOC_MULT(int, numButtons);
      if (buttonWidths == NULL)
  	return -1;
  
      /* Allocate array to hold the X position of each button */
!     buttonPositions = ALLOC_MULT(int, numButtons);
      if (buttonPositions == NULL)
  	return -1;
  
***************
*** 8232,8239 ****
      }
  
      psign = NULL;
!     if (sign.hImage && (psign = (signicon_t *)alloc(sizeof(signicon_t)))
! 								      != NULL)
  	*psign = sign;
  
      if (!psign)
--- 8230,8236 ----
      }
  
      psign = NULL;
!     if (sign.hImage && (psign = ALLOC_ONE(signicon_t)) != NULL)
  	*psign = sign;
  
      if (!psign)
***************
*** 8361,8367 ****
      else
  	ToolInfoSize = sizeof(TOOLINFOW);
  
!     pti = (TOOLINFOW *)alloc(ToolInfoSize);
      if (pti == NULL)
  	return;
  
--- 8358,8364 ----
      else
  	ToolInfoSize = sizeof(TOOLINFOW);
  
!     pti = alloc(ToolInfoSize);
      if (pti == NULL)
  	return;
  
***************
*** 8532,8538 ****
  	return NULL;
      }
  
!     beval = (BalloonEval *)alloc_clear(sizeof(BalloonEval));
      if (beval != NULL)
      {
  	beval->target = s_textArea;
--- 8529,8535 ----
  	return NULL;
      }
  
!     beval = ALLOC_CLEAR_ONE(BalloonEval);
      if (beval != NULL)
      {
  	beval->target = s_textArea;
*** ../vim-8.1.1413/src/gui_x11.c	2019-05-24 19:38:59.104545491 +0200
--- src/gui_x11.c	2019-05-28 20:44:20.478842787 +0200
***************
*** 1167,1173 ****
       * Move all the entries in argv which are relevant to X into gui_argv.
       */
      gui_argc = 0;
!     gui_argv = (char **)lalloc(*argc * sizeof(char *), FALSE);
      if (gui_argv == NULL)
  	return;
      gui_argv[gui_argc++] = argv[0];
--- 1167,1173 ----
       * Move all the entries in argv which are relevant to X into gui_argv.
       */
      gui_argc = 0;
!     gui_argv = LALLOC_MULT(char *, *argc);
      if (gui_argv == NULL)
  	return;
      gui_argv[gui_argc++] = argv[0];
*** ../vim-8.1.1413/src/hardcopy.c	2019-05-10 21:28:35.184612974 +0200
--- src/hardcopy.c	2019-05-28 20:31:59.967096670 +0200
***************
*** 186,192 ****
      int		len;
  
      /* Save the old values, so that they can be restored in case of an error. */
!     old_opts = (option_table_T *)alloc(sizeof(option_table_T) * table_size);
      if (old_opts == NULL)
  	return NULL;
  
--- 186,192 ----
      int		len;
  
      /* Save the old values, so that they can be restored in case of an error. */
!     old_opts = ALLOC_MULT(option_table_T, table_size);
      if (old_opts == NULL)
  	return NULL;
  
***************
*** 2236,2242 ****
  {
      char    *fontname;
  
!     fontname = (char *)alloc(name_len + 1);
      if (fontname == NULL)
  	return FALSE;
      vim_strncpy((char_u *)fontname, name, name_len);
--- 2236,2242 ----
  {
      char    *fontname;
  
!     fontname = alloc(name_len + 1);
      if (fontname == NULL)
  	return FALSE;
      vim_strncpy((char_u *)fontname, name, name_len);
*** ../vim-8.1.1413/src/hashtab.c	2019-05-24 18:48:36.762128482 +0200
--- src/hashtab.c	2019-05-28 20:32:03.563075261 +0200
***************
*** 51,57 ****
  {
      hashtab_T *ht;
  
!     ht = (hashtab_T *)alloc(sizeof(hashtab_T));
      if (ht != NULL)
  	hash_init(ht);
      return ht;
--- 51,57 ----
  {
      hashtab_T *ht;
  
!     ht = ALLOC_ONE(hashtab_T);
      if (ht != NULL)
  	hash_init(ht);
      return ht;
***************
*** 400,406 ****
      else
      {
  	/* Allocate an array. */
! 	newarray = (hashitem_T *)alloc(sizeof(hashitem_T) * newsize);
  	if (newarray == NULL)
  	{
  	    /* Out of memory.  When there are NULL items still return OK.
--- 400,406 ----
      else
      {
  	/* Allocate an array. */
! 	newarray = ALLOC_MULT(hashitem_T, newsize);
  	if (newarray == NULL)
  	{
  	    /* Out of memory.  When there are NULL items still return OK.
*** ../vim-8.1.1413/src/if_cscope.c	2019-05-24 18:48:36.762128482 +0200
--- src/if_cscope.c	2019-05-28 21:53:34.360471443 +0200
***************
*** 466,472 ****
  cs_stat_emsg(char *fname)
  {
      char *stat_emsg = _("E563: stat(%s) error: %d");
!     char *buf = (char *)alloc(strlen(stat_emsg) + MAXPATHL + 10);
  
      if (buf != NULL)
      {
--- 466,472 ----
  cs_stat_emsg(char *fname)
  {
      char *stat_emsg = _("E563: stat(%s) error: %d");
!     char *buf = alloc(strlen(stat_emsg) + MAXPATHL + 10);
  
      if (buf != NULL)
      {
***************
*** 503,509 ****
  #endif
  
      /* get the filename (arg1), expand it, and try to stat it */
!     if ((fname = (char *)alloc(MAXPATHL + 1)) == NULL)
  	goto add_err;
  
      expand_env((char_u *)arg1, (char_u *)fname, MAXPATHL);
--- 503,509 ----
  #endif
  
      /* get the filename (arg1), expand it, and try to stat it */
!     if ((fname = alloc(MAXPATHL + 1)) == NULL)
  	goto add_err;
  
      expand_env((char_u *)arg1, (char_u *)fname, MAXPATHL);
***************
*** 531,537 ****
      {
  	stat_T	    statbuf2;
  
! 	if ((ppath = (char *)alloc(MAXPATHL + 1)) == NULL)
  	    goto add_err;
  
  	expand_env((char_u *)arg2, (char_u *)ppath, MAXPATHL);
--- 531,537 ----
      {
  	stat_T	    statbuf2;
  
! 	if ((ppath = alloc(MAXPATHL + 1)) == NULL)
  	    goto add_err;
  
  	expand_env((char_u *)arg2, (char_u *)ppath, MAXPATHL);
***************
*** 543,549 ****
      /* if filename is a directory, append the cscope database name to it */
      if (S_ISDIR(statbuf.st_mode))
      {
! 	fname2 = (char *)alloc(strlen(CSCOPE_DBFILE) + strlen(fname) + 2);
  	if (fname2 == NULL)
  	    goto add_err;
  
--- 543,549 ----
      /* if filename is a directory, append the cscope database name to it */
      if (S_ISDIR(statbuf.st_mode))
      {
! 	fname2 = alloc(strlen(CSCOPE_DBFILE) + strlen(fname) + 2);
  	if (fname2 == NULL)
  	    goto add_err;
  
***************
*** 665,671 ****
      char *buf;
      int nlines = 0;
  
!     buf = (char *)alloc(CSREAD_BUFSIZE);
      if (buf == NULL)
  	return 0;
      for (;;)
--- 665,671 ----
      char *buf;
      int nlines = 0;
  
!     buf = alloc(CSREAD_BUFSIZE);
      if (buf == NULL)
  	return 0;
      for (;;)
***************
*** 769,775 ****
  	while VIM_ISWHITE(*pat)
  	    ++pat;
  
!     if ((cmd = (char *)alloc(strlen(pat) + 2)) == NULL)
  	return NULL;
  
      (void)sprintf(cmd, "%d%s", search, pat);
--- 769,775 ----
  	while VIM_ISWHITE(*pat)
  	    ++pat;
  
!     if ((cmd = alloc(strlen(pat) + 2)) == NULL)
  	return NULL;
  
      (void)sprintf(cmd, "%d%s", search, pat);
***************
*** 869,875 ****
  	}
  #endif
  	/* expand the cscope exec for env var's */
! 	if ((prog = (char *)alloc(MAXPATHL + 1)) == NULL)
  	{
  #ifdef UNIX
  	    return CSCOPE_FAILURE;
--- 869,875 ----
  	}
  #endif
  	/* expand the cscope exec for env var's */
! 	if ((prog = alloc(MAXPATHL + 1)) == NULL)
  	{
  #ifdef UNIX
  	    return CSCOPE_FAILURE;
***************
*** 885,891 ****
  	if (csinfo[i].ppath)
  	{
  	    /* expand the prepend path for env var's */
! 	    if ((ppath = (char *)alloc(MAXPATHL + 1)) == NULL)
  	    {
  		vim_free(prog);
  #ifdef UNIX
--- 885,891 ----
  	if (csinfo[i].ppath)
  	{
  	    /* expand the prepend path for env var's */
! 	    if ((ppath = alloc(MAXPATHL + 1)) == NULL)
  	    {
  		vim_free(prog);
  #ifdef UNIX
***************
*** 903,909 ****
  	if (csinfo[i].flags)
  	    len += (int)strlen(csinfo[i].flags);
  
! 	if ((cmd = (char *)alloc(len)) == NULL)
  	{
  	    vim_free(prog);
  	    vim_free(ppath);
--- 903,909 ----
  	if (csinfo[i].flags)
  	    len += (int)strlen(csinfo[i].flags);
  
! 	if ((cmd = alloc(len)) == NULL)
  	{
  	    vim_free(prog);
  	    vim_free(ppath);
***************
*** 1121,1127 ****
  	if (strchr(CSQF_FLAGS, *qfpos) == NULL)
  	{
  	    char *nf = _("E469: invalid cscopequickfix flag %c for %c");
! 	    char *buf = (char *)alloc(strlen(nf));
  
  	    /* strlen will be enough because we use chars */
  	    if (buf != NULL)
--- 1121,1127 ----
  	if (strchr(CSQF_FLAGS, *qfpos) == NULL)
  	{
  	    char *nf = _("E469: invalid cscopequickfix flag %c for %c");
! 	    char *buf = alloc(strlen(nf));
  
  	    /* strlen will be enough because we use chars */
  	    if (buf != NULL)
***************
*** 1150,1156 ****
      if (cmd == NULL)
  	return FALSE;
  
!     nummatches = (int *)alloc(sizeof(int)*csinfo_size);
      if (nummatches == NULL)
      {
  	vim_free(cmd);
--- 1150,1156 ----
      if (cmd == NULL)
  	return FALSE;
  
!     nummatches = ALLOC_MULT(int, csinfo_size);
      if (nummatches == NULL)
      {
  	vim_free(cmd);
***************
*** 1192,1198 ****
  	    return FALSE;
  	}
  
! 	buf = (char *)alloc(strlen(opt) + strlen(pat) + strlen(nf));
  	if (buf == NULL)
  	    (void)emsg(nf);
  	else
--- 1192,1198 ----
  	    return FALSE;
  	}
  
! 	buf = alloc(strlen(opt) + strlen(pat) + strlen(nf));
  	if (buf == NULL)
  	    (void)emsg(nf);
  	else
***************
*** 1429,1435 ****
  	     * be enough for most users.  If more is needed, csinfo will be
  	     * reallocated. */
  	    csinfo_size = 1;
! 	    csinfo = (csinfo_T *)alloc_clear(sizeof(csinfo_T));
  	}
  	else
  	{
--- 1429,1435 ----
  	     * be enough for most users.  If more is needed, csinfo will be
  	     * reallocated. */
  	    csinfo_size = 1;
! 	    csinfo = ALLOC_CLEAR_ONE(csinfo_T);
  	}
  	else
  	{
***************
*** 1450,1463 ****
  	    clear_csinfo(j);
      }
  
!     if ((csinfo[i].fname = (char *)alloc(strlen(fname)+1)) == NULL)
  	return -1;
  
      (void)strcpy(csinfo[i].fname, (const char *)fname);
  
      if (ppath != NULL)
      {
! 	if ((csinfo[i].ppath = (char *)alloc(strlen(ppath) + 1)) == NULL)
  	{
  	    VIM_CLEAR(csinfo[i].fname);
  	    return -1;
--- 1450,1463 ----
  	    clear_csinfo(j);
      }
  
!     if ((csinfo[i].fname = alloc(strlen(fname)+1)) == NULL)
  	return -1;
  
      (void)strcpy(csinfo[i].fname, (const char *)fname);
  
      if (ppath != NULL)
      {
! 	if ((csinfo[i].ppath = alloc(strlen(ppath) + 1)) == NULL)
  	{
  	    VIM_CLEAR(csinfo[i].fname);
  	    return -1;
***************
*** 1468,1474 ****
  
      if (flags != NULL)
      {
! 	if ((csinfo[i].flags = (char *)alloc(strlen(flags) + 1)) == NULL)
  	{
  	    VIM_CLEAR(csinfo[i].fname);
  	    VIM_CLEAR(csinfo[i].ppath);
--- 1468,1474 ----
  
      if (flags != NULL)
      {
! 	if ((csinfo[i].flags = alloc(strlen(flags) + 1)) == NULL)
  	{
  	    VIM_CLEAR(csinfo[i].fname);
  	    VIM_CLEAR(csinfo[i].ppath);
***************
*** 1635,1641 ****
      if (search != NULL)
      {
  	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + strlen(search)+6);
! 	if ((buf = (char *)alloc(amt)) == NULL)
  	    return NULL;
  
  	(void)sprintf(buf, "%s\t%s\t%s;\"\t%s", tagstr, fname, slno, search);
--- 1635,1641 ----
      if (search != NULL)
      {
  	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + strlen(search)+6);
! 	if ((buf = alloc(amt)) == NULL)
  	    return NULL;
  
  	(void)sprintf(buf, "%s\t%s\t%s;\"\t%s", tagstr, fname, slno, search);
***************
*** 1643,1649 ****
      else
      {
  	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + 5);
! 	if ((buf = (char *)alloc(amt)) == NULL)
  	    return NULL;
  
  	(void)sprintf(buf, "%s\t%s\t%s;\"", tagstr, fname, slno);
--- 1643,1649 ----
      else
      {
  	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + 5);
! 	if ((buf = alloc(amt)) == NULL)
  	    return NULL;
  
  	(void)sprintf(buf, "%s\t%s\t%s;\"", tagstr, fname, slno);
***************
*** 1805,1811 ****
      char *cntx;
      char *context;
  
!     buf = (char *)alloc(CSREAD_BUFSIZE);
      if (buf == NULL)
  	return;
  
--- 1805,1811 ----
      char *cntx;
      char *context;
  
!     buf = alloc(CSREAD_BUFSIZE);
      if (buf == NULL)
  	return;
  
***************
*** 1820,1826 ****
  			   &slno, &search)) == NULL)
  	       continue;
  
! 	   context = (char *)alloc(strlen(cntx)+5);
  	   if (context == NULL)
  	       continue;
  
--- 1820,1826 ----
  			   &slno, &search)) == NULL)
  	       continue;
  
! 	   context = alloc(strlen(cntx)+5);
  	   if (context == NULL)
  	       continue;
  
***************
*** 1870,1882 ****
  
      assert(totmatches > 0);
  
!     buf = (char *)alloc(CSREAD_BUFSIZE);
      if (buf == NULL)
  	return;
  
!     if ((matches = (char **)alloc(sizeof(char *) * totmatches)) == NULL)
  	goto parse_out;
!     if ((cntxts = (char **)alloc(sizeof(char *) * totmatches)) == NULL)
  	goto parse_out;
  
      for (i = 0; i < csinfo_size; i++)
--- 1870,1882 ----
  
      assert(totmatches > 0);
  
!     buf = alloc(CSREAD_BUFSIZE);
      if (buf == NULL)
  	return;
  
!     if ((matches = ALLOC_MULT(char *, totmatches)) == NULL)
  	goto parse_out;
!     if ((cntxts = ALLOC_MULT(char *, totmatches)) == NULL)
  	goto parse_out;
  
      for (i = 0; i < csinfo_size; i++)
***************
*** 1975,1981 ****
  
      assert(num_matches > 0);
  
!     if ((tbuf = (char *)alloc(strlen(matches[0]) + 1)) == NULL)
  	return;
  
      strcpy(tbuf, matches[0]);
--- 1975,1981 ----
  
      assert(num_matches > 0);
  
!     if ((tbuf = alloc(strlen(matches[0]) + 1)) == NULL)
  	return;
  
      strcpy(tbuf, matches[0]);
***************
*** 1987,1993 ****
      }
  
      newsize = (int)(strlen(cstag_msg) + strlen(ptag));
!     buf = (char *)alloc(newsize);
      if (buf != NULL)
      {
  	bufsize = newsize;
--- 1987,1993 ----
      }
  
      newsize = (int)(strlen(cstag_msg) + strlen(ptag));
!     buf = alloc(newsize);
      if (buf != NULL)
      {
  	bufsize = newsize;
***************
*** 2010,2016 ****
  	 * by parsing matches[i] on the fly and placing stuff into buf
  	 * directly, but that's too much of a hassle
  	 */
! 	if ((tbuf = (char *)alloc(strlen(matches[idx]) + 1)) == NULL)
  	    continue;
  	(void)strcpy(tbuf, matches[idx]);
  
--- 2010,2016 ----
  	 * by parsing matches[i] on the fly and placing stuff into buf
  	 * directly, but that's too much of a hassle
  	 */
! 	if ((tbuf = alloc(strlen(matches[idx]) + 1)) == NULL)
  	    continue;
  	(void)strcpy(tbuf, matches[idx]);
  
***************
*** 2030,2036 ****
  	if (bufsize < newsize)
  	{
  	    t_buf = buf;
! 	    buf = (char *)vim_realloc(buf, newsize);
  	    if (buf == NULL)
  	    {
  		bufsize = 0;
--- 2030,2036 ----
  	if (bufsize < newsize)
  	{
  	    t_buf = buf;
! 	    buf = vim_realloc(buf, newsize);
  	    if (buf == NULL)
  	    {
  		bufsize = 0;
***************
*** 2058,2064 ****
  	if (bufsize < newsize)
  	{
  	    t_buf = buf;
! 	    buf = (char *)vim_realloc(buf, newsize);
  	    if (buf == NULL)
  	    {
  		bufsize = 0;
--- 2058,2064 ----
  	if (bufsize < newsize)
  	{
  	    t_buf = buf;
! 	    buf = vim_realloc(buf, newsize);
  	    if (buf == NULL)
  	    {
  		bufsize = 0;
***************
*** 2129,2135 ****
  	    if (bufpos < maxlen - 1 && vim_isprintc(ch))
  	    {
  		if (buf == NULL) /* lazy buffer allocation */
! 		    buf = (char *)alloc(maxlen);
  		if (buf != NULL)
  		{
  		    /* append character to the message */
--- 2129,2135 ----
  	    if (bufpos < maxlen - 1 && vim_isprintc(ch))
  	    {
  		if (buf == NULL) /* lazy buffer allocation */
! 		    buf = alloc(maxlen);
  		if (buf != NULL)
  		{
  		    /* append character to the message */
***************
*** 2339,2347 ****
  	return CSCOPE_SUCCESS;
  
      /* malloc our db and ppath list */
!     dblist = (char **)alloc(csinfo_size * sizeof(char *));
!     pplist = (char **)alloc(csinfo_size * sizeof(char *));
!     fllist = (char **)alloc(csinfo_size * sizeof(char *));
      if (dblist == NULL || pplist == NULL || fllist == NULL)
      {
  	vim_free(dblist);
--- 2339,2347 ----
  	return CSCOPE_SUCCESS;
  
      /* malloc our db and ppath list */
!     dblist = ALLOC_MULT(char *, csinfo_size);
!     pplist = ALLOC_MULT(char *, csinfo_size);
!     fllist = ALLOC_MULT(char *, csinfo_size);
      if (dblist == NULL || pplist == NULL || fllist == NULL)
      {
  	vim_free(dblist);
***************
*** 2438,2444 ****
  #endif
         )
      {
! 	if ((fullname = (char *)alloc(len)) != NULL)
  	    (void)sprintf(fullname, "%s/%s", csinfo[i].ppath, name);
      }
      else if (csdir != NULL && csinfo[i].fname != NULL && *csdir != NUL)
--- 2438,2444 ----
  #endif
         )
      {
! 	if ((fullname = alloc(len)) != NULL)
  	    (void)sprintf(fullname, "%s/%s", csinfo[i].ppath, name);
      }
      else if (csdir != NULL && csinfo[i].fname != NULL && *csdir != NUL)
*** ../vim-8.1.1413/src/if_mzsch.c	2019-04-28 19:46:17.030060105 +0200
--- src/if_mzsch.c	2019-05-28 21:54:52.416098974 +0200
***************
*** 2582,2588 ****
  	    MZ_GC_VAR_IN_REG(1, rest);
  	    MZ_GC_REG();
  
! 	    array = (char **)alloc((new_len+1)* sizeof(char *));
  	    vim_memset(array, 0, (new_len+1) * sizeof(char *));
  
  	    rest = line_list;
--- 2582,2588 ----
  	    MZ_GC_VAR_IN_REG(1, rest);
  	    MZ_GC_REG();
  
! 	    array = ALLOC_MULT(char *, new_len + 1);
  	    vim_memset(array, 0, (new_len+1) * sizeof(char *));
  
  	    rest = line_list;
***************
*** 2766,2772 ****
  	MZ_GC_VAR_IN_REG(1, rest);
  	MZ_GC_REG();
  
! 	array = (char **)alloc((size+1) * sizeof(char *));
  	vim_memset(array, 0, (size+1) * sizeof(char *));
  
  	rest = list;
--- 2766,2772 ----
  	MZ_GC_VAR_IN_REG(1, rest);
  	MZ_GC_REG();
  
! 	array = ALLOC_MULT(char *, size + 1);
  	vim_memset(array, 0, (size+1) * sizeof(char *));
  
  	rest = list;
***************
*** 2886,2892 ****
      if (memchr(scheme_str, '\n', len))
  	scheme_signal_error(_("string cannot contain newlines"));
  
!     vim_str = (char *)alloc(len + 1);
  
      /* Create a copy of the string, with internal nulls replaced by
       * newline characters, as is the vim convention.
--- 2886,2892 ----
      if (memchr(scheme_str, '\n', len))
  	scheme_signal_error(_("string cannot contain newlines"));
  
!     vim_str = alloc(len + 1);
  
      /* Create a copy of the string, with internal nulls replaced by
       * newline characters, as is the vim convention.
***************
*** 3213,3226 ****
  	    tv->vval.v_list = list;
  	    ++list->lv_refcount;
  
! 	    v = (typval_T *)alloc(sizeof(typval_T));
  	    if (v == NULL)
  		status = FAIL;
  	    else
  	    {
  		/* add the value in advance to allow handling of self-referential
  		 * data structures */
! 		typval_T    *visited_tv = (typval_T *)alloc(sizeof(typval_T));
  		copy_tv(tv, visited_tv);
  		scheme_hash_set(visited, obj, (Scheme_Object *)visited_tv);
  
--- 3213,3226 ----
  	    tv->vval.v_list = list;
  	    ++list->lv_refcount;
  
! 	    v = ALLOC_ONE(typval_T);
  	    if (v == NULL)
  		status = FAIL;
  	    else
  	    {
  		/* add the value in advance to allow handling of self-referential
  		 * data structures */
! 		typval_T    *visited_tv = ALLOC_ONE(typval_T);
  		copy_tv(tv, visited_tv);
  		scheme_hash_set(visited, obj, (Scheme_Object *)visited_tv);
  
***************
*** 3288,3294 ****
  	    status = FAIL;
  	else
  	{
! 	    typval_T    *visited_tv = (typval_T *)alloc(sizeof(typval_T));
  
  	    tv->v_type = VAR_DICT;
  	    tv->vval.v_dict = dict;
--- 3288,3294 ----
  	    status = FAIL;
  	else
  	{
! 	    typval_T    *visited_tv = ALLOC_ONE(typval_T);
  
  	    tv->v_type = VAR_DICT;
  	    tv->vval.v_dict = dict;
***************
*** 3353,3359 ****
  	++list->lv_refcount;
  	for (i = 0; status == OK && i < argc; ++i)
  	{
! 	    typval_T *v = (typval_T *)alloc(sizeof(typval_T));
  	    if (v == NULL)
  		status = FAIL;
  	    else
--- 3353,3359 ----
  	++list->lv_refcount;
  	for (i = 0; status == OK && i < argc; ++i)
  	{
! 	    typval_T *v = ALLOC_ONE(typval_T);
  	    if (v == NULL)
  		status = FAIL;
  	    else
*** ../vim-8.1.1413/src/if_perlsfio.c	2019-05-24 18:48:36.762128482 +0200
--- src/if_perlsfio.c	2019-05-28 20:23:27.686316402 +0200
***************
*** 51,57 ****
  {
      Sfdisc_t	*disc;
  
!     disc = (Sfdisc_t *)alloc(sizeof(Sfdisc_t));
      if (disc == NULL)
  	return NULL;
  
--- 51,57 ----
  {
      Sfdisc_t	*disc;
  
!     disc = ALLOC_ONE(Sfdisc_t);
      if (disc == NULL)
  	return NULL;
  
*** ../vim-8.1.1413/src/if_py_both.h	2019-05-25 20:21:24.677951017 +0200
--- src/if_py_both.h	2019-05-28 21:56:32.959618882 +0200
***************
*** 3138,3145 ****
  	pt->pt_argc = self->argc;
  	if (exported)
  	{
! 	    pt->pt_argv = (typval_T *)alloc_clear(
! 						sizeof(typval_T) * self->argc);
  	    for (i = 0; i < pt->pt_argc; ++i)
  		copy_tv(&self->argv[i], &pt->pt_argv[i]);
  	}
--- 3138,3144 ----
  	pt->pt_argc = self->argc;
  	if (exported)
  	{
! 	    pt->pt_argv = ALLOC_CLEAR_MULT(typval_T, self->argc);
  	    for (i = 0; i < pt->pt_argc; ++i)
  		copy_tv(&self->argv[i], &pt->pt_argv[i]);
  	}
***************
*** 4262,4268 ****
      /* Create a copy of the string, with internal nulls replaced by
       * newline characters, as is the vim convention.
       */
!     save = (char *)alloc(len+1);
      if (save == NULL)
      {
  	PyErr_NoMemory();
--- 4261,4267 ----
      /* Create a copy of the string, with internal nulls replaced by
       * newline characters, as is the vim convention.
       */
!     save = alloc(len+1);
      if (save == NULL)
      {
  	PyErr_NoMemory();
***************
*** 6243,6249 ****
  	FunctionObject *func = (FunctionObject *) obj;
  	if (func->self != NULL || func->argv != NULL)
  	{
! 	    partial_T *pt = (partial_T *)alloc_clear(sizeof(partial_T));
  	    set_partial(func, pt, TRUE);
  	    tv->vval.v_partial = pt;
  	    tv->v_type = VAR_PARTIAL;
--- 6242,6249 ----
  	FunctionObject *func = (FunctionObject *) obj;
  	if (func->self != NULL || func->argv != NULL)
  	{
! 	    partial_T *pt = ALLOC_CLEAR_ONE(partial_T);
! 
  	    set_partial(func, pt, TRUE);
  	    tv->vval.v_partial = pt;
  	    tv->v_type = VAR_PARTIAL;
*** ../vim-8.1.1413/src/if_python3.c	2019-05-24 18:48:36.762128482 +0200
--- src/if_python3.c	2019-05-28 21:56:58.571496547 +0200
***************
*** 877,883 ****
  	    size_t len = mbstowcs(NULL, (char *)p_py3home, 0) + 1;
  
  	    /* The string must not change later, make a copy in static memory. */
! 	    py_home_buf = (wchar_t *)alloc(len * sizeof(wchar_t));
  	    if (py_home_buf != NULL && mbstowcs(
  			    py_home_buf, (char *)p_py3home, len) != (size_t)-1)
  		Py_SetPythonHome(py_home_buf);
--- 877,883 ----
  	    size_t len = mbstowcs(NULL, (char *)p_py3home, 0) + 1;
  
  	    /* The string must not change later, make a copy in static memory. */
! 	    py_home_buf = ALLOC_MULT(wchar_t, len);
  	    if (py_home_buf != NULL && mbstowcs(
  			    py_home_buf, (char *)p_py3home, len) != (size_t)-1)
  		Py_SetPythonHome(py_home_buf);
***************
*** 1629,1635 ****
      Py_ssize_t len = strlen(str);
      char *tmp,*p;
  
!     tmp = (char *)alloc(len + 1);
      p = tmp;
      if (p == NULL)
      {
--- 1629,1635 ----
      Py_ssize_t len = strlen(str);
      char *tmp,*p;
  
!     tmp = alloc(len + 1);
      p = tmp;
      if (p == NULL)
      {
*** ../vim-8.1.1413/src/if_xcmdsrv.c	2019-05-24 18:48:36.762128482 +0200
--- src/if_xcmdsrv.c	2019-05-28 20:23:31.818288567 +0200
***************
*** 441,447 ****
       * Length must be computed exactly!
       */
      length = STRLEN(name) + STRLEN(p_enc) + STRLEN(cmd) + 14;
!     property = (char_u *)alloc(length + 30);
  
      sprintf((char *)property, "%c%c%c-n %s%c-E %s%c-s %s",
  		      0, asExpr ? 'c' : 'k', 0, name, 0, p_enc, 0, cmd);
--- 441,447 ----
       * Length must be computed exactly!
       */
      length = STRLEN(name) + STRLEN(p_enc) + STRLEN(cmd) + 14;
!     property = alloc(length + 30);
  
      sprintf((char *)property, "%c%c%c-n %s%c-E %s%c-s %s",
  		      0, asExpr ? 'c' : 'k', 0, name, 0, p_enc, 0, cmd);
***************
*** 750,756 ****
  	return -1;
  
      length = STRLEN(p_enc) + STRLEN(str) + 14;
!     if ((property = (char_u *)alloc(length + 30)) != NULL)
      {
  	sprintf((char *)property, "%cn%c-E %s%c-n %s%c-w %x",
  			    0, 0, p_enc, 0, str, 0, (unsigned int)commWindow);
--- 750,756 ----
  	return -1;
  
      length = STRLEN(p_enc) + STRLEN(str) + 14;
!     if ((property = alloc(length + 30)) != NULL)
      {
  	sprintf((char *)property, "%cn%c-E %s%c-n %s%c-w %x",
  			    0, 0, p_enc, 0, str, 0, (unsigned int)commWindow);
***************
*** 1157,1163 ****
  {
      x_queue_T *node;
  
!     node = (x_queue_T *)alloc(sizeof(x_queue_T));
      if (node == NULL)
  	return;	    /* out of memory */
      node->propInfo = propInfo;
--- 1157,1163 ----
  {
      x_queue_T *node;
  
!     node = ALLOC_ONE(x_queue_T);
      if (node == NULL)
  	return;	    /* out of memory */
      node->propInfo = propInfo;
*** ../vim-8.1.1413/src/insexpand.c	2019-05-24 19:38:59.104545491 +0200
--- src/insexpand.c	2019-05-28 21:58:06.267173187 +0200
***************
*** 473,479 ****
  					   ? actual_len : actual_compl_length;
  
  	// Allocate wide character array for the completion and fill it.
! 	wca = (int *)alloc(actual_len * sizeof(int));
  	if (wca != NULL)
  	{
  	    p = str;
--- 473,479 ----
  					   ? actual_len : actual_compl_length;
  
  	// Allocate wide character array for the completion and fill it.
! 	wca = ALLOC_MULT(int, actual_len);
  	if (wca != NULL)
  	{
  	    p = str;
***************
*** 611,617 ****
  
      // Allocate a new match structure.
      // Copy the values to the new match structure.
!     match = (compl_T *)alloc_clear(sizeof(compl_T));
      if (match == NULL)
  	return FAIL;
      match->cp_number = -1;
--- 611,617 ----
  
      // Allocate a new match structure.
      // Copy the values to the new match structure.
!     match = ALLOC_CLEAR_ONE(compl_T);
      if (match == NULL)
  	return FAIL;
      match->cp_number = -1;
***************
*** 1070,1077 ****
  	} while (compl != NULL && compl != compl_first_match);
  	if (compl_match_arraysize == 0)
  	    return;
! 	compl_match_array = (pumitem_T *)alloc_clear(
! 				    sizeof(pumitem_T) * compl_match_arraysize);
  	if (compl_match_array != NULL)
  	{
  	    // If the current match is the original text don't find the first
--- 1070,1076 ----
  	} while (compl != NULL && compl != compl_first_match);
  	if (compl_match_arraysize == 0)
  	    return;
! 	compl_match_array = ALLOC_CLEAR_MULT(pumitem_T, compl_match_arraysize);
  	if (compl_match_array != NULL)
  	{
  	    // If the current match is the original text don't find the first
*** ../vim-8.1.1413/src/list.c	2019-05-25 20:21:24.677951017 +0200
--- src/list.c	2019-05-28 20:26:57.692947550 +0200
***************
*** 72,78 ****
  {
      list_T  *l;
  
!     l = (list_T *)alloc_clear(sizeof(list_T));
      if (l != NULL)
      {
  	/* Prepend the list to the list of lists for garbage collection. */
--- 72,78 ----
  {
      list_T  *l;
  
!     l = ALLOC_CLEAR_ONE(list_T);
      if (l != NULL)
      {
  	/* Prepend the list to the list of lists for garbage collection. */
***************
*** 244,250 ****
      listitem_T *
  listitem_alloc(void)
  {
!     return (listitem_T *)alloc(sizeof(listitem_T));
  }
  
  /*
--- 244,250 ----
      listitem_T *
  listitem_alloc(void)
  {
!     return ALLOC_ONE(listitem_T);
  }
  
  /*
*** ../vim-8.1.1413/src/mark.c	2019-05-09 15:12:45.172723940 +0200
--- src/mark.c	2019-05-28 21:59:00.450914373 +0200
***************
*** 1478,1488 ****
      void
  prepare_viminfo_marks(void)
  {
!     vi_namedfm = (xfmark_T *)alloc_clear((NMARKS + EXTRA_MARKS)
! 						     * (int)sizeof(xfmark_T));
  #ifdef FEAT_JUMPLIST
!     vi_jumplist = (xfmark_T *)alloc_clear(JUMPLISTSIZE
! 						     * (int)sizeof(xfmark_T));
      vi_jumplist_len = 0;
  #endif
  }
--- 1478,1486 ----
      void
  prepare_viminfo_marks(void)
  {
!     vi_namedfm = ALLOC_CLEAR_MULT(xfmark_T, NMARKS + EXTRA_MARKS);
  #ifdef FEAT_JUMPLIST
!     vi_jumplist = ALLOC_CLEAR_MULT(xfmark_T, JUMPLISTSIZE);
      vi_jumplist_len = 0;
  #endif
  }
*** ../vim-8.1.1413/src/mbyte.c	2019-05-24 18:48:36.766128461 +0200
--- src/mbyte.c	2019-05-28 20:32:06.715056498 +0200
***************
*** 6897,6903 ****
  		    return retval;
  		}
  	    }
! 	    tmp = (short_u *)alloc(sizeof(short_u) * tmp_len);
  	    if (tmp == NULL)
  		break;
  	    if (vcp->vc_cpfrom == 0)
--- 6897,6903 ----
  		    return retval;
  		}
  	    }
! 	    tmp = ALLOC_MULT(short_u, tmp_len);
  	    if (tmp == NULL)
  		break;
  	    if (vcp->vc_cpfrom == 0)
*** ../vim-8.1.1413/src/memfile.c	2019-05-27 23:36:17.456452208 +0200
--- src/memfile.c	2019-05-28 20:23:42.830214601 +0200
***************
*** 130,136 ****
      struct STATFS	stf;
  #endif
  
!     if ((mfp = (memfile_T *)alloc(sizeof(memfile_T))) == NULL)
  	return NULL;
  
      if (fname == NULL)	    /* no file for this memfile, use memory only */
--- 130,136 ----
      struct STATFS	stf;
  #endif
  
!     if ((mfp = ALLOC_ONE(memfile_T)) == NULL)
  	return NULL;
  
      if (fname == NULL)	    /* no file for this memfile, use memory only */
***************
*** 362,368 ****
  	}
  	else if (hp == NULL)	    /* need to allocate memory for this block */
  	{
! 	    if ((p = (char_u *)alloc(mfp->mf_page_size * page_count)) == NULL)
  		return NULL;
  	    hp = mf_rem_free(mfp);
  	    hp->bh_data = p;
--- 362,368 ----
  	}
  	else if (hp == NULL)	    /* need to allocate memory for this block */
  	{
! 	    if ((p = alloc(mfp->mf_page_size * page_count)) == NULL)
  		return NULL;
  	    hp = mf_rem_free(mfp);
  	    hp->bh_data = p;
***************
*** 893,902 ****
  {
      bhdr_T	*hp;
  
!     if ((hp = (bhdr_T *)alloc(sizeof(bhdr_T))) != NULL)
      {
! 	if ((hp->bh_data = (char_u *)alloc(mfp->mf_page_size * page_count))
! 								      == NULL)
  	{
  	    vim_free(hp);	    /* not enough memory */
  	    return NULL;
--- 893,901 ----
  {
      bhdr_T	*hp;
  
!     if ((hp = ALLOC_ONE(bhdr_T)) != NULL)
      {
! 	if ((hp->bh_data = alloc(mfp->mf_page_size * page_count)) == NULL)
  	{
  	    vim_free(hp);	    /* not enough memory */
  	    return NULL;
***************
*** 1131,1137 ****
      if (hp->bh_bnum >= 0)		    /* it's already positive */
  	return OK;
  
!     if ((np = (NR_TRANS *)alloc(sizeof(NR_TRANS))) == NULL)
  	return FAIL;
  
  /*
--- 1130,1136 ----
      if (hp->bh_bnum >= 0)		    /* it's already positive */
  	return OK;
  
!     if ((np = ALLOC_ONE(NR_TRANS)) == NULL)
  	return FAIL;
  
  /*
***************
*** 1460,1466 ****
      size_t	    size;
  
      size = (mht->mht_mask + 1) * MHT_GROWTH_FACTOR * sizeof(void *);
!     buckets = (mf_hashitem_T **)lalloc_clear(size, FALSE);
      if (buckets == NULL)
  	return FAIL;
  
--- 1459,1465 ----
      size_t	    size;
  
      size = (mht->mht_mask + 1) * MHT_GROWTH_FACTOR * sizeof(void *);
!     buckets = lalloc_clear(size, FALSE);
      if (buckets == NULL)
  	return FAIL;
  
*** ../vim-8.1.1413/src/memfile_test.c	2016-08-29 22:42:20.000000000 +0200
--- src/memfile_test.c	2019-05-28 22:00:20.166533407 +0200
***************
*** 67,73 ****
  	assert(mf_hash_find(&ht, key) == NULL);
  
  	/* allocate and add new item */
! 	item = (mf_hashitem_T *)lalloc_clear(sizeof(mf_hashtab_T), FALSE);
  	assert(item != NULL);
  	item->mhi_key = key;
  	mf_hash_add_item(&ht, item);
--- 67,73 ----
  	assert(mf_hash_find(&ht, key) == NULL);
  
  	/* allocate and add new item */
! 	item = LALLOC_CLEAR_ONE(mf_hashtab_T);
  	assert(item != NULL);
  	item->mhi_key = key;
  	mf_hash_add_item(&ht, item);
*** ../vim-8.1.1413/src/memline.c	2019-05-25 22:11:42.474849134 +0200
--- src/memline.c	2019-05-28 22:02:15.693937617 +0200
***************
*** 1189,1195 ****
       * Allocate a buffer structure for the swap file that is used for recovery.
       * Only the memline and crypt information in it are really used.
       */
!     buf = (buf_T *)alloc(sizeof(buf_T));
      if (buf == NULL)
  	goto theend;
  
--- 1189,1195 ----
       * Allocate a buffer structure for the swap file that is used for recovery.
       * Only the memline and crypt information in it are really used.
       */
!     buf = ALLOC_ONE(buf_T);
      if (buf == NULL)
  	goto theend;
  
***************
*** 1911,1919 ****
  			      );
  	    if (swapname != NULL)
  	    {
! 		if (mch_stat((char *)swapname, &st) != -1)	    /* It exists! */
  		{
! 		    files = (char_u **)alloc(sizeof(char_u *));
  		    if (files != NULL)
  		    {
  			files[0] = swapname;
--- 1911,1919 ----
  			      );
  	    if (swapname != NULL)
  	    {
! 		if (mch_stat((char *)swapname, &st) != -1)    // It exists!
  		{
! 		    files = ALLOC_ONE(char_u *);
  		    if (files != NULL)
  		    {
  			files[0] = swapname;
***************
*** 4205,4212 ****
      {
  	CHECK(top > 0, _("Stack size increases")); /* more than 5 levels??? */
  
! 	newstack = (infoptr_T *)alloc(sizeof(infoptr_T) *
! 					(buf->b_ml.ml_stack_size + STACK_INCR));
  	if (newstack == NULL)
  	    return -1;
  	if (top > 0)
--- 4205,4211 ----
      {
  	CHECK(top > 0, _("Stack size increases")); /* more than 5 levels??? */
  
! 	newstack = ALLOC_MULT(infoptr_T, buf->b_ml.ml_stack_size + STACK_INCR);
  	if (newstack == NULL)
  	    return -1;
  	if (top > 0)
***************
*** 5235,5241 ****
      if (state == NULL)
  	return data;
  
!     new_data = (char_u *)alloc(size);
      if (new_data == NULL)
  	return NULL;
      head_end = (char_u *)(&dp->db_index[dp->db_line_count]);
--- 5234,5240 ----
      if (state == NULL)
  	return data;
  
!     new_data = alloc(size);
      if (new_data == NULL)
  	return NULL;
      head_end = (char_u *)(&dp->db_index[dp->db_line_count]);
***************
*** 5375,5382 ****
  	return;
      if (buf->b_ml.ml_chunksize == NULL)
      {
! 	buf->b_ml.ml_chunksize =
! 			       (chunksize_T *)alloc(sizeof(chunksize_T) * 100);
  	if (buf->b_ml.ml_chunksize == NULL)
  	{
  	    buf->b_ml.ml_usedchunks = -1;
--- 5374,5380 ----
  	return;
      if (buf->b_ml.ml_chunksize == NULL)
      {
! 	buf->b_ml.ml_chunksize = ALLOC_MULT(chunksize_T, 100);
  	if (buf->b_ml.ml_chunksize == NULL)
  	{
  	    buf->b_ml.ml_usedchunks = -1;
*** ../vim-8.1.1413/src/message.c	2019-05-25 20:21:24.677951017 +0200
--- src/message.c	2019-05-28 22:12:22.190705459 +0200
***************
*** 875,881 ****
  	(void)delete_first_msg();
  
      /* allocate an entry and add the message at the end of the history */
!     p = (struct msg_hist *)alloc(sizeof(struct msg_hist));
      if (p != NULL)
      {
  	if (len < 0)
--- 875,881 ----
  	(void)delete_first_msg();
  
      /* allocate an entry and add the message at the end of the history */
!     p = ALLOC_ONE(struct msg_hist);
      if (p != NULL)
      {
  	if (len < 0)
***************
*** 2360,2366 ****
  
      if (s > *sb_str)
      {
! 	mp = (msgchunk_T *)alloc(sizeof(msgchunk_T) + (s - *sb_str));
  	if (mp != NULL)
  	{
  	    mp->sb_eol = finish;
--- 2360,2366 ----
  
      if (s > *sb_str)
      {
! 	mp = alloc(sizeof(msgchunk_T) + (s - *sb_str));
  	if (mp != NULL)
  	{
  	    mp->sb_eol = finish;
*** ../vim-8.1.1413/src/misc2.c	2019-05-25 20:21:24.677951017 +0200
--- src/misc2.c	2019-05-28 22:16:25.429471791 +0200
***************
*** 821,827 ****
   * The normal way to allocate memory.  This handles an out-of-memory situation
   * as well as possible, still returns NULL when we're completely out.
   */
!     char_u *
  alloc(size_t size)
  {
      return lalloc(size, TRUE);
--- 821,827 ----
   * The normal way to allocate memory.  This handles an out-of-memory situation
   * as well as possible, still returns NULL when we're completely out.
   */
!     void *
  alloc(size_t size)
  {
      return lalloc(size, TRUE);
***************
*** 830,836 ****
  /*
   * alloc() with an ID for alloc_fail().
   */
!     char_u *
  alloc_id(size_t size, alloc_id_T id UNUSED)
  {
  #ifdef FEAT_EVAL
--- 830,836 ----
  /*
   * alloc() with an ID for alloc_fail().
   */
!     void *
  alloc_id(size_t size, alloc_id_T id UNUSED)
  {
  #ifdef FEAT_EVAL
***************
*** 843,852 ****
  /*
   * Allocate memory and set all bytes to zero.
   */
!     char_u *
  alloc_clear(size_t size)
  {
!     char_u *p;
  
      p = lalloc(size, TRUE);
      if (p != NULL)
--- 843,852 ----
  /*
   * Allocate memory and set all bytes to zero.
   */
!     void *
  alloc_clear(size_t size)
  {
!     void *p;
  
      p = lalloc(size, TRUE);
      if (p != NULL)
***************
*** 857,863 ****
  /*
   * Same as alloc_clear() but with allocation id for testing
   */
!     char_u *
  alloc_clear_id(size_t size, alloc_id_T id UNUSED)
  {
  #ifdef FEAT_EVAL
--- 857,863 ----
  /*
   * Same as alloc_clear() but with allocation id for testing
   */
!     void *
  alloc_clear_id(size_t size, alloc_id_T id UNUSED)
  {
  #ifdef FEAT_EVAL
***************
*** 870,881 ****
  /*
   * Allocate memory like lalloc() and set all bytes to zero.
   */
!     char_u *
  lalloc_clear(size_t size, int message)
  {
!     char_u *p;
  
!     p = (lalloc(size, message));
      if (p != NULL)
  	(void)vim_memset(p, 0, size);
      return p;
--- 870,881 ----
  /*
   * Allocate memory like lalloc() and set all bytes to zero.
   */
!     void *
  lalloc_clear(size_t size, int message)
  {
!     void *p;
  
!     p = lalloc(size, message);
      if (p != NULL)
  	(void)vim_memset(p, 0, size);
      return p;
***************
*** 885,894 ****
   * Low level memory allocation function.
   * This is used often, KEEP IT FAST!
   */
!     char_u *
  lalloc(size_t size, int message)
  {
!     char_u	*p;		    /* pointer to new storage space */
      static int	releasing = FALSE;  /* don't do mf_release_all() recursive */
      int		try_again;
  #if defined(HAVE_AVAIL_MEM)
--- 885,894 ----
   * Low level memory allocation function.
   * This is used often, KEEP IT FAST!
   */
!     void *
  lalloc(size_t size, int message)
  {
!     void	*p;		    /* pointer to new storage space */
      static int	releasing = FALSE;  /* don't do mf_release_all() recursive */
      int		try_again;
  #if defined(HAVE_AVAIL_MEM)
***************
*** 921,927 ****
  	 *    allocating KEEP_ROOM amount of memory.
  	 * 3. Strict check for available memory: call mch_avail_mem()
  	 */
! 	if ((p = (char_u *)malloc(size)) != NULL)
  	{
  #ifndef HAVE_AVAIL_MEM
  	    /* 1. No check for available memory: Just return. */
--- 921,927 ----
  	 *    allocating KEEP_ROOM amount of memory.
  	 * 3. Strict check for available memory: call mch_avail_mem()
  	 */
! 	if ((p = malloc(size)) != NULL)
  	{
  #ifndef HAVE_AVAIL_MEM
  	    /* 1. No check for available memory: Just return. */
***************
*** 937,943 ****
  	    /* 3. check for available memory: call mch_avail_mem() */
  	    if (mch_avail_mem(TRUE) < KEEP_ROOM_KB && !releasing)
  	    {
! 		free((char *)p);	/* System is low... no go! */
  		p = NULL;
  	    }
  	    else
--- 937,943 ----
  	    /* 3. check for available memory: call mch_avail_mem() */
  	    if (mch_avail_mem(TRUE) < KEEP_ROOM_KB && !releasing)
  	    {
! 		free(p);	/* System is low... no go! */
  		p = NULL;
  	    }
  	    else
***************
*** 965,971 ****
  
  theend:
  #ifdef MEM_PROFILE
!     mem_post_alloc((void **)&p, size);
  #endif
      return p;
  }
--- 965,971 ----
  
  theend:
  #ifdef MEM_PROFILE
!     mem_post_alloc(&p, size);
  #endif
      return p;
  }
***************
*** 974,980 ****
   * lalloc() with an ID for alloc_fail().
   */
  #if defined(FEAT_SIGNS) || defined(PROTO)
!     char_u *
  lalloc_id(size_t size, int message, alloc_id_T id UNUSED)
  {
  #ifdef FEAT_EVAL
--- 974,980 ----
   * lalloc() with an ID for alloc_fail().
   */
  #if defined(FEAT_SIGNS) || defined(PROTO)
!     void *
  lalloc_id(size_t size, int message, alloc_id_T id UNUSED)
  {
  #ifdef FEAT_EVAL
***************
*** 2058,2065 ****
  	if (n < gap->ga_growsize)
  	    n = gap->ga_growsize;
  	new_len = gap->ga_itemsize * (gap->ga_len + n);
! 	pp = (gap->ga_data == NULL)
! 	      ? alloc(new_len) : vim_realloc(gap->ga_data, new_len);
  	if (pp == NULL)
  	    return FAIL;
  	old_len = gap->ga_itemsize * gap->ga_maxlen;
--- 2058,2064 ----
  	if (n < gap->ga_growsize)
  	    n = gap->ga_growsize;
  	new_len = gap->ga_itemsize * (gap->ga_len + n);
! 	pp = vim_realloc(gap->ga_data, new_len);
  	if (pp == NULL)
  	    return FAIL;
  	old_len = gap->ga_itemsize * gap->ga_maxlen;
***************
*** 4055,4061 ****
  	    if (moreenv() < 0)
  		return -1;
  	}
! 	p = (char *)alloc(strlen(string) + 1);
  	if (p == NULL)		/* not enough core */
  	    return -1;
  	environ[i + 1] = 0;	/* new end of env. */
--- 4054,4060 ----
  	    if (moreenv() < 0)
  		return -1;
  	}
! 	p = alloc(strlen(string) + 1);
  	if (p == NULL)		/* not enough core */
  	    return -1;
  	environ[i + 1] = 0;	/* new end of env. */
***************
*** 4103,4115 ****
  	;
  
      esize = i + EXTRASIZE + 1;
!     env = (char **)alloc(esize * sizeof (elem));
      if (env == NULL)
  	return -1;
  
      for (i = 0; environ[i]; i++)
      {
! 	elem = (char *)alloc(strlen(environ[i]) + 1);
  	if (elem == NULL)
  	    return -1;
  	env[i] = elem;
--- 4102,4114 ----
  	;
  
      esize = i + EXTRASIZE + 1;
!     env = ALLOC_MULT(char *, esize);
      if (env == NULL)
  	return -1;
  
      for (i = 0; environ[i]; i++)
      {
! 	elem = alloc(strlen(environ[i]) + 1);
  	if (elem == NULL)
  	    return -1;
  	env[i] = elem;
***************
*** 4129,4135 ****
      char    **env;
  
      esize = envsize + EXTRASIZE;
!     env = (char **)vim_realloc((char *)environ, esize * sizeof (*env));
      if (env == 0)
  	return -1;
      environ = env;
--- 4128,4134 ----
      char    **env;
  
      esize = envsize + EXTRASIZE;
!     env = vim_realloc((char *)environ, esize * sizeof (*env));
      if (env == 0)
  	return -1;
      environ = env;
***************
*** 4575,4581 ****
  		}
  	    }
  
! 	    *argv = (char **)alloc((*argc + 4) * sizeof(char *));
  	    if (*argv == NULL)	    /* out of memory */
  		return FAIL;
  	}
--- 4574,4580 ----
  		}
  	    }
  
! 	    *argv = ALLOC_MULT(char *, *argc + 4);
  	    if (*argv == NULL)	    /* out of memory */
  		return FAIL;
  	}
***************
*** 4622,4628 ****
      char_u	*s;
  
      /* Pass argv[] to mch_call_shell(). */
!     *argv = (char **)alloc(sizeof(char *) * (l->lv_len + 1));
      if (*argv == NULL)
  	return FAIL;
      *argc = 0;
--- 4621,4627 ----
      char_u	*s;
  
      /* Pass argv[] to mch_call_shell(). */
!     *argv = ALLOC_MULT(char *, l->lv_len + 1);
      if (*argv == NULL)
  	return FAIL;
      *argc = 0;
***************
*** 4667,4673 ****
      escaped_filename = vim_strsave_escaped(filename, escape_chars);
      if (escaped_filename == NULL)
  	return FALSE;
!     mksession_cmdline = (char *)alloc(10 + (int)STRLEN(escaped_filename) + 1);
      if (mksession_cmdline == NULL)
      {
  	vim_free(escaped_filename);
--- 4666,4672 ----
      escaped_filename = vim_strsave_escaped(filename, escape_chars);
      if (escaped_filename == NULL)
  	return FALSE;
!     mksession_cmdline = alloc(10 + (int)STRLEN(escaped_filename) + 1);
      if (mksession_cmdline == NULL)
      {
  	vim_free(escaped_filename);
*** ../vim-8.1.1413/src/netbeans.c	2019-05-24 19:38:59.104545491 +0200
--- src/netbeans.c	2019-05-28 22:18:03.568979260 +0200
***************
*** 321,327 ****
  {
      keyQ_T *node;
  
!     node = (keyQ_T *)alloc(sizeof(keyQ_T));
      if (node == NULL)
  	return;  /* out of memory, drop the key */
  
--- 321,327 ----
  {
      keyQ_T *node;
  
!     node = ALLOC_ONE(keyQ_T);
      if (node == NULL)
  	return;  /* out of memory, drop the key */
  
***************
*** 667,673 ****
      if (!buf_list)
      {
  	/* initialize */
! 	buf_list = (nbbuf_T *)alloc_clear(100 * sizeof(nbbuf_T));
  	buf_list_size = 100;
      }
      if (bufno >= buf_list_used) /* new */
--- 667,673 ----
      if (!buf_list)
      {
  	/* initialize */
! 	buf_list = alloc_clear(100 * sizeof(nbbuf_T));
  	buf_list_size = 100;
      }
      if (bufno >= buf_list_used) /* new */
***************
*** 678,685 ****
  
  	    incr = bufno - buf_list_size + 90;
  	    buf_list_size += incr;
! 	    buf_list = (nbbuf_T *)vim_realloc(
! 				   buf_list, buf_list_size * sizeof(nbbuf_T));
  	    if (buf_list == NULL)
  	    {
  		vim_free(t_buf_list);
--- 678,684 ----
  
  	    incr = bufno - buf_list_size + 90;
  	    buf_list_size += incr;
! 	    buf_list = vim_realloc(buf_list, buf_list_size * sizeof(nbbuf_T));
  	    if (buf_list == NULL)
  	    {
  		vim_free(t_buf_list);
***************
*** 863,869 ****
      int done = 0;
  
      /* result is never longer than input */
!     result = (char *)alloc_clear(STRLEN(p) + 1);
      if (result == NULL)
  	return NULL;
  
--- 862,868 ----
      int done = 0;
  
      /* result is never longer than input */
!     result = alloc_clear(STRLEN(p) + 1);
      if (result == NULL)
  	return NULL;
  
***************
*** 2470,2476 ****
  	 * length. */
  	if (text != NULL && text[0] != NUL && STRLEN(text) < MAXPATHL)
  	{
! 	    buf = (char *)alloc(MAXPATHL * 2 + 25);
  	    if (buf != NULL)
  	    {
  		p = nb_quote(text);
--- 2469,2475 ----
  	 * length. */
  	if (text != NULL && text[0] != NUL && STRLEN(text) < MAXPATHL)
  	{
! 	    buf = alloc(MAXPATHL * 2 + 25);
  	    if (buf != NULL)
  	    {
  		p = nb_quote(text);
***************
*** 3210,3217 ****
  	    if (globalsignmaplen == 0) /* first allocation */
  	    {
  		globalsignmaplen = 20;
! 		globalsignmap = (char **)alloc_clear(
! 					    globalsignmaplen * sizeof(char *));
  	    }
  	    else    /* grow it */
  	    {
--- 3209,3215 ----
  	    if (globalsignmaplen == 0) /* first allocation */
  	    {
  		globalsignmaplen = 20;
! 		globalsignmap = ALLOC_CLEAR_MULT(char *, globalsignmaplen);
  	    }
  	    else    /* grow it */
  	    {
***************
*** 3221,3227 ****
  
  		globalsignmaplen *= 2;
  		incr = globalsignmaplen - oldlen;
! 		globalsignmap = (char **)vim_realloc(globalsignmap,
  					   globalsignmaplen * sizeof(char *));
  		if (globalsignmap == NULL)
  		{
--- 3219,3225 ----
  
  		globalsignmaplen *= 2;
  		incr = globalsignmaplen - oldlen;
! 		globalsignmap = vim_realloc(globalsignmap,
  					   globalsignmaplen * sizeof(char *));
  		if (globalsignmap == NULL)
  		{
***************
*** 3248,3254 ****
  	if (buf->signmaplen == 0) /* first allocation */
  	{
  	    buf->signmaplen = 5;
! 	    buf->signmap = (int *)alloc_clear(buf->signmaplen * sizeof(int));
  	}
  	else    /* grow it */
  	{
--- 3246,3252 ----
  	if (buf->signmaplen == 0) /* first allocation */
  	{
  	    buf->signmaplen = 5;
! 	    buf->signmap = ALLOC_CLEAR_MULT(int, buf->signmaplen);
  	}
  	else    /* grow it */
  	{
***************
*** 3258,3264 ****
  
  	    buf->signmaplen *= 2;
  	    incr = buf->signmaplen - oldlen;
! 	    buf->signmap = (int *)vim_realloc(buf->signmap,
  					       buf->signmaplen * sizeof(int));
  	    if (buf->signmap == NULL)
  	    {
--- 3256,3262 ----
  
  	    buf->signmaplen *= 2;
  	    incr = buf->signmaplen - oldlen;
! 	    buf->signmap = vim_realloc(buf->signmap,
  					       buf->signmaplen * sizeof(int));
  	    if (buf->signmap == NULL)
  	    {
*** ../vim-8.1.1413/src/normal.c	2019-05-23 23:27:29.781416583 +0200
--- src/normal.c	2019-05-28 20:12:03.770451332 +0200
***************
*** 5655,5661 ****
  	    vim_free(buf);
  	    return;
  	}
! 	newbuf = (char_u *)vim_realloc(buf, STRLEN(buf) + STRLEN(p) + 1);
  	if (newbuf == NULL)
  	{
  	    vim_free(buf);
--- 5655,5661 ----
  	    vim_free(buf);
  	    return;
  	}
! 	newbuf = vim_realloc(buf, STRLEN(buf) + STRLEN(p) + 1);
  	if (newbuf == NULL)
  	{
  	    vim_free(buf);
*** ../vim-8.1.1413/src/ops.c	2019-05-25 20:21:24.677951017 +0200
--- src/ops.c	2019-05-28 22:23:15.311427600 +0200
***************
*** 1003,1009 ****
  #endif
  
      get_yank_register(name, 0);
!     reg = (yankreg_T *)alloc(sizeof(yankreg_T));
      if (reg != NULL)
      {
  	*reg = *y_current;
--- 1003,1009 ----
  #endif
  
      get_yank_register(name, 0);
!     reg = ALLOC_ONE(yankreg_T);
      if (reg != NULL)
      {
  	*reg = *y_current;
***************
*** 1013,1019 ****
  	    if (reg->y_size == 0)
  		reg->y_array = NULL;
  	    else
! 		reg->y_array = (char_u **)alloc(sizeof(char_u *) * reg->y_size);
  	    if (reg->y_array != NULL)
  	    {
  		for (i = 0; i < reg->y_size; ++i)
--- 1013,1019 ----
  	    if (reg->y_size == 0)
  		reg->y_array = NULL;
  	    else
! 		reg->y_array = ALLOC_MULT(char_u *, reg->y_size);
  	    if (reg->y_array != NULL)
  	    {
  		for (i = 0; i < reg->y_size; ++i)
***************
*** 1175,1182 ****
      else
      {
  	free_yank_all();
! 	if ((y_current->y_array =
! 			(char_u **)alloc(sizeof(char_u *))) == NULL)
  	{
  	    vim_free(p);
  	    return FAIL;
--- 1175,1181 ----
      else
      {
  	free_yank_all();
! 	if ((y_current->y_array = ALLOC_ONE(char_u *)) == NULL)
  	{
  	    vim_free(p);
  	    return FAIL;
***************
*** 3057,3064 ****
      y_current->y_size = yanklines;
      y_current->y_type = yanktype;   /* set the yank register type */
      y_current->y_width = 0;
!     y_current->y_array = (char_u **)lalloc_clear(sizeof(char_u *) * yanklines,
! 									 TRUE);
      if (y_current->y_array == NULL)
      {
  	y_current = curr;
--- 3056,3062 ----
      y_current->y_size = yanklines;
      y_current->y_type = yanktype;   /* set the yank register type */
      y_current->y_width = 0;
!     y_current->y_array = lalloc_clear(sizeof(char_u *) * yanklines, TRUE);
      if (y_current->y_array == NULL)
      {
  	y_current = curr;
***************
*** 3171,3178 ****
  
      if (curr != y_current)	/* append the new block to the old block */
      {
! 	new_ptr = (char_u **)alloc(sizeof(char_u *) *
! 					   (curr->y_size + y_current->y_size));
  	if (new_ptr == NULL)
  	    goto fail;
  	for (j = 0; j < curr->y_size; ++j)
--- 3169,3175 ----
  
      if (curr != y_current)	/* append the new block to the old block */
      {
! 	new_ptr = ALLOC_MULT(char_u *, curr->y_size + y_current->y_size);
  	if (new_ptr == NULL)
  	    goto fail;
  	for (j = 0; j < curr->y_size; ++j)
***************
*** 3354,3360 ****
      y_current = reg;
      free_yank_all();
      *y_current = *curr;
!     y_current->y_array = (char_u **)lalloc_clear(
  				    sizeof(char_u *) * y_current->y_size, TRUE);
      if (y_current->y_array == NULL)
  	y_current->y_size = 0;
--- 3351,3357 ----
      y_current = reg;
      free_yank_all();
      *y_current = *curr;
!     y_current->y_array = lalloc_clear(
  				    sizeof(char_u *) * y_current->y_size, TRUE);
      if (y_current->y_array == NULL)
  	y_current->y_size = 0;
***************
*** 3491,3497 ****
  		}
  		if (y_array != NULL)
  		    break;
! 		y_array = (char_u **)alloc((y_size * sizeof(char_u *)));
  		if (y_array == NULL)
  		    goto end;
  	    }
--- 3488,3494 ----
  		}
  		if (y_array != NULL)
  		    break;
! 		y_array = ALLOC_MULT(char_u *, y_size);
  		if (y_array == NULL)
  		    goto end;
  	    }
***************
*** 4459,4465 ****
  #if defined(FEAT_COMMENTS) || defined(PROTO)
      if (remove_comments)
      {
! 	comments = (int *)lalloc_clear(count * sizeof(int), TRUE);
  	if (comments == NULL)
  	{
  	    vim_free(spaces);
--- 4456,4462 ----
  #if defined(FEAT_COMMENTS) || defined(PROTO)
      if (remove_comments)
      {
! 	comments = lalloc_clear(count * sizeof(int), TRUE);
  	if (comments == NULL)
  	{
  	    vim_free(spaces);
***************
*** 4570,4578 ****
      {
  	// Allocate an array to copy the text properties of joined lines into.
  	// And another array to store the number of properties in each line.
! 	prop_lines = (textprop_T **)alloc_clear(
! 					   (count - 1) * sizeof(textprop_T *));
! 	prop_lengths = (int *)alloc_clear((count - 1) * sizeof(int));
  	if (prop_lengths == NULL)
  	    VIM_CLEAR(prop_lines);
      }
--- 4567,4574 ----
      {
  	// Allocate an array to copy the text properties of joined lines into.
  	// And another array to store the number of properties in each line.
! 	prop_lines = ALLOC_CLEAR_MULT(textprop_T *, count - 1);
! 	prop_lengths = ALLOC_CLEAR_MULT(int, count - 1);
  	if (prop_lengths == NULL)
  	    VIM_CLEAR(prop_lines);
      }
***************
*** 5975,5982 ****
      void
  prepare_viminfo_registers(void)
  {
!      y_read_regs = (yankreg_T *)alloc_clear(NUM_REGISTERS
! 						    * (int)sizeof(yankreg_T));
  }
  
      void
--- 5971,5977 ----
      void
  prepare_viminfo_registers(void)
  {
!      y_read_regs = ALLOC_CLEAR_MULT(yankreg_T, NUM_REGISTERS);
  }
  
      void
***************
*** 6051,6057 ****
  	 */
  	if (set_prev)
  	    y_previous = y_current;
! 	array = (char_u **)alloc(limit * sizeof(char_u *));
  	str = skipwhite(skiptowhite(str));
  	if (STRNCMP(str, "CHAR", 4) == 0)
  	    new_type = MCHAR;
--- 6046,6052 ----
  	 */
  	if (set_prev)
  	    y_previous = y_current;
! 	array = ALLOC_MULT(char_u *, limit);
  	str = skipwhite(skiptowhite(str));
  	if (STRNCMP(str, "CHAR", 4) == 0)
  	    new_type = MCHAR;
***************
*** 6112,6118 ****
  	else
  	{
  	    /* Move the lines from array[] to y_array[]. */
! 	    y_current->y_array = (char_u **)alloc(size * sizeof(char_u *));
  	    for (i = 0; i < size; i++)
  	    {
  		if (y_current->y_array == NULL)
--- 6107,6113 ----
  	else
  	{
  	    /* Move the lines from array[] to y_array[]. */
! 	    y_current->y_array = ALLOC_MULT(char_u *, size);
  	    for (i = 0; i < size; i++)
  	    {
  		if (y_current->y_array == NULL)
***************
*** 6209,6215 ****
  	y_ptr->y_array = NULL;
  	return;
      }
!     y_ptr->y_array = (char_u **)alloc(linecount * sizeof(char_u *));
      if (y_ptr->y_array == NULL)
      {
  	y_ptr->y_size = 0; // ensure object state is consistent
--- 6204,6210 ----
  	y_ptr->y_array = NULL;
  	return;
      }
!     y_ptr->y_array = ALLOC_MULT(char_u *, linecount);
      if (y_ptr->y_array == NULL)
      {
  	y_ptr->y_size = 0; // ensure object state is consistent
***************
*** 7100,7107 ****
       * Allocate an array to hold the pointers to the new register lines.
       * If the register was not empty, move the existing lines to the new array.
       */
!     pp = (char_u **)lalloc_clear((y_ptr->y_size + newlines)
! 						    * sizeof(char_u *), TRUE);
      if (pp == NULL)	/* out of memory */
  	return;
      for (lnum = 0; lnum < y_ptr->y_size; ++lnum)
--- 7095,7101 ----
       * Allocate an array to hold the pointers to the new register lines.
       * If the register was not empty, move the existing lines to the new array.
       */
!     pp = lalloc_clear((y_ptr->y_size + newlines) * sizeof(char_u *), TRUE);
      if (pp == NULL)	/* out of memory */
  	return;
      for (lnum = 0; lnum < y_ptr->y_size; ++lnum)
*** ../vim-8.1.1413/src/option.c	2019-05-26 21:03:19.936073948 +0200
--- src/option.c	2019-05-28 22:26:04.090593262 +0200
***************
*** 7966,7972 ****
  	wp->w_p_cc_cols = NULL;
      else
      {
! 	wp->w_p_cc_cols = (int *)alloc(sizeof(int) * (count + 1));
  	if (wp->w_p_cc_cols != NULL)
  	{
  	    /* sort the columns for faster usage on screen redraw inside
--- 7966,7972 ----
  	wp->w_p_cc_cols = NULL;
      else
      {
! 	wp->w_p_cc_cols = ALLOC_MULT(int, count + 1);
  	if (wp->w_p_cc_cols != NULL)
  	{
  	    /* sort the columns for faster usage on screen redraw inside
***************
*** 10106,10113 ****
  #define INC 20
  #define GAP 3
  
!     items = (struct vimoption **)alloc(sizeof(struct vimoption *)
! 								* PARAM_COUNT);
      if (items == NULL)
  	return;
  
--- 10106,10112 ----
  #define INC 20
  #define GAP 3
  
!     items = ALLOC_MULT(struct vimoption *, PARAM_COUNT);
      if (items == NULL)
  	return;
  
***************
*** 11998,12004 ****
  		*num_file = num_term;
  	    else
  		return OK;
! 	    *file = (char_u **)alloc(*num_file * sizeof(char_u *));
  	    if (*file == NULL)
  	    {
  		*file = (char_u **)"";
--- 11997,12003 ----
  		*num_file = num_term;
  	    else
  		return OK;
! 	    *file = ALLOC_MULT(char_u *, *num_file);
  	    if (*file == NULL)
  	    {
  		*file = (char_u **)"";
***************
*** 12016,12022 ****
      char_u  *buf;
  
      *num_file = 0;
!     *file = (char_u **)alloc(sizeof(char_u *));
      if (*file == NULL)
  	return FAIL;
  
--- 12015,12021 ----
      char_u  *buf;
  
      *num_file = 0;
!     *file = ALLOC_ONE(char_u *);
      if (*file == NULL)
  	return FAIL;
  
***************
*** 12879,12885 ****
  	return FALSE;
      }
  
!     *array = (int *)alloc((valcount + 1) * sizeof(int));
      if (*array == NULL)
  	return FALSE;
      (*array)[0] = valcount;
--- 12878,12884 ----
  	return FALSE;
      }
  
!     *array = ALLOC_MULT(int, valcount + 1);
      if (*array == NULL)
  	return FALSE;
      (*array)[0] = valcount;
***************
*** 13102,13108 ****
  
      if (oldts == NULL)
  	return NULL;
!     newts = (int *)alloc((oldts[0] + 1) * sizeof(int));
      if (newts != NULL)
  	for (t = 0; t <= oldts[0]; ++t)
  	    newts[t] = oldts[t];
--- 13101,13107 ----
  
      if (oldts == NULL)
  	return NULL;
!     newts = ALLOC_MULT(int, oldts[0] + 1);
      if (newts != NULL)
  	for (t = 0; t <= oldts[0]; ++t)
  	    newts[t] = oldts[t];
*** ../vim-8.1.1413/src/os_amiga.c	2019-05-24 19:38:59.104545491 +0200
--- src/os_amiga.c	2019-05-28 22:26:26.486482784 +0200
***************
*** 580,586 ****
  #ifdef __amigaos4__
      fib = AllocDosObject(DOS_FIB,0);
  #else
!     fib = (struct FileInfoBlock *)alloc(sizeof(struct FileInfoBlock));
  #endif
      if (fib != NULL)
      {
--- 580,586 ----
  #ifdef __amigaos4__
      fib = AllocDosObject(DOS_FIB,0);
  #else
!     fib = ALLOC_ONE(struct FileInfoBlock);
  #endif
      if (fib != NULL)
      {
***************
*** 1448,1454 ****
  #ifdef __amigaos4__
      Anchor = AllocDosObject(DOS_ANCHORPATH, AnchorTags);
  #else
!     Anchor = (struct AnchorPath *)alloc_clear(ANCHOR_SIZE);
  #endif
      if (Anchor == NULL)
  	return 0;
--- 1448,1454 ----
  #ifdef __amigaos4__
      Anchor = AllocDosObject(DOS_ANCHORPATH, AnchorTags);
  #else
!     Anchor = alloc_clear(ANCHOR_SIZE);
  #endif
      if (Anchor == NULL)
  	return 0;
*** ../vim-8.1.1413/src/os_mac_conv.c	2018-02-10 18:34:22.000000000 +0100
--- src/os_mac_conv.c	2019-05-28 22:27:05.854288701 +0200
***************
*** 550,556 ****
      }
  
      convertRange = CFRangeMake(0, CFStringGetLength(utf8_str));
!     result = (UniChar *)alloc(convertRange.length * sizeof(UniChar));
  
      CFStringGetCharacters(utf8_str, convertRange, result);
  
--- 550,556 ----
      }
  
      convertRange = CFRangeMake(0, CFStringGetLength(utf8_str));
!     result = ALLOC_MULT(UniChar, convertRange.length);
  
      CFStringGetCharacters(utf8_str, convertRange, result);
  
*** ../vim-8.1.1413/src/os_mswin.c	2019-05-24 19:38:59.104545491 +0200
--- src/os_mswin.c	2019-05-28 22:27:50.390069279 +0200
***************
*** 1801,1807 ****
  	goto fail;
  
      size = sizeof(FILE_NAME_INFO_) + sizeof(WCHAR) * (MAX_PATH - 1);
!     nameinfo = (FILE_NAME_INFO_*)alloc(size + sizeof(WCHAR));
      if (nameinfo == NULL)
  	goto fail;
  
--- 1801,1807 ----
  	goto fail;
  
      size = sizeof(FILE_NAME_INFO_) + sizeof(WCHAR) * (MAX_PATH - 1);
!     nameinfo = alloc(size + sizeof(WCHAR));
      if (nameinfo == NULL)
  	goto fail;
  
***************
*** 1835,1841 ****
  	    GetLastError() != ERROR_MORE_DATA)
  	goto fail;
  
!     volnames = (WCHAR*)alloc(size * sizeof(WCHAR));
      if (!GetVolumePathNamesForVolumeNameW(buff, volnames, size,
  		&size))
  	goto fail;
--- 1835,1841 ----
  	    GetLastError() != ERROR_MORE_DATA)
  	goto fail;
  
!     volnames = ALLOC_MULT(WCHAR, size);
      if (!GetVolumePathNamesForVolumeNameW(buff, volnames, size,
  		&size))
  	goto fail;
***************
*** 3078,3084 ****
      if (ret == OK && printer_dc == NULL)
      {
  	vim_free(lastlf);
! 	lastlf = (LOGFONTW *)alloc(sizeof(LOGFONTW));
  	if (lastlf != NULL)
  	    mch_memmove(lastlf, lf, sizeof(LOGFONTW));
      }
--- 3078,3084 ----
      if (ret == OK && printer_dc == NULL)
      {
  	vim_free(lastlf);
! 	lastlf = ALLOC_ONE(LOGFONTW);
  	if (lastlf != NULL)
  	    mch_memmove(lastlf, lf, sizeof(LOGFONTW));
      }
*** ../vim-8.1.1413/src/os_unix.c	2019-05-24 19:38:59.108545464 +0200
--- src/os_unix.c	2019-05-28 22:28:51.501768391 +0200
***************
*** 3210,3216 ****
       * Ignore any errors.
       */
  #if defined(HAVE_SIGALTSTACK) || defined(HAVE_SIGSTACK)
!     signal_stack = (char *)alloc(SIGSTKSZ);
      init_signal_stack();
  #endif
  }
--- 3210,3216 ----
       * Ignore any errors.
       */
  #if defined(HAVE_SIGALTSTACK) || defined(HAVE_SIGSTACK)
!     signal_stack = alloc(SIGSTKSZ);
      init_signal_stack();
  #endif
  }
***************
*** 6843,6849 ****
  	goto notfound;
      }
      *num_file = i;
!     *file = (char_u **)alloc(sizeof(char_u *) * i);
      if (*file == NULL)
      {
  	/* out of memory */
--- 6843,6849 ----
  	goto notfound;
      }
      *num_file = i;
!     *file = ALLOC_MULT(char_u *, i);
      if (*file == NULL)
      {
  	/* out of memory */
***************
*** 6938,6944 ****
      int		i;
      char_u	*s;
  
!     *file = (char_u **)alloc(num_pat * sizeof(char_u *));
      if (*file == NULL)
  	return FAIL;
      for (i = 0; i < num_pat; i++)
--- 6938,6944 ----
      int		i;
      char_u	*s;
  
!     *file = ALLOC_MULT(char_u *, num_pat);
      if (*file == NULL)
  	return FAIL;
      for (i = 0; i < num_pat; i++)
*** ../vim-8.1.1413/src/os_vms.c	2019-05-25 20:21:24.677951017 +0200
--- src/os_vms.c	2019-05-28 22:30:43.309218541 +0200
***************
*** 238,251 ****
      if (sys$trnlnm(&attrib, &d_file_dev, &d_lognam, NULL,&itmlst) == SS$_NORMAL)
      {
  	buffer[lengte] = '\0';
! 	if (cp = (char_u *)alloc(lengte + 1))
  	    strcpy((char *)cp, buffer);
  	return(cp);
      }
      else if ((sbuf = getenv((char *)lognam)))
      {
  	lengte = strlen(sbuf) + 1;
! 	cp = (char_u *)alloc(lengte);
  	if (cp)
  	    strcpy((char *)cp, sbuf);
  	return cp;
--- 238,251 ----
      if (sys$trnlnm(&attrib, &d_file_dev, &d_lognam, NULL,&itmlst) == SS$_NORMAL)
      {
  	buffer[lengte] = '\0';
! 	if (cp = alloc(lengte + 1))
  	    strcpy((char *)cp, buffer);
  	return(cp);
      }
      else if ((sbuf = getenv((char *)lognam)))
      {
  	lengte = strlen(sbuf) + 1;
! 	cp = alloc(lengte);
  	if (cp)
  	    strcpy((char *)cp, sbuf);
  	return cp;
***************
*** 382,388 ****
      if (vms_match_num == 0) {
  	/* first time through, setup some things */
  	if (NULL == vms_fmatch) {
! 	    vms_fmatch = (char_u **)alloc(EXPL_ALLOC_INC * sizeof(char *));
  	    if (!vms_fmatch)
  		return 0;
  	    vms_match_alloced = EXPL_ALLOC_INC;
--- 382,388 ----
      if (vms_match_num == 0) {
  	/* first time through, setup some things */
  	if (NULL == vms_fmatch) {
! 	    vms_fmatch = ALLOC_MULT(char *, EXPL_ALLOC_INC);
  	    if (!vms_fmatch)
  		return 0;
  	    vms_match_alloced = EXPL_ALLOC_INC;
***************
*** 406,412 ****
      if (--vms_match_free == 0) {
  	/* add more space to store matches */
  	vms_match_alloced += EXPL_ALLOC_INC;
! 	vms_fmatch = (char_u **)vim_realloc(vms_fmatch,
  		sizeof(char **) * vms_match_alloced);
  	if (!vms_fmatch)
  	    return 0;
--- 406,412 ----
      if (--vms_match_free == 0) {
  	/* add more space to store matches */
  	vms_match_alloced += EXPL_ALLOC_INC;
! 	vms_fmatch = vim_realloc(vms_fmatch,
  		sizeof(char **) * vms_match_alloced);
  	if (!vms_fmatch)
  	    return 0;
***************
*** 443,449 ****
      *num_file = 0;			/* default: no files found	*/
      files_alloced = EXPL_ALLOC_INC;
      files_free = EXPL_ALLOC_INC;
!     *file = (char_u **) alloc(sizeof(char_u **) * files_alloced);
      if (*file == NULL)
      {
  	*num_file = 0;
--- 443,449 ----
      *num_file = 0;			/* default: no files found	*/
      files_alloced = EXPL_ALLOC_INC;
      files_free = EXPL_ALLOC_INC;
!     *file = ALLOC_MULT(char_u **, files_alloced);
      if (*file == NULL)
      {
  	*num_file = 0;
***************
*** 490,497 ****
  	    if (--files_free < 1)
  	    {
  		files_alloced += EXPL_ALLOC_INC;
! 		*file = (char_u **)vim_realloc(*file,
! 		    sizeof(char_u **) * files_alloced);
  		if (*file == NULL)
  		{
  		    *file = (char_u **)"";
--- 490,496 ----
  	    if (--files_free < 1)
  	    {
  		files_alloced += EXPL_ALLOC_INC;
! 		*file = vim_realloc(*file, sizeof(char_u **) * files_alloced);
  		if (*file == NULL)
  		{
  		    *file = (char_u **)"";
***************
*** 649,663 ****
      if (len > buflen)
      {
  	buflen = len + 128;
! 	if (buf)
! 	    buf = (char *)vim_realloc(buf, buflen);
! 	else
! 	    buf = (char *)alloc(buflen * sizeof(char));
      }
  
  #ifdef DEBUG
       char		 *tmpbuf = NULL;
!      tmpbuf = (char *)alloc(buflen * sizeof(char));
       strcpy(tmpbuf, instring);
  #endif
  
--- 648,659 ----
      if (len > buflen)
      {
  	buflen = len + 128;
! 	buf = vim_realloc(buf, buflen * sizeof(char));
      }
  
  #ifdef DEBUG
       char		 *tmpbuf = NULL;
!      tmpbuf = ALLOC_MULT(char, buflen);
       strcpy(tmpbuf, instring);
  #endif
  
*** ../vim-8.1.1413/src/os_win32.c	2019-05-25 20:21:24.681950994 +0200
--- src/os_win32.c	2019-05-28 22:33:23.000434245 +0200
***************
*** 2075,2081 ****
  	return FALSE;
  
      wcurpath = _wgetenv(L"PATH");
!     wnewpath = (WCHAR *)alloc((wcslen(wcurpath) + 3) * sizeof(WCHAR));
      if (wnewpath == NULL)
  	return FALSE;
      wcscpy(wnewpath, L".;");
--- 2075,2081 ----
  	return FALSE;
  
      wcurpath = _wgetenv(L"PATH");
!     wnewpath = ALLOC_MULT(WCHAR, wcslen(wcurpath) + 3);
      if (wnewpath == NULL)
  	return FALSE;
      wcscpy(wnewpath, L".;");
***************
*** 2338,2344 ****
  	cb->BufferSize.Y = cb->Info.dwSize.Y;
  	NumCells = cb->BufferSize.X * cb->BufferSize.Y;
  	vim_free(cb->Buffer);
! 	cb->Buffer = (PCHAR_INFO)alloc(NumCells * sizeof(CHAR_INFO));
  	if (cb->Buffer == NULL)
  	    return FALSE;
      }
--- 2338,2344 ----
  	cb->BufferSize.Y = cb->Info.dwSize.Y;
  	NumCells = cb->BufferSize.X * cb->BufferSize.Y;
  	vim_free(cb->Buffer);
! 	cb->Buffer = ALLOC_MULT(CHAR_INFO, NumCells);
  	if (cb->Buffer == NULL)
  	    return FALSE;
      }
***************
*** 2362,2368 ****
      {
  	cb->NumRegions = numregions;
  	vim_free(cb->Regions);
! 	cb->Regions = (PSMALL_RECT)alloc(cb->NumRegions * sizeof(SMALL_RECT));
  	if (cb->Regions == NULL)
  	{
  	    VIM_CLEAR(cb->Buffer);
--- 2362,2368 ----
      {
  	cb->NumRegions = numregions;
  	vim_free(cb->Regions);
! 	cb->Regions = ALLOC_MULT(SMALL_RECT, cb->NumRegions);
  	if (cb->Regions == NULL)
  	{
  	    VIM_CLEAR(cb->Buffer);
***************
*** 3394,3400 ****
      struct my_acl   *p = NULL;
      DWORD   err;
  
!     p = (struct my_acl *)alloc_clear(sizeof(struct my_acl));
      if (p != NULL)
      {
  	WCHAR	*wn;
--- 3394,3400 ----
      struct my_acl   *p = NULL;
      DWORD   err;
  
!     p = ALLOC_CLEAR_ONE(struct my_acl);
      if (p != NULL)
      {
  	WCHAR	*wn;
***************
*** 5952,5958 ****
      WORD    attrFlash = ~g_attrCurrent & 0xff;
  
      DWORD   dwDummy;
!     LPWORD  oldattrs = (LPWORD)alloc(Rows * Columns * sizeof(WORD));
  
      if (oldattrs == NULL)
  	return;
--- 5952,5958 ----
      WORD    attrFlash = ~g_attrCurrent & 0xff;
  
      DWORD   dwDummy;
!     LPWORD  oldattrs = ALLOC_MULT(WORD, Rows * Columns);
  
      if (oldattrs == NULL)
  	return;
***************
*** 6003,6009 ****
      if (unicodebuf == NULL || length > unibuflen)
      {
  	vim_free(unicodebuf);
! 	unicodebuf = (WCHAR *)lalloc(length * sizeof(WCHAR), FALSE);
  	unibuflen = length;
      }
      MultiByteToWideChar(cp, 0, (LPCSTR)pchBuf, cbToWrite,
--- 6003,6009 ----
      if (unicodebuf == NULL || length > unibuflen)
      {
  	vim_free(unicodebuf);
! 	unicodebuf = LALLOC_MULT(WCHAR, length);
  	unibuflen = length;
      }
      MultiByteToWideChar(cp, 0, (LPCSTR)pchBuf, cbToWrite,
***************
*** 7117,7123 ****
  	return;
  
      /* Remember the buffer numbers for the arguments. */
!     fnum_list = (int *)alloc(sizeof(int) * GARGCOUNT);
      if (fnum_list == NULL)
  	return;		/* out of memory */
      for (i = 0; i < GARGCOUNT; ++i)
--- 7117,7123 ----
  	return;
  
      /* Remember the buffer numbers for the arguments. */
!     fnum_list = ALLOC_MULT(int, GARGCOUNT);
      if (fnum_list == NULL)
  	return;		/* out of memory */
      for (i = 0; i < GARGCOUNT; ++i)
*** ../vim-8.1.1413/src/popupmnu.c	2019-05-24 19:38:59.108545464 +0200
--- src/popupmnu.c	2019-05-28 20:34:46.830113475 +0200
***************
*** 1071,1077 ****
       * position. */
      if (height > max_height)
  	height = max_height;
!     *array = (pumitem_T *)alloc_clear(sizeof(pumitem_T) * height);
      if (*array == NULL)
  	goto failed;
  
--- 1071,1077 ----
       * position. */
      if (height > max_height)
  	height = max_height;
!     *array = ALLOC_CLEAR_MULT(pumitem_T, height);
      if (*array == NULL)
  	goto failed;
  
***************
*** 1164,1171 ****
  	int	    idx;
  
  	balloon_arraysize = list->lv_len;
! 	balloon_array = (pumitem_T *)alloc_clear(
! 					     sizeof(pumitem_T) * list->lv_len);
  	if (balloon_array == NULL)
  	    return;
  	for (idx = 0, li = list->lv_first; li != NULL; li = li->li_next, ++idx)
--- 1164,1170 ----
  	int	    idx;
  
  	balloon_arraysize = list->lv_len;
! 	balloon_array = ALLOC_CLEAR_MULT(pumitem_T, list->lv_len);
  	if (balloon_array == NULL)
  	    return;
  	for (idx = 0, li = list->lv_first; li != NULL; li = li->li_next, ++idx)
***************
*** 1271,1277 ****
  	return;
      }
  
!     array = (pumitem_T *)alloc_clear(sizeof(pumitem_T) * pum_size);
      if (array == NULL)
  	return;
  
--- 1270,1276 ----
  	return;
      }
  
!     array = ALLOC_CLEAR_MULT(pumitem_T, pum_size);
      if (array == NULL)
  	return;
  
*** ../vim-8.1.1413/src/proto/misc2.pro	2019-05-24 18:48:36.746128566 +0200
--- src/proto/misc2.pro	2019-05-28 20:12:11.506411492 +0200
***************
*** 21,33 ****
  int leftcol_changed(void);
  void vim_mem_profile_dump(void);
  int alloc_does_fail(size_t size);
! char_u *alloc(size_t size);
! char_u *alloc_id(size_t size, alloc_id_T id);
! char_u *alloc_clear(size_t size);
! char_u *alloc_clear_id(size_t size, alloc_id_T id);
! char_u *lalloc_clear(size_t size, int message);
! char_u *lalloc(size_t size, int message);
! char_u *lalloc_id(size_t size, int message, alloc_id_T id);
  void *mem_realloc(void *ptr, size_t size);
  void do_outofmem_msg(size_t size);
  void free_all_mem(void);
--- 21,33 ----
  int leftcol_changed(void);
  void vim_mem_profile_dump(void);
  int alloc_does_fail(size_t size);
! void *alloc(size_t size);
! void *alloc_id(size_t size, alloc_id_T id);
! void *alloc_clear(size_t size);
! void *alloc_clear_id(size_t size, alloc_id_T id);
! void *lalloc_clear(size_t size, int message);
! void *lalloc(size_t size, int message);
! void *lalloc_id(size_t size, int message, alloc_id_T id);
  void *mem_realloc(void *ptr, size_t size);
  void do_outofmem_msg(size_t size);
  void free_all_mem(void);
*** ../vim-8.1.1413/src/quickfix.c	2019-05-25 20:21:24.681950994 +0200
--- src/quickfix.c	2019-05-28 22:35:16.887875520 +0200
***************
*** 540,546 ****
      while (efm[0] != NUL)
      {
  	// Allocate a new eformat structure and put it at the end of the list
! 	fmt_ptr = (efm_T *)alloc_clear(sizeof(efm_T));
  	if (fmt_ptr == NULL)
  	    goto parse_efm_error;
  	if (fmt_first == NULL)	    // first one
--- 540,546 ----
      while (efm[0] != NUL)
      {
  	// Allocate a new eformat structure and put it at the end of the list
! 	fmt_ptr = ALLOC_CLEAR_ONE(efm_T);
  	if (fmt_ptr == NULL)
  	    goto parse_efm_error;
  	if (fmt_first == NULL)	    // first one
***************
*** 1890,1896 ****
  {
      qf_delq_T	*q;
  
!     q = (qf_delq_T *)alloc(sizeof(qf_delq_T));
      if (q != NULL)
      {
  	q->qi = qi;
--- 1890,1896 ----
  {
      qf_delq_T	*q;
  
!     q = ALLOC_ONE(qf_delq_T);
      if (q != NULL)
      {
  	q->qi = qi;
***************
*** 2063,2069 ****
      qfline_T	*qfp;
      qfline_T	**lastp;	// pointer to qf_last or NULL
  
!     if ((qfp = (qfline_T *)alloc(sizeof(qfline_T))) == NULL)
  	return QF_FAIL;
      if (bufnum != 0)
      {
--- 2063,2069 ----
      qfline_T	*qfp;
      qfline_T	**lastp;	// pointer to qf_last or NULL
  
!     if ((qfp = ALLOC_ONE(qfline_T)) == NULL)
  	return QF_FAIL;
      if (bufnum != 0)
      {
***************
*** 2141,2147 ****
  {
      qf_info_T *qi;
  
!     qi = (qf_info_T *)alloc_clear(sizeof(qf_info_T));
      if (qi != NULL)
      {
  	qi->qf_refcount++;
--- 2141,2147 ----
  {
      qf_info_T *qi;
  
!     qi = ALLOC_CLEAR_ONE(qf_info_T);
      if (qi != NULL)
      {
  	qi->qf_refcount++;
***************
*** 2429,2435 ****
      struct dir_stack_T  *ds_ptr;
  
      // allocate new stack element and hook it in
!     ds_new = (struct dir_stack_T *)alloc(sizeof(struct dir_stack_T));
      if (ds_new == NULL)
  	return NULL;
  
--- 2429,2435 ----
      struct dir_stack_T  *ds_ptr;
  
      // allocate new stack element and hook it in
!     ds_new = ALLOC_ONE(struct dir_stack_T);
      if (ds_new == NULL)
  	return NULL;
  
*** ../vim-8.1.1413/src/regexp.c	2019-05-24 19:38:59.108545464 +0200
--- src/regexp.c	2019-05-28 20:27:16.592828285 +0200
***************
*** 1319,1325 ****
  	return NULL;
  
      /* Allocate space. */
!     r = (bt_regprog_T *)alloc(sizeof(bt_regprog_T) + regsize);
      if (r == NULL)
  	return NULL;
      r->re_in_use = FALSE;
--- 1319,1325 ----
  	return NULL;
  
      /* Allocate space. */
!     r = alloc(sizeof(bt_regprog_T) + regsize);
      if (r == NULL)
  	return NULL;
      r->re_in_use = FALSE;
***************
*** 3932,3938 ****
  {
      reg_extmatch_T	*em;
  
!     em = (reg_extmatch_T *)alloc_clear(sizeof(reg_extmatch_T));
      if (em != NULL)
  	em->refcnt = 1;
      return em;
--- 3932,3938 ----
  {
      reg_extmatch_T	*em;
  
!     em = ALLOC_CLEAR_ONE(reg_extmatch_T);
      if (em != NULL)
  	em->refcnt = 1;
      return em;
*** ../vim-8.1.1413/src/regexp_nfa.c	2019-05-25 20:21:24.681950994 +0200
--- src/regexp_nfa.c	2019-05-28 22:36:31.083398968 +0200
***************
*** 300,306 ****
      /* Size for postfix representation of expr. */
      postfix_size = sizeof(int) * nstate_max;
  
!     post_start = (int *)alloc(postfix_size);
      if (post_start == NULL)
  	return FAIL;
      post_ptr = post_start;
--- 300,306 ----
      /* Size for postfix representation of expr. */
      postfix_size = sizeof(int) * nstate_max;
  
!     post_start = alloc(postfix_size);
      if (post_start == NULL)
  	return FAIL;
      post_ptr = post_start;
***************
*** 516,522 ****
      // For weird patterns the number of states can be very high. Increasing by
      // 50% seems a reasonable compromise between memory use and speed.
      new_max = nstate_max * 3 / 2;
!     new_start = (int *)alloc(new_max * sizeof(int));
      if (new_start == NULL)
  	return FAIL;
      mch_memmove(new_start, post_start, nstate_max * sizeof(int));
--- 516,522 ----
      // For weird patterns the number of states can be very high. Increasing by
      // 50% seems a reasonable compromise between memory use and speed.
      new_max = nstate_max * 3 / 2;
!     new_start = ALLOC_MULT(int, new_max);
      if (new_start == NULL)
  	return FAIL;
      mch_memmove(new_start, post_start, nstate_max * sizeof(int));
***************
*** 3214,3220 ****
      if (nfa_calc_size == FALSE)
      {
  	// Allocate space for the stack. Max states on the stack: "nstate'.
! 	stack = (Frag_T *)alloc((nstate + 1) * sizeof(Frag_T));
  	if (stack == NULL)
  	    return NULL;
  	stackp = stack;
--- 3214,3220 ----
      if (nfa_calc_size == FALSE)
      {
  	// Allocate space for the stack. Max states on the stack: "nstate'.
! 	stack = ALLOC_MULT(Frag_T, nstate + 1);
  	if (stack == NULL)
  	    return NULL;
  	stackp = stack;
***************
*** 4799,4805 ****
  		emsg(_(e_maxmempat));
  		return NULL;
  	    }
! 	    newl = (nfa_thread_T *)alloc(newsize);
  	    if (newl == NULL)
  		return NULL;
  	    l->len = newlen;
--- 4799,4805 ----
  		emsg(_(e_maxmempat));
  		return NULL;
  	    }
! 	    newl = alloc(newsize);
  	    if (newl == NULL)
  		return NULL;
  	    l->len = newlen;
***************
*** 5184,5190 ****
  	if (*listids == NULL || *listids_len < prog->nstate)
  	{
  	    vim_free(*listids);
! 	    *listids = (int *)alloc(sizeof(int) * prog->nstate);
  	    if (*listids == NULL)
  	    {
  		emsg(_("E878: (NFA) Could not allocate memory for branch traversal!"));
--- 5184,5190 ----
  	if (*listids == NULL || *listids_len < prog->nstate)
  	{
  	    vim_free(*listids);
! 	    *listids = ALLOC_MULT(int, prog->nstate);
  	    if (*listids == NULL)
  	    {
  		emsg(_("E878: (NFA) Could not allocate memory for branch traversal!"));
***************
*** 5567,5575 ****
      /* Allocate memory for the lists of nodes. */
      size = (prog->nstate + 1) * sizeof(nfa_thread_T);
  
!     list[0].t = (nfa_thread_T *)alloc(size);
      list[0].len = prog->nstate + 1;
!     list[1].t = (nfa_thread_T *)alloc(size);
      list[1].len = prog->nstate + 1;
      if (list[0].t == NULL || list[1].t == NULL)
  	goto theend;
--- 5567,5575 ----
      /* Allocate memory for the lists of nodes. */
      size = (prog->nstate + 1) * sizeof(nfa_thread_T);
  
!     list[0].t = alloc(size);
      list[0].len = prog->nstate + 1;
!     list[1].t = alloc(size);
      list[1].len = prog->nstate + 1;
      if (list[0].t == NULL || list[1].t == NULL)
  	goto theend;
***************
*** 7276,7282 ****
  
      /* allocate the regprog with space for the compiled regexp */
      prog_size = sizeof(nfa_regprog_T) + sizeof(nfa_state_T) * (nstate - 1);
!     prog = (nfa_regprog_T *)alloc(prog_size);
      if (prog == NULL)
  	goto fail;
      state_ptr = prog->state;
--- 7276,7282 ----
  
      /* allocate the regprog with space for the compiled regexp */
      prog_size = sizeof(nfa_regprog_T) + sizeof(nfa_state_T) * (nstate - 1);
!     prog = alloc(prog_size);
      if (prog == NULL)
  	goto fail;
      state_ptr = prog->state;
*** ../vim-8.1.1413/src/screen.c	2019-05-27 21:53:53.990229301 +0200
--- src/screen.c	2019-05-28 22:38:45.078506457 +0200
***************
*** 328,354 ****
  
      /* Allocate space to save the text displayed in the command line area. */
      rows = screen_Rows - cmdline_row;
!     screenline = (schar_T *)lalloc(rows * cols * sizeof(schar_T), FALSE);
!     screenattr = (sattr_T *)lalloc(rows * cols * sizeof(sattr_T), FALSE);
      if (screenline == NULL || screenattr == NULL)
  	ret = 2;
      if (enc_utf8)
      {
! 	screenlineUC = (u8char_T *)lalloc(
! 				       rows * cols * sizeof(u8char_T), FALSE);
  	if (screenlineUC == NULL)
  	    ret = 2;
  	for (i = 0; i < p_mco; ++i)
  	{
! 	    screenlineC[i] = (u8char_T *)lalloc(
! 				       rows * cols * sizeof(u8char_T), FALSE);
  	    if (screenlineC[i] == NULL)
  		ret = 2;
  	}
      }
      if (enc_dbcs == DBCS_JPNU)
      {
! 	screenline2 = (schar_T *)lalloc(rows * cols * sizeof(schar_T), FALSE);
  	if (screenline2 == NULL)
  	    ret = 2;
      }
--- 328,352 ----
  
      /* Allocate space to save the text displayed in the command line area. */
      rows = screen_Rows - cmdline_row;
!     screenline = LALLOC_MULT(schar_T, rows * cols);
!     screenattr = LALLOC_MULT(sattr_T, rows * cols);
      if (screenline == NULL || screenattr == NULL)
  	ret = 2;
      if (enc_utf8)
      {
! 	screenlineUC = LALLOC_MULT(u8char_T, rows * cols);
  	if (screenlineUC == NULL)
  	    ret = 2;
  	for (i = 0; i < p_mco; ++i)
  	{
! 	    screenlineC[i] = LALLOC_MULT(u8char_T, rows * cols);
  	    if (screenlineC[i] == NULL)
  		ret = 2;
  	}
      }
      if (enc_dbcs == DBCS_JPNU)
      {
! 	screenline2 = LALLOC_MULT(schar_T, rows * cols);
  	if (screenline2 == NULL)
  	    ret = 2;
      }
***************
*** 3810,3823 ****
  	{
  	    // Make a copy of the properties, so that they are properly
  	    // aligned.
! 	    text_props = (textprop_T *)alloc(
! 					 text_prop_count * sizeof(textprop_T));
  	    if (text_props != NULL)
  		mch_memmove(text_props, prop_start,
  					 text_prop_count * sizeof(textprop_T));
  
  	    // Allocate an array for the indexes.
! 	    text_prop_idxs = (int *)alloc(text_prop_count * sizeof(int));
  	    area_highlighting = TRUE;
  	    extra_check = TRUE;
  	}
--- 3808,3820 ----
  	{
  	    // Make a copy of the properties, so that they are properly
  	    // aligned.
! 	    text_props = ALLOC_MULT(textprop_T, text_prop_count);
  	    if (text_props != NULL)
  		mch_memmove(text_props, prop_start,
  					 text_prop_count * sizeof(textprop_T));
  
  	    // Allocate an array for the indexes.
! 	    text_prop_idxs = ALLOC_MULT(int, text_prop_count);
  	    area_highlighting = TRUE;
  	    extra_check = TRUE;
  	}
***************
*** 8901,8925 ****
      if (aucmd_win != NULL)
  	win_free_lsize(aucmd_win);
  
!     new_ScreenLines = (schar_T *)lalloc(
! 			      (Rows + 1) * Columns * sizeof(schar_T), FALSE);
      vim_memset(new_ScreenLinesC, 0, sizeof(u8char_T *) * MAX_MCO);
      if (enc_utf8)
      {
! 	new_ScreenLinesUC = (u8char_T *)lalloc(
! 			     (Rows + 1) * Columns * sizeof(u8char_T), FALSE);
  	for (i = 0; i < p_mco; ++i)
! 	    new_ScreenLinesC[i] = (u8char_T *)lalloc_clear(
! 			     (Rows + 1) * Columns * sizeof(u8char_T), FALSE);
      }
      if (enc_dbcs == DBCS_JPNU)
! 	new_ScreenLines2 = (schar_T *)lalloc(
! 			     (Rows + 1) * Columns * sizeof(schar_T), FALSE);
!     new_ScreenAttrs = (sattr_T *)lalloc(
! 			      (Rows + 1) * Columns * sizeof(sattr_T), FALSE);
!     new_LineOffset = (unsigned *)lalloc(Rows * sizeof(unsigned), FALSE);
!     new_LineWraps = (char_u *)lalloc(Rows * sizeof(char_u), FALSE);
!     new_TabPageIdxs = (short *)lalloc(Columns * sizeof(short), FALSE);
  
      FOR_ALL_TAB_WINDOWS(tp, wp)
      {
--- 8898,8918 ----
      if (aucmd_win != NULL)
  	win_free_lsize(aucmd_win);
  
!     new_ScreenLines = LALLOC_MULT(schar_T, (Rows + 1) * Columns);
      vim_memset(new_ScreenLinesC, 0, sizeof(u8char_T *) * MAX_MCO);
      if (enc_utf8)
      {
! 	new_ScreenLinesUC = LALLOC_MULT(u8char_T, (Rows + 1) * Columns);
  	for (i = 0; i < p_mco; ++i)
! 	    new_ScreenLinesC[i] = LALLOC_CLEAR_MULT(u8char_T,
! 							 (Rows + 1) * Columns);
      }
      if (enc_dbcs == DBCS_JPNU)
! 	new_ScreenLines2 = LALLOC_MULT(schar_T, (Rows + 1) * Columns);
!     new_ScreenAttrs = LALLOC_MULT(sattr_T, (Rows + 1) * Columns);
!     new_LineOffset = LALLOC_MULT(unsigned, Rows);
!     new_LineWraps = LALLOC_MULT(char_u, Rows);
!     new_TabPageIdxs = LALLOC_MULT(short, Columns);
  
      FOR_ALL_TAB_WINDOWS(tp, wp)
      {
***************
*** 10858,10865 ****
      vim_free(wp->w_winbar_items);
      for (menu = wp->w_winbar->children; menu != NULL; menu = menu->next)
  	++item_count;
!     wp->w_winbar_items = (winbar_item_T *)alloc_clear(
! 				     sizeof(winbar_item_T) * (item_count + 1));
  
      /* TODO: use fewer spaces if there is not enough room */
      for (menu = wp->w_winbar->children;
--- 10851,10857 ----
      vim_free(wp->w_winbar_items);
      for (menu = wp->w_winbar->children; menu != NULL; menu = menu->next)
  	++item_count;
!     wp->w_winbar_items = ALLOC_CLEAR_MULT(winbar_item_T, item_count + 1);
  
      /* TODO: use fewer spaces if there is not enough room */
      for (menu = wp->w_winbar->children;
*** ../vim-8.1.1413/src/search.c	2019-05-25 20:21:24.681950994 +0200
--- src/search.c	2019-05-28 22:44:02.532550679 +0200
***************
*** 5145,5152 ****
  	    goto fpip_end;
  	def_regmatch.rm_ic = FALSE;	/* don't ignore case in define pat. */
      }
!     files = (SearchedFile *)lalloc_clear(
! 				  max_path_depth * sizeof(SearchedFile), TRUE);
      if (files == NULL)
  	goto fpip_end;
      old_files = max_path_depth;
--- 5145,5151 ----
  	    goto fpip_end;
  	def_regmatch.rm_ic = FALSE;	/* don't ignore case in define pat. */
      }
!     files = lalloc_clear(max_path_depth * sizeof(SearchedFile), TRUE);
      if (files == NULL)
  	goto fpip_end;
      old_files = max_path_depth;
***************
*** 5306,5313 ****
  		/* Push the new file onto the file stack */
  		if (depth + 1 == old_files)
  		{
! 		    bigger = (SearchedFile *)alloc(
! 				    max_path_depth * 2 * sizeof(SearchedFile));
  		    if (bigger != NULL)
  		    {
  			for (i = 0; i <= depth; i++)
--- 5305,5311 ----
  		/* Push the new file onto the file stack */
  		if (depth + 1 == old_files)
  		{
! 		    bigger = ALLOC_MULT(SearchedFile, max_path_depth * 2);
  		    if (bigger != NULL)
  		    {
  			for (i = 0; i <= depth; i++)
*** ../vim-8.1.1413/src/sign.c	2019-05-25 20:21:24.681950994 +0200
--- src/sign.c	2019-05-28 22:41:10.249589206 +0200
***************
*** 85,91 ****
      if (HASHITEM_EMPTY(hi))
      {
  	// new group
! 	group = (signgroup_T *)alloc(sizeof(signgroup_T) + STRLEN(groupname));
  	if (group == NULL)
  	    return NULL;
  	STRCPY(group->sg_name, groupname);
--- 85,91 ----
      if (HASHITEM_EMPTY(hi))
      {
  	// new group
! 	group = alloc(sizeof(signgroup_T) + STRLEN(groupname));
  	if (group == NULL)
  	    return NULL;
  	STRCPY(group->sg_name, groupname);
***************
*** 201,208 ****
  {
      signlist_T	*newsign;
  
!     newsign = (signlist_T *)lalloc_id(sizeof(signlist_T), FALSE,
! 							      aid_insert_sign);
      if (newsign != NULL)
      {
  	newsign->id = id;
--- 201,207 ----
  {
      signlist_T	*newsign;
  
!     newsign = lalloc_id(sizeof(signlist_T), FALSE, aid_insert_sign);
      if (newsign != NULL)
      {
  	newsign->id = id;
***************
*** 736,742 ****
      int	start = next_sign_typenr;
  
      // Allocate a new sign.
!     sp = (sign_T *)alloc_clear_id(sizeof(sign_T), aid_sign_define_by_name);
      if (sp == NULL)
  	return NULL;
  
--- 735,741 ----
      int	start = next_sign_typenr;
  
      // Allocate a new sign.
!     sp = alloc_clear_id(sizeof(sign_T), aid_sign_define_by_name);
      if (sp == NULL)
  	return NULL;
  
*** ../vim-8.1.1413/src/spell.c	2019-05-24 19:38:59.112545434 +0200
--- src/spell.c	2019-05-28 20:32:44.870829922 +0200
***************
*** 1899,1905 ****
  {
      slang_T *lp;
  
!     lp = (slang_T *)alloc_clear(sizeof(slang_T));
      if (lp != NULL)
      {
  	if (lang != NULL)
--- 1899,1905 ----
  {
      slang_T *lp;
  
!     lp = ALLOC_CLEAR_ONE(slang_T);
      if (lp != NULL)
      {
  	if (lang != NULL)
***************
*** 2083,2089 ****
      hi = hash_lookup(&lp->sl_wordcount, p, hash);
      if (HASHITEM_EMPTY(hi))
      {
! 	wc = (wordcount_T *)alloc(sizeof(wordcount_T) + STRLEN(p));
  	if (wc == NULL)
  	    return;
  	STRCPY(wc->wc_word, p);
--- 2083,2089 ----
      hi = hash_lookup(&lp->sl_wordcount, p, hash);
      if (HASHITEM_EMPTY(hi))
      {
! 	wc = alloc(sizeof(wordcount_T) + STRLEN(p));
  	if (wc == NULL)
  	    return;
  	STRCPY(wc->wc_word, p);
***************
*** 2883,2889 ****
  {
      buf_T	*buf;
  
!     buf = (buf_T *)alloc_clear(sizeof(buf_T));
      if (buf != NULL)
      {
  	buf->b_spell = TRUE;
--- 2883,2889 ----
  {
      buf_T	*buf;
  
!     buf = ALLOC_CLEAR_ONE(buf_T);
      if (buf != NULL)
      {
  	buf->b_spell = TRUE;
***************
*** 6223,6229 ****
      hi = hash_lookup(&slang->sl_sounddone, goodword, hash);
      if (HASHITEM_EMPTY(hi))
      {
! 	sft = (sftword_T *)alloc(sizeof(sftword_T) + STRLEN(goodword));
  	if (sft != NULL)
  	{
  	    sft->sft_score = score;
--- 6223,6229 ----
      hi = hash_lookup(&slang->sl_sounddone, goodword, hash);
      if (HASHITEM_EMPTY(hi))
      {
! 	sft = alloc(sizeof(sftword_T) + STRLEN(goodword));
  	if (sft != NULL)
  	{
  	    sft->sft_score = score;
***************
*** 7820,7826 ****
  
      /* We use "cnt" as an array: CNT(badword_idx, goodword_idx). */
  #define CNT(a, b)   cnt[(a) + (b) * (badlen + 1)]
!     cnt = (int *)alloc(sizeof(int) * (badlen + 1) * (goodlen + 1));
      if (cnt == NULL)
  	return 0;	/* out of memory */
  
--- 7820,7826 ----
  
      /* We use "cnt" as an array: CNT(badword_idx, goodword_idx). */
  #define CNT(a, b)   cnt[(a) + (b) * (badlen + 1)]
!     cnt = ALLOC_MULT(int, (badlen + 1) * (goodlen + 1));
      if (cnt == NULL)
  	return 0;	/* out of memory */
  
*** ../vim-8.1.1413/src/spellfile.c	2019-05-24 19:38:59.112545434 +0200
--- src/spellfile.c	2019-05-28 22:41:30.177466603 +0200
***************
*** 892,898 ****
      if (cnt <= 0)
  	return SP_FORMERROR;
  
!     lp->sl_prefprog = (regprog_T **)alloc_clear(sizeof(regprog_T *) * cnt);
      if (lp->sl_prefprog == NULL)
  	return SP_OTHERERROR;
      lp->sl_prefixcnt = cnt;
--- 892,898 ----
      if (cnt <= 0)
  	return SP_FORMERROR;
  
!     lp->sl_prefprog = ALLOC_CLEAR_MULT(regprog_T *, cnt);
      if (lp->sl_prefprog == NULL)
  	return SP_OTHERERROR;
      lp->sl_prefixcnt = cnt;
***************
*** 1539,1545 ****
      char_u	*p;
      int		i = 0;
  
!     res = (int *)alloc(sizeof(int) * (mb_charlen(s) + 1));
      if (res != NULL)
      {
  	for (p = s; *p != NUL; )
--- 1539,1545 ----
      char_u	*p;
      int		i = 0;
  
!     res = ALLOC_MULT(int, mb_charlen(s) + 1);
      if (res != NULL)
      {
  	for (p = s; *p != NUL; )
***************
*** 1585,1591 ****
  	*bytsp = bp;
  
  	/* Allocate the index array. */
! 	ip = (idx_T *)lalloc_clear(len * sizeof(int), TRUE);
  	if (ip == NULL)
  	    return SP_OTHERERROR;
  	*idxsp = ip;
--- 1585,1591 ----
  	*bytsp = bp;
  
  	/* Allocate the index array. */
! 	ip = lalloc_clear(len * sizeof(int), TRUE);
  	if (ip == NULL)
  	    return SP_OTHERERROR;
  	*idxsp = ip;
***************
*** 4271,4277 ****
  	    bl = NULL;
  	else
  	    /* Allocate a block of memory. It is not freed until much later. */
! 	    bl = (sblock_T *)alloc_clear(sizeof(sblock_T) + SBLOCKSIZE);
  	if (bl == NULL)
  	{
  	    if (!spin->si_did_emsg)
--- 4271,4277 ----
  	    bl = NULL;
  	else
  	    /* Allocate a block of memory. It is not freed until much later. */
! 	    bl = alloc_clear(sizeof(sblock_T) + SBLOCKSIZE);
  	if (bl == NULL)
  	{
  	    if (!spin->si_did_emsg)
*** ../vim-8.1.1413/src/syntax.c	2019-05-25 23:42:10.226781089 +0200
--- src/syntax.c	2019-05-28 22:53:42.517285113 +0200
***************
*** 1215,1221 ****
  		len = syn_block->b_sst_len - syn_block->b_sst_freecount + 2;
  	}
  
! 	sstp = (synstate_T *)alloc_clear(len * sizeof(synstate_T));
  	if (sstp == NULL)	/* out of memory! */
  	    return;
  
--- 1215,1221 ----
  		len = syn_block->b_sst_len - syn_block->b_sst_freecount + 2;
  	}
  
! 	sstp = ALLOC_CLEAR_MULT(synstate_T, len);
  	if (sstp == NULL)	/* out of memory! */
  	    return;
  
***************
*** 4494,4500 ****
  						 name_folded, MAXKEYWLEN + 1);
      else
  	name_ic = name;
!     kp = (keyentry_T *)alloc(sizeof(keyentry_T) + STRLEN(name_ic));
      if (kp == NULL)
  	return;
      STRCPY(kp->keyword, name_ic);
--- 4494,4500 ----
  						 name_folded, MAXKEYWLEN + 1);
      else
  	name_ic = name;
!     kp = alloc(sizeof(keyentry_T) + STRLEN(name_ic));
      if (kp == NULL)
  	return;
      STRCPY(kp->keyword, name_ic);
***************
*** 4757,4771 ****
      if (curwin->w_s->b_syn_topgrp >= SYNID_CLUSTER)
      {
  	/* We have to alloc this, because syn_combine_list() will free it. */
! 	short	    *grp_list = (short *)alloc(2 * sizeof(short));
  	int	    tlg_id = curwin->w_s->b_syn_topgrp - SYNID_CLUSTER;
  
  	if (grp_list != NULL)
  	{
  	    grp_list[0] = id;
  	    grp_list[1] = 0;
! 	    syn_combine_list(&SYN_CLSTR(curwin->w_s)[tlg_id].scl_list, &grp_list,
! 			 CLUSTER_ADD);
  	}
      }
  }
--- 4757,4771 ----
      if (curwin->w_s->b_syn_topgrp >= SYNID_CLUSTER)
      {
  	/* We have to alloc this, because syn_combine_list() will free it. */
! 	short	    *grp_list = ALLOC_MULT(short, 2);
  	int	    tlg_id = curwin->w_s->b_syn_topgrp - SYNID_CLUSTER;
  
  	if (grp_list != NULL)
  	{
  	    grp_list[0] = id;
  	    grp_list[1] = 0;
! 	    syn_combine_list(&SYN_CLSTR(curwin->w_s)[tlg_id].scl_list,
! 						       &grp_list, CLUSTER_ADD);
  	}
      }
  }
***************
*** 5208,5214 ****
  	     * syn_patterns for this item, at the start (because the list is
  	     * used from end to start).
  	     */
! 	    ppp = (struct pat_ptr *)alloc(sizeof(struct pat_ptr));
  	    if (ppp == NULL)
  	    {
  		rest = NULL;
--- 5208,5214 ----
  	     * syn_patterns for this item, at the start (because the list is
  	     * used from end to start).
  	     */
! 	    ppp = ALLOC_ONE(struct pat_ptr);
  	    if (ppp == NULL)
  	    {
  		rest = NULL;
***************
*** 5216,5222 ****
  	    }
  	    ppp->pp_next = pat_ptrs[item];
  	    pat_ptrs[item] = ppp;
! 	    ppp->pp_synp = (synpat_T *)alloc_clear(sizeof(synpat_T));
  	    if (ppp->pp_synp == NULL)
  	    {
  		rest = NULL;
--- 5216,5222 ----
  	    }
  	    ppp->pp_next = pat_ptrs[item];
  	    pat_ptrs[item] = ppp;
! 	    ppp->pp_synp = ALLOC_CLEAR_ONE(synpat_T);
  	    if (ppp->pp_synp == NULL)
  	    {
  		rest = NULL;
***************
*** 5465,5471 ****
  		clstr = NULL;
  		break;
  	    }
! 	    clstr = (short *)alloc((count + 1) * sizeof(short));
  	    if (clstr == NULL)
  		break;
  	    clstr[count] = 0;
--- 5465,5471 ----
  		clstr = NULL;
  		break;
  	    }
! 	    clstr = ALLOC_MULT(short, count + 1);
  	    if (clstr == NULL)
  		break;
  	    clstr[count] = 0;
***************
*** 6124,6130 ****
  	    break;
  	if (round == 1)
  	{
! 	    retval = (short *)alloc((count + 1) * sizeof(short));
  	    if (retval == NULL)
  		break;
  	    retval[count] = 0;	    /* zero means end of the list */
--- 6124,6130 ----
  	    break;
  	if (round == 1)
  	{
! 	    retval = ALLOC_MULT(short, count + 1);
  	    if (retval == NULL)
  		break;
  	    retval[count] = 0;	    /* zero means end of the list */
***************
*** 6163,6169 ****
      for (count = 0; list[count]; ++count)
  	;
      len = (count + 1) * sizeof(short);
!     retval = (short *)alloc(len);
      if (retval != NULL)
  	mch_memmove(retval, list, (size_t)len);
  
--- 6163,6169 ----
      for (count = 0; list[count]; ++count)
  	;
      len = (count + 1) * sizeof(short);
!     retval = alloc(len);
      if (retval != NULL)
  	mch_memmove(retval, list, (size_t)len);
  
***************
*** 6355,6361 ****
  
      if (curwin->w_s == &curwin->w_buffer->b_s)
      {
! 	curwin->w_s = (synblock_T *)alloc(sizeof(synblock_T));
  	memset(curwin->w_s, 0, sizeof(synblock_T));
  	hash_init(&curwin->w_s->b_keywtab);
  	hash_init(&curwin->w_s->b_keywtab_ic);
--- 6355,6361 ----
  
      if (curwin->w_s == &curwin->w_buffer->b_s)
      {
! 	curwin->w_s = ALLOC_ONE(synblock_T);
  	memset(curwin->w_s, 0, sizeof(synblock_T));
  	hash_init(&curwin->w_s->b_keywtab);
  	hash_init(&curwin->w_s->b_keywtab_ic);
*** ../vim-8.1.1413/src/tag.c	2019-05-25 20:21:24.685950973 +0200
--- src/tag.c	2019-05-28 22:54:43.500953784 +0200
***************
*** 1430,1436 ****
  	if (name_only)
  	    mfp = vim_strsave(res_name);
  	else
! 	    mfp = (char_u *)alloc(sizeof(char_u) + len + 1);
  
  	if (mfp == NULL)
  	    continue;
--- 1430,1436 ----
  	if (name_only)
  	    mfp = vim_strsave(res_name);
  	else
! 	    mfp = alloc(sizeof(char_u) + len + 1);
  
  	if (mfp == NULL)
  	    continue;
***************
*** 2536,2543 ****
  		     */
  		    *tagp.tagname_end = NUL;
  		    len = (int)(tagp.tagname_end - tagp.tagname);
! 		    mfp = (char_u *)alloc(sizeof(char_u)
! 						    + len + 10 + ML_EXTRA + 1);
  		    if (mfp != NULL)
  		    {
  			int heuristic;
--- 2536,2542 ----
  		     */
  		    *tagp.tagname_end = NUL;
  		    len = (int)(tagp.tagname_end - tagp.tagname);
! 		    mfp = alloc(sizeof(char_u) + len + 10 + ML_EXTRA + 1);
  		    if (mfp != NULL)
  		    {
  			int heuristic;
***************
*** 2574,2580 ****
  			if (tagp.command + 2 < temp_end)
  			{
  			    len = (int)(temp_end - tagp.command - 2);
! 			    mfp = (char_u *)alloc(len + 2);
  			    if (mfp != NULL)
  				vim_strncpy(mfp, tagp.command + 2, len);
  			}
--- 2573,2579 ----
  			if (tagp.command + 2 < temp_end)
  			{
  			    len = (int)(temp_end - tagp.command - 2);
! 			    mfp = alloc(len + 2);
  			    if (mfp != NULL)
  				vim_strncpy(mfp, tagp.command + 2, len);
  			}
***************
*** 2585,2591 ****
  		    else
  		    {
  			len = (int)(tagp.tagname_end - tagp.tagname);
! 			mfp = (char_u *)alloc(sizeof(char_u) + len + 1);
  			if (mfp != NULL)
  			    vim_strncpy(mfp, tagp.tagname, len);
  
--- 2584,2590 ----
  		    else
  		    {
  			len = (int)(tagp.tagname_end - tagp.tagname);
! 			mfp = alloc(sizeof(char_u) + len + 1);
  			if (mfp != NULL)
  			    vim_strncpy(mfp, tagp.tagname, len);
  
***************
*** 2620,2626 ****
  		    else
  			++len;
  #endif
! 		    mfp = (char_u *)alloc(sizeof(char_u) + len + 1);
  		    if (mfp != NULL)
  		    {
  			p = mfp;
--- 2619,2625 ----
  		    else
  			++len;
  #endif
! 		    mfp = alloc(sizeof(char_u) + len + 1);
  		    if (mfp != NULL)
  		    {
  			p = mfp;
***************
*** 2789,2795 ****
  	match_count = 0;
  
      if (match_count > 0)
! 	matches = (char_u **)alloc(match_count * sizeof(char_u *));
      else
  	matches = NULL;
      match_count = 0;
--- 2788,2794 ----
  	match_count = 0;
  
      if (match_count > 0)
! 	matches = ALLOC_MULT(char_u *, match_count);
      else
  	matches = NULL;
      match_count = 0;
*** ../vim-8.1.1413/src/term.c	2019-05-25 20:21:24.685950973 +0200
--- src/term.c	2019-05-28 22:55:38.412656638 +0200
***************
*** 4187,4194 ****
      if (tc_len == tc_max_len)
      {
  	tc_max_len += 20;
! 	new_tc = (struct termcode *)alloc(
! 			    tc_max_len * sizeof(struct termcode));
  	if (new_tc == NULL)
  	{
  	    tc_max_len -= 20;
--- 4187,4193 ----
      if (tc_len == tc_max_len)
      {
  	tc_max_len += 20;
! 	new_tc = ALLOC_MULT(struct termcode, tc_max_len);
  	if (new_tc == NULL)
  	{
  	    tc_max_len -= 20;
***************
*** 6420,6426 ****
  
      if (tc_len == 0)	    /* no terminal codes (must be GUI) */
  	return;
!     items = (int *)alloc(sizeof(int) * tc_len);
      if (items == NULL)
  	return;
  
--- 6419,6425 ----
  
      if (tc_len == 0)	    /* no terminal codes (must be GUI) */
  	return;
!     items = ALLOC_MULT(int, tc_len);
      if (items == NULL)
  	return;
  
***************
*** 7071,7078 ****
  	{
  	    if (!counting)
  	    {
! 		colornames_table = (struct rgbcolor_table_S *)alloc(
! 				    sizeof(struct rgbcolor_table_S) * size);
  		if (colornames_table == NULL)
  		{
  		    fclose(fd);
--- 7070,7076 ----
  	{
  	    if (!counting)
  	    {
! 		colornames_table = ALLOC_MULT(struct rgbcolor_table_S, size);
  		if (colornames_table == NULL)
  		{
  		    fclose(fd);
*** ../vim-8.1.1413/src/terminal.c	2019-05-25 20:21:24.685950973 +0200
--- src/terminal.c	2019-05-28 22:56:28.252387863 +0200
***************
*** 413,419 ****
  	return NULL;
      }
  
!     term = (term_T *)alloc_clear(sizeof(term_T));
      if (term == NULL)
  	return NULL;
      term->tl_dirty_row_end = MAX_ROW;
--- 413,419 ----
  	return NULL;
      }
  
!     term = ALLOC_CLEAR_ONE(term_T);
      if (term == NULL)
  	return NULL;
      term->tl_dirty_row_end = MAX_ROW;
***************
*** 1630,1636 ****
  	    if (len == 0)
  		p = NULL;
  	    else
! 		p = (cellattr_T *)alloc(sizeof(cellattr_T) * len);
  	    if ((p != NULL || len == 0)
  				     && ga_grow(&term->tl_scrollback, 1) == OK)
  	    {
--- 1630,1636 ----
  	    if (len == 0)
  		p = NULL;
  	    else
! 		p = ALLOC_MULT(cellattr_T, len);
  	    if ((p != NULL || len == 0)
  				     && ga_grow(&term->tl_scrollback, 1) == OK)
  	    {
***************
*** 2884,2890 ****
  
  	ga_init2(&ga, 1, 100);
  	if (len > 0)
! 	    p = (cellattr_T *)alloc(sizeof(cellattr_T) * len);
  	if (p != NULL)
  	{
  	    for (col = 0; col < len; col += cells[col].width)
--- 2884,2890 ----
  
  	ga_init2(&ga, 1, 100);
  	if (len > 0)
! 	    p = ALLOC_MULT(cellattr_T, len);
  	if (p != NULL)
  	{
  	    for (col = 0; col < len; col += cells[col].width)
***************
*** 4935,4941 ****
      else
      {
  	size_t		size = sizeof(sb_line_T) * term->tl_scrollback.ga_len;
! 	sb_line_T	*temp = (sb_line_T *)alloc(size);
  
  	/* need to copy cell properties into temp memory */
  	if (temp != NULL)
--- 4935,4941 ----
      else
      {
  	size_t		size = sizeof(sb_line_T) * term->tl_scrollback.ga_len;
! 	sb_line_T	*temp = alloc(size);
  
  	/* need to copy cell properties into temp memory */
  	if (temp != NULL)
***************
*** 5800,5806 ****
      {
  	/* Request by CreateProcessW */
  	breq = wcslen(cmd_wchar) + 1 + 1;	/* Addition of NUL by API */
! 	cmd_wchar_copy = (PWSTR)alloc(breq * sizeof(WCHAR));
  	wcsncpy(cmd_wchar_copy, cmd_wchar, breq - 1);
      }
  
--- 5800,5806 ----
      {
  	/* Request by CreateProcessW */
  	breq = wcslen(cmd_wchar) + 1 + 1;	/* Addition of NUL by API */
! 	cmd_wchar_copy = ALLOC_MULT(WCHAR, breq);
  	wcsncpy(cmd_wchar_copy, cmd_wchar, breq - 1);
      }
  
***************
*** 5829,5836 ****
  
      /* Set up pipe inheritance safely: Vista or later. */
      pInitializeProcThreadAttributeList(NULL, 1, 0, &breq);
!     term->tl_siex.lpAttributeList =
! 	    (PPROC_THREAD_ATTRIBUTE_LIST)alloc(breq);
      if (!term->tl_siex.lpAttributeList)
  	goto failed;
      if (!pInitializeProcThreadAttributeList(term->tl_siex.lpAttributeList, 1,
--- 5829,5835 ----
  
      /* Set up pipe inheritance safely: Vista or later. */
      pInitializeProcThreadAttributeList(NULL, 1, 0, &breq);
!     term->tl_siex.lpAttributeList = alloc(breq);
      if (!term->tl_siex.lpAttributeList)
  	goto failed;
      if (!pInitializeProcThreadAttributeList(term->tl_siex.lpAttributeList, 1,
*** ../vim-8.1.1413/src/textprop.c	2019-05-26 23:32:03.175678045 +0200
--- src/textprop.c	2019-05-28 22:57:18.140119595 +0200
***************
*** 695,701 ****
  	    semsg(_("E969: Property type %s already defined"), name);
  	    return;
  	}
! 	prop = (proptype_T *)alloc_clear(sizeof(proptype_T) + STRLEN(name));
  	if (prop == NULL)
  	    return;
  	STRCPY(prop->pt_name, name);
--- 695,701 ----
  	    semsg(_("E969: Property type %s already defined"), name);
  	    return;
  	}
! 	prop = alloc_clear(sizeof(proptype_T) + STRLEN(name));
  	if (prop == NULL)
  	    return;
  	STRCPY(prop->pt_name, name);
***************
*** 703,709 ****
  	htp = buf == NULL ? &global_proptypes : &buf->b_proptypes;
  	if (*htp == NULL)
  	{
! 	    *htp = (hashtab_T *)alloc(sizeof(hashtab_T));
  	    if (*htp == NULL)
  	    {
  		vim_free(prop);
--- 703,709 ----
  	htp = buf == NULL ? &global_proptypes : &buf->b_proptypes;
  	if (*htp == NULL)
  	{
! 	    *htp = ALLOC_ONE(hashtab_T);
  	    if (*htp == NULL)
  	    {
  		vim_free(prop);
***************
*** 1177,1183 ****
      proplen = get_text_props(curbuf, lnum, &props, FALSE);
      if (proplen > 0)
      {
! 	*prop_line = (textprop_T *)alloc(proplen * (int)sizeof(textprop_T));
  	if (*prop_line != NULL)
  	{
  	    for (ri = 0; ri < proplen; ++ri)
--- 1177,1183 ----
      proplen = get_text_props(curbuf, lnum, &props, FALSE);
      if (proplen > 0)
      {
! 	*prop_line = ALLOC_MULT(textprop_T, proplen);
  	if (*prop_line != NULL)
  	{
  	    for (ri = 0; ri < proplen; ++ri)
*** ../vim-8.1.1413/src/ui.c	2019-05-24 19:38:59.112545434 +0200
--- src/ui.c	2019-05-28 20:24:13.254011690 +0200
***************
*** 1897,1903 ****
      garray_T	*gap;
  
      /* We use a growarray to store the data pointer and the length. */
!     gap = (garray_T *)alloc(sizeof(garray_T));
      if (gap != NULL)
      {
  	/* Add one to avoid a zero size. */
--- 1897,1903 ----
      garray_T	*gap;
  
      /* We use a growarray to store the data pointer and the length. */
!     gap = ALLOC_ONE(garray_T);
      if (gap != NULL)
      {
  	/* Add one to avoid a zero size. */
*** ../vim-8.1.1413/src/undo.c	2019-05-24 19:38:59.116545403 +0200
--- src/undo.c	2019-05-28 20:12:11.518411430 +0200
***************
*** 468,474 ****
  	     * Make a new header entry.  Do this first so that we don't mess
  	     * up the undo info when out of memory.
  	     */
! 	    uhp = (u_header_T *)U_ALLOC_LINE(sizeof(u_header_T));
  	    if (uhp == NULL)
  		goto nomem;
  #ifdef U_DEBUG
--- 468,474 ----
  	     * Make a new header entry.  Do this first so that we don't mess
  	     * up the undo info when out of memory.
  	     */
! 	    uhp = U_ALLOC_LINE(sizeof(u_header_T));
  	    if (uhp == NULL)
  		goto nomem;
  #ifdef U_DEBUG
***************
*** 659,665 ****
      /*
       * add lines in front of entry list
       */
!     uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));
      if (uep == NULL)
  	goto nomem;
      vim_memset(uep, 0, sizeof(u_entry_T));
--- 659,665 ----
      /*
       * add lines in front of entry list
       */
!     uep = U_ALLOC_LINE(sizeof(u_entry_T));
      if (uep == NULL)
  	goto nomem;
      vim_memset(uep, 0, sizeof(u_entry_T));
***************
*** 685,692 ****
  
      if (size > 0)
      {
! 	if ((uep->ue_array = (undoline_T *)U_ALLOC_LINE(
! 					   sizeof(undoline_T) * size)) == NULL)
  	{
  	    u_freeentry(uep, 0L);
  	    goto nomem;
--- 685,691 ----
  
      if (size > 0)
      {
! 	if ((uep->ue_array = U_ALLOC_LINE(sizeof(undoline_T) * size)) == NULL)
  	{
  	    u_freeentry(uep, 0L);
  	    goto nomem;
***************
*** 1286,1292 ****
      int		c;
      int		error;
  
!     uhp = (u_header_T *)U_ALLOC_LINE(sizeof(u_header_T));
      if (uhp == NULL)
  	return NULL;
      vim_memset(uhp, 0, sizeof(u_header_T));
--- 1285,1291 ----
      int		c;
      int		error;
  
!     uhp = U_ALLOC_LINE(sizeof(u_header_T));
      if (uhp == NULL)
  	return NULL;
      vim_memset(uhp, 0, sizeof(u_header_T));
***************
*** 1397,1403 ****
      char_u	*line;
      int		line_len;
  
!     uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));
      if (uep == NULL)
  	return NULL;
      vim_memset(uep, 0, sizeof(u_entry_T));
--- 1396,1402 ----
      char_u	*line;
      int		line_len;
  
!     uep = U_ALLOC_LINE(sizeof(u_entry_T));
      if (uep == NULL)
  	return NULL;
      vim_memset(uep, 0, sizeof(u_entry_T));
***************
*** 1411,1417 ****
      if (uep->ue_size > 0)
      {
  	if (uep->ue_size < LONG_MAX / (int)sizeof(char_u *))
! 	    array = (undoline_T *)U_ALLOC_LINE(sizeof(undoline_T) * uep->ue_size);
  	if (array == NULL)
  	{
  	    *error = TRUE;
--- 1410,1416 ----
      if (uep->ue_size > 0)
      {
  	if (uep->ue_size < LONG_MAX / (int)sizeof(char_u *))
! 	    array = U_ALLOC_LINE(sizeof(undoline_T) * uep->ue_size);
  	if (array == NULL)
  	{
  	    *error = TRUE;
***************
*** 1981,1988 ****
      if (num_head > 0)
      {
  	if (num_head < LONG_MAX / (long)sizeof(u_header_T *))
! 	    uhp_table = (u_header_T **)U_ALLOC_LINE(
! 					     num_head * sizeof(u_header_T *));
  	if (uhp_table == NULL)
  	    goto error;
      }
--- 1980,1986 ----
      if (num_head > 0)
      {
  	if (num_head < LONG_MAX / (long)sizeof(u_header_T *))
! 	    uhp_table = U_ALLOC_LINE(num_head * sizeof(u_header_T *));
  	if (uhp_table == NULL)
  	    goto error;
      }
***************
*** 2013,2019 ****
      }
  
  #ifdef U_DEBUG
!     uhp_table_used = (int *)alloc_clear(sizeof(int) * num_head + 1);
  # define SET_FLAG(j) ++uhp_table_used[j]
  #else
  # define SET_FLAG(j)
--- 2011,2017 ----
      }
  
  #ifdef U_DEBUG
!     uhp_table_used = alloc_clear(sizeof(int) * num_head + 1);
  # define SET_FLAG(j) ++uhp_table_used[j]
  #else
  # define SET_FLAG(j)
***************
*** 2712,2719 ****
  	/* delete the lines between top and bot and save them in newarray */
  	if (oldsize > 0)
  	{
! 	    if ((newarray = (undoline_T *)U_ALLOC_LINE(
! 					sizeof(undoline_T) * oldsize)) == NULL)
  	    {
  		do_outofmem_msg((long_u)(sizeof(undoline_T) * oldsize));
  		/*
--- 2710,2716 ----
  	/* delete the lines between top and bot and save them in newarray */
  	if (oldsize > 0)
  	{
! 	    if ((newarray = U_ALLOC_LINE(sizeof(undoline_T) * oldsize)) == NULL)
  	    {
  		do_outofmem_msg((long_u)(sizeof(undoline_T) * oldsize));
  		/*
*** ../vim-8.1.1413/src/userfunc.c	2019-05-24 19:38:59.116545403 +0200
--- src/userfunc.c	2019-05-28 22:58:41.511672799 +0200
***************
*** 292,301 ****
  
  	sprintf((char*)name, "<lambda>%d", ++lambda_no);
  
! 	fp = (ufunc_T *)alloc_clear(sizeof(ufunc_T) + STRLEN(name));
  	if (fp == NULL)
  	    goto errret;
! 	pt = (partial_T *)alloc_clear(sizeof(partial_T));
  	if (pt == NULL)
  	    goto errret;
  
--- 292,301 ----
  
  	sprintf((char*)name, "<lambda>%d", ++lambda_no);
  
! 	fp = alloc_clear(sizeof(ufunc_T) + STRLEN(name));
  	if (fp == NULL)
  	    goto errret;
! 	pt = ALLOC_CLEAR_ONE(partial_T);
  	if (pt == NULL)
  	    goto errret;
  
***************
*** 305,311 ****
  
  	/* Add "return " before the expression. */
  	len = 7 + e - s + 1;
! 	p = (char_u *)alloc(len);
  	if (p == NULL)
  	    goto errret;
  	((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;
--- 305,311 ----
  
  	/* Add "return " before the expression. */
  	len = 7 + e - s + 1;
! 	p = alloc(len);
  	if (p == NULL)
  	    goto errret;
  	((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;
***************
*** 802,808 ****
  
      line_breakcheck();		/* check for CTRL-C hit */
  
!     fc = (funccall_T *)alloc_clear(sizeof(funccall_T));
      if (fc == NULL)
  	return;
      fc->caller = current_funccal;
--- 802,808 ----
  
      line_breakcheck();		/* check for CTRL-C hit */
  
!     fc = ALLOC_CLEAR_ONE(funccall_T);
      if (fc == NULL)
  	return;
      fc->caller = current_funccal;
***************
*** 2580,2586 ****
  	    }
  	}
  
! 	fp = (ufunc_T *)alloc_clear(sizeof(ufunc_T) + STRLEN(name));
  	if (fp == NULL)
  	    goto erret;
  
--- 2580,2586 ----
  	    }
  	}
  
! 	fp = alloc_clear(sizeof(ufunc_T) + STRLEN(name));
  	if (fp == NULL)
  	    goto erret;
  
***************
*** 2751,2763 ****
  	profile_zero(&fp->uf_tm_self);
  	profile_zero(&fp->uf_tm_total);
  	if (fp->uf_tml_count == NULL)
! 	    fp->uf_tml_count = (int *)alloc_clear(sizeof(int) * len);
  	if (fp->uf_tml_total == NULL)
! 	    fp->uf_tml_total = (proftime_T *)alloc_clear(
! 						     sizeof(proftime_T) * len);
  	if (fp->uf_tml_self == NULL)
! 	    fp->uf_tml_self = (proftime_T *)alloc_clear(
! 						     sizeof(proftime_T) * len);
  	fp->uf_tml_idx = -1;
  	if (fp->uf_tml_count == NULL || fp->uf_tml_total == NULL
  						    || fp->uf_tml_self == NULL)
--- 2751,2761 ----
  	profile_zero(&fp->uf_tm_self);
  	profile_zero(&fp->uf_tm_total);
  	if (fp->uf_tml_count == NULL)
! 	    fp->uf_tml_count = ALLOC_CLEAR_MULT(int, len);
  	if (fp->uf_tml_total == NULL)
! 	    fp->uf_tml_total = ALLOC_CLEAR_MULT(proftime_T, len);
  	if (fp->uf_tml_self == NULL)
! 	    fp->uf_tml_self = ALLOC_CLEAR_MULT(proftime_T, len);
  	fp->uf_tml_idx = -1;
  	if (fp->uf_tml_count == NULL || fp->uf_tml_total == NULL
  						    || fp->uf_tml_self == NULL)
***************
*** 2786,2792 ****
      if (todo == 0)
  	return;     /* nothing to dump */
  
!     sorttab = (ufunc_T **)alloc(sizeof(ufunc_T *) * todo);
  
      for (hi = func_hashtab.ht_array; todo > 0; ++hi)
      {
--- 2784,2790 ----
      if (todo == 0)
  	return;     /* nothing to dump */
  
!     sorttab = ALLOC_MULT(ufunc_T *, todo);
  
      for (hi = func_hashtab.ht_array; todo > 0; ++hi)
      {
***************
*** 3670,3676 ****
  
      if (fp != NULL && (fp->uf_flags & FC_DICT))
      {
! 	partial_T	*pt = (partial_T *)alloc_clear(sizeof(partial_T));
  
  	if (pt != NULL)
  	{
--- 3668,3674 ----
  
      if (fp != NULL && (fp->uf_flags & FC_DICT))
      {
! 	partial_T	*pt = ALLOC_CLEAR_ONE(partial_T);
  
  	if (pt != NULL)
  	{
***************
*** 3704,3711 ****
  		}
  		if (ret_pt->pt_argc > 0)
  		{
! 		    pt->pt_argv = (typval_T *)alloc(
! 				      sizeof(typval_T) * ret_pt->pt_argc);
  		    if (pt->pt_argv == NULL)
  			/* out of memory: drop the arguments */
  			pt->pt_argc = 0;
--- 3702,3708 ----
  		}
  		if (ret_pt->pt_argc > 0)
  		{
! 		    pt->pt_argv = ALLOC_MULT(typval_T, ret_pt->pt_argc);
  		    if (pt->pt_argv == NULL)
  			/* out of memory: drop the arguments */
  			pt->pt_argc = 0;
*** ../vim-8.1.1413/src/version.c	2019-05-27 23:36:17.456452208 +0200
--- src/version.c	2019-05-28 20:55:50.867626458 +0200
***************
*** 61,67 ****
  		+ strlen(VIM_VERSION_DATE_ONLY)
  		+ strlen(date_time);
  
!     longVersion = (char *)alloc(len);
      if (longVersion == NULL)
  	longVersion = VIM_VERSION_LONG;
      else
--- 61,67 ----
  		+ strlen(VIM_VERSION_DATE_ONLY)
  		+ strlen(date_time);
  
!     longVersion = alloc(len);
      if (longVersion == NULL)
  	longVersion = VIM_VERSION_LONG;
      else
*** ../vim-8.1.1413/src/winclip.c	2019-05-24 19:38:59.116545403 +0200
--- src/winclip.c	2019-05-28 22:59:38.571367967 +0200
***************
*** 149,155 ****
  {
      *outlen = MultiByteToWideChar(cp, flags, in, inlen, 0, 0);
      /* Add one one word to avoid a zero-length alloc(). */
!     *out = (LPWSTR)alloc(sizeof(WCHAR) * (*outlen + 1));
      if (*out != NULL)
      {
  	MultiByteToWideChar(cp, flags, in, inlen, *out, *outlen);
--- 149,155 ----
  {
      *outlen = MultiByteToWideChar(cp, flags, in, inlen, 0, 0);
      /* Add one one word to avoid a zero-length alloc(). */
!     *out = ALLOC_MULT(WCHAR, *outlen + 1);
      if (*out != NULL)
      {
  	MultiByteToWideChar(cp, flags, in, inlen, *out, *outlen);
***************
*** 169,175 ****
  {
      *outlen = WideCharToMultiByte(cp, flags, in, inlen, NULL, 0, def, useddef);
      /* Add one one byte to avoid a zero-length alloc(). */
!     *out = (LPSTR)alloc(*outlen + 1);
      if (*out != NULL)
      {
  	WideCharToMultiByte(cp, flags, in, inlen, *out, *outlen, def, useddef);
--- 169,175 ----
  {
      *outlen = WideCharToMultiByte(cp, flags, in, inlen, NULL, 0, def, useddef);
      /* Add one one byte to avoid a zero-length alloc(). */
!     *out = alloc(*outlen + 1);
      if (*out != NULL)
      {
  	WideCharToMultiByte(cp, flags, in, inlen, *out, *outlen, def, useddef);
***************
*** 512,518 ****
  	    metadata.txtlen = WideCharToMultiByte(GetACP(), 0, out, len,
  							       NULL, 0, 0, 0);
  	    vim_free(str);
! 	    str = (char_u *)alloc(metadata.txtlen == 0 ? 1 : metadata.txtlen);
  	    if (str == NULL)
  	    {
  		vim_free(out);
--- 512,518 ----
  	    metadata.txtlen = WideCharToMultiByte(GetACP(), 0, out, len,
  							       NULL, 0, 0, 0);
  	    vim_free(str);
! 	    str = alloc(metadata.txtlen == 0 ? 1 : metadata.txtlen);
  	    if (str == NULL)
  	    {
  		vim_free(out);
***************
*** 654,660 ****
  	convert_setup(&conv, NULL, NULL);
  
  	length = utf8_to_utf16(str, *lenp, NULL, NULL);
! 	ret = (WCHAR *)alloc((length + 1) * sizeof(WCHAR));
  	if (ret != NULL)
  	{
  	    utf8_to_utf16(str, *lenp, (short_u *)ret, NULL);
--- 654,660 ----
  	convert_setup(&conv, NULL, NULL);
  
  	length = utf8_to_utf16(str, *lenp, NULL, NULL);
! 	ret = ALLOC_MULT(WCHAR, length + 1);
  	if (ret != NULL)
  	{
  	    utf8_to_utf16(str, *lenp, (short_u *)ret, NULL);
*** ../vim-8.1.1413/src/window.c	2019-05-26 20:44:07.105974009 +0200
--- src/window.c	2019-05-28 23:00:28.123103824 +0200
***************
*** 1065,1071 ****
      if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)
      {
  	/* Need to create a new frame in the tree to make a branch. */
! 	frp = (frame_T *)alloc_clear(sizeof(frame_T));
  	*frp = *curfrp;
  	curfrp->fr_layout = layout;
  	frp->fr_parent = curfrp;
--- 1065,1071 ----
      if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)
      {
  	/* Need to create a new frame in the tree to make a branch. */
! 	frp = ALLOC_CLEAR_ONE(frame_T);
  	*frp = *curfrp;
  	curfrp->fr_layout = layout;
  	frp->fr_parent = curfrp;
***************
*** 3599,3605 ****
      static void
  new_frame(win_T *wp)
  {
!     frame_T *frp = (frame_T *)alloc_clear(sizeof(frame_T));
  
      wp->w_frame = frp;
      if (frp != NULL)
--- 3599,3605 ----
      static void
  new_frame(win_T *wp)
  {
!     frame_T *frp = ALLOC_CLEAR_ONE(frame_T);
  
      wp->w_frame = frp;
      if (frp != NULL)
***************
*** 3634,3640 ****
  # endif
  
  
!     tp = (tabpage_T *)alloc_clear(sizeof(tabpage_T));
      if (tp == NULL)
  	return NULL;
  
--- 3634,3640 ----
  # endif
  
  
!     tp = ALLOC_CLEAR_ONE(tabpage_T);
      if (tp == NULL)
  	return NULL;
  
***************
*** 4651,4657 ****
      /*
       * allocate window structure and linesizes arrays
       */
!     new_wp = (win_T *)alloc_clear(sizeof(win_T));
      if (new_wp == NULL)
  	return NULL;
  
--- 4651,4657 ----
      /*
       * allocate window structure and linesizes arrays
       */
!     new_wp = ALLOC_CLEAR_ONE(win_T);
      if (new_wp == NULL)
  	return NULL;
  
***************
*** 4980,4986 ****
  win_alloc_lines(win_T *wp)
  {
      wp->w_lines_valid = 0;
!     wp->w_lines = (wline_T *)alloc_clear(Rows * sizeof(wline_T));
      if (wp->w_lines == NULL)
  	return FAIL;
      return OK;
--- 4980,4986 ----
  win_alloc_lines(win_T *wp)
  {
      wp->w_lines_valid = 0;
!     wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows );
      if (wp->w_lines == NULL)
  	return FAIL;
      return OK;
***************
*** 6362,6368 ****
      static void
  make_snapshot_rec(frame_T *fr, frame_T **frp)
  {
!     *frp = (frame_T *)alloc_clear(sizeof(frame_T));
      if (*frp == NULL)
  	return;
      (*frp)->fr_layout = fr->fr_layout;
--- 6362,6368 ----
      static void
  make_snapshot_rec(frame_T *fr, frame_T **frp)
  {
!     *frp = ALLOC_CLEAR_ONE(frame_T);
      if (*frp == NULL)
  	return;
      (*frp)->fr_layout = fr->fr_layout;
***************
*** 6671,6677 ****
      }
  
      /* Build new match. */
!     m = (matchitem_T *)alloc_clear(sizeof(matchitem_T));
      m->id = id;
      m->priority = prio;
      m->pattern = pat == NULL ? NULL : vim_strsave(pat);
--- 6671,6677 ----
      }
  
      /* Build new match. */
!     m = ALLOC_CLEAR_ONE(matchitem_T);
      m->id = id;
      m->priority = prio;
      m->pattern = pat == NULL ? NULL : vim_strsave(pat);
***************
*** 7057,7063 ****
  	if (wp->w_id == id)
  	    return wp;
  #ifdef FEAT_TEXT_PROP
!     // popup windows are in a separate list
       FOR_ALL_TABPAGES(tp)
  	 for (wp = tp->tp_first_popupwin; wp != NULL; wp = wp->w_next)
  	     if (wp->w_id == id)
--- 7057,7063 ----
  	if (wp->w_id == id)
  	    return wp;
  #ifdef FEAT_TEXT_PROP
!     // popup windows are in separate lists
       FOR_ALL_TABPAGES(tp)
  	 for (wp = tp->tp_first_popupwin; wp != NULL; wp = wp->w_next)
  	     if (wp->w_id == id)
*** ../vim-8.1.1413/src/vim.h	2019-05-27 10:04:37.530426996 +0200
--- src/vim.h	2019-05-28 22:43:30.320741483 +0200
***************
*** 1546,1551 ****
--- 1546,1561 ----
  # define R_OK 4		/* for systems that don't have R_OK in unistd.h */
  #endif
  
+ // Allocate memory for one type and cast the returned pointer to have the
+ // compiler check the types.
+ #define ALLOC_ONE(type)  (type *)alloc(sizeof(type))
+ #define ALLOC_MULT(type, count)  (type *)alloc(sizeof(type) * (count))
+ #define ALLOC_CLEAR_ONE(type)  (type *)alloc_clear(sizeof(type))
+ #define ALLOC_CLEAR_MULT(type, count)  (type *)alloc_clear(sizeof(type) * (count))
+ #define LALLOC_CLEAR_ONE(type)  (type *)lalloc_clear(sizeof(type), FALSE)
+ #define LALLOC_CLEAR_MULT(type, count)  (type *)lalloc_clear(sizeof(type) * (count), FALSE)
+ #define LALLOC_MULT(type, count)  (type *)lalloc(sizeof(type) * (count), FALSE)
+ 
  /*
   * defines to avoid typecasts from (char_u *) to (char *) and back
   * (vim_strchr() and vim_strrchr() are now in alloc.c)
*** ../vim-8.1.1413/src/testdir/test_cscope.vim	2018-08-22 20:06:22.829022787 +0200
--- src/testdir/test_cscope.vim	2019-05-28 23:07:04.269005974 +0200
***************
*** 123,130 ****
      if cs_version >= 15.8
        for cmd in ['cs find a item', 'cs find 9 item']
          let a = execute(cmd)
!         call assert_equal(['', '(1 of 4): <<test_mf_hash>> item = (mf_hashitem_T *)lalloc_clear(sizeof(mf_hashtab_T), FALSE);'], split(a, '\n', 1))
!         call assert_equal('	item = (mf_hashitem_T *)lalloc_clear(sizeof(mf_hashtab_T), FALSE);', getline('.'))
          cnext
          call assert_equal('	item = mf_hash_find(&ht, key);', getline('.'))
          cnext
--- 123,130 ----
      if cs_version >= 15.8
        for cmd in ['cs find a item', 'cs find 9 item']
          let a = execute(cmd)
!         call assert_equal(['', '(1 of 4): <<test_mf_hash>> item = LALLOC_CLEAR_ONE(mf_hashtab_T);'], split(a, '\n', 1))
!         call assert_equal('	item = LALLOC_CLEAR_ONE(mf_hashtab_T);', getline('.'))
          cnext
          call assert_equal('	item = mf_hash_find(&ht, key);', getline('.'))
          cnext
*** ../vim-8.1.1413/src/version.c	2019-05-27 23:36:17.456452208 +0200
--- src/version.c	2019-05-28 20:55:50.867626458 +0200
***************
*** 769,770 ****
--- 769,772 ----
  {   /* Add new patch number below this line */
+ /**/
+     1414,
  /**/

-- 
A fine is a tax for doing wrong.  A tax is a fine for doing well.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
