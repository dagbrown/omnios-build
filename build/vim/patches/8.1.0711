To: vim_dev@googlegroups.com
Subject: Patch 8.1.0711
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.1.0711
Problem:    Test files still use function!.
Solution:   Remove the exclamation mark.  Fix overwriting a function.
Files:	    src/testdir/test49.vim, src/testdir/test_autocmd.vim,
            src/testdir/test_charsearch.vim,
            src/testdir/test_charsearch_utf8.vim,
            src/testdir/test_display.vim, src/testdir/test_edit.vim,
            src/testdir/test_eval_func.vim, src/testdir/test_fnameescape.vim,
            src/testdir/test_getcwd.vim, src/testdir/test_highlight.vim,
            src/testdir/test_hlsearch.vim, src/testdir/test_ins_complete.vim,
            src/testdir/test_lambda.vim, src/testdir/test_listdict.vim,
            src/testdir/test_listlbr.vim, src/testdir/test_listlbr_utf8.vim,
            src/testdir/test_marks.vim, src/testdir/test_matchadd_conceal.vim,
            src/testdir/test_matchadd_conceal_utf8.vim,
            src/testdir/test_messages.vim, src/testdir/test_number.vim,
            src/testdir/test_options.vim, src/testdir/test_partial.vim,
            src/testdir/test_smartindent.vim, src/testdir/test_substitute.vim,
            src/testdir/test_system.vim, src/testdir/test_terminal.vim,
            src/testdir/test_textobjects.vim, src/testdir/test_utf8.vim,
            src/testdir/test_utf8_comparisons.vim,
            src/testdir/test_vartabs.vim, src/testdir/test_vimscript.vim,
            src/testdir/test_window_cmd.vim, src/testdir/test_xxd.vim


*** ../vim-8.1.0710/src/testdir/test49.vim	2017-02-23 18:49:31.000000000 +0100
--- src/testdir/test49.vim	2019-01-09 22:29:59.429878275 +0100
***************
*** 1,6 ****
  " Vim script language tests
  " Author:	Servatius Brandt <Servatius.Brandt@fujitsu-siemens.com>
! " Last Change:	2016 Feb 07
  
  "-------------------------------------------------------------------------------
  " Test environment							    {{{1
--- 1,6 ----
  " Vim script language tests
  " Author:	Servatius Brandt <Servatius.Brandt@fujitsu-siemens.com>
! " Last Change:	2019 Jan 09
  
  "-------------------------------------------------------------------------------
  " Test environment							    {{{1
***************
*** 318,324 ****
  let ExtraVimBase = expand("<sfile>")
  let ExtraVimTestEnv = ""
  "
! function! ExtraVim(...)
      " Count how often this function is called.
      let g:ExtraVimCount = g:ExtraVimCount + 1
  
--- 318,324 ----
  let ExtraVimBase = expand("<sfile>")
  let ExtraVimTestEnv = ""
  "
! function ExtraVim(...)
      " Count how often this function is called.
      let g:ExtraVimCount = g:ExtraVimCount + 1
  
***************
*** 500,506 ****
  " an ExtraVim script as passed by ExtraVim() in ExtraVimBegin.
  "
  " EXTRA_VIM_START - do not change or remove this line.
! function! ExtraVimThrowpoint()
      if !exists("g:ExtraVimBegin")
  	Xout "ExtraVimThrowpoint() used outside ExtraVim() script."
  	return v:throwpoint
--- 500,506 ----
  " an ExtraVim script as passed by ExtraVim() in ExtraVimBegin.
  "
  " EXTRA_VIM_START - do not change or remove this line.
! function ExtraVimThrowpoint()
      if !exists("g:ExtraVimBegin")
  	Xout "ExtraVimThrowpoint() used outside ExtraVim() script."
  	return v:throwpoint
***************
*** 530,536 ****
  " as a script file, use ExecAsScript below.
  "
  " EXTRA_VIM_START - do not change or remove this line.
! function! MakeScript(funcname, ...)
      let script = tempname()
      execute "redir! >" . script
      execute "function" a:funcname
--- 530,536 ----
  " as a script file, use ExecAsScript below.
  "
  " EXTRA_VIM_START - do not change or remove this line.
! function MakeScript(funcname, ...)
      let script = tempname()
      execute "redir! >" . script
      execute "function" a:funcname
***************
*** 568,574 ****
  " location specified in the function.
  "
  " EXTRA_VIM_START - do not change or remove this line.
! function! ExecAsScript(funcname)
      " Make a script from the function passed as argument.
      let script = MakeScript(a:funcname)
  
--- 568,574 ----
  " location specified in the function.
  "
  " EXTRA_VIM_START - do not change or remove this line.
! function ExecAsScript(funcname)
      " Make a script from the function passed as argument.
      let script = MakeScript(a:funcname)
  
***************
*** 8548,8554 ****
  
  " Remove the autocommands for the events specified as arguments in all used
  " autogroups.
! function! Delete_autocommands(...)
      let augfile = tempname()
      while 1
  	try
--- 8548,8554 ----
  
  " Remove the autocommands for the events specified as arguments in all used
  " autogroups.
! function Delete_autocommands(...)
      let augfile = tempname()
      while 1
  	try
*** ../vim-8.1.0710/src/testdir/test_autocmd.vim	2018-12-21 13:03:24.292337854 +0100
--- src/testdir/test_autocmd.vim	2019-01-09 22:30:57.069457594 +0100
***************
*** 2,8 ****
  
  source shared.vim
  
! func! s:cleanup_buffers() abort
    for bnr in range(1, bufnr('$'))
      if bufloaded(bnr) && bufnr('%') != bnr
        execute 'bd! ' . bnr
--- 2,8 ----
  
  source shared.vim
  
! func s:cleanup_buffers() abort
    for bnr in range(1, bufnr('$'))
      if bufloaded(bnr) && bufnr('%') != bnr
        execute 'bd! ' . bnr
***************
*** 1343,1349 ****
  endfunc
  
  let g:setline_handled = v:false
! func! SetLineOne()
    if !g:setline_handled
      call setline(1, "(x)")
      let g:setline_handled = v:true
--- 1343,1349 ----
  endfunc
  
  let g:setline_handled = v:false
! func SetLineOne()
    if !g:setline_handled
      call setline(1, "(x)")
      let g:setline_handled = v:true
*** ../vim-8.1.0710/src/testdir/test_charsearch.vim	2016-09-07 20:37:01.000000000 +0200
--- src/testdir/test_charsearch.vim	2019-01-09 22:31:27.609160734 +0100
***************
*** 1,5 ****
  
! function! Test_charsearch()
    enew!
    call append(0, ['Xabcdefghijkemnopqretuvwxyz',
  	      \ 'Yabcdefghijkemnopqretuvwxyz',
--- 1,5 ----
  
! func Test_charsearch()
    enew!
    call append(0, ['Xabcdefghijkemnopqretuvwxyz',
  	      \ 'Yabcdefghijkemnopqretuvwxyz',
***************
*** 29,38 ****
    normal! ;;p
    call assert_equal('ZabcdeZfghijkZZemnokqretkZvwxyz', getline(3))
    enew!
! endfunction
  
  " Test for t,f,F,T movement commands and 'cpo-;' setting
! function! Test_search_cmds()
    enew!
    call append(0, ["aaa two three four", "    zzz", "yyy   ",
  	      \ "bbb yee yoo four", "ccc two three four",
--- 29,38 ----
    normal! ;;p
    call assert_equal('ZabcdeZfghijkZZemnokqretkZvwxyz', getline(3))
    enew!
! endfunc
  
  " Test for t,f,F,T movement commands and 'cpo-;' setting
! func Test_search_cmds()
    enew!
    call append(0, ["aaa two three four", "    zzz", "yyy   ",
  	      \ "bbb yee yoo four", "ccc two three four",
***************
*** 59,62 ****
    call assert_equal('ccc', getline(5))
    call assert_equal('ddd yee y', getline(6))
    enew!
! endfunction
--- 59,62 ----
    call assert_equal('ccc', getline(5))
    call assert_equal('ddd yee y', getline(6))
    enew!
! endfunc
*** ../vim-8.1.0710/src/testdir/test_charsearch_utf8.vim	2017-03-12 16:16:51.000000000 +0100
--- src/testdir/test_charsearch_utf8.vim	2019-01-09 22:31:48.896914212 +0100
***************
*** 4,10 ****
  endif
  
  " Test for t,f,F,T movement commands
! function! Test_search_cmds()
    new!
    call setline(1, "・最初から最後まで最強のVimは最高")
    1
--- 4,10 ----
  endif
  
  " Test for t,f,F,T movement commands
! func Test_search_cmds()
    new!
    call setline(1, "・最初から最後まで最強のVimは最高")
    1
***************
*** 17,22 ****
    normal! ,
    call assert_equal([0, 1, 28, 0], getpos('.'))
    bw!
! endfunction
  
  " vim: shiftwidth=2 sts=2 expandtab
--- 17,22 ----
    normal! ,
    call assert_equal([0, 1, 28, 0], getpos('.'))
    bw!
! endfunc
  
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.1.0710/src/testdir/test_display.vim	2017-08-13 20:14:30.000000000 +0200
--- src/testdir/test_display.vim	2019-01-09 22:32:22.280533816 +0100
***************
*** 5,11 ****
  
  source view_util.vim
  
! func! Test_display_foldcolumn()
    if !has("folding")
      return
    endif
--- 5,11 ----
  
  source view_util.vim
  
! func Test_display_foldcolumn()
    if !has("folding")
      return
    endif
***************
*** 38,44 ****
    quit!
  endfunc
  
! func! Test_display_foldtext_mbyte()
    if !has("folding") || !has("multi_byte")
      return
    endif
--- 38,44 ----
    quit!
  endfunc
  
! func Test_display_foldtext_mbyte()
    if !has("folding") || !has("multi_byte")
      return
    endif
*** ../vim-8.1.0710/src/testdir/test_edit.vim	2018-11-02 11:59:11.555438565 +0100
--- src/testdir/test_edit.vim	2019-01-09 22:34:16.315285600 +0100
***************
*** 9,15 ****
  
  " Needs to come first until the bug in getchar() is
  " fixed: https://groups.google.com/d/msg/vim_dev/fXL9yme4H4c/bOR-U6_bAQAJ
! func! Test_edit_00b()
    new
    call setline(1, ['abc '])
    inoreabbr <buffer> h here some more
--- 9,15 ----
  
  " Needs to come first until the bug in getchar() is
  " fixed: https://groups.google.com/d/msg/vim_dev/fXL9yme4H4c/bOR-U6_bAQAJ
! func Test_edit_00b()
    new
    call setline(1, ['abc '])
    inoreabbr <buffer> h here some more
***************
*** 21,27 ****
    bw!
  endfunc
  
! func! Test_edit_01()
    " set for Travis CI?
    "  set nocp noesckeys
    new
--- 21,27 ----
    bw!
  endfunc
  
! func Test_edit_01()
    " set for Travis CI?
    "  set nocp noesckeys
    new
***************
*** 61,67 ****
    bw!
  endfunc
  
! func! Test_edit_02()
    " Change cursor position in InsertCharPre command
    new
    call setline(1, 'abc')
--- 61,67 ----
    bw!
  endfunc
  
! func Test_edit_02()
    " Change cursor position in InsertCharPre command
    new
    call setline(1, 'abc')
***************
*** 101,107 ****
    bw!
  endfunc
  
! func! Test_edit_03()
    " Change cursor after <c-o> command to end of line
    new
    call setline(1, 'abc')
--- 101,107 ----
    bw!
  endfunc
  
! func Test_edit_03()
    " Change cursor after <c-o> command to end of line
    new
    call setline(1, 'abc')
***************
*** 120,126 ****
    bw!
  endfunc
  
! func! Test_edit_04()
    " test for :stopinsert
    new
    call setline(1, 'abc')
--- 120,126 ----
    bw!
  endfunc
  
! func Test_edit_04()
    " test for :stopinsert
    new
    call setline(1, 'abc')
***************
*** 132,138 ****
    bw!
  endfunc
  
! func! Test_edit_05()
    " test for folds being opened
    new
    call setline(1, ['abcX', 'abcX', 'zzzZ'])
--- 132,138 ----
    bw!
  endfunc
  
! func Test_edit_05()
    " test for folds being opened
    new
    call setline(1, ['abcX', 'abcX', 'zzzZ'])
***************
*** 154,160 ****
    bw!
  endfunc
  
! func! Test_edit_06()
    " Test in diff mode
    if !has("diff") || !executable("diff")
      return
--- 154,160 ----
    bw!
  endfunc
  
! func Test_edit_06()
    " Test in diff mode
    if !has("diff") || !executable("diff")
      return
***************
*** 176,182 ****
    bw!
  endfunc
  
! func! Test_edit_07()
    " 1) Test with completion <c-l> when popupmenu is visible
    new
    call setline(1, 'J')
--- 176,182 ----
    bw!
  endfunc
  
! func Test_edit_07()
    " 1) Test with completion <c-l> when popupmenu is visible
    new
    call setline(1, 'J')
***************
*** 213,219 ****
    bw!
  endfunc
  
! func! Test_edit_08()
    " reset insertmode from i_ctrl-r_=
    let g:bufnr = bufnr('%')
    new
--- 213,219 ----
    bw!
  endfunc
  
! func Test_edit_08()
    " reset insertmode from i_ctrl-r_=
    let g:bufnr = bufnr('%')
    new
***************
*** 227,233 ****
    unlet g:bufnr
  endfunc
  
! func! Test_edit_09()
    " test i_CTRL-\ combinations
    new
    call setline(1, ['abc', 'def', 'ghi'])
--- 227,233 ----
    unlet g:bufnr
  endfunc
  
! func Test_edit_09()
    " test i_CTRL-\ combinations
    new
    call setline(1, ['abc', 'def', 'ghi'])
***************
*** 257,263 ****
    bw!
  endfunc
  
! func! Test_edit_10()
    " Test for starting selectmode
    new
    set selectmode=key keymodel=startsel
--- 257,263 ----
    bw!
  endfunc
  
! func Test_edit_10()
    " Test for starting selectmode
    new
    set selectmode=key keymodel=startsel
***************
*** 269,275 ****
    bw!
  endfunc
  
! func! Test_edit_11()
    " Test that indenting kicks in
    new
    set cindent
--- 269,275 ----
    bw!
  endfunc
  
! func Test_edit_11()
    " Test that indenting kicks in
    new
    set cindent
***************
*** 313,319 ****
    bw!
  endfunc
  
! func! Test_edit_11_indentexpr()
    " Test that indenting kicks in
    new
    " Use indentexpr instead of cindenting
--- 313,319 ----
    bw!
  endfunc
  
! func Test_edit_11_indentexpr()
    " Test that indenting kicks in
    new
    " Use indentexpr instead of cindenting
***************
*** 340,346 ****
    bw!
  endfunc
  
! func! Test_edit_12()
    " Test changing indent in replace mode
    new
    call setline(1, ["\tabc", "\tdef"])
--- 340,346 ----
    bw!
  endfunc
  
! func Test_edit_12()
    " Test changing indent in replace mode
    new
    call setline(1, ["\tabc", "\tdef"])
***************
*** 392,398 ****
    bw!
  endfunc
  
! func! Test_edit_13()
    " Test smartindenting
    if exists("+smartindent")
      new
--- 392,398 ----
    bw!
  endfunc
  
! func Test_edit_13()
    " Test smartindenting
    if exists("+smartindent")
      new
***************
*** 405,411 ****
    endif
  endfunc
  
! func! Test_edit_CR()
    " Test for <CR> in insert mode
    " basically only in quickfix mode ist tested, the rest
    " has been taken care of by other tests
--- 405,411 ----
    endif
  endfunc
  
! func Test_edit_CR()
    " Test for <CR> in insert mode
    " basically only in quickfix mode ist tested, the rest
    " has been taken care of by other tests
***************
*** 438,444 ****
    call delete('Xqflist.txt')
  endfunc
  
! func! Test_edit_CTRL_()
    " disabled for Windows builds, why?
    if !has("multi_byte") || !has("rightleft") || has("win32")
      return
--- 438,444 ----
    call delete('Xqflist.txt')
  endfunc
  
! func Test_edit_CTRL_()
    " disabled for Windows builds, why?
    if !has("multi_byte") || !has("rightleft") || has("win32")
      return
***************
*** 469,475 ****
  endfunc
  
  " needs to come first, to have the @. register empty
! func! Test_edit_00a_CTRL_A()
    " Test pressing CTRL-A
    new
    call setline(1, repeat([''], 5))
--- 469,475 ----
  endfunc
  
  " needs to come first, to have the @. register empty
! func Test_edit_00a_CTRL_A()
    " Test pressing CTRL-A
    new
    call setline(1, repeat([''], 5))
***************
*** 489,495 ****
    bw!
  endfunc
  
! func! Test_edit_CTRL_EY()
    " Ctrl-E/ Ctrl-Y in insert mode completion to scroll
    10new
    call setline(1, range(1, 100))
--- 489,495 ----
    bw!
  endfunc
  
! func Test_edit_CTRL_EY()
    " Ctrl-E/ Ctrl-Y in insert mode completion to scroll
    10new
    call setline(1, range(1, 100))
***************
*** 505,511 ****
    bw!
  endfunc
  
! func! Test_edit_CTRL_G()
    new
    call setline(1, ['foobar', 'foobar', 'foobar'])
    call cursor(2, 4)
--- 505,511 ----
    bw!
  endfunc
  
! func Test_edit_CTRL_G()
    new
    call setline(1, ['foobar', 'foobar', 'foobar'])
    call cursor(2, 4)
***************
*** 523,529 ****
    bw!
  endfunc
  
! func! Test_edit_CTRL_I()
    " Tab in completion mode
    let path=expand("%:p:h")
    new
--- 523,529 ----
    bw!
  endfunc
  
! func Test_edit_CTRL_I()
    " Tab in completion mode
    let path=expand("%:p:h")
    new
***************
*** 547,553 ****
    bw!
  endfunc
  
! func! Test_edit_CTRL_K()
    " Test pressing CTRL-K (basically only dictionary completion and digraphs
    " the rest is already covered
    call writefile(['A', 'AA', 'AAA', 'AAAA'], 'Xdictionary.txt')
--- 547,553 ----
    bw!
  endfunc
  
! func Test_edit_CTRL_K()
    " Test pressing CTRL-K (basically only dictionary completion and digraphs
    " the rest is already covered
    call writefile(['A', 'AA', 'AAA', 'AAAA'], 'Xdictionary.txt')
***************
*** 620,626 ****
    bw!
  endfunc
  
! func! Test_edit_CTRL_L()
    " Test Ctrl-X Ctrl-L (line completion)
    new
    set complete=.
--- 620,626 ----
    bw!
  endfunc
  
! func Test_edit_CTRL_L()
    " Test Ctrl-X Ctrl-L (line completion)
    new
    set complete=.
***************
*** 676,682 ****
    bw!
  endfunc
  
! func! Test_edit_CTRL_N()
    " Check keyword completion
    new
    set complete=.
--- 676,682 ----
    bw!
  endfunc
  
! func Test_edit_CTRL_N()
    " Check keyword completion
    new
    set complete=.
***************
*** 697,703 ****
    bw!
  endfunc
  
! func! Test_edit_CTRL_O()
    " Check for CTRL-O in insert mode
    new
    inoreabbr <buffer> h here some more
--- 697,703 ----
    bw!
  endfunc
  
! func Test_edit_CTRL_O()
    " Check for CTRL-O in insert mode
    new
    inoreabbr <buffer> h here some more
***************
*** 722,728 ****
    bw!
  endfunc
  
! func! Test_edit_CTRL_R()
    " Insert Register
    new
    call test_override("ALL", 1)
--- 722,728 ----
    bw!
  endfunc
  
! func Test_edit_CTRL_R()
    " Insert Register
    new
    call test_override("ALL", 1)
***************
*** 737,743 ****
    bw!
  endfunc
  
! func! Test_edit_CTRL_S()
    " Test pressing CTRL-S (basically only spellfile completion)
    " the rest is already covered
    new
--- 737,743 ----
    bw!
  endfunc
  
! func Test_edit_CTRL_S()
    " Test pressing CTRL-S (basically only spellfile completion)
    " the rest is already covered
    new
***************
*** 781,787 ****
    bw!
  endfunc
  
! func! Test_edit_CTRL_T()
    " Check for CTRL-T and CTRL-X CTRL-T in insert mode
    " 1) increase indent
    new
--- 781,787 ----
    bw!
  endfunc
  
! func Test_edit_CTRL_T()
    " Check for CTRL-T and CTRL-X CTRL-T in insert mode
    " 1) increase indent
    new
***************
*** 858,864 ****
    bw!
  endfunc
  
! func! Test_edit_CTRL_U()
    " Test 'completefunc'
    new
    " -1, -2 and -3 are special return values
--- 858,864 ----
    bw!
  endfunc
  
! func Test_edit_CTRL_U()
    " Test 'completefunc'
    new
    " -1, -2 and -3 are special return values
***************
*** 917,923 ****
    bw!
  endfunc
  
! func! Test_edit_CTRL_Z()
    " Ctrl-Z when insertmode is not set inserts it literally
    new
    call setline(1, 'abc')
--- 917,923 ----
    bw!
  endfunc
  
! func Test_edit_CTRL_Z()
    " Ctrl-Z when insertmode is not set inserts it literally
    new
    call setline(1, 'abc')
***************
*** 927,933 ****
    " TODO: How to Test Ctrl-Z in insert mode, e.g. suspend?
  endfunc
  
! func! Test_edit_DROP()
    if !has("dnd")
      return
    endif
--- 927,933 ----
    " TODO: How to Test Ctrl-Z in insert mode, e.g. suspend?
  endfunc
  
! func Test_edit_DROP()
    if !has("dnd")
      return
    endif
***************
*** 943,949 ****
    bw!
  endfunc
  
! func! Test_edit_CTRL_V()
    if has("ebcdic")
      return
    endif
--- 943,949 ----
    bw!
  endfunc
  
! func Test_edit_CTRL_V()
    if has("ebcdic")
      return
    endif
***************
*** 971,977 ****
    bw!
  endfunc
  
! func! Test_edit_F1()
    " Pressing <f1>
    new
    call feedkeys(":set im\<cr>\<f1>\<c-l>", 'tnix')
--- 971,977 ----
    bw!
  endfunc
  
! func Test_edit_F1()
    " Pressing <f1>
    new
    call feedkeys(":set im\<cr>\<f1>\<c-l>", 'tnix')
***************
*** 981,987 ****
    bw
  endfunc
  
! func! Test_edit_F21()
    " Pressing <f21>
    " sends a netbeans command
    if has("netbeans_intg")
--- 981,987 ----
    bw
  endfunc
  
! func Test_edit_F21()
    " Pressing <f21>
    " sends a netbeans command
    if has("netbeans_intg")
***************
*** 992,998 ****
    endif
  endfunc
  
! func! Test_edit_HOME_END()
    " Test Home/End Keys
    new
    set foldopen+=hor
--- 992,998 ----
    endif
  endfunc
  
! func Test_edit_HOME_END()
    " Test Home/End Keys
    new
    set foldopen+=hor
***************
*** 1007,1013 ****
    bw!
  endfunc
  
! func! Test_edit_INS()
    " Test for Pressing <Insert>
    new
    call setline(1, ['abc', 'def'])
--- 1007,1013 ----
    bw!
  endfunc
  
! func Test_edit_INS()
    " Test for Pressing <Insert>
    new
    call setline(1, ['abc', 'def'])
***************
*** 1021,1027 ****
    bw!
  endfunc
  
! func! Test_edit_LEFT_RIGHT()
    " Left, Shift-Left, Right, Shift-Right
    new
    call setline(1, ['abc def ghi', 'ABC DEF GHI', 'ZZZ YYY XXX'])
--- 1021,1027 ----
    bw!
  endfunc
  
! func Test_edit_LEFT_RIGHT()
    " Left, Shift-Left, Right, Shift-Right
    new
    call setline(1, ['abc def ghi', 'ABC DEF GHI', 'ZZZ YYY XXX'])
***************
*** 1068,1074 ****
    bw!
  endfunc
  
! func! Test_edit_MOUSE()
    " This is a simple test, since we not really using the mouse here
    if !has("mouse")
      return
--- 1068,1074 ----
    bw!
  endfunc
  
! func Test_edit_MOUSE()
    " This is a simple test, since we not really using the mouse here
    if !has("mouse")
      return
***************
*** 1123,1129 ****
    bw!
  endfunc
  
! func! Test_edit_PAGEUP_PAGEDOWN()
    10new
    call setline(1, repeat(['abc def ghi'], 30))
    call cursor(1, 1)
--- 1123,1129 ----
    bw!
  endfunc
  
! func Test_edit_PAGEUP_PAGEDOWN()
    10new
    call setline(1, repeat(['abc def ghi'], 30))
    call cursor(1, 1)
***************
*** 1222,1228 ****
    bw!
  endfunc
  
! func! Test_edit_forbidden()
    new
    " 1) edit in the sandbox is not allowed
    call setline(1, 'a')
--- 1222,1228 ----
    bw!
  endfunc
  
! func Test_edit_forbidden()
    new
    " 1) edit in the sandbox is not allowed
    call setline(1, 'a')
***************
*** 1282,1288 ****
    bw!
  endfunc
  
! func! Test_edit_rightleft()
    " Cursor in rightleft mode moves differently
    if !exists("+rightleft")
      return
--- 1282,1288 ----
    bw!
  endfunc
  
! func Test_edit_rightleft()
    " Cursor in rightleft mode moves differently
    if !exists("+rightleft")
      return
*** ../vim-8.1.0710/src/testdir/test_eval_func.vim	2014-04-29 13:57:34.000000000 +0200
--- src/testdir/test_eval_func.vim	2019-01-09 22:34:29.947141160 +0100
***************
*** 1,6 ****
  " Vim script used in test_eval.in.  Needed for script-local function.
  
! func! s:Testje()
    return "foo"
  endfunc
  let Bar = function('s:Testje')
--- 1,6 ----
  " Vim script used in test_eval.in.  Needed for script-local function.
  
! func s:Testje()
    return "foo"
  endfunc
  let Bar = function('s:Testje')
*** ../vim-8.1.0710/src/testdir/test_fnameescape.vim	2016-09-07 20:37:01.000000000 +0200
--- src/testdir/test_fnameescape.vim	2019-01-09 22:35:06.338760034 +0100
***************
*** 1,6 ****
  
  " Test if fnameescape is correct for special chars like !
! function! Test_fnameescape()
    let fname = 'Xspa ce'
    let status = v:false
    try
--- 1,6 ----
  
  " Test if fnameescape is correct for special chars like !
! func Test_fnameescape()
    let fname = 'Xspa ce'
    let status = v:false
    try
***************
*** 18,21 ****
    endtry
    call assert_true(status, "ExclamationMark")
    call delete(fname)
! endfunction
--- 18,21 ----
    endtry
    call assert_true(status, "ExclamationMark")
    call delete(fname)
! endfunc
*** ../vim-8.1.0710/src/testdir/test_getcwd.vim	2018-09-23 19:36:10.215763496 +0200
--- src/testdir/test_getcwd.vim	2019-01-09 22:35:35.954454435 +0100
***************
*** 1,112 ****
! function! GetCwdInfo(win, tab)
!  	let tab_changed = 0
!  	let mod = ":t"
!  	if a:tab > 0 && a:tab != tabpagenr()
!    	let tab_changed = 1
!    	exec "tabnext " . a:tab
!  	endif
!  	let bufname = fnamemodify(bufname(winbufnr(a:win)), mod)
!  	if tab_changed
!    	tabprevious
!  	endif
!  	if a:win == 0 && a:tab == 0
!    	let dirname = fnamemodify(getcwd(), mod)
!    	let lflag = haslocaldir()
!  	elseif a:tab == 0
!    	let dirname = fnamemodify(getcwd(a:win), mod)
!    	let lflag = haslocaldir(a:win)
!  	else
!    	let dirname = fnamemodify(getcwd(a:win, a:tab), mod)
!    	let lflag = haslocaldir(a:win, a:tab)
!  	endif
!  	return bufname . ' ' . dirname . ' ' . lflag
! endfunction
  
  " Do all test in a separate window to avoid E211 when we recursively
  " delete the Xtopdir directory during cleanup
  function SetUp()
! 	set visualbell
! 	set nocp viminfo+=nviminfo
  
! 	" On windows a swapfile in Xtopdir prevents it from being cleaned up.
! 	set noswapfile
  
! 	" On windows a stale "Xtopdir" directory may exist, remove it so that
! 	" we start from a clean state.
! 	call delete("Xtopdir", "rf")
! 	new
! 	call mkdir('Xtopdir')
! 	cd Xtopdir
! 	let g:topdir = getcwd()
! 	call mkdir('Xdir1')
! 	call mkdir('Xdir2')
! 	call mkdir('Xdir3')
  endfunction
  
  let g:cwd=getcwd()
  function TearDown()
! 	q
! 	exec "cd " . g:cwd
! 	call delete("Xtopdir", "rf")
  endfunction
  
  function Test_GetCwd()
! 	new a
! 	new b
! 	new c
! 	3wincmd w
! 	lcd Xdir1
! 	call assert_equal("a Xdir1 1", GetCwdInfo(0, 0))
! 	call assert_equal(g:topdir, getcwd(-1))
! 	wincmd W
! 	call assert_equal("b Xtopdir 0", GetCwdInfo(0, 0))
! 	call assert_equal(g:topdir, getcwd(-1))
! 	wincmd W
! 	lcd Xdir3
! 	call assert_equal("c Xdir3 1", GetCwdInfo(0, 0))
! 	call assert_equal("a Xdir1 1", GetCwdInfo(bufwinnr("a"), 0))
! 	call assert_equal("b Xtopdir 0", GetCwdInfo(bufwinnr("b"), 0))
! 	call assert_equal("c Xdir3 1", GetCwdInfo(bufwinnr("c"), 0))
! 	call assert_equal(g:topdir, getcwd(-1))
! 	wincmd W
! 	call assert_equal("a Xdir1 1", GetCwdInfo(bufwinnr("a"), tabpagenr()))
! 	call assert_equal("b Xtopdir 0", GetCwdInfo(bufwinnr("b"), tabpagenr()))
! 	call assert_equal("c Xdir3 1", GetCwdInfo(bufwinnr("c"), tabpagenr()))
! 	call assert_equal(g:topdir, getcwd(-1))
! 
! 	tabnew x
! 	new y
! 	new z
! 	3wincmd w
! 	call assert_equal("x Xtopdir 0", GetCwdInfo(0, 0))
! 	call assert_equal(g:topdir, getcwd(-1))
! 	wincmd W
! 	lcd Xdir2
! 	call assert_equal("y Xdir2 1", GetCwdInfo(0, 0))
! 	call assert_equal(g:topdir, getcwd(-1))
! 	wincmd W
! 	lcd Xdir3
! 	call assert_equal("z Xdir3 1", GetCwdInfo(0, 0))
! 	call assert_equal("x Xtopdir 0", GetCwdInfo(bufwinnr("x"), 0))
! 	call assert_equal("y Xdir2 1", GetCwdInfo(bufwinnr("y"), 0))
! 	call assert_equal("z Xdir3 1", GetCwdInfo(bufwinnr("z"), 0))
! 	call assert_equal(g:topdir, getcwd(-1))
! 	let tp_nr = tabpagenr()
! 	tabrewind
! 	call assert_equal("x Xtopdir 0", GetCwdInfo(3, tp_nr))
! 	call assert_equal("y Xdir2 1", GetCwdInfo(2, tp_nr))
! 	call assert_equal("z Xdir3 1", GetCwdInfo(1, tp_nr))
! 	call assert_equal(g:topdir, getcwd(-1))
  endfunc
  
  function Test_GetCwd_lcd_shellslash()
! 	new
! 	let root = fnamemodify('/', ':p')
! 	exe 'lcd '.root
! 	let cwd = getcwd()
! 	if !exists('+shellslash') || &shellslash
! 		call assert_equal(cwd[-1:], '/')
! 	else
! 		call assert_equal(cwd[-1:], '\')
! 	endif
  endfunc
--- 1,112 ----
! func GetCwdInfo(win, tab)
!   let tab_changed = 0
!   let mod = ":t"
!   if a:tab > 0 && a:tab != tabpagenr()
!     let tab_changed = 1
!     exec "tabnext " . a:tab
!   endif
!   let bufname = fnamemodify(bufname(winbufnr(a:win)), mod)
!   if tab_changed
!     tabprevious
!   endif
!   if a:win == 0 && a:tab == 0
!     let dirname = fnamemodify(getcwd(), mod)
!     let lflag = haslocaldir()
!   elseif a:tab == 0
!     let dirname = fnamemodify(getcwd(a:win), mod)
!     let lflag = haslocaldir(a:win)
!   else
!     let dirname = fnamemodify(getcwd(a:win, a:tab), mod)
!     let lflag = haslocaldir(a:win, a:tab)
!   endif
!   return bufname . ' ' . dirname . ' ' . lflag
! endfunc
  
  " Do all test in a separate window to avoid E211 when we recursively
  " delete the Xtopdir directory during cleanup
  function SetUp()
!   set visualbell
!   set nocp viminfo+=nviminfo
  
!   " On windows a swapfile in Xtopdir prevents it from being cleaned up.
!   set noswapfile
  
!   " On windows a stale "Xtopdir" directory may exist, remove it so that
!   " we start from a clean state.
!   call delete("Xtopdir", "rf")
!   new
!   call mkdir('Xtopdir')
!   cd Xtopdir
!   let g:topdir = getcwd()
!   call mkdir('Xdir1')
!   call mkdir('Xdir2')
!   call mkdir('Xdir3')
  endfunction
  
  let g:cwd=getcwd()
  function TearDown()
!   q
!   exec "cd " . g:cwd
!   call delete("Xtopdir", "rf")
  endfunction
  
  function Test_GetCwd()
!   new a
!   new b
!   new c
!   3wincmd w
!   lcd Xdir1
!   call assert_equal("a Xdir1 1", GetCwdInfo(0, 0))
!   call assert_equal(g:topdir, getcwd(-1))
!   wincmd W
!   call assert_equal("b Xtopdir 0", GetCwdInfo(0, 0))
!   call assert_equal(g:topdir, getcwd(-1))
!   wincmd W
!   lcd Xdir3
!   call assert_equal("c Xdir3 1", GetCwdInfo(0, 0))
!   call assert_equal("a Xdir1 1", GetCwdInfo(bufwinnr("a"), 0))
!   call assert_equal("b Xtopdir 0", GetCwdInfo(bufwinnr("b"), 0))
!   call assert_equal("c Xdir3 1", GetCwdInfo(bufwinnr("c"), 0))
!   call assert_equal(g:topdir, getcwd(-1))
!   wincmd W
!   call assert_equal("a Xdir1 1", GetCwdInfo(bufwinnr("a"), tabpagenr()))
!   call assert_equal("b Xtopdir 0", GetCwdInfo(bufwinnr("b"), tabpagenr()))
!   call assert_equal("c Xdir3 1", GetCwdInfo(bufwinnr("c"), tabpagenr()))
!   call assert_equal(g:topdir, getcwd(-1))
! 
!   tabnew x
!   new y
!   new z
!   3wincmd w
!   call assert_equal("x Xtopdir 0", GetCwdInfo(0, 0))
!   call assert_equal(g:topdir, getcwd(-1))
!   wincmd W
!   lcd Xdir2
!   call assert_equal("y Xdir2 1", GetCwdInfo(0, 0))
!   call assert_equal(g:topdir, getcwd(-1))
!   wincmd W
!   lcd Xdir3
!   call assert_equal("z Xdir3 1", GetCwdInfo(0, 0))
!   call assert_equal("x Xtopdir 0", GetCwdInfo(bufwinnr("x"), 0))
!   call assert_equal("y Xdir2 1", GetCwdInfo(bufwinnr("y"), 0))
!   call assert_equal("z Xdir3 1", GetCwdInfo(bufwinnr("z"), 0))
!   call assert_equal(g:topdir, getcwd(-1))
!   let tp_nr = tabpagenr()
!   tabrewind
!   call assert_equal("x Xtopdir 0", GetCwdInfo(3, tp_nr))
!   call assert_equal("y Xdir2 1", GetCwdInfo(2, tp_nr))
!   call assert_equal("z Xdir3 1", GetCwdInfo(1, tp_nr))
!   call assert_equal(g:topdir, getcwd(-1))
  endfunc
  
  function Test_GetCwd_lcd_shellslash()
!   new
!   let root = fnamemodify('/', ':p')
!   exe 'lcd '.root
!   let cwd = getcwd()
!   if !exists('+shellslash') || &shellslash
!     call assert_equal(cwd[-1:], '/')
!   else
!     call assert_equal(cwd[-1:], '\')
!   endif
  endfunc
*** ../vim-8.1.0710/src/testdir/test_highlight.vim	2018-03-12 22:16:02.000000000 +0100
--- src/testdir/test_highlight.vim	2019-01-09 22:36:26.589940740 +0100
***************
*** 38,52 ****
    call assert_fails("hi Crash term='asdf", "E475:")
  endfunc
  
! function! HighlightArgs(name)
    return 'hi ' . substitute(split(execute('hi ' . a:name), '\n')[0], '\<xxx\>', '', '')
! endfunction
  
! function! IsColorable()
    return has('gui_running') || str2nr(&t_Co) >= 8
! endfunction
  
! function! HiCursorLine()
    let hiCursorLine = HighlightArgs('CursorLine')
    if has('gui_running')
      let guibg = matchstr(hiCursorLine, 'guibg=\w\+')
--- 38,52 ----
    call assert_fails("hi Crash term='asdf", "E475:")
  endfunc
  
! func HighlightArgs(name)
    return 'hi ' . substitute(split(execute('hi ' . a:name), '\n')[0], '\<xxx\>', '', '')
! endfunc
  
! func IsColorable()
    return has('gui_running') || str2nr(&t_Co) >= 8
! endfunc
  
! func HiCursorLine()
    let hiCursorLine = HighlightArgs('CursorLine')
    if has('gui_running')
      let guibg = matchstr(hiCursorLine, 'guibg=\w\+')
***************
*** 57,65 ****
      let hi_bg = 'hi CursorLine cterm=NONE ctermbg=Gray'
    endif
    return [hiCursorLine, hi_ul, hi_bg]
! endfunction
  
! function! Check_lcs_eol_attrs(attrs, row, col)
    let save_lcs = &lcs
    set list
  
--- 57,65 ----
      let hi_bg = 'hi CursorLine cterm=NONE ctermbg=Gray'
    endif
    return [hiCursorLine, hi_ul, hi_bg]
! endfunc
  
! func Check_lcs_eol_attrs(attrs, row, col)
    let save_lcs = &lcs
    set list
  
***************
*** 67,73 ****
  
    set nolist
    let &lcs = save_lcs
! endfunction
  
  func Test_highlight_eol_with_cursorline()
    let [hiCursorLine, hi_ul, hi_bg] = HiCursorLine()
--- 67,73 ----
  
    set nolist
    let &lcs = save_lcs
! endfunc
  
  func Test_highlight_eol_with_cursorline()
    let [hiCursorLine, hi_ul, hi_bg] = HiCursorLine()
*** ../vim-8.1.0710/src/testdir/test_hlsearch.vim	2018-09-02 15:07:21.977655529 +0200
--- src/testdir/test_hlsearch.vim	2019-01-09 22:36:38.901817415 +0100
***************
*** 1,6 ****
  " Test for v:hlsearch
  
! function! Test_hlsearch()
    new
    call setline(1, repeat(['aaa'], 10))
    set hlsearch nolazyredraw
--- 1,6 ----
  " Test for v:hlsearch
  
! func Test_hlsearch()
    new
    call setline(1, repeat(['aaa'], 10))
    set hlsearch nolazyredraw
***************
*** 30,36 ****
    call garbagecollect(1)
    call getchar(1)
    enew!
! endfunction
  
  func Test_hlsearch_hangs()
    if !has('reltime') || !has('float')
--- 30,36 ----
    call garbagecollect(1)
    call getchar(1)
    enew!
! endfunc
  
  func Test_hlsearch_hangs()
    if !has('reltime') || !has('float')
*** ../vim-8.1.0710/src/testdir/test_ins_complete.vim	2018-08-08 22:55:38.030420901 +0200
--- src/testdir/test_ins_complete.vim	2019-01-09 22:37:57.473043665 +0100
***************
*** 142,148 ****
    delfunc CompleteFunc
  endfunc
  
! function! s:CompleteDone_CompleteFuncDict( findstart, base )
    if a:findstart
      return 0
    endif
--- 142,148 ----
    delfunc CompleteFunc
  endfunc
  
! func s:CompleteDone_CompleteFuncDict( findstart, base )
    if a:findstart
      return 0
    endif
***************
*** 159,167 ****
              \ }
            \ ]
          \ }
! endfunction
  
! function! s:CompleteDone_CheckCompletedItemDict()
    call assert_equal( 'aword',          v:completed_item[ 'word' ] )
    call assert_equal( 'wrd',            v:completed_item[ 'abbr' ] )
    call assert_equal( 'extra text',     v:completed_item[ 'menu' ] )
--- 159,167 ----
              \ }
            \ ]
          \ }
! endfunc
  
! func s:CompleteDone_CheckCompletedItemDict()
    call assert_equal( 'aword',          v:completed_item[ 'word' ] )
    call assert_equal( 'wrd',            v:completed_item[ 'abbr' ] )
    call assert_equal( 'extra text',     v:completed_item[ 'menu' ] )
***************
*** 170,176 ****
    call assert_equal( 'test',           v:completed_item[ 'user_data' ] )
  
    let s:called_completedone = 1
! endfunction
  
  function Test_CompleteDoneDict()
    au CompleteDone * :call <SID>CompleteDone_CheckCompletedItemDict()
--- 170,176 ----
    call assert_equal( 'test',           v:completed_item[ 'user_data' ] )
  
    let s:called_completedone = 1
! endfunc
  
  function Test_CompleteDoneDict()
    au CompleteDone * :call <SID>CompleteDone_CheckCompletedItemDict()
***************
*** 186,192 ****
    au! CompleteDone
  endfunc
  
! function! s:CompleteDone_CompleteFuncDictNoUserData( findstart, base )
    if a:findstart
      return 0
    endif
--- 186,192 ----
    au! CompleteDone
  endfunc
  
! func s:CompleteDone_CompleteFuncDictNoUserData( findstart, base )
    if a:findstart
      return 0
    endif
***************
*** 202,210 ****
              \ }
            \ ]
          \ }
! endfunction
  
! function! s:CompleteDone_CheckCompletedItemDictNoUserData()
    call assert_equal( 'aword',          v:completed_item[ 'word' ] )
    call assert_equal( 'wrd',            v:completed_item[ 'abbr' ] )
    call assert_equal( 'extra text',     v:completed_item[ 'menu' ] )
--- 202,210 ----
              \ }
            \ ]
          \ }
! endfunc
  
! func s:CompleteDone_CheckCompletedItemDictNoUserData()
    call assert_equal( 'aword',          v:completed_item[ 'word' ] )
    call assert_equal( 'wrd',            v:completed_item[ 'abbr' ] )
    call assert_equal( 'extra text',     v:completed_item[ 'menu' ] )
***************
*** 213,219 ****
    call assert_equal( '',               v:completed_item[ 'user_data' ] )
  
    let s:called_completedone = 1
! endfunction
  
  function Test_CompleteDoneDictNoUserData()
    au CompleteDone * :call <SID>CompleteDone_CheckCompletedItemDictNoUserData()
--- 213,219 ----
    call assert_equal( '',               v:completed_item[ 'user_data' ] )
  
    let s:called_completedone = 1
! endfunc
  
  function Test_CompleteDoneDictNoUserData()
    au CompleteDone * :call <SID>CompleteDone_CheckCompletedItemDictNoUserData()
***************
*** 229,243 ****
    au! CompleteDone
  endfunc
  
! function! s:CompleteDone_CompleteFuncList( findstart, base )
    if a:findstart
      return 0
    endif
  
    return [ 'aword' ]
! endfunction
  
! function! s:CompleteDone_CheckCompletedItemList()
    call assert_equal( 'aword', v:completed_item[ 'word' ] )
    call assert_equal( '',      v:completed_item[ 'abbr' ] )
    call assert_equal( '',      v:completed_item[ 'menu' ] )
--- 229,243 ----
    au! CompleteDone
  endfunc
  
! func s:CompleteDone_CompleteFuncList( findstart, base )
    if a:findstart
      return 0
    endif
  
    return [ 'aword' ]
! endfunc
  
! func s:CompleteDone_CheckCompletedItemList()
    call assert_equal( 'aword', v:completed_item[ 'word' ] )
    call assert_equal( '',      v:completed_item[ 'abbr' ] )
    call assert_equal( '',      v:completed_item[ 'menu' ] )
***************
*** 246,252 ****
    call assert_equal( '',      v:completed_item[ 'user_data' ] )
  
    let s:called_completedone = 1
! endfunction
  
  function Test_CompleteDoneList()
    au CompleteDone * :call <SID>CompleteDone_CheckCompletedItemList()
--- 246,252 ----
    call assert_equal( '',      v:completed_item[ 'user_data' ] )
  
    let s:called_completedone = 1
! endfunc
  
  function Test_CompleteDoneList()
    au CompleteDone * :call <SID>CompleteDone_CheckCompletedItemList()
*** ../vim-8.1.0710/src/testdir/test_lambda.vim	2018-05-22 18:31:30.001365739 +0200
--- src/testdir/test_lambda.vim	2019-01-09 22:40:53.407381391 +0100
***************
*** 1,34 ****
  " Test for lambda and closure
  
! function! Test_lambda_feature()
    call assert_equal(1, has('lambda'))
! endfunction
  
! function! Test_lambda_with_filter()
    let s:x = 2
    call assert_equal([2, 3], filter([1, 2, 3], {i, v -> v >= s:x}))
! endfunction
  
! function! Test_lambda_with_map()
    let s:x = 1
    call assert_equal([2, 3, 4], map([1, 2, 3], {i, v -> v + s:x}))
! endfunction
  
! function! Test_lambda_with_sort()
    call assert_equal([1, 2, 3, 4, 7], sort([3,7,2,1,4], {a, b -> a - b}))
! endfunction
  
! function! Test_lambda_with_timer()
    if !has('timers')
      return
    endif
  
    let s:n = 0
    let s:timer_id = 0
!   function! s:Foo()
      "let n = 0
      let s:timer_id = timer_start(50, {-> execute("let s:n += 1 | echo s:n", "")}, {"repeat": -1})
!   endfunction
  
    call s:Foo()
    sleep 200ms
--- 1,34 ----
  " Test for lambda and closure
  
! func Test_lambda_feature()
    call assert_equal(1, has('lambda'))
! endfunc
  
! func Test_lambda_with_filter()
    let s:x = 2
    call assert_equal([2, 3], filter([1, 2, 3], {i, v -> v >= s:x}))
! endfunc
  
! func Test_lambda_with_map()
    let s:x = 1
    call assert_equal([2, 3, 4], map([1, 2, 3], {i, v -> v + s:x}))
! endfunc
  
! func Test_lambda_with_sort()
    call assert_equal([1, 2, 3, 4, 7], sort([3,7,2,1,4], {a, b -> a - b}))
! endfunc
  
! func Test_lambda_with_timer()
    if !has('timers')
      return
    endif
  
    let s:n = 0
    let s:timer_id = 0
!   func! s:Foo()
      "let n = 0
      let s:timer_id = timer_start(50, {-> execute("let s:n += 1 | echo s:n", "")}, {"repeat": -1})
!   endfunc
  
    call s:Foo()
    sleep 200ms
***************
*** 40,51 ****
    call assert_true(m > 1)
    call assert_true(s:n > m + 1)
    call assert_true(s:n < 9)
! endfunction
  
! function! Test_lambda_with_partial()
    let l:Cb = function({... -> ['zero', a:1, a:2, a:3]}, ['one', 'two'])
    call assert_equal(['zero', 'one', 'two', 'three'], l:Cb('three'))
! endfunction
  
  function Test_lambda_fails()
    call assert_equal(3, {a, b -> a + b}(1, 2))
--- 40,51 ----
    call assert_true(m > 1)
    call assert_true(s:n > m + 1)
    call assert_true(s:n < 9)
! endfunc
  
! func Test_lambda_with_partial()
    let l:Cb = function({... -> ['zero', a:1, a:2, a:3]}, ['one', 'two'])
    call assert_equal(['zero', 'one', 'two', 'three'], l:Cb('three'))
! endfunc
  
  function Test_lambda_fails()
    call assert_equal(3, {a, b -> a + b}(1, 2))
***************
*** 58,116 ****
    call assert_equal('foo', x['>'])
  endfunc
  
! function! Test_lambda_capture_by_reference()
    let v = 1
    let l:F = {x -> x + v}
    let v = 2
    call assert_equal(12, l:F(10))
! endfunction
  
! function! Test_lambda_side_effect()
!   function! s:update_and_return(arr)
      let a:arr[1] = 5
      return a:arr
!   endfunction
  
!   function! s:foo(arr)
      return {-> s:update_and_return(a:arr)}
!   endfunction
  
    let arr = [3,2,1]
    call assert_equal([3, 5, 1], s:foo(arr)())
! endfunction
  
! function! Test_lambda_refer_local_variable_from_other_scope()
!   function! s:foo(X)
      return a:X() " refer l:x in s:bar()
!   endfunction
  
!   function! s:bar()
      let x = 123
      return s:foo({-> x})
!   endfunction
  
    call assert_equal(123, s:bar())
! endfunction
  
! function! Test_lambda_do_not_share_local_variable()
!   function! s:define_funcs()
      let l:One = {-> split(execute("let a = 'abc' | echo a"))[0]}
      let l:Two = {-> exists("a") ? a : "no"}
      return [l:One, l:Two]
!   endfunction
  
    let l:F = s:define_funcs()
  
    call assert_equal('no', l:F[1]())
    call assert_equal('abc', l:F[0]())
    call assert_equal('no', l:F[1]())
! endfunction
  
! function! Test_lambda_closure_counter()
!   function! s:foo()
      let x = 0
      return {-> [execute("let x += 1"), x][-1]}
!   endfunction
  
    let l:F = s:foo()
    call test_garbagecollect_now()
--- 58,116 ----
    call assert_equal('foo', x['>'])
  endfunc
  
! func Test_lambda_capture_by_reference()
    let v = 1
    let l:F = {x -> x + v}
    let v = 2
    call assert_equal(12, l:F(10))
! endfunc
  
! func Test_lambda_side_effect()
!   func! s:update_and_return(arr)
      let a:arr[1] = 5
      return a:arr
!   endfunc
  
!   func! s:foo(arr)
      return {-> s:update_and_return(a:arr)}
!   endfunc
  
    let arr = [3,2,1]
    call assert_equal([3, 5, 1], s:foo(arr)())
! endfunc
  
! func Test_lambda_refer_local_variable_from_other_scope()
!   func! s:foo(X)
      return a:X() " refer l:x in s:bar()
!   endfunc
  
!   func! s:bar()
      let x = 123
      return s:foo({-> x})
!   endfunc
  
    call assert_equal(123, s:bar())
! endfunc
  
! func Test_lambda_do_not_share_local_variable()
!   func! s:define_funcs()
      let l:One = {-> split(execute("let a = 'abc' | echo a"))[0]}
      let l:Two = {-> exists("a") ? a : "no"}
      return [l:One, l:Two]
!   endfunc
  
    let l:F = s:define_funcs()
  
    call assert_equal('no', l:F[1]())
    call assert_equal('abc', l:F[0]())
    call assert_equal('no', l:F[1]())
! endfunc
  
! func Test_lambda_closure_counter()
!   func! s:foo()
      let x = 0
      return {-> [execute("let x += 1"), x][-1]}
!   endfunc
  
    let l:F = s:foo()
    call test_garbagecollect_now()
***************
*** 118,169 ****
    call assert_equal(2, l:F())
    call assert_equal(3, l:F())
    call assert_equal(4, l:F())
! endfunction
  
! function! Test_lambda_with_a_var()
!   function! s:foo()
      let x = 2
      return {... -> a:000 + [x]}
!   endfunction
!   function! s:bar()
      return s:foo()(1)
!   endfunction
  
    call assert_equal([1, 2], s:bar())
! endfunction
  
! function! Test_lambda_call_lambda_from_lambda()
!   function! s:foo(x)
      let l:F1 = {-> {-> a:x}}
      return {-> l:F1()}
!   endfunction
  
    let l:F = s:foo(1)
    call assert_equal(1, l:F()())
! endfunction
  
! function! Test_lambda_delfunc()
!   function! s:gen()
      let pl = l:
      let l:Foo = {-> get(pl, "Foo", get(pl, "Bar", {-> 0}))}
      let l:Bar = l:Foo
      delfunction l:Foo
      return l:Bar
!   endfunction
  
    let l:F = s:gen()
    call assert_fails(':call l:F()', 'E933:')
! endfunction
  
! function! Test_lambda_scope()
!   function! s:NewCounter()
      let c = 0
      return {-> [execute('let c += 1'), c][-1]}
!   endfunction
  
!   function! s:NewCounter2()
      return {-> [execute('let c += 100'), c][-1]}
!   endfunction
  
    let l:C = s:NewCounter()
    let l:D = s:NewCounter2()
--- 118,169 ----
    call assert_equal(2, l:F())
    call assert_equal(3, l:F())
    call assert_equal(4, l:F())
! endfunc
  
! func Test_lambda_with_a_var()
!   func! s:foo()
      let x = 2
      return {... -> a:000 + [x]}
!   endfunc
!   func! s:bar()
      return s:foo()(1)
!   endfunc
  
    call assert_equal([1, 2], s:bar())
! endfunc
  
! func Test_lambda_call_lambda_from_lambda()
!   func! s:foo(x)
      let l:F1 = {-> {-> a:x}}
      return {-> l:F1()}
!   endfunc
  
    let l:F = s:foo(1)
    call assert_equal(1, l:F()())
! endfunc
  
! func Test_lambda_delfunc()
!   func! s:gen()
      let pl = l:
      let l:Foo = {-> get(pl, "Foo", get(pl, "Bar", {-> 0}))}
      let l:Bar = l:Foo
      delfunction l:Foo
      return l:Bar
!   endfunc
  
    let l:F = s:gen()
    call assert_fails(':call l:F()', 'E933:')
! endfunc
  
! func Test_lambda_scope()
!   func! s:NewCounter()
      let c = 0
      return {-> [execute('let c += 1'), c][-1]}
!   endfunc
  
!   func! s:NewCounter2()
      return {-> [execute('let c += 100'), c][-1]}
!   endfunc
  
    let l:C = s:NewCounter()
    let l:D = s:NewCounter2()
***************
*** 171,207 ****
    call assert_equal(1, l:C())
    call assert_fails(':call l:D()', 'E15:') " E121: then E15:
    call assert_equal(2, l:C())
! endfunction
  
! function! Test_lambda_share_scope()
!   function! s:New()
      let c = 0
      let l:Inc0 = {-> [execute('let c += 1'), c][-1]}
      let l:Dec0 = {-> [execute('let c -= 1'), c][-1]}
      return [l:Inc0, l:Dec0]
!   endfunction
  
    let [l:Inc, l:Dec] = s:New()
  
    call assert_equal(1, l:Inc())
    call assert_equal(2, l:Inc())
    call assert_equal(1, l:Dec())
! endfunction
  
! function! Test_lambda_circular_reference()
!   function! s:Foo()
      let d = {}
      let d.f = {-> d}
      return d.f
!   endfunction
  
    call s:Foo()
    call test_garbagecollect_now()
    let i = 0 | while i < 10000 | call s:Foo() | let i+= 1 | endwhile
    call test_garbagecollect_now()
! endfunction
  
! function! Test_lambda_combination()
    call assert_equal(2, {x -> {x -> x}}(1)(2))
    call assert_equal(10, {y -> {x -> x(y)(10)}({y -> y})}({z -> z}))
    call assert_equal(5.0, {x -> {y -> x / y}}(10)(2.0))
--- 171,207 ----
    call assert_equal(1, l:C())
    call assert_fails(':call l:D()', 'E15:') " E121: then E15:
    call assert_equal(2, l:C())
! endfunc
  
! func Test_lambda_share_scope()
!   func! s:New()
      let c = 0
      let l:Inc0 = {-> [execute('let c += 1'), c][-1]}
      let l:Dec0 = {-> [execute('let c -= 1'), c][-1]}
      return [l:Inc0, l:Dec0]
!   endfunc
  
    let [l:Inc, l:Dec] = s:New()
  
    call assert_equal(1, l:Inc())
    call assert_equal(2, l:Inc())
    call assert_equal(1, l:Dec())
! endfunc
  
! func Test_lambda_circular_reference()
!   func! s:Foo()
      let d = {}
      let d.f = {-> d}
      return d.f
!   endfunc
  
    call s:Foo()
    call test_garbagecollect_now()
    let i = 0 | while i < 10000 | call s:Foo() | let i+= 1 | endwhile
    call test_garbagecollect_now()
! endfunc
  
! func Test_lambda_combination()
    call assert_equal(2, {x -> {x -> x}}(1)(2))
    call assert_equal(10, {y -> {x -> x(y)(10)}({y -> y})}({z -> z}))
    call assert_equal(5.0, {x -> {y -> x / y}}(10)(2.0))
***************
*** 214,230 ****
    let Z = {f -> {x -> f({y -> x(x)(y)})}({x -> f({y -> x(x)(y)})})}
    let Fact = {f -> {x -> x == 0 ? 1 : x * f(x - 1)}}
    call assert_equal(120, Z(Fact)(5))
! endfunction
  
! function! Test_closure_counter()
!   function! s:foo()
      let x = 0
!     function! s:bar() closure
        let x += 1
        return x
!     endfunction
      return function('s:bar')
!   endfunction
  
    let l:F = s:foo()
    call test_garbagecollect_now()
--- 214,230 ----
    let Z = {f -> {x -> f({y -> x(x)(y)})}({x -> f({y -> x(x)(y)})})}
    let Fact = {f -> {x -> x == 0 ? 1 : x * f(x - 1)}}
    call assert_equal(120, Z(Fact)(5))
! endfunc
  
! func Test_closure_counter()
!   func! s:foo()
      let x = 0
!     func! s:bar() closure
        let x += 1
        return x
!     endfunc
      return function('s:bar')
!   endfunc
  
    let l:F = s:foo()
    call test_garbagecollect_now()
***************
*** 232,261 ****
    call assert_equal(2, l:F())
    call assert_equal(3, l:F())
    call assert_equal(4, l:F())
! endfunction
  
! function! Test_closure_unlet()
!   function! s:foo()
      let x = 1
!     function! s:bar() closure
        unlet x
!     endfunction
      call s:bar()
      return l:
!   endfunction
  
    call assert_false(has_key(s:foo(), 'x'))
    call test_garbagecollect_now()
! endfunction
  
! function! LambdaFoo()
    let x = 0
!   function! LambdaBar() closure
      let x += 1
      return x
!   endfunction
    return function('LambdaBar')
! endfunction
  
  func Test_closure_refcount()
    let g:Count = LambdaFoo()
--- 232,261 ----
    call assert_equal(2, l:F())
    call assert_equal(3, l:F())
    call assert_equal(4, l:F())
! endfunc
  
! func Test_closure_unlet()
!   func! s:foo()
      let x = 1
!     func! s:bar() closure
        unlet x
!     endfunc
      call s:bar()
      return l:
!   endfunc
  
    call assert_false(has_key(s:foo(), 'x'))
    call test_garbagecollect_now()
! endfunc
  
! func LambdaFoo()
    let x = 0
!   func! LambdaBar() closure
      let x += 1
      return x
!   endfunc
    return function('LambdaBar')
! endfunc
  
  func Test_closure_refcount()
    let g:Count = LambdaFoo()
*** ../vim-8.1.0710/src/testdir/test_listdict.vim	2018-09-30 17:16:22.199142095 +0200
--- src/testdir/test_listdict.vim	2019-01-09 22:55:10.776013666 +0100
***************
*** 499,517 ****
  endfunc
  
  " No remove() of write-protected scope-level variable
! func! Tfunc(this_is_a_long_parameter_name)
    call assert_fails("call remove(a:, 'this_is_a_long_parameter_name')", 'E795')
! endfun
  func Test_dict_scope_var_remove()
!   call Tfunc('testval')
  endfunc
  
  " No extend() of write-protected scope-level variable
! func! Tfunc(this_is_a_long_parameter_name)
    call assert_fails("call extend(a:, {'this_is_a_long_parameter_name': 1234})", 'E742')
  endfunc
  func Test_dict_scope_var_extend()
!   call Tfunc('testval')
  endfunc
  
  " No :unlet of variable in locked scope
--- 499,517 ----
  endfunc
  
  " No remove() of write-protected scope-level variable
! func Tfunc1(this_is_a_long_parameter_name)
    call assert_fails("call remove(a:, 'this_is_a_long_parameter_name')", 'E795')
! endfunc
  func Test_dict_scope_var_remove()
!   call Tfunc1('testval')
  endfunc
  
  " No extend() of write-protected scope-level variable
! func Tfunc2(this_is_a_long_parameter_name)
    call assert_fails("call extend(a:, {'this_is_a_long_parameter_name': 1234})", 'E742')
  endfunc
  func Test_dict_scope_var_extend()
!   call Tfunc2('testval')
  endfunc
  
  " No :unlet of variable in locked scope
*** ../vim-8.1.0710/src/testdir/test_listlbr.vim	2017-03-01 17:12:54.000000000 +0100
--- src/testdir/test_listlbr.vim	2019-01-09 22:41:37.282979294 +0100
***************
*** 13,21 ****
    return ScreenLines(a:lnum, a:width)
  endfunction
  
! function! s:compare_lines(expect, actual)
    call assert_equal(join(a:expect, "\n"), join(a:actual, "\n"))
! endfunction
  
  function s:test_windows(...)
    call NewWindow(10, 20)
--- 13,21 ----
    return ScreenLines(a:lnum, a:width)
  endfunction
  
! func s:compare_lines(expect, actual)
    call assert_equal(join(a:expect, "\n"), join(a:actual, "\n"))
! endfunc
  
  function s:test_windows(...)
    call NewWindow(10, 20)
*** ../vim-8.1.0710/src/testdir/test_listlbr_utf8.vim	2017-06-25 17:52:58.000000000 +0200
--- src/testdir/test_listlbr_utf8.vim	2019-01-09 22:42:04.510731883 +0100
***************
*** 9,23 ****
  
  source view_util.vim
  
! function s:screen_lines(lnum, width) abort
    return ScreenLines(a:lnum, a:width)
! endfunction
  
! function! s:compare_lines(expect, actual)
    call assert_equal(a:expect, a:actual)
! endfunction
  
! function s:screen_attr(lnum, chars, ...) abort
    let line = getline(a:lnum)
    let attr = []
    let prefix = get(a:000, 0, 0)
--- 9,23 ----
  
  source view_util.vim
  
! func s:screen_lines(lnum, width) abort
    return ScreenLines(a:lnum, a:width)
! endfunc
  
! func s:compare_lines(expect, actual)
    call assert_equal(a:expect, a:actual)
! endfunc
  
! func s:screen_attr(lnum, chars, ...) abort
    let line = getline(a:lnum)
    let attr = []
    let prefix = get(a:000, 0, 0)
***************
*** 26,43 ****
      let attr += [screenattr(a:lnum, scol + prefix)]
    endfor
    return attr
! endfunction
  
! function s:test_windows(...)
    call NewWindow(10, 20)
    setl ts=4 sw=4 sts=4 linebreak sbr=+ wrap
    exe get(a:000, 0, '')
! endfunction
  
! function s:close_windows(...)
    call CloseWindow()
    exe get(a:000, 0, '')
! endfunction
  
  func Test_linebreak_with_fancy_listchars()
    call s:test_windows("setl list listchars=nbsp:\u2423,tab:\u2595\u2014,trail:\u02d1,eol:\ub6")
--- 26,43 ----
      let attr += [screenattr(a:lnum, scol + prefix)]
    endfor
    return attr
! endfunc
  
! func s:test_windows(...)
    call NewWindow(10, 20)
    setl ts=4 sw=4 sts=4 linebreak sbr=+ wrap
    exe get(a:000, 0, '')
! endfunc
  
! func s:close_windows(...)
    call CloseWindow()
    exe get(a:000, 0, '')
! endfunc
  
  func Test_linebreak_with_fancy_listchars()
    call s:test_windows("setl list listchars=nbsp:\u2423,tab:\u2595\u2014,trail:\u02d1,eol:\ub6")
*** ../vim-8.1.0710/src/testdir/test_marks.vim	2018-07-10 15:22:28.710142328 +0200
--- src/testdir/test_marks.vim	2019-01-09 22:42:25.030546439 +0100
***************
*** 1,6 ****
  
  " Test that a deleted mark is restored after delete-undo-redo-undo.
! function! Test_Restore_DelMark()
    enew!
    call append(0, ["	textline A", "	textline B", "	textline C"])
    normal! 2gg
--- 1,6 ----
  
  " Test that a deleted mark is restored after delete-undo-redo-undo.
! func Test_Restore_DelMark()
    enew!
    call append(0, ["	textline A", "	textline B", "	textline C"])
    normal! 2gg
***************
*** 11,20 ****
    call assert_equal(2, pos[1])
    call assert_equal(1, pos[2])
    enew!
! endfunction
  
  " Test that CTRL-A and CTRL-X updates last changed mark '[, '].
! function! Test_Incr_Marks()
    enew!
    call append(0, ["123 123 123", "123 123 123", "123 123 123"])
    normal! gg
--- 11,20 ----
    call assert_equal(2, pos[1])
    call assert_equal(1, pos[2])
    enew!
! endfunc
  
  " Test that CTRL-A and CTRL-X updates last changed mark '[, '].
! func Test_Incr_Marks()
    enew!
    call append(0, ["123 123 123", "123 123 123", "123 123 123"])
    normal! gg
***************
*** 23,29 ****
    call assert_equal("123 XXXXXXX", getline(2))
    call assert_equal("XXX 123 123", getline(3))
    enew!
! endfunction
  
  func Test_setpos()
    new one
--- 23,29 ----
    call assert_equal("123 XXXXXXX", getline(2))
    call assert_equal("XXX 123 123", getline(3))
    enew!
! endfunc
  
  func Test_setpos()
    new one
*** ../vim-8.1.0710/src/testdir/test_matchadd_conceal.vim	2018-02-27 20:11:53.000000000 +0100
--- src/testdir/test_matchadd_conceal.vim	2019-01-09 22:43:19.454058524 +0100
***************
*** 9,15 ****
  
  source shared.vim
  
! function! Test_simple_matchadd()
    new
  
    1put='# This is a Test'
--- 9,15 ----
  
  source shared.vim
  
! func Test_simple_matchadd()
    new
  
    1put='# This is a Test'
***************
*** 29,37 ****
    call assert_equal(screenattr(lnum, 1), screenattr(lnum, 16))
  
    quit!
! endfunction
  
! function! Test_simple_matchadd_and_conceal()
    new
    setlocal concealcursor=n conceallevel=1
  
--- 29,37 ----
    call assert_equal(screenattr(lnum, 1), screenattr(lnum, 16))
  
    quit!
! endfunc
  
! func Test_simple_matchadd_and_conceal()
    new
    setlocal concealcursor=n conceallevel=1
  
***************
*** 51,59 ****
    call assert_equal(screenattr(lnum, 1), screenattr(lnum, 16))
  
    quit!
! endfunction
  
! function! Test_matchadd_and_conceallevel_3()
    new
  
    setlocal conceallevel=3
--- 51,59 ----
    call assert_equal(screenattr(lnum, 1), screenattr(lnum, 16))
  
    quit!
! endfunc
  
! func Test_matchadd_and_conceallevel_3()
    new
  
    setlocal conceallevel=3
***************
*** 92,100 ****
  
    syntax off
    quit!
! endfunction
  
! function! Test_default_conceal_char()
    new
    setlocal concealcursor=n conceallevel=1
  
--- 92,100 ----
  
    syntax off
    quit!
! endfunc
  
! func Test_default_conceal_char()
    new
    setlocal concealcursor=n conceallevel=1
  
***************
*** 128,136 ****
  
    let &listchars = listchars_save
    quit!
! endfunction
  
! function! Test_syn_and_match_conceal()
    new
    setlocal concealcursor=n conceallevel=1
  
--- 128,136 ----
  
    let &listchars = listchars_save
    quit!
! endfunc
  
! func Test_syn_and_match_conceal()
    new
    setlocal concealcursor=n conceallevel=1
  
***************
*** 164,172 ****
  
    syntax off
    quit!
! endfunction
  
! function! Test_clearmatches()
    new
    setlocal concealcursor=n conceallevel=1
  
--- 164,172 ----
  
    syntax off
    quit!
! endfunc
  
! func Test_clearmatches()
    new
    setlocal concealcursor=n conceallevel=1
  
***************
*** 203,211 ****
    call assert_equal({'group': 'Conceal', 'pattern': '\%2l ', 'priority': 10, 'id': a[0].id, 'conceal': 'Z'}, a[0])
  
    quit!
! endfunction
  
! function! Test_using_matchaddpos()
    new
    setlocal concealcursor=n conceallevel=1
    " set filetype and :syntax on to change screenattr()
--- 203,211 ----
    call assert_equal({'group': 'Conceal', 'pattern': '\%2l ', 'priority': 10, 'id': a[0].id, 'conceal': 'Z'}, a[0])
  
    quit!
! endfunc
  
! func Test_using_matchaddpos()
    new
    setlocal concealcursor=n conceallevel=1
    " set filetype and :syntax on to change screenattr()
***************
*** 234,242 ****
  
    syntax off
    quit!
! endfunction
  
! function! Test_matchadd_repeat_conceal_with_syntax_off()
    new
  
    " To test targets in the same line string is replaced with conceal char
--- 234,242 ----
  
    syntax off
    quit!
! endfunc
  
! func Test_matchadd_repeat_conceal_with_syntax_off()
    new
  
    " To test targets in the same line string is replaced with conceal char
***************
*** 253,261 ****
    call assert_equal('t_tt', Screenline(2))
  
    quit!
! endfunction
  
! function! Test_matchadd_and_syn_conceal()
    new
    let cnt='Inductive bool : Type := | true : bool | false : bool.'
    let expect = 'Inductive - : Type := | true : - | false : -.'
--- 253,261 ----
    call assert_equal('t_tt', Screenline(2))
  
    quit!
! endfunc
  
! func Test_matchadd_and_syn_conceal()
    new
    let cnt='Inductive bool : Type := | true : bool | false : bool.'
    let expect = 'Inductive - : Type := | true : - | false : -.'
***************
*** 276,279 ****
    call assert_notequal(screenattr(1, 10) , screenattr(1, 11))
    call assert_notequal(screenattr(1, 11) , screenattr(1, 12))
    call assert_equal(screenattr(1, 11) , screenattr(1, 32))
! endfunction
--- 276,279 ----
    call assert_notequal(screenattr(1, 10) , screenattr(1, 11))
    call assert_notequal(screenattr(1, 11) , screenattr(1, 12))
    call assert_equal(screenattr(1, 11) , screenattr(1, 32))
! endfunc
*** ../vim-8.1.0710/src/testdir/test_matchadd_conceal_utf8.vim	2016-07-21 20:10:48.000000000 +0200
--- src/testdir/test_matchadd_conceal_utf8.vim	2019-01-09 22:43:42.721851560 +0100
***************
*** 7,25 ****
    set term=ansi
  endif
  
! function! s:screenline(lnum) abort
    let line = []
    for c in range(1, winwidth(0))
      call add(line, nr2char(screenchar(a:lnum, c)))
    endfor
    return s:trim(join(line, ''))
! endfunction
  
! function! s:trim(str) abort
    return matchstr(a:str,'^\s*\zs.\{-}\ze\s*$')
! endfunction
  
! function! Test_match_using_multibyte_conceal_char()
    new
    setlocal concealcursor=n conceallevel=1
  
--- 7,25 ----
    set term=ansi
  endif
  
! func s:screenline(lnum) abort
    let line = []
    for c in range(1, winwidth(0))
      call add(line, nr2char(screenchar(a:lnum, c)))
    endfor
    return s:trim(join(line, ''))
! endfunc
  
! func s:trim(str) abort
    return matchstr(a:str,'^\s*\zs.\{-}\ze\s*$')
! endfunc
  
! func Test_match_using_multibyte_conceal_char()
    new
    setlocal concealcursor=n conceallevel=1
  
***************
*** 40,43 ****
    call assert_equal(screenattr(lnum, 1), screenattr(lnum, 16))
  
    quit!
! endfunction
--- 40,43 ----
    call assert_equal(screenattr(lnum, 1), screenattr(lnum, 16))
  
    quit!
! endfunc
*** ../vim-8.1.0710/src/testdir/test_messages.vim	2018-12-22 13:27:59.119503967 +0100
--- src/testdir/test_messages.vim	2019-01-09 22:44:04.793656085 +0100
***************
*** 43,49 ****
  " indicator (e.g., "-- INSERT --") when ":stopinsert" is invoked.  Message
  " output could then be disturbed when 'cmdheight' was greater than one.
  " This test ensures that the bugfix for this issue remains in place.
! function! Test_stopinsert_does_not_break_message_output()
    set cmdheight=2
    redraw!
  
--- 43,49 ----
  " indicator (e.g., "-- INSERT --") when ":stopinsert" is invoked.  Message
  " output could then be disturbed when 'cmdheight' was greater than one.
  " This test ensures that the bugfix for this issue remains in place.
! func Test_stopinsert_does_not_break_message_output()
    set cmdheight=2
    redraw!
  
***************
*** 58,64 ****
    redraw!
  
    set cmdheight&
! endfunction
  
  func Test_message_completion()
    call feedkeys(":message \<C-A>\<C-B>\"\<CR>", 'tx')
--- 58,64 ----
    redraw!
  
    set cmdheight&
! endfunc
  
  func Test_message_completion()
    call feedkeys(":message \<C-A>\<C-B>\"\<CR>", 'tx')
*** ../vim-8.1.0710/src/testdir/test_number.vim	2017-02-23 18:23:28.000000000 +0100
--- src/testdir/test_number.vim	2019-01-09 22:44:44.669304914 +0100
***************
*** 2,24 ****
  
  source view_util.vim
  
! func! s:screen_lines(start, end) abort
    return ScreenLines([a:start, a:end], 8)
  endfunc
  
! func! s:compare_lines(expect, actual)
    call assert_equal(a:expect, a:actual)
  endfunc
  
! func! s:test_windows(h, w) abort
    call NewWindow(a:h, a:w)
  endfunc
  
! func! s:close_windows() abort
    call CloseWindow()
  endfunc
  
! func! s:validate_cursor() abort
    " update skipcol.
    " wincol():
    "   f_wincol
--- 2,24 ----
  
  source view_util.vim
  
! func s:screen_lines(start, end) abort
    return ScreenLines([a:start, a:end], 8)
  endfunc
  
! func s:compare_lines(expect, actual)
    call assert_equal(a:expect, a:actual)
  endfunc
  
! func s:test_windows(h, w) abort
    call NewWindow(a:h, a:w)
  endfunc
  
! func s:close_windows() abort
    call CloseWindow()
  endfunc
  
! func s:validate_cursor() abort
    " update skipcol.
    " wincol():
    "   f_wincol
*** ../vim-8.1.0710/src/testdir/test_options.vim	2018-10-02 15:06:36.761478333 +0200
--- src/testdir/test_options.vim	2019-01-09 22:45:10.113082099 +0100
***************
*** 1,6 ****
  " Test for options
  
! function! Test_whichwrap()
    set whichwrap=b,s
    call assert_equal('b,s', &whichwrap)
  
--- 1,6 ----
  " Test for options
  
! func Test_whichwrap()
    set whichwrap=b,s
    call assert_equal('b,s', &whichwrap)
  
***************
*** 20,35 ****
    call assert_equal('h', &whichwrap)
  
    set whichwrap&
! endfunction
  
! function! Test_isfname()
    " This used to cause Vim to access uninitialized memory.
    set isfname=
    call assert_equal("~X", expand("~X"))
    set isfname&
! endfunction
  
! function Test_wildchar()
    " Empty 'wildchar' used to access invalid memory.
    call assert_fails('set wildchar=', 'E521:')
    call assert_fails('set wildchar=abc', 'E521:')
--- 20,35 ----
    call assert_equal('h', &whichwrap)
  
    set whichwrap&
! endfunc
  
! func Test_isfname()
    " This used to cause Vim to access uninitialized memory.
    set isfname=
    call assert_equal("~X", expand("~X"))
    set isfname&
! endfunc
  
! func Test_wildchar()
    " Empty 'wildchar' used to access invalid memory.
    call assert_fails('set wildchar=', 'E521:')
    call assert_fails('set wildchar=abc', 'E521:')
***************
*** 40,48 ****
    let a=execute('set wildchar?')
    call assert_equal("\n  wildchar=<Esc>", a)
    set wildchar&
! endfunction
  
! function Test_options()
    let caught = 'ok'
    try
      options
--- 40,48 ----
    let a=execute('set wildchar?')
    call assert_equal("\n  wildchar=<Esc>", a)
    set wildchar&
! endfunc
  
! func Test_options()
    let caught = 'ok'
    try
      options
***************
*** 53,61 ****
  
    " close option-window
    close
! endfunction
  
! function Test_path_keep_commas()
    " Test that changing 'path' keeps two commas.
    set path=foo,,bar
    set path-=bar
--- 53,61 ----
  
    " close option-window
    close
! endfunc
  
! func Test_path_keep_commas()
    " Test that changing 'path' keeps two commas.
    set path=foo,,bar
    set path-=bar
***************
*** 63,69 ****
    call assert_equal('foo,,bar', &path)
  
    set path&
! endfunction
  
  func Test_signcolumn()
    if has('signs')
--- 63,69 ----
    call assert_equal('foo,,bar', &path)
  
    set path&
! endfunc
  
  func Test_signcolumn()
    if has('signs')
*** ../vim-8.1.0710/src/testdir/test_partial.vim	2016-08-11 22:46:37.000000000 +0200
--- src/testdir/test_partial.vim	2019-01-09 22:45:36.684850393 +0100
***************
*** 114,122 ****
    call OuterCall()
  endfunc
  
! function! s:cache_clear() dict
    return self.name
! endfunction
  
  func Test_script_function_in_dict()
    let s:obj = {'name': 'foo'}
--- 114,122 ----
    call OuterCall()
  endfunc
  
! func s:cache_clear() dict
    return self.name
! endfunc
  
  func Test_script_function_in_dict()
    let s:obj = {'name': 'foo'}
***************
*** 136,145 ****
    call assert_equal('bar', B())
  endfunc
  
! function! s:cache_arg(arg) dict
    let s:result = self.name . '/' . a:arg
    return s:result
! endfunction
  
  func Test_script_function_in_dict_arg()
    let s:obj = {'name': 'foo'}
--- 136,145 ----
    call assert_equal('bar', B())
  endfunc
  
! func s:cache_arg(arg) dict
    let s:result = self.name . '/' . a:arg
    return s:result
! endfunc
  
  func Test_script_function_in_dict_arg()
    let s:obj = {'name': 'foo'}
*** ../vim-8.1.0710/src/testdir/test_smartindent.vim	2017-08-03 17:53:54.000000000 +0200
--- src/testdir/test_smartindent.vim	2019-01-09 22:46:34.496349516 +0100
***************
*** 1,24 ****
  " Tests for smartindent
  
  " Tests for not doing smart indenting when it isn't set.
! function! Test_nosmartindent()
    new
    call append(0, ["		some test text",
!       	\ "		test text",
!       	\ "test text",
!       	\ "		test text"])
    set nocindent nosmartindent autoindent
    exe "normal! gg/some\<CR>"
    exe "normal! 2cc#test\<Esc>"
    call assert_equal("		#test", getline(1))
    enew! | close
! endfunction
  
! function MyIndent()
! endfunction
  
  " When 'indentexpr' is set, setting 'si' has no effect.
! function Test_smartindent_has_no_effect()
    new
    exe "normal! i\<Tab>one\<Esc>"
    set noautoindent
--- 1,24 ----
  " Tests for smartindent
  
  " Tests for not doing smart indenting when it isn't set.
! func Test_nosmartindent()
    new
    call append(0, ["		some test text",
! 	\ "		test text",
! 	\ "test text",
! 	\ "		test text"])
    set nocindent nosmartindent autoindent
    exe "normal! gg/some\<CR>"
    exe "normal! 2cc#test\<Esc>"
    call assert_equal("		#test", getline(1))
    enew! | close
! endfunc
  
! func MyIndent()
! endfunc
  
  " When 'indentexpr' is set, setting 'si' has no effect.
! func Test_smartindent_has_no_effect()
    new
    exe "normal! i\<Tab>one\<Esc>"
    set noautoindent
***************
*** 36,41 ****
    set smartindent&
    set indentexpr&
    bwipe!
! endfunction
  
  " vim: shiftwidth=2 sts=2 expandtab
--- 36,41 ----
    set smartindent&
    set indentexpr&
    bwipe!
! endfunc
  
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.1.0710/src/testdir/test_substitute.vim	2017-10-26 19:57:28.000000000 +0200
--- src/testdir/test_substitute.vim	2019-01-09 22:47:00.292127354 +0100
***************
*** 1,6 ****
  " Tests for multi-line regexps with ":s".
  
! function! Test_multiline_subst()
    enew!
    call append(0, ["1 aa",
  	      \ "bb",
--- 1,6 ----
  " Tests for multi-line regexps with ":s".
  
! func Test_multiline_subst()
    enew!
    call append(0, ["1 aa",
  	      \ "bb",
***************
*** 38,46 ****
    call assert_equal('7x7f', getline(12))
    call assert_equal('xxxxx', getline(13))
    enew!
! endfunction
  
! function! Test_substitute_variants()
    " Validate that all the 2-/3-letter variants which embed the flags into the
    " command name actually work.
    enew!
--- 38,46 ----
    call assert_equal('7x7f', getline(12))
    call assert_equal('xxxxx', getline(13))
    enew!
! endfunc
  
! func Test_substitute_variants()
    " Validate that all the 2-/3-letter variants which embed the flags into the
    " command name actually work.
    enew!
***************
*** 105,111 ****
        call assert_equal(var.exp, getline('.'), msg)
      endfor
    endfor
! endfunction
  
  func Test_substitute_repeat()
    " This caused an invalid memory access.
--- 105,111 ----
        call assert_equal(var.exp, getline('.'), msg)
      endfor
    endfor
! endfunc
  
  func Test_substitute_repeat()
    " This caused an invalid memory access.
***************
*** 401,409 ****
  
    " List entry format: [input, cmd, output]
    let tests = [ ['aAa', "s/A/\\=substitute(submatch(0), '.', '\\', '')/",
! 	      \ 			['a\a']],
  	      \ ['bBb', "s/B/\\=substitute(submatch(0), '.', '\\', '')/",
! 	      \   			['b\b']],
  	      \ ['cCc', "s/C/\\=substitute(submatch(0), '.', '\<C-V>\<C-M>', '')/",
  	      \				["c\<C-V>", 'c']],
  	      \ ['dDd', "s/D/\\=substitute(submatch(0), '.', '\\\<C-V>\<C-M>', '')/",
--- 401,409 ----
  
    " List entry format: [input, cmd, output]
    let tests = [ ['aAa', "s/A/\\=substitute(submatch(0), '.', '\\', '')/",
! 	      \				['a\a']],
  	      \ ['bBb', "s/B/\\=substitute(submatch(0), '.', '\\', '')/",
! 	      \				['b\b']],
  	      \ ['cCc', "s/C/\\=substitute(submatch(0), '.', '\<C-V>\<C-M>', '')/",
  	      \				["c\<C-V>", 'c']],
  	      \ ['dDd', "s/D/\\=substitute(submatch(0), '.', '\\\<C-V>\<C-M>', '')/",
*** ../vim-8.1.0710/src/testdir/test_system.vim	2017-12-20 22:05:10.000000000 +0100
--- src/testdir/test_system.vim	2019-01-09 22:47:27.771891532 +0100
***************
*** 1,6 ****
  " Tests for system() and systemlist()
  
! function! Test_System()
    if !executable('echo') || !executable('cat') || !executable('wc')
      return
    endif
--- 1,6 ----
  " Tests for system() and systemlist()
  
! func Test_System()
    if !executable('echo') || !executable('cat') || !executable('wc')
      return
    endif
***************
*** 45,53 ****
    bwipe!
  
    call assert_fails('call system("wc -l", 99999)', 'E86:')
! endfunction
  
! function! Test_system_exmode()
    if has('unix') " echo $? only works on Unix
      let cmd = ' -es -u NONE -c "source Xscript" +q; echo "result=$?"'
      " Need to put this in a script, "catch" isn't found after an unknown
--- 45,53 ----
    bwipe!
  
    call assert_fails('call system("wc -l", 99999)', 'E86:')
! endfunc
  
! func Test_system_exmode()
    if has('unix') " echo $? only works on Unix
      let cmd = ' -es -u NONE -c "source Xscript" +q; echo "result=$?"'
      " Need to put this in a script, "catch" isn't found after an unknown
*** ../vim-8.1.0710/src/testdir/test_terminal.vim	2018-12-24 19:15:15.551304134 +0100
--- src/testdir/test_terminal.vim	2019-01-09 22:47:35.611824406 +0100
***************
*** 122,128 ****
    unlet g:job
  endfunc
  
! func! s:Nasty_exit_cb(job, st)
    exe g:buf . 'bwipe!'
    let g:buf = 0
  endfunc
--- 122,128 ----
    unlet g:job
  endfunc
  
! func s:Nasty_exit_cb(job, st)
    exe g:buf . 'bwipe!'
    let g:buf = 0
  endfunc
***************
*** 1727,1729 ****
--- 1727,1753 ----
    let term = term_start('false', {'term_finish': 'close'})
    call WaitForAssert({-> assert_equal(v:null, term_getjob(term)) })
  endfunc
+ 
+ func Test_term_gettitle()
+   if !has('title') || empty(&t_ts)
+     return
+   endif
+   " TODO: this fails on Travis
+   return
+ 
+   " term_gettitle() returns an empty string for a non-terminal buffer
+   " or for a non-existing buffer.
+   call assert_equal('', term_gettitle(bufnr('%')))
+   call assert_equal('', term_gettitle(bufnr('$') + 1))
+ 
+   let term = term_start([GetVimProg(), '--clean', '-c', 'set noswapfile'])
+   call WaitForAssert({-> assert_equal('[No Name] - VIM', term_gettitle(term)) })
+ 
+   call term_sendkeys(term, ":e Xfoo\r")
+   call WaitForAssert({-> assert_match('Xfoo (.*[/\\]testdir) - VIM', term_gettitle(term)) })
+ 
+   call term_sendkeys(term, ":set titlestring=foo\r")
+   call WaitForAssert({-> assert_equal('foo', term_gettitle(term)) })
+ 
+   exe term . 'bwipe!'
+ endfunc
*** ../vim-8.1.0710/src/testdir/test_textobjects.vim	2018-08-16 21:37:46.389318767 +0200
--- src/testdir/test_textobjects.vim	2019-01-09 22:47:49.067709349 +0100
***************
*** 236,242 ****
    %delete _
  endfunc
  
! func! Test_sentence_with_cursor_on_delimiter()
    enew!
    call setline(1, "A '([sentence.])'  A sentence.")
  
--- 236,242 ----
    %delete _
  endfunc
  
! func Test_sentence_with_cursor_on_delimiter()
    enew!
    call setline(1, "A '([sentence.])'  A sentence.")
  
*** ../vim-8.1.0710/src/testdir/test_utf8.vim	2017-03-18 22:49:29.000000000 +0100
--- src/testdir/test_utf8.vim	2019-01-09 22:48:16.191477993 +0100
***************
*** 25,41 ****
  endfunc
  
  " Test for customlist completion
! function! CustomComplete1(lead, line, pos)
  	return ['あ', 'い']
! endfunction
  
! function! CustomComplete2(lead, line, pos)
  	return ['あたし', 'あたま', 'あたりめ']
! endfunction
  
! function! CustomComplete3(lead, line, pos)
  	return ['Nこ', 'Nん', 'Nぶ']
! endfunction
  
  func Test_customlist_completion()
    command -nargs=1 -complete=customlist,CustomComplete1 Test1 echo
--- 25,41 ----
  endfunc
  
  " Test for customlist completion
! func CustomComplete1(lead, line, pos)
  	return ['あ', 'い']
! endfunc
  
! func CustomComplete2(lead, line, pos)
  	return ['あたし', 'あたま', 'あたりめ']
! endfunc
  
! func CustomComplete3(lead, line, pos)
  	return ['Nこ', 'Nん', 'Nぶ']
! endfunc
  
  func Test_customlist_completion()
    command -nargs=1 -complete=customlist,CustomComplete1 Test1 echo
*** ../vim-8.1.0710/src/testdir/test_utf8_comparisons.vim	2017-06-27 18:20:28.000000000 +0200
--- src/testdir/test_utf8_comparisons.vim	2019-01-09 22:48:57.287128840 +0100
***************
*** 5,16 ****
    finish
  endif
  
! function! Ch(a, op, b, expected)
    call assert_equal(eval(printf('"%s" %s "%s"', a:a, a:op, a:b)), a:expected,
          \ printf('"%s" %s "%s" should return %d', a:a, a:op, a:b, a:expected))
! endfunction
  
! function! Chk(a, b, result)
    if a:result == 0
      call Ch(a:a, '==?', a:b, 1)
      call Ch(a:a, '!=?', a:b, 0)
--- 5,16 ----
    finish
  endif
  
! func Ch(a, op, b, expected)
    call assert_equal(eval(printf('"%s" %s "%s"', a:a, a:op, a:b)), a:expected,
          \ printf('"%s" %s "%s" should return %d', a:a, a:op, a:b, a:expected))
! endfunc
  
! func Chk(a, b, result)
    if a:result == 0
      call Ch(a:a, '==?', a:b, 1)
      call Ch(a:a, '!=?', a:b, 0)
***************
*** 33,58 ****
      call Ch(a:a, '<?', a:b, 1)
      call Ch(a:a, '>?', a:b, 0)
    endif
! endfunction
  
! function! Check(a, b, result)
    call Chk(a:a, a:b, a:result)
    call Chk(a:b, a:a, -a:result)
! endfunction
  
! function! LT(a, b)
    call Check(a:a, a:b, -1)
! endfunction
  
! function! GT(a, b)
    call Check(a:a, a:b, 1)
! endfunction
  
! function! EQ(a, b)
    call Check(a:a, a:b, 0)
! endfunction
  
! function Test_comparisons()
    call EQ('', '')
    call LT('', 'a')
    call EQ('abc', 'abc')
--- 33,58 ----
      call Ch(a:a, '<?', a:b, 1)
      call Ch(a:a, '>?', a:b, 0)
    endif
! endfunc
  
! func Check(a, b, result)
    call Chk(a:a, a:b, a:result)
    call Chk(a:b, a:a, -a:result)
! endfunc
  
! func LT(a, b)
    call Check(a:a, a:b, -1)
! endfunc
  
! func GT(a, b)
    call Check(a:a, a:b, 1)
! endfunc
  
! func EQ(a, b)
    call Check(a:a, a:b, 0)
! endfunc
  
! func Test_comparisons()
    call EQ('', '')
    call LT('', 'a')
    call EQ('abc', 'abc')
***************
*** 85,95 ****
    for n in range(0xC0, 0xFF)
      call LT(printf('xYz\xc2\x%.2XUvW', n), printf('XyZ\xc2\x%.2XuVw', n))
    endfor
! endfunction
  
  " test that g~ap changes one paragraph only.
! function Test_gap()
    new
    call feedkeys("iabcd\n\ndefggg0g~ap", "tx")
    call assert_equal(["ABCD", "", "defg"], getline(1,3))
! endfunction
--- 85,95 ----
    for n in range(0xC0, 0xFF)
      call LT(printf('xYz\xc2\x%.2XUvW', n), printf('XyZ\xc2\x%.2XuVw', n))
    endfor
! endfunc
  
  " test that g~ap changes one paragraph only.
! func Test_gap()
    new
    call feedkeys("iabcd\n\ndefggg0g~ap", "tx")
    call assert_equal(["ABCD", "", "defg"], getline(1,3))
! endfunc
*** ../vim-8.1.0710/src/testdir/test_vartabs.vim	2018-11-22 03:07:30.948596188 +0100
--- src/testdir/test_vartabs.vim	2019-01-09 22:49:05.211061699 +0100
***************
*** 134,140 ****
    bwipeout!
  endfunc
  
! func! Test_vartabs_breakindent()
    if !exists("+breakindent")
      return
    endif
--- 134,140 ----
    bwipeout!
  endfunc
  
! func Test_vartabs_breakindent()
    if !exists("+breakindent")
      return
    endif
*** ../vim-8.1.0710/src/testdir/test_vimscript.vim	2017-09-23 18:58:18.000000000 +0200
--- src/testdir/test_vimscript.vim	2019-01-09 22:50:51.474166455 +0100
***************
*** 5,15 ****
  " Test environment							    {{{1
  "-------------------------------------------------------------------------------
  
! com!               XpathINIT  let g:Xpath = ''
  com! -nargs=1 -bar Xpath      let g:Xpath = g:Xpath . <args>
  
  " Append a message to the "messages" file
! func! Xout(text)
      split messages
      $put =a:text
      wq
--- 5,15 ----
  " Test environment							    {{{1
  "-------------------------------------------------------------------------------
  
! com!		   XpathINIT  let g:Xpath = ''
  com! -nargs=1 -bar Xpath      let g:Xpath = g:Xpath . <args>
  
  " Append a message to the "messages" file
! func Xout(text)
      split messages
      $put =a:text
      wq
***************
*** 25,31 ****
  " in the variable argument list.  This function is useful if similar tests are
  " to be made for a ":return" from a function call or a ":finish" in a script
  " file.
! function! MakeScript(funcname, ...)
      let script = tempname()
      execute "redir! >" . script
      execute "function" a:funcname
--- 25,31 ----
  " in the variable argument list.  This function is useful if similar tests are
  " to be made for a ":return" from a function call or a ":finish" in a script
  " file.
! func MakeScript(funcname, ...)
      let script = tempname()
      execute "redir! >" . script
      execute "function" a:funcname
***************
*** 50,56 ****
      write
      bwipeout
      return script
! endfunction
  
  " ExecAsScript - Source a temporary script made from a function.	    {{{2
  "
--- 50,56 ----
      write
      bwipeout
      return script
! endfunc
  
  " ExecAsScript - Source a temporary script made from a function.	    {{{2
  "
***************
*** 301,309 ****
  "
  let calls = ""
  com! -nargs=1 CALL
!     	\ if !exists("calls") && !exists("outer") |
!     	\ let g:calls = g:calls . <args> |
!     	\ endif
  
  let i = 0
  while i < 3
--- 301,309 ----
  "
  let calls = ""
  com! -nargs=1 CALL
! 	    \ if !exists("calls") && !exists("outer") |
! 	    \ let g:calls = g:calls . <args> |
! 	    \ endif
  
  let i = 0
  while i < 3
***************
*** 357,363 ****
  if exists("*F1")
      call F1("F1")
      if exists("*G1")
!         call G1("G1")
      endif
  endif
  
--- 357,363 ----
  if exists("*F1")
      call F1("F1")
      if exists("*G1")
!        call G1("G1")
      endif
  endif
  
***************
*** 367,379 ****
  if exists("*F2")
      call F2(2, "F2")
      if exists("*G21")
!         call G21("G21")
      endif
      if exists("*G22")
!         call G22("G22")
      endif
      if exists("*G23")
!         call G23("G23")
      endif
  endif
  
--- 367,379 ----
  if exists("*F2")
      call F2(2, "F2")
      if exists("*G21")
!        call G21("G21")
      endif
      if exists("*G22")
!        call G22("G22")
      endif
      if exists("*G23")
!        call G23("G23")
      endif
  endif
  
***************
*** 383,395 ****
  if exists("*F3")
      call F3(3, "F3")
      if exists("*G31")
!         call G31("G31")
      endif
      if exists("*G32")
!         call G32("G32")
      endif
      if exists("*G33")
!         call G33("G33")
      endif
  endif
  
--- 383,395 ----
  if exists("*F3")
      call F3(3, "F3")
      if exists("*G31")
!        call G31("G31")
      endif
      if exists("*G32")
!        call G32("G32")
      endif
      if exists("*G33")
!        call G33("G33")
      endif
  endif
  
***************
*** 640,646 ****
  	endif
      endif
      return match
! endfunction
  
  if 1 || strlen("\"") | Xpath 'a'
      Xpath 'b'
--- 640,646 ----
  	endif
      endif
      return match
! endfunc
  
  if 1 || strlen("\"") | Xpath 'a'
      Xpath 'b'
***************
*** 1032,1042 ****
      call assert_true(empty(v:none))
  
      func ChangeYourMind()
!       try
! 	return v:true
!       finally
!         return 'something else'
!       endtry
      endfunc
  
      call ChangeYourMind()
--- 1032,1042 ----
      call assert_true(empty(v:none))
  
      func ChangeYourMind()
! 	try
! 	    return v:true
! 	finally
! 	    return 'something else'
! 	endtry
      endfunc
  
      call ChangeYourMind()
***************
*** 1250,1319 ****
  func Test_script_lines()
      " :append
      try
!         call DefineFunction('T_Append', [
!                     \ 'append',
!                     \ 'py <<EOS',
!                     \ '.',
!                     \ ])
      catch
!         call assert_report("Can't define function")
      endtry
      try
!         call DefineFunction('T_Append', [
!                     \ 'append',
!                     \ 'abc',
!                     \ ])
!         call assert_report("Shouldn't be able to define function")
      catch
!         call assert_exception('Vim(function):E126: Missing :endfunction')
      endtry
  
      " :change
      try
!         call DefineFunction('T_Change', [
!                     \ 'change',
!                     \ 'py <<EOS',
!                     \ '.',
!                     \ ])
      catch
!         call assert_report("Can't define function")
      endtry
      try
!         call DefineFunction('T_Change', [
!                     \ 'change',
!                     \ 'abc',
!                     \ ])
!         call assert_report("Shouldn't be able to define function")
      catch
!         call assert_exception('Vim(function):E126: Missing :endfunction')
      endtry
  
      " :insert
      try
!         call DefineFunction('T_Insert', [
!                     \ 'insert',
!                     \ 'py <<EOS',
!                     \ '.',
!                     \ ])
      catch
!         call assert_report("Can't define function")
      endtry
      try
!         call DefineFunction('T_Insert', [
!                     \ 'insert',
!                     \ 'abc',
!                     \ ])
!         call assert_report("Shouldn't be able to define function")
      catch
!         call assert_exception('Vim(function):E126: Missing :endfunction')
      endtry
  endfunc
  
  "-------------------------------------------------------------------------------
  " Test 96:  line continuation						    {{{1
  "
! "           Undefined behavior was detected by ubsan with line continuation
! "           after an empty line.
  "-------------------------------------------------------------------------------
  func Test_script_emty_line_continuation()
  
--- 1250,1319 ----
  func Test_script_lines()
      " :append
      try
! 	call DefineFunction('T_Append', [
! 		    \ 'append',
! 		    \ 'py <<EOS',
! 		    \ '.',
! 		    \ ])
      catch
! 	call assert_report("Can't define function")
      endtry
      try
! 	call DefineFunction('T_Append', [
! 		    \ 'append',
! 		    \ 'abc',
! 		    \ ])
! 	call assert_report("Shouldn't be able to define function")
      catch
! 	call assert_exception('Vim(function):E126: Missing :endfunction')
      endtry
  
      " :change
      try
! 	call DefineFunction('T_Change', [
! 		    \ 'change',
! 		    \ 'py <<EOS',
! 		    \ '.',
! 		    \ ])
      catch
! 	call assert_report("Can't define function")
      endtry
      try
! 	call DefineFunction('T_Change', [
! 		    \ 'change',
! 		    \ 'abc',
! 		    \ ])
! 	call assert_report("Shouldn't be able to define function")
      catch
! 	call assert_exception('Vim(function):E126: Missing :endfunction')
      endtry
  
      " :insert
      try
! 	call DefineFunction('T_Insert', [
! 		    \ 'insert',
! 		    \ 'py <<EOS',
! 		    \ '.',
! 		    \ ])
      catch
! 	call assert_report("Can't define function")
      endtry
      try
! 	call DefineFunction('T_Insert', [
! 		    \ 'insert',
! 		    \ 'abc',
! 		    \ ])
! 	call assert_report("Shouldn't be able to define function")
      catch
! 	call assert_exception('Vim(function):E126: Missing :endfunction')
      endtry
  endfunc
  
  "-------------------------------------------------------------------------------
  " Test 96:  line continuation						    {{{1
  "
! "	    Undefined behavior was detected by ubsan with line continuation
! "	    after an empty line.
  "-------------------------------------------------------------------------------
  func Test_script_emty_line_continuation()
  
*** ../vim-8.1.0710/src/testdir/test_window_cmd.vim	2018-12-24 00:22:35.739150151 +0100
--- src/testdir/test_window_cmd.vim	2019-01-09 22:51:15.453965638 +0100
***************
*** 578,590 ****
    only
  endfunc
  
! function! Fun_RenewFile()
    sleep 2
    silent execute '!echo "1" > tmp.txt'
    sp
    wincmd p
    edit! tmp.txt
! endfunction
  
  func Test_window_prevwin()
    " Can we make this work on MS-Windows?
--- 578,590 ----
    only
  endfunc
  
! func Fun_RenewFile()
    sleep 2
    silent execute '!echo "1" > tmp.txt'
    sp
    wincmd p
    edit! tmp.txt
! endfunc
  
  func Test_window_prevwin()
    " Can we make this work on MS-Windows?
*** ../vim-8.1.0710/src/testdir/test_xxd.vim	2018-05-17 15:49:14.000000000 +0200
--- src/testdir/test_xxd.vim	2019-01-09 22:51:36.965785833 +0100
***************
*** 7,23 ****
    let s:xxd_cmd = $XXD
  endif
  
! func! PrepareBuffer(lines)
    new
    call append(0, a:lines)
    $d
  endfunc
  
! func! s:Mess(counter)
    return printf("Failed xxd test %d:", a:counter)
  endfunc
  
! func! Test_xxd()
    call PrepareBuffer(range(1,30))
    set ff=unix
    w XXDfile
--- 7,23 ----
    let s:xxd_cmd = $XXD
  endif
  
! func PrepareBuffer(lines)
    new
    call append(0, a:lines)
    $d
  endfunc
  
! func s:Mess(counter)
    return printf("Failed xxd test %d:", a:counter)
  endfunc
  
! func Test_xxd()
    call PrepareBuffer(range(1,30))
    set ff=unix
    w XXDfile
*** ../vim-8.1.0710/src/version.c	2019-01-09 22:24:46.568161097 +0100
--- src/version.c	2019-01-09 22:58:02.562605011 +0100
***************
*** 801,802 ****
--- 801,804 ----
  {   /* Add new patch number below this line */
+ /**/
+     711,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
140. You'd rather catch a score on the web than watch the game as
     it is being played on tv.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
