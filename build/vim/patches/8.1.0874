To: vim_dev@googlegroups.com
Subject: Patch 8.1.0874
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.1.0874
Problem:    Using old style comments in new file.
Solution:   Convert to // comments in new file. (Yegappan Lakshmanan)
Files:	    src/indent.c


*** ../vim-8.1.0873/src/indent.c	2019-01-31 13:47:51.122632648 +0100
--- src/indent.c	2019-02-04 20:28:25.798161568 +0100
***************
*** 59,71 ****
   * Return NULL when not inside a comment.
   */
      static pos_T *
! ind_find_start_comment(void)	    /* XXX */
  {
      return find_start_comment(curbuf->b_ind_maxcomment);
  }
  
      pos_T *
! find_start_comment(int ind_maxcomment)	/* XXX */
  {
      pos_T	*pos;
      char_u	*line;
--- 59,71 ----
   * Return NULL when not inside a comment.
   */
      static pos_T *
! ind_find_start_comment(void)	    // XXX
  {
      return find_start_comment(curbuf->b_ind_maxcomment);
  }
  
      pos_T *
! find_start_comment(int ind_maxcomment)	// XXX
  {
      pos_T	*pos;
      char_u	*line;
***************
*** 78,87 ****
  	if (pos == NULL)
  	    break;
  
! 	/*
! 	 * Check if the comment start we found is inside a string.
! 	 * If it is then restrict the search to below this line and try again.
! 	 */
  	line = ml_get(pos->lnum);
  	for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)
  	    p = skip_string(p);
--- 78,85 ----
  	if (pos == NULL)
  	    break;
  
! 	// Check if the comment start we found is inside a string.
! 	// If it is then restrict the search to below this line and try again.
  	line = ml_get(pos->lnum);
  	for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)
  	    p = skip_string(p);
***************
*** 106,112 ****
   * "CORS" -> Comment Or Raw String
   */
      static pos_T *
! ind_find_start_CORS(linenr_T *is_raw)	    /* XXX */
  {
      static pos_T comment_pos_copy;
      pos_T	*comment_pos;
--- 104,110 ----
   * "CORS" -> Comment Or Raw String
   */
      static pos_T *
! ind_find_start_CORS(linenr_T *is_raw)	    // XXX
  {
      static pos_T comment_pos_copy;
      pos_T	*comment_pos;
***************
*** 115,129 ****
      comment_pos = find_start_comment(curbuf->b_ind_maxcomment);
      if (comment_pos != NULL)
      {
! 	/* Need to make a copy of the static pos in findmatchlimit(),
! 	 * calling find_start_rawstring() may change it. */
  	comment_pos_copy = *comment_pos;
  	comment_pos = &comment_pos_copy;
      }
      rs_pos = find_start_rawstring(curbuf->b_ind_maxcomment);
  
!     /* If comment_pos is before rs_pos the raw string is inside the comment.
!      * If rs_pos is before comment_pos the comment is inside the raw string. */
      if (comment_pos == NULL || (rs_pos != NULL
  					     && LT_POS(*rs_pos, *comment_pos)))
      {
--- 113,127 ----
      comment_pos = find_start_comment(curbuf->b_ind_maxcomment);
      if (comment_pos != NULL)
      {
! 	// Need to make a copy of the static pos in findmatchlimit(),
! 	// calling find_start_rawstring() may change it.
  	comment_pos_copy = *comment_pos;
  	comment_pos = &comment_pos_copy;
      }
      rs_pos = find_start_rawstring(curbuf->b_ind_maxcomment);
  
!     // If comment_pos is before rs_pos the raw string is inside the comment.
!     // If rs_pos is before comment_pos the comment is inside the raw string.
      if (comment_pos == NULL || (rs_pos != NULL
  					     && LT_POS(*rs_pos, *comment_pos)))
      {
***************
*** 140,146 ****
   * Return NULL when not inside a raw string.
   */
      static pos_T *
! find_start_rawstring(int ind_maxcomment)	/* XXX */
  {
      pos_T	*pos;
      char_u	*line;
--- 138,144 ----
   * Return NULL when not inside a raw string.
   */
      static pos_T *
! find_start_rawstring(int ind_maxcomment)	// XXX
  {
      pos_T	*pos;
      char_u	*line;
***************
*** 153,162 ****
  	if (pos == NULL)
  	    break;
  
! 	/*
! 	 * Check if the raw string start we found is inside a string.
! 	 * If it is then restrict the search to below this line and try again.
! 	 */
  	line = ml_get(pos->lnum);
  	for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)
  	    p = skip_string(p);
--- 151,158 ----
  	if (pos == NULL)
  	    break;
  
! 	// Check if the raw string start we found is inside a string.
! 	// If it is then restrict the search to below this line and try again.
  	line = ml_get(pos->lnum);
  	for (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)
  	    p = skip_string(p);
***************
*** 181,223 ****
  {
      int	    i;
  
!     /*
!      * We loop, because strings may be concatenated: "date""time".
!      */
      for ( ; ; ++p)
      {
! 	if (p[0] == '\'')		    /* 'c' or '\n' or '\000' */
  	{
! 	    if (!p[1])			    /* ' at end of line */
  		break;
  	    i = 2;
! 	    if (p[1] == '\\')		    /* '\n' or '\000' */
  	    {
  		++i;
! 		while (vim_isdigit(p[i - 1]))   /* '\000' */
  		    ++i;
  	    }
! 	    if (p[i] == '\'')		    /* check for trailing ' */
  	    {
  		p += i;
  		continue;
  	    }
  	}
! 	else if (p[0] == '"')		    /* start of string */
  	{
  	    for (++p; p[0]; ++p)
  	    {
  		if (p[0] == '\\' && p[1] != NUL)
  		    ++p;
! 		else if (p[0] == '"')	    /* end of string */
  		    break;
  	    }
  	    if (p[0] == '"')
! 		continue; /* continue for another string */
  	}
  	else if (p[0] == 'R' && p[1] == '"')
  	{
! 	    /* Raw string: R"[delim](...)[delim]" */
  	    char_u *delim = p + 2;
  	    char_u *paren = vim_strchr(delim, '(');
  
--- 177,217 ----
  {
      int	    i;
  
!     // We loop, because strings may be concatenated: "date""time".
      for ( ; ; ++p)
      {
! 	if (p[0] == '\'')		    // 'c' or '\n' or '\000'
  	{
! 	    if (!p[1])			    // ' at end of line
  		break;
  	    i = 2;
! 	    if (p[1] == '\\')		    // '\n' or '\000'
  	    {
  		++i;
! 		while (vim_isdigit(p[i - 1]))   // '\000'
  		    ++i;
  	    }
! 	    if (p[i] == '\'')		    // check for trailing '
  	    {
  		p += i;
  		continue;
  	    }
  	}
! 	else if (p[0] == '"')		    // start of string
  	{
  	    for (++p; p[0]; ++p)
  	    {
  		if (p[0] == '\\' && p[1] != NUL)
  		    ++p;
! 		else if (p[0] == '"')	    // end of string
  		    break;
  	    }
  	    if (p[0] == '"')
! 		continue; // continue for another string
  	}
  	else if (p[0] == 'R' && p[1] == '"')
  	{
! 	    // Raw string: R"[delim](...)[delim]"
  	    char_u *delim = p + 2;
  	    char_u *paren = vim_strchr(delim, '(');
  
***************
*** 233,248 ****
  			break;
  		    }
  		if (p[0] == '"')
! 		    continue; /* continue for another string */
  	    }
  	}
! 	break;				    /* no string found */
      }
      if (!*p)
! 	--p;				    /* backup from NUL */
      return p;
  }
! #endif /* FEAT_CINDENT || FEAT_SYN_HL */
  
  #if defined(FEAT_CINDENT) || defined(PROTO)
  
--- 227,242 ----
  			break;
  		    }
  		if (p[0] == '"')
! 		    continue; // continue for another string
  	    }
  	}
! 	break;				    // no string found
      }
      if (!*p)
! 	--p;				    // backup from NUL
      return p;
  }
! #endif // FEAT_CINDENT || FEAT_SYN_HL
  
  #if defined(FEAT_CINDENT) || defined(PROTO)
  
***************
*** 259,265 ****
  		    ));
  }
  
! /* Find result cache for cpp_baseclass */
  typedef struct {
      int	    found;
      lpos_T  lpos;
--- 253,259 ----
  		    ));
  }
  
! // Find result cache for cpp_baseclass
  typedef struct {
      int	    found;
      lpos_T  lpos;
***************
*** 299,306 ****
  
  	s = skipwhite(s);
  
! 	/* Perl/shell # comment comment continues until eol.  Require a space
! 	 * before # to avoid recognizing $#array. */
  	if (curbuf->b_ind_hash_comment != 0 && s != prev_s && *s == '#')
  	{
  	    s += STRLEN(s);
--- 293,300 ----
  
  	s = skipwhite(s);
  
! 	// Perl/shell # comment comment continues until eol.  Require a space
! 	// before # to avoid recognizing $#array.
  	if (curbuf->b_ind_hash_comment != 0 && s != prev_s && *s == '#')
  	{
  	    s += STRLEN(s);
***************
*** 309,322 ****
  	if (*s != '/')
  	    break;
  	++s;
! 	if (*s == '/')		/* slash-slash comment continues till eol */
  	{
  	    s += STRLEN(s);
  	    break;
  	}
  	if (*s != '*')
  	    break;
! 	for (++s; *s; ++s)	/* skip slash-star comment */
  	    if (s[0] == '*' && s[1] == '/')
  	    {
  		s += 2;
--- 303,316 ----
  	if (*s != '/')
  	    break;
  	++s;
! 	if (*s == '/')		// slash-slash comment continues till eol
  	{
  	    s += STRLEN(s);
  	    break;
  	}
  	if (*s != '*')
  	    break;
! 	for (++s; *s; ++s)	// skip slash-star comment
  	    if (s[0] == '*' && s[1] == '/')
  	    {
  		s += 2;
***************
*** 340,346 ****
   * Check previous lines for a "//" line comment, skipping over blank lines.
   */
      static pos_T *
! find_line_comment(void) /* XXX */
  {
      static pos_T pos;
      char_u	 *line;
--- 334,340 ----
   * Check previous lines for a "//" line comment, skipping over blank lines.
   */
      static pos_T *
! find_line_comment(void) // XXX
  {
      static pos_T pos;
      char_u	 *line;
***************
*** 373,383 ****
  
      if (*s == '\'' || *s == '"')
      {
! 	/* can be 'key': or "key": */
  	quote = *s;
  	++s;
      }
!     if (!vim_isIDc(*s))	    /* need at least one ID character */
  	return FALSE;
  
      while (vim_isIDc(*s))
--- 367,377 ----
  
      if (*s == '\'' || *s == '"')
      {
! 	// can be 'key': or "key":
  	quote = *s;
  	++s;
      }
!     if (!vim_isIDc(*s))	    // need at least one ID character
  	return FALSE;
  
      while (vim_isIDc(*s))
***************
*** 387,393 ****
  
      s = cin_skipcomment(s);
  
!     /* "::" is not a label, it's C++ */
      return (*s == ':' && s[1] != ':');
  }
  
--- 381,387 ----
  
      s = cin_skipcomment(s);
  
!     // "::" is not a label, it's C++
      return (*s == ':' && s[1] != ':');
  }
  
***************
*** 398,404 ****
      static int
  cin_islabel_skip(char_u **s)
  {
!     if (!vim_isIDc(**s))	    /* need at least one ID character */
  	return FALSE;
  
      while (vim_isIDc(**s))
--- 392,398 ----
      static int
  cin_islabel_skip(char_u **s)
  {
!     if (!vim_isIDc(**s))	    // need at least one ID character
  	return FALSE;
  
      while (vim_isIDc(**s))
***************
*** 406,412 ****
  
      *s = cin_skipcomment(*s);
  
!     /* "::" is not a label, it's C++ */
      return (**s == ':' && *++*s != ':');
  }
  
--- 400,406 ----
  
      *s = cin_skipcomment(*s);
  
!     // "::" is not a label, it's C++
      return (**s == ':' && *++*s != ':');
  }
  
***************
*** 415,430 ****
   * Note: curwin->w_cursor must be where we are looking for the label.
   */
      int
! cin_islabel(void)		/* XXX */
  {
      char_u	*s;
  
      s = cin_skipcomment(ml_get_curline());
  
!     /*
!      * Exclude "default" from labels, since it should be indented
!      * like a switch label.  Same for C++ scope declarations.
!      */
      if (cin_isdefault(s))
  	return FALSE;
      if (cin_isscopedecl(s))
--- 409,422 ----
   * Note: curwin->w_cursor must be where we are looking for the label.
   */
      int
! cin_islabel(void)		// XXX
  {
      char_u	*s;
  
      s = cin_skipcomment(ml_get_curline());
  
!     // Exclude "default" from labels, since it should be indented
!     // like a switch label.  Same for C++ scope declarations.
      if (cin_isdefault(s))
  	return FALSE;
      if (cin_isscopedecl(s))
***************
*** 432,441 ****
  
      if (cin_islabel_skip(&s))
      {
! 	/*
! 	 * Only accept a label if the previous line is terminated or is a case
! 	 * label.
! 	 */
  	pos_T	cursor_save;
  	pos_T	*trypos;
  	char_u	*line;
--- 424,431 ----
  
      if (cin_islabel_skip(&s))
      {
! 	// Only accept a label if the previous line is terminated or is a case
! 	// label.
  	pos_T	cursor_save;
  	pos_T	*trypos;
  	char_u	*line;
***************
*** 445,460 ****
  	{
  	    --curwin->w_cursor.lnum;
  
! 	    /*
! 	     * If we're in a comment or raw string now, skip to the start of
! 	     * it.
! 	     */
  	    curwin->w_cursor.col = 0;
! 	    if ((trypos = ind_find_start_CORS(NULL)) != NULL) /* XXX */
  		curwin->w_cursor = *trypos;
  
  	    line = ml_get_curline();
! 	    if (cin_ispreproc(line))	/* ignore #defines, #if, etc. */
  		continue;
  	    if (*(line = cin_skipcomment(line)) == NUL)
  		continue;
--- 435,448 ----
  	{
  	    --curwin->w_cursor.lnum;
  
! 	    // If we're in a comment or raw string now, skip to the start of
! 	    // it.
  	    curwin->w_cursor.col = 0;
! 	    if ((trypos = ind_find_start_CORS(NULL)) != NULL) // XXX
  		curwin->w_cursor = *trypos;
  
  	    line = ml_get_curline();
! 	    if (cin_ispreproc(line))	// ignore #defines, #if, etc.
  		continue;
  	    if (*(line = cin_skipcomment(line)) == NUL)
  		continue;
***************
*** 468,474 ****
  	    return FALSE;
  	}
  	curwin->w_cursor = cursor_save;
! 	return TRUE;		/* label at start of file??? */
      }
      return FALSE;
  }
--- 456,462 ----
  	    return FALSE;
  	}
  	curwin->w_cursor = cursor_save;
! 	return TRUE;		// label at start of file???
      }
      return FALSE;
  }
***************
*** 522,528 ****
       int
  cin_iscase(
      char_u *s,
!     int strict) /* Allow relaxed check of case statement for JS */
  {
      s = cin_skipcomment(s);
      if (cin_starts_with(s, "case"))
--- 510,516 ----
       int
  cin_iscase(
      char_u *s,
!     int strict) // Allow relaxed check of case statement for JS
  {
      s = cin_skipcomment(s);
      if (cin_starts_with(s, "case"))
***************
*** 532,551 ****
  	    s = cin_skipcomment(s);
  	    if (*s == ':')
  	    {
! 		if (s[1] == ':')	/* skip over "::" for C++ */
  		    ++s;
  		else
  		    return TRUE;
  	    }
  	    if (*s == '\'' && s[1] && s[2] == '\'')
! 		s += 2;			/* skip over ':' */
  	    else if (*s == '/' && (s[1] == '*' || s[1] == '/'))
! 		return FALSE;		/* stop at comment */
  	    else if (*s == '"')
  	    {
! 		/* JS etc. */
  		if (strict)
! 		    return FALSE;		/* stop at string */
  		else
  		    return TRUE;
  	    }
--- 520,539 ----
  	    s = cin_skipcomment(s);
  	    if (*s == ':')
  	    {
! 		if (s[1] == ':')	// skip over "::" for C++
  		    ++s;
  		else
  		    return TRUE;
  	    }
  	    if (*s == '\'' && s[1] && s[2] == '\'')
! 		s += 2;			// skip over ':'
  	    else if (*s == '/' && (s[1] == '*' || s[1] == '/'))
! 		return FALSE;		// stop at comment
  	    else if (*s == '"')
  	    {
! 		// JS etc.
  		if (strict)
! 		    return FALSE;		// stop at string
  		else
  		    return TRUE;
  	    }
***************
*** 589,595 ****
      return (*(s = cin_skipcomment(s + i)) == ':' && s[1] != ':');
  }
  
! /* Maximum number of lines to search back for a "namespace" line. */
  #define FIND_NAMESPACE_LIM 20
  
  /*
--- 577,583 ----
      return (*(s = cin_skipcomment(s + i)) == ':' && s[1] != ':');
  }
  
! // Maximum number of lines to search back for a "namespace" line.
  #define FIND_NAMESPACE_LIM 20
  
  /*
***************
*** 610,616 ****
  	{
  	    if (VIM_ISWHITE(*p))
  	    {
! 		has_name = TRUE; /* found end of a name */
  		p = cin_skipcomment(skipwhite(p));
  	    }
  	    else if (*p == '{')
--- 598,604 ----
  	{
  	    if (VIM_ISWHITE(*p))
  	    {
! 		has_name = TRUE; // found end of a name
  		p = cin_skipcomment(skipwhite(p));
  	    }
  	    else if (*p == '{')
***************
*** 621,634 ****
  	    {
  		has_name_start = TRUE;
  		if (has_name)
! 		    return FALSE; /* word character after skipping past name */
  		++p;
  	    }
  	    else if (p[0] == ':' && p[1] == ':' && vim_iswordc(p[2]))
  	    {
  		if (!has_name_start || has_name)
  		    return FALSE;
! 		/* C++ 17 nested namespace */
  		p += 3;
  	    }
  	    else
--- 609,622 ----
  	    {
  		has_name_start = TRUE;
  		if (has_name)
! 		    return FALSE; // word character after skipping past name
  		++p;
  	    }
  	    else if (p[0] == ':' && p[1] == ':' && vim_iswordc(p[2]))
  	    {
  		if (!has_name_start || has_name)
  		    return FALSE;
! 		// C++ 17 nested namespace
  		p += 3;
  	    }
  	    else
***************
*** 702,714 ****
      {
  	if (*l == ':')
  	{
! 	    if (l[1] == ':')	    /* skip over "::" for C++ */
  		++l;
  	    else if (!cin_iscase(l + 1, FALSE))
  		break;
  	}
  	else if (*l == '\'' && l[1] && l[2] == '\'')
! 	    l += 2;		    /* skip over 'x' */
      }
      if (*l == NUL)
  	return NULL;
--- 690,702 ----
      {
  	if (*l == ':')
  	{
! 	    if (l[1] == ':')	    // skip over "::" for C++
  		++l;
  	    else if (!cin_iscase(l + 1, FALSE))
  		break;
  	}
  	else if (*l == '\'' && l[1] && l[2] == '\'')
! 	    l += 2;		    // skip over 'x'
      }
      if (*l == NUL)
  	return NULL;
***************
*** 723,729 ****
   * Return 0 if there is nothing after the label.
   */
      static int
! get_indent_nolabel (linenr_T lnum)	/* XXX */
  {
      char_u	*l;
      pos_T	fp;
--- 711,717 ----
   * Return 0 if there is nothing after the label.
   */
      static int
! get_indent_nolabel (linenr_T lnum)	// XXX
  {
      char_u	*l;
      pos_T	fp;
***************
*** 757,768 ****
      cursor_save = curwin->w_cursor;
      curwin->w_cursor.lnum = lnum;
      l = ml_get_curline();
! 				    /* XXX */
      if (cin_iscase(l, FALSE) || cin_isscopedecl(l) || cin_islabel())
      {
  	amount = get_indent_nolabel(lnum);
  	l = after_label(ml_get_curline());
! 	if (l == NULL)		/* just in case */
  	    l = ml_get_curline();
      }
      else
--- 745,756 ----
      cursor_save = curwin->w_cursor;
      curwin->w_cursor.lnum = lnum;
      l = ml_get_curline();
! 				    // XXX
      if (cin_iscase(l, FALSE) || cin_isscopedecl(l) || cin_islabel())
      {
  	amount = get_indent_nolabel(lnum);
  	l = after_label(ml_get_curline());
! 	if (l == NULL)		// just in case
  	    l = ml_get_curline();
      }
      else
***************
*** 852,858 ****
      line = s = ml_get(lnum);
      while (*s != NUL && vim_strchr((char_u *)"=;{}\"'", *s) == NULL)
      {
! 	if (cin_iscomment(s))	/* ignore comments */
  	    s = cin_skipcomment(s);
  	else
  	    ++s;
--- 840,846 ----
      line = s = ml_get(lnum);
      while (*s != NUL && vim_strchr((char_u *)"=;{}\"'", *s) == NULL)
      {
! 	if (cin_iscomment(s))	// ignore comments
  	    s = cin_skipcomment(s);
  	else
  	    ++s;
***************
*** 864,870 ****
      if (cin_nocode(s))
  	return 0;
  
!     if (*s == '"')	/* nice alignment for continued strings */
  	++s;
  
      fp.lnum = lnum;
--- 852,858 ----
      if (cin_nocode(s))
  	return 0;
  
!     if (*s == '"')	// nice alignment for continued strings
  	++s;
  
      fp.lnum = lnum;
***************
*** 953,960 ****
      static int
  cin_isterminated(
      char_u	*s,
!     int		incl_open,	/* include '{' at the end as terminator */
!     int		incl_comma)	/* recognize a trailing comma */
  {
      char_u	found_start = 0;
      unsigned	n_open = 0;
--- 941,948 ----
      static int
  cin_isterminated(
      char_u	*s,
!     int		incl_open,	// include '{' at the end as terminator
!     int		incl_comma)	// recognize a trailing comma
  {
      char_u	found_start = 0;
      unsigned	n_open = 0;
***************
*** 970,976 ****
  
      while (*s)
      {
! 	/* skip over comments, "" strings and 'c'haracters */
  	s = skip_string(cin_skipcomment(s));
  	if (*s == '}' && n_open > 0)
  	    --n_open;
--- 958,964 ----
  
      while (*s)
      {
! 	// skip over comments, "" strings and 'c'haracters
  	s = skip_string(cin_skipcomment(s));
  	if (*s == '}' && n_open > 0)
  	    --n_open;
***************
*** 1035,1072 ****
      }
      curwin->w_cursor.lnum = save_lnum;
  
!     /* Ignore line starting with #. */
      if (cin_ispreproc(s))
  	return FALSE;
  
      while (*s && *s != '(' && *s != ';' && *s != '\'' && *s != '"')
      {
! 	if (cin_iscomment(s))	/* ignore comments */
  	    s = cin_skipcomment(s);
  	else if (*s == ':')
  	{
  	    if (*(s + 1) == ':')
  		s += 2;
  	    else
! 		/* To avoid a mistake in the following situation:
! 		 * A::A(int a, int b)
! 		 *     : a(0)  // <--not a function decl
! 		 *     , b(0)
! 		 * {...
! 		 */
  		return FALSE;
  	}
  	else
  	    ++s;
      }
      if (*s != '(')
! 	return FALSE;		/* ';', ' or "  before any () or no '(' */
  
      while (*s && *s != ';' && *s != '\'' && *s != '"')
      {
  	if (*s == ')' && cin_nocode(s + 1))
  	{
! 	    /* ')' at the end: may have found a match
  	     * Check for he previous line not to end in a backslash:
  	     *       #if defined(x) && \
  	     *		 defined(y)
--- 1023,1060 ----
      }
      curwin->w_cursor.lnum = save_lnum;
  
!     // Ignore line starting with #.
      if (cin_ispreproc(s))
  	return FALSE;
  
      while (*s && *s != '(' && *s != ';' && *s != '\'' && *s != '"')
      {
! 	if (cin_iscomment(s))	// ignore comments
  	    s = cin_skipcomment(s);
  	else if (*s == ':')
  	{
  	    if (*(s + 1) == ':')
  		s += 2;
  	    else
! 		// To avoid a mistake in the following situation:
! 		// A::A(int a, int b)
! 		//     : a(0)  // <--not a function decl
! 		//     , b(0)
! 		// {...
  		return FALSE;
  	}
  	else
  	    ++s;
      }
      if (*s != '(')
! 	return FALSE;		// ';', ' or "  before any () or no '('
  
      while (*s && *s != ';' && *s != '\'' && *s != '"')
      {
  	if (*s == ')' && cin_nocode(s + 1))
  	{
! 	    /*
! 	     * ')' at the end: may have found a match
  	     * Check for he previous line not to end in a backslash:
  	     *       #if defined(x) && \
  	     *		 defined(y)
***************
*** 1081,1090 ****
  	{
  	    int comma = (*s == ',');
  
! 	    /* ',' at the end: continue looking in the next line.
! 	     * At the end: check for ',' in the next line, for this style:
! 	     * func(arg1
! 	     *       , arg2) */
  	    for (;;)
  	    {
  		if (lnum >= curbuf->b_ml.ml_line_count)
--- 1069,1078 ----
  	{
  	    int comma = (*s == ',');
  
! 	    // ',' at the end: continue looking in the next line.
! 	    // At the end: check for ',' in the next line, for this style:
! 	    // func(arg1
! 	    //       , arg2)
  	    for (;;)
  	    {
  		if (lnum >= curbuf->b_ml.ml_line_count)
***************
*** 1095,1108 ****
  	    }
  	    if (lnum >= curbuf->b_ml.ml_line_count)
  		break;
! 	    /* Require a comma at end of the line or a comma or ')' at the
! 	     * start of next line. */
  	    s = skipwhite(s);
  	    if (!just_started && (!comma && *s != ',' && *s != ')'))
  		break;
  	    just_started = FALSE;
  	}
! 	else if (cin_iscomment(s))	/* ignore comments */
  	    s = cin_skipcomment(s);
  	else
  	{
--- 1083,1096 ----
  	    }
  	    if (lnum >= curbuf->b_ml.ml_line_count)
  		break;
! 	    // Require a comma at end of the line or a comma or ')' at the
! 	    // start of next line.
  	    s = skipwhite(s);
  	    if (!just_started && (!comma && *s != ',' && *s != ')'))
  		break;
  	    just_started = FALSE;
  	}
! 	else if (cin_iscomment(s))	// ignore comments
  	    s = cin_skipcomment(s);
  	else
  	{
***************
*** 1128,1134 ****
  cin_iselse(
      char_u  *p)
  {
!     if (*p == '}')	    /* accept "} else" */
  	p = cin_skipcomment(p + 1);
      return (STRNCMP(p, "else", 4) == 0 && !vim_isIDc(p[4]));
  }
--- 1116,1122 ----
  cin_iselse(
      char_u  *p)
  {
!     if (*p == '}')	    // accept "} else"
  	p = cin_skipcomment(p + 1);
      return (STRNCMP(p, "else", 4) == 0 && !vim_isIDc(p[4]));
  }
***************
*** 1145,1158 ****
   * ')' and ';'. The condition may be spread over several lines.
   */
      static int
! cin_iswhileofdo (char_u *p, linenr_T lnum)	/* XXX */
  {
      pos_T	cursor_save;
      pos_T	*trypos;
      int		retval = FALSE;
  
      p = cin_skipcomment(p);
!     if (*p == '}')		/* accept "} while (cond);" */
  	p = cin_skipcomment(p + 1);
      if (cin_starts_with(p, "while"))
      {
--- 1133,1146 ----
   * ')' and ';'. The condition may be spread over several lines.
   */
      static int
! cin_iswhileofdo (char_u *p, linenr_T lnum)	// XXX
  {
      pos_T	cursor_save;
      pos_T	*trypos;
      int		retval = FALSE;
  
      p = cin_skipcomment(p);
!     if (*p == '}')		// accept "} while (cond);"
  	p = cin_skipcomment(p + 1);
      if (cin_starts_with(p, "while"))
      {
***************
*** 1160,1166 ****
  	curwin->w_cursor.lnum = lnum;
  	curwin->w_cursor.col = 0;
  	p = ml_get_curline();
! 	while (*p && *p != 'w')	/* skip any '}', until the 'w' of the "while" */
  	{
  	    ++p;
  	    ++curwin->w_cursor.col;
--- 1148,1154 ----
  	curwin->w_cursor.lnum = lnum;
  	curwin->w_cursor.col = 0;
  	p = ml_get_curline();
! 	while (*p && *p != 'w')	// skip any '}', until the 'w' of the "while"
  	{
  	    ++p;
  	    ++curwin->w_cursor.col;
***************
*** 1235,1241 ****
      pos_T	*trypos;
      int		i;
  
!     if (terminated != ';')	/* there must be a ';' at the end */
  	return FALSE;
  
      p = line = ml_get_curline();
--- 1223,1229 ----
      pos_T	*trypos;
      int		i;
  
!     if (terminated != ';')	// there must be a ';' at the end
  	return FALSE;
  
      p = line = ml_get_curline();
***************
*** 1247,1261 ****
  	    s = skipwhite(p + 1);
  	    if (*s == ';' && cin_nocode(s + 1))
  	    {
! 		/* Found ");" at end of the line, now check there is "while"
! 		 * before the matching '('.  XXX */
  		i = (int)(p - line);
  		curwin->w_cursor.col = i;
  		trypos = find_match_paren(curbuf->b_ind_maxparen);
  		if (trypos != NULL)
  		{
  		    s = cin_skipcomment(ml_get(trypos->lnum));
! 		    if (*s == '}')		/* accept "} while (cond);" */
  			s = cin_skipcomment(s + 1);
  		    if (cin_starts_with(s, "while"))
  		    {
--- 1235,1249 ----
  	    s = skipwhite(p + 1);
  	    if (*s == ';' && cin_nocode(s + 1))
  	    {
! 		// Found ");" at end of the line, now check there is "while"
! 		// before the matching '('.  XXX
  		i = (int)(p - line);
  		curwin->w_cursor.col = i;
  		trypos = find_match_paren(curbuf->b_ind_maxparen);
  		if (trypos != NULL)
  		{
  		    s = cin_skipcomment(ml_get(trypos->lnum));
! 		    if (*s == '}')		// accept "} while (cond);"
  			s = cin_skipcomment(s + 1);
  		    if (cin_starts_with(s, "while"))
  		    {
***************
*** 1264,1270 ****
  		    }
  		}
  
! 		/* Searching may have made "line" invalid, get it again. */
  		line = ml_get_curline();
  		p = line + i;
  	    }
--- 1252,1258 ----
  		    }
  		}
  
! 		// Searching may have made "line" invalid, get it again.
  		line = ml_get_curline();
  		p = line + i;
  	    }
***************
*** 1296,1316 ****
   */
      static int
  cin_is_cpp_baseclass(
!     cpp_baseclass_cache_T *cached) /* input and output */
  {
!     lpos_T	*pos = &cached->lpos;	    /* find position */
      char_u	*s;
      int		class_or_struct, lookfor_ctor_init, cpp_base_class;
      linenr_T	lnum = curwin->w_cursor.lnum;
      char_u	*line = ml_get_curline();
  
      if (pos->lnum <= lnum)
! 	return cached->found;	/* Use the cached result */
  
      pos->col = 0;
  
      s = skipwhite(line);
!     if (*s == '#')		/* skip #define FOO x ? (x) : x */
  	return FALSE;
      s = cin_skipcomment(s);
      if (*s == NUL)
--- 1284,1304 ----
   */
      static int
  cin_is_cpp_baseclass(
!     cpp_baseclass_cache_T *cached) // input and output
  {
!     lpos_T	*pos = &cached->lpos;	    // find position
      char_u	*s;
      int		class_or_struct, lookfor_ctor_init, cpp_base_class;
      linenr_T	lnum = curwin->w_cursor.lnum;
      char_u	*line = ml_get_curline();
  
      if (pos->lnum <= lnum)
! 	return cached->found;	// Use the cached result
  
      pos->col = 0;
  
      s = skipwhite(line);
!     if (*s == '#')		// skip #define FOO x ? (x) : x
  	return FALSE;
      s = cin_skipcomment(s);
      if (*s == NUL)
***************
*** 1318,1336 ****
  
      cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;
  
!     /* Search for a line starting with '#', empty, ending in ';' or containing
!      * '{' or '}' and start below it.  This handles the following situations:
!      *	a = cond ?
!      *	      func() :
!      *		   asdf;
!      *	func::foo()
!      *	      : something
!      *	{}
!      *	Foo::Foo (int one, int two)
!      *		: something(4),
!      *		somethingelse(3)
!      *	{}
!      */
      while (lnum > 1)
      {
  	line = ml_get(lnum - 1);
--- 1306,1323 ----
  
      cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;
  
!     // Search for a line starting with '#', empty, ending in ';' or containing
!     // '{' or '}' and start below it.  This handles the following situations:
!     //	a = cond ?
!     //	      func() :
!     //		   asdf;
!     //	func::foo()
!     //	      : something
!     //	{}
!     //	Foo::Foo (int one, int two)
!     //		: something(4),
!     //		somethingelse(3)
!     //	{}
      while (lnum > 1)
      {
  	line = ml_get(lnum - 1);
***************
*** 1360,1372 ****
  	{
  	    if (lnum == curwin->w_cursor.lnum)
  		break;
! 	    /* Continue in the cursor line. */
  	    line = ml_get(++lnum);
  	    s = line;
  	}
  	if (s == line)
  	{
! 	    /* don't recognize "case (foo):" as a baseclass */
  	    if (cin_iscase(s, FALSE))
  		break;
  	    s = cin_skipcomment(line);
--- 1347,1359 ----
  	{
  	    if (lnum == curwin->w_cursor.lnum)
  		break;
! 	    // Continue in the cursor line.
  	    line = ml_get(++lnum);
  	    s = line;
  	}
  	if (s == line)
  	{
! 	    // don't recognize "case (foo):" as a baseclass
  	    if (cin_iscase(s, FALSE))
  		break;
  	    s = cin_skipcomment(line);
***************
*** 1380,1394 ****
  	{
  	    if (s[1] == ':')
  	    {
! 		/* skip double colon. It can't be a constructor
! 		 * initialization any more */
  		lookfor_ctor_init = FALSE;
  		s = cin_skipcomment(s + 2);
  	    }
  	    else if (lookfor_ctor_init || class_or_struct)
  	    {
! 		/* we have something found, that looks like the start of
! 		 * cpp-base-class-declaration or constructor-initialization */
  		cpp_base_class = TRUE;
  		lookfor_ctor_init = class_or_struct = FALSE;
  		pos->col = 0;
--- 1367,1381 ----
  	{
  	    if (s[1] == ':')
  	    {
! 		// skip double colon. It can't be a constructor
! 		// initialization any more
  		lookfor_ctor_init = FALSE;
  		s = cin_skipcomment(s + 2);
  	    }
  	    else if (lookfor_ctor_init || class_or_struct)
  	    {
! 		// we have something found, that looks like the start of
! 		// cpp-base-class-declaration or constructor-initialization
  		cpp_base_class = TRUE;
  		lookfor_ctor_init = class_or_struct = FALSE;
  		pos->col = 0;
***************
*** 1416,1448 ****
  	    }
  	    else if (s[0] == ')')
  	    {
! 		/* Constructor-initialization is assumed if we come across
! 		 * something like "):" */
  		class_or_struct = FALSE;
  		lookfor_ctor_init = TRUE;
  	    }
  	    else if (s[0] == '?')
  	    {
! 		/* Avoid seeing '() :' after '?' as constructor init. */
  		return FALSE;
  	    }
  	    else if (!vim_isIDc(s[0]))
  	    {
! 		/* if it is not an identifier, we are wrong */
  		class_or_struct = FALSE;
  		lookfor_ctor_init = FALSE;
  	    }
  	    else if (pos->col == 0)
  	    {
! 		/* it can't be a constructor-initialization any more */
  		lookfor_ctor_init = FALSE;
  
! 		/* the first statement starts here: lineup with this one... */
  		if (cpp_base_class)
  		    pos->col = (colnr_T)(s - line);
  	    }
  
! 	    /* When the line ends in a comma don't align with it. */
  	    if (lnum == curwin->w_cursor.lnum && *s == ',' && cin_nocode(s + 1))
  		pos->col = 0;
  
--- 1403,1435 ----
  	    }
  	    else if (s[0] == ')')
  	    {
! 		// Constructor-initialization is assumed if we come across
! 		// something like "):"
  		class_or_struct = FALSE;
  		lookfor_ctor_init = TRUE;
  	    }
  	    else if (s[0] == '?')
  	    {
! 		// Avoid seeing '() :' after '?' as constructor init.
  		return FALSE;
  	    }
  	    else if (!vim_isIDc(s[0]))
  	    {
! 		// if it is not an identifier, we are wrong
  		class_or_struct = FALSE;
  		lookfor_ctor_init = FALSE;
  	    }
  	    else if (pos->col == 0)
  	    {
! 		// it can't be a constructor-initialization any more
  		lookfor_ctor_init = FALSE;
  
! 		// the first statement starts here: lineup with this one...
  		if (cpp_base_class)
  		    pos->col = (colnr_T)(s - line);
  	    }
  
! 	    // When the line ends in a comma don't align with it.
  	    if (lnum == curwin->w_cursor.lnum && *s == ',' && cin_nocode(s + 1))
  		pos->col = 0;
  
***************
*** 1468,1474 ****
  	amount = get_indent();
  	if (find_last_paren(ml_get_curline(), '(', ')')
  		&& (trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)
! 	    amount = get_indent_lnum(trypos->lnum); /* XXX */
  	if (!cin_ends_in(ml_get_curline(), (char_u *)",", NULL))
  	    amount += curbuf->b_ind_cpp_baseclass;
      }
--- 1455,1461 ----
  	amount = get_indent();
  	if (find_last_paren(ml_get_curline(), '(', ')')
  		&& (trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)
! 	    amount = get_indent_lnum(trypos->lnum); // XXX
  	if (!cin_ends_in(ml_get_curline(), (char_u *)",", NULL))
  	    amount += curbuf->b_ind_cpp_baseclass;
      }
***************
*** 1555,1567 ****
   * Find the '{' at the start of the block we are in.
   * Return NULL if no match found.
   * Ignore a '{' that is in a comment, makes indenting the next three lines
!  * work. */
  /* foo()    */
  /* {	    */
  /* }	    */
  
      static pos_T *
! find_start_brace(void)	    /* XXX */
  {
      pos_T	cursor_save;
      pos_T	*trypos;
--- 1542,1555 ----
   * Find the '{' at the start of the block we are in.
   * Return NULL if no match found.
   * Ignore a '{' that is in a comment, makes indenting the next three lines
!  * work.
!  */
  /* foo()    */
  /* {	    */
  /* }	    */
  
      static pos_T *
! find_start_brace(void)	    // XXX
  {
      pos_T	cursor_save;
      pos_T	*trypos;
***************
*** 1571,1583 ****
      cursor_save = curwin->w_cursor;
      while ((trypos = findmatchlimit(NULL, '{', FM_BLOCKSTOP, 0)) != NULL)
      {
! 	pos_copy = *trypos;	/* copy pos_T, next findmatch will change it */
  	trypos = &pos_copy;
  	curwin->w_cursor = *trypos;
  	pos = NULL;
! 	/* ignore the { if it's in a // or / *  * / comment */
  	if ((colnr_T)cin_skip2pos(trypos) == trypos->col
! 		       && (pos = ind_find_start_CORS(NULL)) == NULL) /* XXX */
  	    break;
  	if (pos != NULL)
  	    curwin->w_cursor.lnum = pos->lnum;
--- 1559,1571 ----
      cursor_save = curwin->w_cursor;
      while ((trypos = findmatchlimit(NULL, '{', FM_BLOCKSTOP, 0)) != NULL)
      {
! 	pos_copy = *trypos;	// copy pos_T, next findmatch will change it
  	trypos = &pos_copy;
  	curwin->w_cursor = *trypos;
  	pos = NULL;
! 	// ignore the { if it's in a // or / *  * / comment
  	if ((colnr_T)cin_skip2pos(trypos) == trypos->col
! 		       && (pos = ind_find_start_CORS(NULL)) == NULL) // XXX
  	    break;
  	if (pos != NULL)
  	    curwin->w_cursor.lnum = pos->lnum;
***************
*** 1591,1603 ****
   * Return NULL if no match found.
   */
      static pos_T *
! find_match_paren(int ind_maxparen)	/* XXX */
  {
      return find_match_char('(', ind_maxparen);
  }
  
      static pos_T *
! find_match_char(int c, int ind_maxparen)	/* XXX */
  {
      pos_T	cursor_save;
      pos_T	*trypos;
--- 1579,1591 ----
   * Return NULL if no match found.
   */
      static pos_T *
! find_match_paren(int ind_maxparen)	// XXX
  {
      return find_match_char('(', ind_maxparen);
  }
  
      static pos_T *
! find_match_char(int c, int ind_maxparen)	// XXX
  {
      pos_T	cursor_save;
      pos_T	*trypos;
***************
*** 1609,1622 ****
  retry:
      if ((trypos = findmatchlimit(NULL, c, 0, ind_maxp_wk)) != NULL)
      {
! 	/* check if the ( is in a // comment */
  	if ((colnr_T)cin_skip2pos(trypos) > trypos->col)
  	{
  	    ind_maxp_wk = ind_maxparen - (int)(cursor_save.lnum - trypos->lnum);
  	    if (ind_maxp_wk > 0)
  	    {
  		curwin->w_cursor = *trypos;
! 		curwin->w_cursor.col = 0;	/* XXX */
  		goto retry;
  	    }
  	    trypos = NULL;
--- 1597,1610 ----
  retry:
      if ((trypos = findmatchlimit(NULL, c, 0, ind_maxp_wk)) != NULL)
      {
! 	// check if the ( is in a // comment
  	if ((colnr_T)cin_skip2pos(trypos) > trypos->col)
  	{
  	    ind_maxp_wk = ind_maxparen - (int)(cursor_save.lnum - trypos->lnum);
  	    if (ind_maxp_wk > 0)
  	    {
  		curwin->w_cursor = *trypos;
! 		curwin->w_cursor.col = 0;	// XXX
  		goto retry;
  	    }
  	    trypos = NULL;
***************
*** 1625,1634 ****
  	{
  	    pos_T	*trypos_wk;
  
! 	    pos_copy = *trypos;	    /* copy trypos, findmatch will change it */
  	    trypos = &pos_copy;
  	    curwin->w_cursor = *trypos;
! 	    if ((trypos_wk = ind_find_start_CORS(NULL)) != NULL) /* XXX */
  	    {
  		ind_maxp_wk = ind_maxparen - (int)(cursor_save.lnum
  			- trypos_wk->lnum);
--- 1613,1622 ----
  	{
  	    pos_T	*trypos_wk;
  
! 	    pos_copy = *trypos;	    // copy trypos, findmatch will change it
  	    trypos = &pos_copy;
  	    curwin->w_cursor = *trypos;
! 	    if ((trypos_wk = ind_find_start_CORS(NULL)) != NULL) // XXX
  	    {
  		ind_maxp_wk = ind_maxparen - (int)(cursor_save.lnum
  			- trypos_wk->lnum);
***************
*** 1651,1657 ****
   * Return NULL if no match found.
   */
      static pos_T *
! find_match_paren_after_brace (int ind_maxparen)	    /* XXX */
  {
      pos_T	*trypos = find_match_paren(ind_maxparen);
  
--- 1639,1645 ----
   * Return NULL if no match found.
   */
      static pos_T *
! find_match_paren_after_brace (int ind_maxparen)	    // XXX
  {
      pos_T	*trypos = find_match_paren(ind_maxparen);
  
***************
*** 1659,1666 ****
      {
  	pos_T	*tryposBrace = find_start_brace();
  
! 	/* If both an unmatched '(' and '{' is found.  Ignore the '('
! 	 * position if the '{' is further down. */
  	if (tryposBrace != NULL
  		&& (trypos->lnum != tryposBrace->lnum
  		    ? trypos->lnum < tryposBrace->lnum
--- 1647,1654 ----
      {
  	pos_T	*tryposBrace = find_start_brace();
  
! 	// If both an unmatched '(' and '{' is found.  Ignore the '('
! 	// position if the '{' is further down.
  	if (tryposBrace != NULL
  		&& (trypos->lnum != tryposBrace->lnum
  		    ? trypos->lnum < tryposBrace->lnum
***************
*** 1697,1708 ****
      int		retval = FALSE;
      int		open_count = 0;
  
!     curwin->w_cursor.col = 0;		    /* default is start of line */
  
      for (i = 0; l[i] != NUL; i++)
      {
! 	i = (int)(cin_skipcomment(l + i) - l); /* ignore parens in comments */
! 	i = (int)(skip_string(l + i) - l);    /* ignore parens in quotes */
  	if (l[i] == start)
  	    ++open_count;
  	else if (l[i] == end)
--- 1685,1696 ----
      int		retval = FALSE;
      int		open_count = 0;
  
!     curwin->w_cursor.col = 0;		    // default is start of line
  
      for (i = 0; l[i] != NUL; i++)
      {
! 	i = (int)(cin_skipcomment(l + i) - l); // ignore parens in comments
! 	i = (int)(skip_string(l + i) - l);    // ignore parens in quotes
  	if (l[i] == start)
  	    ++open_count;
  	else if (l[i] == end)
***************
*** 1734,1867 ****
      int		fraction = 0;
      int		sw = (int)get_sw_value(buf);
  
!     /*
!      * Set the default values.
!      */
!     /* Spaces from a block's opening brace the prevailing indent for that
!      * block should be. */
      buf->b_ind_level = sw;
  
!     /* Spaces from the edge of the line an open brace that's at the end of a
!      * line is imagined to be. */
      buf->b_ind_open_imag = 0;
  
!     /* Spaces from the prevailing indent for a line that is not preceded by
!      * an opening brace. */
      buf->b_ind_no_brace = 0;
  
!     /* Column where the first { of a function should be located }. */
      buf->b_ind_first_open = 0;
  
!     /* Spaces from the prevailing indent a leftmost open brace should be
!      * located. */
      buf->b_ind_open_extra = 0;
  
!     /* Spaces from the matching open brace (real location for one at the left
!      * edge; imaginary location from one that ends a line) the matching close
!      * brace should be located. */
      buf->b_ind_close_extra = 0;
  
!     /* Spaces from the edge of the line an open brace sitting in the leftmost
!      * column is imagined to be. */
      buf->b_ind_open_left_imag = 0;
  
!     /* Spaces jump labels should be shifted to the left if N is non-negative,
!      * otherwise the jump label will be put to column 1. */
      buf->b_ind_jump_label = -1;
  
!     /* Spaces from the switch() indent a "case xx" label should be located. */
      buf->b_ind_case = sw;
  
!     /* Spaces from the "case xx:" code after a switch() should be located. */
      buf->b_ind_case_code = sw;
  
!     /* Lineup break at end of case in switch() with case label. */
      buf->b_ind_case_break = 0;
  
!     /* Spaces from the class declaration indent a scope declaration label
!      * should be located. */
      buf->b_ind_scopedecl = sw;
  
!     /* Spaces from the scope declaration label code should be located. */
      buf->b_ind_scopedecl_code = sw;
  
!     /* Amount K&R-style parameters should be indented. */
      buf->b_ind_param = sw;
  
!     /* Amount a function type spec should be indented. */
      buf->b_ind_func_type = sw;
  
!     /* Amount a cpp base class declaration or constructor initialization
!      * should be indented. */
      buf->b_ind_cpp_baseclass = sw;
  
!     /* additional spaces beyond the prevailing indent a continuation line
!      * should be located. */
      buf->b_ind_continuation = sw;
  
!     /* Spaces from the indent of the line with an unclosed parentheses. */
      buf->b_ind_unclosed = sw * 2;
  
!     /* Spaces from the indent of the line with an unclosed parentheses, which
!      * itself is also unclosed. */
      buf->b_ind_unclosed2 = sw;
  
!     /* Suppress ignoring spaces from the indent of a line starting with an
!      * unclosed parentheses. */
      buf->b_ind_unclosed_noignore = 0;
  
!     /* If the opening paren is the last nonwhite character on the line, and
!      * b_ind_unclosed_wrapped is nonzero, use this indent relative to the outer
!      * context (for very long lines). */
      buf->b_ind_unclosed_wrapped = 0;
  
!     /* Suppress ignoring white space when lining up with the character after
!      * an unclosed parentheses. */
      buf->b_ind_unclosed_whiteok = 0;
  
!     /* Indent a closing parentheses under the line start of the matching
!      * opening parentheses. */
      buf->b_ind_matching_paren = 0;
  
!     /* Indent a closing parentheses under the previous line. */
      buf->b_ind_paren_prev = 0;
  
!     /* Extra indent for comments. */
      buf->b_ind_comment = 0;
  
!     /* Spaces from the comment opener when there is nothing after it. */
      buf->b_ind_in_comment = 3;
  
!     /* Boolean: if non-zero, use b_ind_in_comment even if there is something
!      * after the comment opener. */
      buf->b_ind_in_comment2 = 0;
  
!     /* Max lines to search for an open paren. */
      buf->b_ind_maxparen = 20;
  
!     /* Max lines to search for an open comment. */
      buf->b_ind_maxcomment = 70;
  
!     /* Handle braces for java code. */
      buf->b_ind_java = 0;
  
!     /* Not to confuse JS object properties with labels. */
      buf->b_ind_js = 0;
  
!     /* Handle blocked cases correctly. */
      buf->b_ind_keep_case_label = 0;
  
!     /* Handle C++ namespace. */
      buf->b_ind_cpp_namespace = 0;
  
!     /* Handle continuation lines containing conditions of if(), for() and
!      * while(). */
      buf->b_ind_if_for_while = 0;
  
!     /* indentation for # comments */
      buf->b_ind_hash_comment = 0;
  
!     /* Handle C++ extern "C" or "C++" */
      buf->b_ind_cpp_extern_c = 0;
  
      for (p = buf->b_p_cino; *p; )
--- 1722,1854 ----
      int		fraction = 0;
      int		sw = (int)get_sw_value(buf);
  
!     // Set the default values.
! 
!     // Spaces from a block's opening brace the prevailing indent for that
!     // block should be.
      buf->b_ind_level = sw;
  
!     // Spaces from the edge of the line an open brace that's at the end of a
!     // line is imagined to be.
      buf->b_ind_open_imag = 0;
  
!     // Spaces from the prevailing indent for a line that is not preceded by
!     // an opening brace.
      buf->b_ind_no_brace = 0;
  
!     // Column where the first { of a function should be located }.
      buf->b_ind_first_open = 0;
  
!     // Spaces from the prevailing indent a leftmost open brace should be
!     // located.
      buf->b_ind_open_extra = 0;
  
!     // Spaces from the matching open brace (real location for one at the left
!     // edge; imaginary location from one that ends a line) the matching close
!     // brace should be located.
      buf->b_ind_close_extra = 0;
  
!     // Spaces from the edge of the line an open brace sitting in the leftmost
!     // column is imagined to be.
      buf->b_ind_open_left_imag = 0;
  
!     // Spaces jump labels should be shifted to the left if N is non-negative,
!     // otherwise the jump label will be put to column 1.
      buf->b_ind_jump_label = -1;
  
!     // Spaces from the switch() indent a "case xx" label should be located.
      buf->b_ind_case = sw;
  
!     // Spaces from the "case xx:" code after a switch() should be located.
      buf->b_ind_case_code = sw;
  
!     // Lineup break at end of case in switch() with case label.
      buf->b_ind_case_break = 0;
  
!     // Spaces from the class declaration indent a scope declaration label
!     // should be located.
      buf->b_ind_scopedecl = sw;
  
!     // Spaces from the scope declaration label code should be located.
      buf->b_ind_scopedecl_code = sw;
  
!     // Amount K&R-style parameters should be indented.
      buf->b_ind_param = sw;
  
!     // Amount a function type spec should be indented.
      buf->b_ind_func_type = sw;
  
!     // Amount a cpp base class declaration or constructor initialization
!     // should be indented.
      buf->b_ind_cpp_baseclass = sw;
  
!     // additional spaces beyond the prevailing indent a continuation line
!     // should be located.
      buf->b_ind_continuation = sw;
  
!     // Spaces from the indent of the line with an unclosed parentheses.
      buf->b_ind_unclosed = sw * 2;
  
!     // Spaces from the indent of the line with an unclosed parentheses, which
!     // itself is also unclosed.
      buf->b_ind_unclosed2 = sw;
  
!     // Suppress ignoring spaces from the indent of a line starting with an
!     // unclosed parentheses.
      buf->b_ind_unclosed_noignore = 0;
  
!     // If the opening paren is the last nonwhite character on the line, and
!     // b_ind_unclosed_wrapped is nonzero, use this indent relative to the outer
!     // context (for very long lines).
      buf->b_ind_unclosed_wrapped = 0;
  
!     // Suppress ignoring white space when lining up with the character after
!     // an unclosed parentheses.
      buf->b_ind_unclosed_whiteok = 0;
  
!     // Indent a closing parentheses under the line start of the matching
!     // opening parentheses.
      buf->b_ind_matching_paren = 0;
  
!     // Indent a closing parentheses under the previous line.
      buf->b_ind_paren_prev = 0;
  
!     // Extra indent for comments.
      buf->b_ind_comment = 0;
  
!     // Spaces from the comment opener when there is nothing after it.
      buf->b_ind_in_comment = 3;
  
!     // Boolean: if non-zero, use b_ind_in_comment even if there is something
!     // after the comment opener.
      buf->b_ind_in_comment2 = 0;
  
!     // Max lines to search for an open paren.
      buf->b_ind_maxparen = 20;
  
!     // Max lines to search for an open comment.
      buf->b_ind_maxcomment = 70;
  
!     // Handle braces for java code.
      buf->b_ind_java = 0;
  
!     // Not to confuse JS object properties with labels.
      buf->b_ind_js = 0;
  
!     // Handle blocked cases correctly.
      buf->b_ind_keep_case_label = 0;
  
!     // Handle C++ namespace.
      buf->b_ind_cpp_namespace = 0;
  
!     // Handle continuation lines containing conditions of if(), for() and
!     // while().
      buf->b_ind_if_for_while = 0;
  
!     // indentation for # comments
      buf->b_ind_hash_comment = 0;
  
!     // Handle C++ extern "C" or "C++"
      buf->b_ind_cpp_extern_c = 0;
  
      for (p = buf->b_p_cino; *p; )
***************
*** 1869,1878 ****
  	l = p++;
  	if (*p == '-')
  	    ++p;
! 	digits = p;	    /* remember where the digits start */
  	n = getdigits(&p);
  	divider = 0;
! 	if (*p == '.')	    /* ".5s" means a fraction */
  	{
  	    fraction = atol((char *)++p);
  	    while (VIM_ISDIGIT(*p))
--- 1856,1865 ----
  	l = p++;
  	if (*p == '-')
  	    ++p;
! 	digits = p;	    // remember where the digits start
  	n = getdigits(&p);
  	divider = 0;
! 	if (*p == '.')	    // ".5s" means a fraction
  	{
  	    fraction = atol((char *)++p);
  	    while (VIM_ISDIGIT(*p))
***************
*** 1884,1893 ****
  		    divider = 10;
  	    }
  	}
! 	if (*p == 's')	    /* "2s" means two times 'shiftwidth' */
  	{
  	    if (p == digits)
! 		n = sw;	/* just "s" is one 'shiftwidth' */
  	    else
  	    {
  		n *= sw;
--- 1871,1880 ----
  		    divider = 10;
  	    }
  	}
! 	if (*p == 's')	    // "2s" means two times 'shiftwidth'
  	{
  	    if (p == digits)
! 		n = sw;	// just "s" is one 'shiftwidth'
  	    else
  	    {
  		n *= sw;
***************
*** 1899,1906 ****
  	if (l[1] == '-')
  	    n = -n;
  
! 	/* When adding an entry here, also update the default 'cinoptions' in
! 	 * doc/indent.txt, and add explanation for it! */
  	switch (*l)
  	{
  	    case '>': buf->b_ind_level = n; break;
--- 1886,1893 ----
  	if (l[1] == '-')
  	    n = -n;
  
! 	// When adding an entry here, also update the default 'cinoptions' in
! 	// doc/indent.txt, and add explanation for it!
  	switch (*l)
  	{
  	    case '>': buf->b_ind_level = n; break;
***************
*** 1966,1974 ****
      pos_T	our_paren_pos;
      char_u	*start;
      int		start_brace;
! #define BRACE_IN_COL0		1	    /* '{' is in column 0 */
! #define BRACE_AT_START		2	    /* '{' is at start of line */
! #define BRACE_AT_END		3	    /* '{' is at end of line */
      linenr_T	ourscope;
      char_u	*l;
      char_u	*look;
--- 1953,1961 ----
      pos_T	our_paren_pos;
      char_u	*start;
      int		start_brace;
! #define BRACE_IN_COL0		1	    // '{' is in column 0
! #define BRACE_AT_START		2	    // '{' is at start of line
! #define BRACE_AT_END		3	    // '{' is at end of line
      linenr_T	ourscope;
      char_u	*l;
      char_u	*look;
***************
*** 1994,2030 ****
      int		iscase;
      int		lookfor_break;
      int		lookfor_cpp_namespace = FALSE;
!     int		cont_amount = 0;    /* amount for continuation line */
      int		original_line_islabel;
      int		added_to_amount = 0;
      int		js_cur_has_key = 0;
      linenr_T	raw_string_start = 0;
      cpp_baseclass_cache_T cache_cpp_baseclass = { FALSE, { MAXLNUM, 0 } };
  
!     /* make a copy, value is changed below */
      int		ind_continuation = curbuf->b_ind_continuation;
  
!     /* remember where the cursor was when we started */
      cur_curpos = curwin->w_cursor;
  
!     /* if we are at line 1 zero indent is fine, right? */
      if (cur_curpos.lnum == 1)
  	return 0;
  
!     /* Get a copy of the current contents of the line.
!      * This is required, because only the most recent line obtained with
!      * ml_get is valid! */
      linecopy = vim_strsave(ml_get(cur_curpos.lnum));
      if (linecopy == NULL)
  	return 0;
  
!     /*
!      * In insert mode and the cursor is on a ')' truncate the line at the
!      * cursor position.  We don't want to line up with the matching '(' when
!      * inserting new stuff.
!      * For unknown reasons the cursor might be past the end of the line, thus
!      * check for that.
!      */
      if ((State & INSERT)
  	    && curwin->w_cursor.col < (colnr_T)STRLEN(linecopy)
  	    && linecopy[curwin->w_cursor.col] == ')')
--- 1981,2015 ----
      int		iscase;
      int		lookfor_break;
      int		lookfor_cpp_namespace = FALSE;
!     int		cont_amount = 0;    // amount for continuation line
      int		original_line_islabel;
      int		added_to_amount = 0;
      int		js_cur_has_key = 0;
      linenr_T	raw_string_start = 0;
      cpp_baseclass_cache_T cache_cpp_baseclass = { FALSE, { MAXLNUM, 0 } };
  
!     // make a copy, value is changed below
      int		ind_continuation = curbuf->b_ind_continuation;
  
!     // remember where the cursor was when we started
      cur_curpos = curwin->w_cursor;
  
!     // if we are at line 1 zero indent is fine, right?
      if (cur_curpos.lnum == 1)
  	return 0;
  
!     // Get a copy of the current contents of the line.
!     // This is required, because only the most recent line obtained with
!     // ml_get is valid!
      linecopy = vim_strsave(ml_get(cur_curpos.lnum));
      if (linecopy == NULL)
  	return 0;
  
!     // In insert mode and the cursor is on a ')' truncate the line at the
!     // cursor position.  We don't want to line up with the matching '(' when
!     // inserting new stuff.
!     // For unknown reasons the cursor might be past the end of the line, thus
!     // check for that.
      if ((State & INSERT)
  	    && curwin->w_cursor.col < (colnr_T)STRLEN(linecopy)
  	    && linecopy[curwin->w_cursor.col] == ')')
***************
*** 2032,2051 ****
  
      theline = skipwhite(linecopy);
  
!     /* move the cursor to the start of the line */
  
      curwin->w_cursor.col = 0;
  
!     original_line_islabel = cin_islabel();  /* XXX */
  
!     /*
!      * If we are inside a raw string don't change the indent.
!      * Ignore a raw string inside a comment.
!      */
      comment_pos = ind_find_start_comment();
      if (comment_pos != NULL)
      {
! 	/* findmatchlimit() static pos is overwritten, make a copy */
  	tryposCopy = *comment_pos;
  	comment_pos = &tryposCopy;
      }
--- 2017,2034 ----
  
      theline = skipwhite(linecopy);
  
!     // move the cursor to the start of the line
  
      curwin->w_cursor.col = 0;
  
!     original_line_islabel = cin_islabel();  // XXX
  
!     // If we are inside a raw string don't change the indent.
!     // Ignore a raw string inside a comment.
      comment_pos = ind_find_start_comment();
      if (comment_pos != NULL)
      {
! 	// findmatchlimit() static pos is overwritten, make a copy
  	tryposCopy = *comment_pos;
  	comment_pos = &tryposCopy;
      }
***************
*** 2057,2076 ****
  	goto laterend;
      }
  
!     /*
!      * #defines and so on always go at the left when included in 'cinkeys'.
!      */
      if (*theline == '#' && (*linecopy == '#' || in_cinkeys('#', ' ', TRUE)))
      {
  	amount = curbuf->b_ind_hash_comment;
  	goto theend;
      }
  
!     /*
!      * Is it a non-case label?	Then that goes at the left margin too unless:
!      *  - JS flag is set.
!      *  - 'L' item has a positive value.
!      */
      if (original_line_islabel && !curbuf->b_ind_js
  					      && curbuf->b_ind_jump_label < 0)
      {
--- 2040,2055 ----
  	goto laterend;
      }
  
!     // #defines and so on always go at the left when included in 'cinkeys'.
      if (*theline == '#' && (*linecopy == '#' || in_cinkeys('#', ' ', TRUE)))
      {
  	amount = curbuf->b_ind_hash_comment;
  	goto theend;
      }
  
!     // Is it a non-case label?	Then that goes at the left margin too unless:
!     //  - JS flag is set.
!     //  - 'L' item has a positive value.
      if (original_line_islabel && !curbuf->b_ind_js
  					      && curbuf->b_ind_jump_label < 0)
      {
***************
*** 2078,2113 ****
  	goto theend;
      }
  
!     /*
!      * If we're inside a "//" comment and there is a "//" comment in a
!      * previous line, lineup with that one.
!      */
      if (cin_islinecomment(theline)
! 	    && (trypos = find_line_comment()) != NULL) /* XXX */
      {
! 	/* find how indented the line beginning the comment is */
  	getvcol(curwin, trypos, &col, NULL, NULL);
  	amount = col;
  	goto theend;
      }
  
!     /*
!      * If we're inside a comment and not looking at the start of the
!      * comment, try using the 'comments' option.
!      */
!     if (!cin_iscomment(theline) && comment_pos != NULL) /* XXX */
      {
  	int	lead_start_len = 2;
  	int	lead_middle_len = 1;
! 	char_u	lead_start[COM_MAX_LEN];	/* start-comment string */
! 	char_u	lead_middle[COM_MAX_LEN];	/* middle-comment string */
! 	char_u	lead_end[COM_MAX_LEN];		/* end-comment string */
  	char_u	*p;
  	int	start_align = 0;
  	int	start_off = 0;
  	int	done = FALSE;
  
! 	/* find how indented the line beginning the comment is */
  	getvcol(curwin, comment_pos, &col, NULL, NULL);
  	amount = col;
  	*lead_start = NUL;
--- 2057,2088 ----
  	goto theend;
      }
  
!     // If we're inside a "//" comment and there is a "//" comment in a
!     // previous line, lineup with that one.
      if (cin_islinecomment(theline)
! 	    && (trypos = find_line_comment()) != NULL) // XXX
      {
! 	// find how indented the line beginning the comment is
  	getvcol(curwin, trypos, &col, NULL, NULL);
  	amount = col;
  	goto theend;
      }
  
!     // If we're inside a comment and not looking at the start of the
!     // comment, try using the 'comments' option.
!     if (!cin_iscomment(theline) && comment_pos != NULL) // XXX
      {
  	int	lead_start_len = 2;
  	int	lead_middle_len = 1;
! 	char_u	lead_start[COM_MAX_LEN];	// start-comment string
! 	char_u	lead_middle[COM_MAX_LEN];	// middle-comment string
! 	char_u	lead_end[COM_MAX_LEN];		// end-comment string
  	char_u	*p;
  	int	start_align = 0;
  	int	start_off = 0;
  	int	done = FALSE;
  
! 	// find how indented the line beginning the comment is
  	getvcol(curwin, comment_pos, &col, NULL, NULL);
  	amount = col;
  	*lead_start = NUL;
***************
*** 2149,2166 ****
  	    }
  	    else if (what == COM_END)
  	    {
! 		/* If our line starts with the middle comment string, line it
! 		 * up with the comment opener per the 'comments' option. */
  		if (STRNCMP(theline, lead_middle, lead_middle_len) == 0
  			&& STRNCMP(theline, lead_end, STRLEN(lead_end)) != 0)
  		{
  		    done = TRUE;
  		    if (curwin->w_cursor.lnum > 1)
  		    {
! 			/* If the start comment string matches in the previous
! 			 * line, use the indent of that line plus offset.  If
! 			 * the middle comment string matches in the previous
! 			 * line, use the indent of that line.  XXX */
  			look = skipwhite(ml_get(curwin->w_cursor.lnum - 1));
  			if (STRNCMP(look, lead_start, lead_start_len) == 0)
  			    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);
--- 2124,2141 ----
  	    }
  	    else if (what == COM_END)
  	    {
! 		// If our line starts with the middle comment string, line it
! 		// up with the comment opener per the 'comments' option.
  		if (STRNCMP(theline, lead_middle, lead_middle_len) == 0
  			&& STRNCMP(theline, lead_end, STRLEN(lead_end)) != 0)
  		{
  		    done = TRUE;
  		    if (curwin->w_cursor.lnum > 1)
  		    {
! 			// If the start comment string matches in the previous
! 			// line, use the indent of that line plus offset.  If
! 			// the middle comment string matches in the previous
! 			// line, use the indent of that line.  XXX
  			look = skipwhite(ml_get(curwin->w_cursor.lnum - 1));
  			if (STRNCMP(look, lead_start, lead_start_len) == 0)
  			    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);
***************
*** 2170,2177 ****
  			    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);
  			    break;
  			}
! 			/* If the start comment string doesn't match with the
! 			 * start of the comment, skip this entry. XXX */
  			else if (STRNCMP(ml_get(comment_pos->lnum) + comment_pos->col,
  					     lead_start, lead_start_len) != 0)
  			    continue;
--- 2145,2152 ----
  			    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);
  			    break;
  			}
! 			// If the start comment string doesn't match with the
! 			// start of the comment, skip this entry.  XXX
  			else if (STRNCMP(ml_get(comment_pos->lnum) + comment_pos->col,
  					     lead_start, lead_start_len) != 0)
  			    continue;
***************
*** 2184,2196 ****
  		    break;
  		}
  
! 		/* If our line starts with the end comment string, line it up
! 		 * with the middle comment */
  		if (STRNCMP(theline, lead_middle, lead_middle_len) != 0
  			&& STRNCMP(theline, lead_end, STRLEN(lead_end)) == 0)
  		{
  		    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);
! 								     /* XXX */
  		    if (off != 0)
  			amount += off;
  		    else if (align == COM_RIGHT)
--- 2159,2171 ----
  		    break;
  		}
  
! 		// If our line starts with the end comment string, line it up
! 		// with the middle comment
  		if (STRNCMP(theline, lead_middle, lead_middle_len) != 0
  			&& STRNCMP(theline, lead_end, STRLEN(lead_end)) == 0)
  		{
  		    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);
! 								     // XXX
  		    if (off != 0)
  			amount += off;
  		    else if (align == COM_RIGHT)
***************
*** 2202,2239 ****
  	    }
  	}
  
! 	/* If our line starts with an asterisk, line up with the
! 	 * asterisk in the comment opener; otherwise, line up
! 	 * with the first character of the comment text.
! 	 */
  	if (done)
  	    ;
  	else if (theline[0] == '*')
  	    amount += 1;
  	else
  	{
! 	    /*
! 	     * If we are more than one line away from the comment opener, take
! 	     * the indent of the previous non-empty line.  If 'cino' has "CO"
! 	     * and we are just below the comment opener and there are any
! 	     * white characters after it line up with the text after it;
! 	     * otherwise, add the amount specified by "c" in 'cino'
! 	     */
  	    amount = -1;
  	    for (lnum = cur_curpos.lnum - 1; lnum > comment_pos->lnum; --lnum)
  	    {
! 		if (linewhite(lnum))		    /* skip blank lines */
  		    continue;
! 		amount = get_indent_lnum(lnum);	    /* XXX */
  		break;
  	    }
! 	    if (amount == -1)			    /* use the comment opener */
  	    {
  		if (!curbuf->b_ind_in_comment2)
  		{
  		    start = ml_get(comment_pos->lnum);
! 		    look = start + comment_pos->col + 2; /* skip / and * */
! 		    if (*look != NUL)		    /* if something after it */
  			comment_pos->col = (colnr_T)(skipwhite(look) - start);
  		}
  		getvcol(curwin, comment_pos, &col, NULL, NULL);
--- 2177,2211 ----
  	    }
  	}
  
! 	// If our line starts with an asterisk, line up with the
! 	// asterisk in the comment opener; otherwise, line up
! 	// with the first character of the comment text.
  	if (done)
  	    ;
  	else if (theline[0] == '*')
  	    amount += 1;
  	else
  	{
! 	    // If we are more than one line away from the comment opener, take
! 	    // the indent of the previous non-empty line.  If 'cino' has "CO"
! 	    // and we are just below the comment opener and there are any
! 	    // white characters after it line up with the text after it;
! 	    // otherwise, add the amount specified by "c" in 'cino'
  	    amount = -1;
  	    for (lnum = cur_curpos.lnum - 1; lnum > comment_pos->lnum; --lnum)
  	    {
! 		if (linewhite(lnum))		    // skip blank lines
  		    continue;
! 		amount = get_indent_lnum(lnum);	    // XXX
  		break;
  	    }
! 	    if (amount == -1)			    // use the comment opener
  	    {
  		if (!curbuf->b_ind_in_comment2)
  		{
  		    start = ml_get(comment_pos->lnum);
! 		    look = start + comment_pos->col + 2; // skip / and *
! 		    if (*look != NUL)		    // if something after it
  			comment_pos->col = (colnr_T)(skipwhite(look) - start);
  		}
  		getvcol(curwin, comment_pos, &col, NULL, NULL);
***************
*** 2245,2264 ****
  	goto theend;
      }
  
!     /*
!      * Are we looking at a ']' that has a match?
!      */
      if (*skipwhite(theline) == ']'
  	    && (trypos = find_match_char('[', curbuf->b_ind_maxparen)) != NULL)
      {
! 	/* align with the line containing the '['. */
  	amount = get_indent_lnum(trypos->lnum);
  	goto theend;
      }
  
!     /*
!      * Are we inside parentheses or braces?
!      */						    /* XXX */
      if (((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL
  		&& curbuf->b_ind_java == 0)
  	    || (tryposBrace = find_start_brace()) != NULL
--- 2217,2232 ----
  	goto theend;
      }
  
!     // Are we looking at a ']' that has a match?
      if (*skipwhite(theline) == ']'
  	    && (trypos = find_match_char('[', curbuf->b_ind_maxparen)) != NULL)
      {
! 	// align with the line containing the '['.
  	amount = get_indent_lnum(trypos->lnum);
  	goto theend;
      }
  
!     // Are we inside parentheses or braces?  XXX
      if (((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL
  		&& curbuf->b_ind_java == 0)
  	    || (tryposBrace = find_start_brace()) != NULL
***************
*** 2266,2273 ****
      {
        if (trypos != NULL && tryposBrace != NULL)
        {
! 	  /* Both an unmatched '(' and '{' is found.  Use the one which is
! 	   * closer to the current cursor position, set the other to NULL. */
  	  if (trypos->lnum != tryposBrace->lnum
  		  ? trypos->lnum < tryposBrace->lnum
  		  : trypos->col < tryposBrace->col)
--- 2234,2241 ----
      {
        if (trypos != NULL && tryposBrace != NULL)
        {
! 	  // Both an unmatched '(' and '{' is found.  Use the one which is
! 	  // closer to the current cursor position, set the other to NULL.
  	  if (trypos->lnum != tryposBrace->lnum
  		  ? trypos->lnum < tryposBrace->lnum
  		  : trypos->col < tryposBrace->col)
***************
*** 2278,2291 ****
  
        if (trypos != NULL)
        {
! 	/*
! 	 * If the matching paren is more than one line away, use the indent of
! 	 * a previous non-empty line that matches the same paren.
! 	 */
  	if (theline[0] == ')' && curbuf->b_ind_paren_prev)
  	{
! 	    /* Line up with the start of the matching paren line. */
! 	    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);  /* XXX */
  	}
  	else
  	{
--- 2246,2257 ----
  
        if (trypos != NULL)
        {
! 	// If the matching paren is more than one line away, use the indent of
! 	// a previous non-empty line that matches the same paren.
  	if (theline[0] == ')' && curbuf->b_ind_paren_prev)
  	{
! 	    // Line up with the start of the matching paren line.
! 	    amount = get_indent_lnum(curwin->w_cursor.lnum - 1);  // XXX
  	}
  	else
  	{
***************
*** 2294,2319 ****
  	    for (lnum = cur_curpos.lnum - 1; lnum > our_paren_pos.lnum; --lnum)
  	    {
  		l = skipwhite(ml_get(lnum));
! 		if (cin_nocode(l))		/* skip comment lines */
  		    continue;
  		if (cin_ispreproc_cont(&l, &lnum, &amount))
! 		    continue;			/* ignore #define, #if, etc. */
  		curwin->w_cursor.lnum = lnum;
  
! 		/* Skip a comment or raw string. XXX */
  		if ((trypos = ind_find_start_CORS(NULL)) != NULL)
  		{
  		    lnum = trypos->lnum + 1;
  		    continue;
  		}
  
! 		/* XXX */
  		if ((trypos = find_match_paren(
  			corr_ind_maxparen(&cur_curpos))) != NULL
  			&& trypos->lnum == our_paren_pos.lnum
  			&& trypos->col == our_paren_pos.col)
  		{
! 			amount = get_indent_lnum(lnum);	/* XXX */
  
  			if (theline[0] == ')')
  			{
--- 2260,2285 ----
  	    for (lnum = cur_curpos.lnum - 1; lnum > our_paren_pos.lnum; --lnum)
  	    {
  		l = skipwhite(ml_get(lnum));
! 		if (cin_nocode(l))		// skip comment lines
  		    continue;
  		if (cin_ispreproc_cont(&l, &lnum, &amount))
! 		    continue;			// ignore #define, #if, etc.
  		curwin->w_cursor.lnum = lnum;
  
! 		// Skip a comment or raw string.  XXX
  		if ((trypos = ind_find_start_CORS(NULL)) != NULL)
  		{
  		    lnum = trypos->lnum + 1;
  		    continue;
  		}
  
! 		// XXX
  		if ((trypos = find_match_paren(
  			corr_ind_maxparen(&cur_curpos))) != NULL
  			&& trypos->lnum == our_paren_pos.lnum
  			&& trypos->col == our_paren_pos.col)
  		{
! 			amount = get_indent_lnum(lnum);	// XXX
  
  			if (theline[0] == ')')
  			{
***************
*** 2327,2337 ****
  	    }
  	}
  
! 	/*
! 	 * Line up with line where the matching paren is. XXX
! 	 * If the line starts with a '(' or the indent for unclosed
! 	 * parentheses is zero, line up with the unclosed parentheses.
! 	 */
  	if (amount == -1)
  	{
  	    int	    ignore_paren_col = 0;
--- 2293,2301 ----
  	    }
  	}
  
! 	// Line up with line where the matching paren is. XXX
! 	// If the line starts with a '(' or the indent for unclosed
! 	// parentheses is zero, line up with the unclosed parentheses.
  	if (amount == -1)
  	{
  	    int	    ignore_paren_col = 0;
***************
*** 2339,2346 ****
  
  	    if (curbuf->b_ind_if_for_while)
  	    {
! 		/* Look for the outermost opening parenthesis on this line
! 		 * and check whether it belongs to an "if", "for" or "while". */
  
  		pos_T	    cursor_save = curwin->w_cursor;
  		pos_T	    outermost;
--- 2303,2310 ----
  
  	    if (curbuf->b_ind_if_for_while)
  	    {
! 		// Look for the outermost opening parenthesis on this line
! 		// and check whether it belongs to an "if", "for" or "while".
  
  		pos_T	    cursor_save = curwin->w_cursor;
  		pos_T	    outermost;
***************
*** 2371,2378 ****
  		char_u	    *line;
  		int	    look_col;
  
! 		/* Ignore a '(' in front of the line that has a match before
! 		 * our matching '('. */
  		curwin->w_cursor.lnum = our_paren_pos.lnum;
  		line = ml_get_curline();
  		look_col = (int)(look - line);
--- 2335,2342 ----
  		char_u	    *line;
  		int	    look_col;
  
! 		// Ignore a '(' in front of the line that has a match before
! 		// our matching '('.
  		curwin->w_cursor.lnum = our_paren_pos.lnum;
  		line = ml_get_curline();
  		look_col = (int)(look - line);
***************
*** 2392,2406 ****
  		    || (!curbuf->b_ind_unclosed_noignore && *look == '('
  						    && ignore_paren_col == 0))
  	    {
! 		/*
! 		 * If we're looking at a close paren, line up right there;
! 		 * otherwise, line up with the next (non-white) character.
! 		 * When b_ind_unclosed_wrapped is set and the matching paren is
! 		 * the last nonwhite character of the line, use either the
! 		 * indent of the current line or the indentation of the next
! 		 * outer paren and add b_ind_unclosed_wrapped (for very long
! 		 * lines).
! 		 */
  		if (theline[0] != ')')
  		{
  		    cur_amount = MAXCOL;
--- 2356,2368 ----
  		    || (!curbuf->b_ind_unclosed_noignore && *look == '('
  						    && ignore_paren_col == 0))
  	    {
! 		// If we're looking at a close paren, line up right there;
! 		// otherwise, line up with the next (non-white) character.
! 		// When b_ind_unclosed_wrapped is set and the matching paren is
! 		// the last nonwhite character of the line, use either the
! 		// indent of the current line or the indentation of the next
! 		// outer paren and add b_ind_unclosed_wrapped (for very long
! 		// lines).
  		if (theline[0] != ')')
  		{
  		    cur_amount = MAXCOL;
***************
*** 2408,2415 ****
  		    if (curbuf->b_ind_unclosed_wrapped
  				       && cin_ends_in(l, (char_u *)"(", NULL))
  		    {
! 			/* look for opening unmatched paren, indent one level
! 			 * for each additional level */
  			n = 1;
  			for (col = 0; col < our_paren_pos.col; ++col)
  			{
--- 2370,2377 ----
  		    if (curbuf->b_ind_unclosed_wrapped
  				       && cin_ends_in(l, (char_u *)"(", NULL))
  		    {
! 			// look for opening unmatched paren, indent one level
! 			// for each additional level
  			n = 1;
  			for (col = 0; col < our_paren_pos.col; ++col)
  			{
***************
*** 2436,2452 ****
  			col = our_paren_pos.col + 1;
  			while (VIM_ISWHITE(l[col]))
  			    col++;
! 			if (l[col] != NUL)	/* In case of trailing space */
  			    our_paren_pos.col = col;
  			else
  			    our_paren_pos.col++;
  		    }
  		}
  
! 		/*
! 		 * Find how indented the paren is, or the character after it
! 		 * if we did the above "if".
! 		 */
  		if (our_paren_pos.col > 0)
  		{
  		    getvcol(curwin, &our_paren_pos, &col, NULL, NULL);
--- 2398,2412 ----
  			col = our_paren_pos.col + 1;
  			while (VIM_ISWHITE(l[col]))
  			    col++;
! 			if (l[col] != NUL)	// In case of trailing space
  			    our_paren_pos.col = col;
  			else
  			    our_paren_pos.col++;
  		    }
  		}
  
! 		// Find how indented the paren is, or the character after it
! 		// if we did the above "if".
  		if (our_paren_pos.col > 0)
  		{
  		    getvcol(curwin, &our_paren_pos, &col, NULL, NULL);
***************
*** 2457,2463 ****
  
  	    if (theline[0] == ')' && curbuf->b_ind_matching_paren)
  	    {
! 		/* Line up with the start of the matching paren line. */
  	    }
  	    else if ((curbuf->b_ind_unclosed == 0 && is_if_for_while == 0)
  		     || (!curbuf->b_ind_unclosed_noignore
--- 2417,2423 ----
  
  	    if (theline[0] == ')' && curbuf->b_ind_matching_paren)
  	    {
! 		// Line up with the start of the matching paren line.
  	    }
  	    else if ((curbuf->b_ind_unclosed == 0 && is_if_for_while == 0)
  		     || (!curbuf->b_ind_unclosed_noignore
***************
*** 2468,2475 ****
  	    }
  	    else
  	    {
! 		/* Add b_ind_unclosed2 for each '(' before our matching one,
! 		 * but ignore (void) before the line (ignore_paren_col). */
  		col = our_paren_pos.col;
  		while ((int)our_paren_pos.col > ignore_paren_col)
  		{
--- 2428,2435 ----
  	    }
  	    else
  	    {
! 		// Add b_ind_unclosed2 for each '(' before our matching one,
! 		// but ignore (void) before the line (ignore_paren_col).
  		col = our_paren_pos.col;
  		while ((int)our_paren_pos.col > ignore_paren_col)
  		{
***************
*** 2485,2492 ****
  		    }
  		}
  
! 		/* Use b_ind_unclosed once, when the first '(' is not inside
! 		 * braces */
  		if (col == MAXCOL)
  		    amount += curbuf->b_ind_unclosed;
  		else
--- 2445,2452 ----
  		    }
  		}
  
! 		// Use b_ind_unclosed once, when the first '(' is not inside
! 		// braces
  		if (col == MAXCOL)
  		    amount += curbuf->b_ind_unclosed;
  		else
***************
*** 2504,2546 ****
  			    amount += curbuf->b_ind_unclosed;
  		    }
  		}
! 		/*
! 		 * For a line starting with ')' use the minimum of the two
! 		 * positions, to avoid giving it more indent than the previous
! 		 * lines:
! 		 *  func_long_name(		    if (x
! 		 *	arg				    && yy
! 		 *	)	  ^ not here	       )    ^ not here
! 		 */
  		if (cur_amount < amount)
  		    amount = cur_amount;
  	    }
  	}
  
! 	/* add extra indent for a comment */
  	if (cin_iscomment(theline))
  	    amount += curbuf->b_ind_comment;
        }
        else
        {
! 	/*
! 	 * We are inside braces, there is a { before this line at the position
! 	 * stored in tryposBrace.
! 	 * Make a copy of tryposBrace, it may point to pos_copy inside
! 	 * find_start_brace(), which may be changed somewhere.
! 	 */
  	tryposCopy = *tryposBrace;
  	tryposBrace = &tryposCopy;
  	trypos = tryposBrace;
  	ourscope = trypos->lnum;
  	start = ml_get(ourscope);
  
! 	/*
! 	 * Now figure out how indented the line is in general.
! 	 * If the brace was at the start of the line, we use that;
! 	 * otherwise, check out the indentation of the line as
! 	 * a whole and then add the "imaginary indent" to that.
! 	 */
  	look = skipwhite(start);
  	if (*look == '{')
  	{
--- 2464,2500 ----
  			    amount += curbuf->b_ind_unclosed;
  		    }
  		}
! 		// For a line starting with ')' use the minimum of the two
! 		// positions, to avoid giving it more indent than the previous
! 		// lines:
! 		//  func_long_name(		    if (x
! 		//	arg				    && yy
! 		//	)	  ^ not here	       )    ^ not here
  		if (cur_amount < amount)
  		    amount = cur_amount;
  	    }
  	}
  
! 	// add extra indent for a comment
  	if (cin_iscomment(theline))
  	    amount += curbuf->b_ind_comment;
        }
        else
        {
! 	// We are inside braces, there is a { before this line at the position
! 	// stored in tryposBrace.
! 	// Make a copy of tryposBrace, it may point to pos_copy inside
! 	// find_start_brace(), which may be changed somewhere.
  	tryposCopy = *tryposBrace;
  	tryposBrace = &tryposCopy;
  	trypos = tryposBrace;
  	ourscope = trypos->lnum;
  	start = ml_get(ourscope);
  
! 	// Now figure out how indented the line is in general.
! 	// If the brace was at the start of the line, we use that;
! 	// otherwise, check out the indentation of the line as
! 	// a whole and then add the "imaginary indent" to that.
  	look = skipwhite(start);
  	if (*look == '{')
  	{
***************
*** 2553,2575 ****
  	}
  	else
  	{
! 	    /* That opening brace might have been on a continuation
! 	     * line.  if so, find the start of the line. */
  	    curwin->w_cursor.lnum = ourscope;
  
! 	    /* Position the cursor over the rightmost paren, so that
! 	     * matching it will take us back to the start of the line. */
  	    lnum = ourscope;
  	    if (find_last_paren(start, '(', ')')
  			&& (trypos = find_match_paren(curbuf->b_ind_maxparen))
  								      != NULL)
  		lnum = trypos->lnum;
  
! 	    /* It could have been something like
! 	     *	   case 1: if (asdf &&
! 	     *			ldfd) {
! 	     *		    }
! 	     */
  	    if ((curbuf->b_ind_js || curbuf->b_ind_keep_case_label)
  			   && cin_iscase(skipwhite(ml_get_curline()), FALSE))
  		amount = get_indent();
--- 2507,2528 ----
  	}
  	else
  	{
! 	    // That opening brace might have been on a continuation
! 	    // line.  if so, find the start of the line.
  	    curwin->w_cursor.lnum = ourscope;
  
! 	    // Position the cursor over the rightmost paren, so that
! 	    // matching it will take us back to the start of the line.
  	    lnum = ourscope;
  	    if (find_last_paren(start, '(', ')')
  			&& (trypos = find_match_paren(curbuf->b_ind_maxparen))
  								      != NULL)
  		lnum = trypos->lnum;
  
! 	    // It could have been something like
! 	    //	   case 1: if (asdf &&
! 	    //			ldfd) {
! 	    //		    }
  	    if ((curbuf->b_ind_js || curbuf->b_ind_keep_case_label)
  			   && cin_iscase(skipwhite(ml_get_curline()), FALSE))
  		amount = get_indent();
***************
*** 2581,2653 ****
  	    start_brace = BRACE_AT_END;
  	}
  
! 	/* For Javascript check if the line starts with "key:". */
  	if (curbuf->b_ind_js)
  	    js_cur_has_key = cin_has_js_key(theline);
  
! 	/*
! 	 * If we're looking at a closing brace, that's where
! 	 * we want to be.  otherwise, add the amount of room
! 	 * that an indent is supposed to be.
! 	 */
  	if (theline[0] == '}')
  	{
! 	    /*
! 	     * they may want closing braces to line up with something
! 	     * other than the open brace.  indulge them, if so.
! 	     */
  	    amount += curbuf->b_ind_close_extra;
  	}
  	else
  	{
! 	    /*
! 	     * If we're looking at an "else", try to find an "if"
! 	     * to match it with.
! 	     * If we're looking at a "while", try to find a "do"
! 	     * to match it with.
! 	     */
  	    lookfor = LOOKFOR_INITIAL;
  	    if (cin_iselse(theline))
  		lookfor = LOOKFOR_IF;
! 	    else if (cin_iswhileofdo(theline, cur_curpos.lnum)) /* XXX */
  		lookfor = LOOKFOR_DO;
  	    if (lookfor != LOOKFOR_INITIAL)
  	    {
  		curwin->w_cursor.lnum = cur_curpos.lnum;
  		if (find_match(lookfor, ourscope) == OK)
  		{
! 		    amount = get_indent();	/* XXX */
  		    goto theend;
  		}
  	    }
  
! 	    /*
! 	     * We get here if we are not on an "while-of-do" or "else" (or
! 	     * failed to find a matching "if").
! 	     * Search backwards for something to line up with.
! 	     * First set amount for when we don't find anything.
! 	     */
! 
! 	    /*
! 	     * if the '{' is  _really_ at the left margin, use the imaginary
! 	     * location of a left-margin brace.  Otherwise, correct the
! 	     * location for b_ind_open_extra.
! 	     */
  
! 	    if (start_brace == BRACE_IN_COL0)	    /* '{' is in column 0 */
  	    {
  		amount = curbuf->b_ind_open_left_imag;
  		lookfor_cpp_namespace = TRUE;
  	    }
  	    else if (start_brace == BRACE_AT_START &&
! 		    lookfor_cpp_namespace)	  /* '{' is at start */
  	    {
  
  		lookfor_cpp_namespace = TRUE;
  	    }
  	    else
  	    {
! 		if (start_brace == BRACE_AT_END)    /* '{' is at end of line */
  		{
  		    amount += curbuf->b_ind_open_imag;
  
--- 2534,2596 ----
  	    start_brace = BRACE_AT_END;
  	}
  
! 	// For Javascript check if the line starts with "key:".
  	if (curbuf->b_ind_js)
  	    js_cur_has_key = cin_has_js_key(theline);
  
! 	// If we're looking at a closing brace, that's where
! 	// we want to be.  otherwise, add the amount of room
! 	// that an indent is supposed to be.
  	if (theline[0] == '}')
  	{
! 	    // they may want closing braces to line up with something
! 	    // other than the open brace.  indulge them, if so.
  	    amount += curbuf->b_ind_close_extra;
  	}
  	else
  	{
! 	    // If we're looking at an "else", try to find an "if"
! 	    // to match it with.
! 	    // If we're looking at a "while", try to find a "do"
! 	    // to match it with.
  	    lookfor = LOOKFOR_INITIAL;
  	    if (cin_iselse(theline))
  		lookfor = LOOKFOR_IF;
! 	    else if (cin_iswhileofdo(theline, cur_curpos.lnum)) // XXX
  		lookfor = LOOKFOR_DO;
  	    if (lookfor != LOOKFOR_INITIAL)
  	    {
  		curwin->w_cursor.lnum = cur_curpos.lnum;
  		if (find_match(lookfor, ourscope) == OK)
  		{
! 		    amount = get_indent();	// XXX
  		    goto theend;
  		}
  	    }
  
! 	    // We get here if we are not on an "while-of-do" or "else" (or
! 	    // failed to find a matching "if").
! 	    // Search backwards for something to line up with.
! 	    // First set amount for when we don't find anything.
! 
! 	    // if the '{' is  _really_ at the left margin, use the imaginary
! 	    // location of a left-margin brace.  Otherwise, correct the
! 	    // location for b_ind_open_extra.
  
! 	    if (start_brace == BRACE_IN_COL0)	    // '{' is in column 0
  	    {
  		amount = curbuf->b_ind_open_left_imag;
  		lookfor_cpp_namespace = TRUE;
  	    }
  	    else if (start_brace == BRACE_AT_START &&
! 		    lookfor_cpp_namespace)	  // '{' is at start
  	    {
  
  		lookfor_cpp_namespace = TRUE;
  	    }
  	    else
  	    {
! 		if (start_brace == BRACE_AT_END)    // '{' is at end of line
  		{
  		    amount += curbuf->b_ind_open_imag;
  
***************
*** 2659,2665 ****
  		}
  		else
  		{
! 		    /* Compensate for adding b_ind_open_extra later. */
  		    amount -= curbuf->b_ind_open_extra;
  		    if (amount < 0)
  			amount = 0;
--- 2602,2608 ----
  		}
  		else
  		{
! 		    // Compensate for adding b_ind_open_extra later.
  		    amount -= curbuf->b_ind_open_extra;
  		    if (amount < 0)
  			amount = 0;
***************
*** 2668,2734 ****
  
  	    lookfor_break = FALSE;
  
! 	    if (cin_iscase(theline, FALSE))	/* it's a switch() label */
  	    {
! 		lookfor = LOOKFOR_CASE;	/* find a previous switch() label */
  		amount += curbuf->b_ind_case;
  	    }
! 	    else if (cin_isscopedecl(theline))	/* private:, ... */
  	    {
! 		lookfor = LOOKFOR_SCOPEDECL;	/* class decl is this block */
  		amount += curbuf->b_ind_scopedecl;
  	    }
  	    else
  	    {
  		if (curbuf->b_ind_case_break && cin_isbreak(theline))
! 		    /* break; ... */
  		    lookfor_break = TRUE;
  
  		lookfor = LOOKFOR_INITIAL;
! 		/* b_ind_level from start of block */
  		amount += curbuf->b_ind_level;
  	    }
  	    scope_amount = amount;
  	    whilelevel = 0;
  
! 	    /*
! 	     * Search backwards.  If we find something we recognize, line up
! 	     * with that.
! 	     *
! 	     * If we're looking at an open brace, indent
! 	     * the usual amount relative to the conditional
! 	     * that opens the block.
! 	     */
  	    curwin->w_cursor = cur_curpos;
  	    for (;;)
  	    {
  		curwin->w_cursor.lnum--;
  		curwin->w_cursor.col = 0;
  
! 		/*
! 		 * If we went all the way back to the start of our scope, line
! 		 * up with it.
! 		 */
  		if (curwin->w_cursor.lnum <= ourscope)
  		{
! 		    /* We reached end of scope:
! 		     * If looking for a enum or structure initialization
! 		     * go further back:
! 		     * If it is an initializer (enum xxx or xxx =), then
! 		     * don't add ind_continuation, otherwise it is a variable
! 		     * declaration:
! 		     * int x,
! 		     *     here; <-- add ind_continuation
! 		     */
  		    if (lookfor == LOOKFOR_ENUM_OR_INIT)
  		    {
  			if (curwin->w_cursor.lnum == 0
  				|| curwin->w_cursor.lnum
  					  < ourscope - curbuf->b_ind_maxparen)
  			{
! 			    /* nothing found (abuse curbuf->b_ind_maxparen as
! 			     * limit) assume terminated line (i.e. a variable
! 			     * initialization) */
  			    if (cont_amount > 0)
  				amount = cont_amount;
  			    else if (!curbuf->b_ind_js)
--- 2611,2672 ----
  
  	    lookfor_break = FALSE;
  
! 	    if (cin_iscase(theline, FALSE))	// it's a switch() label
  	    {
! 		lookfor = LOOKFOR_CASE;	// find a previous switch() label
  		amount += curbuf->b_ind_case;
  	    }
! 	    else if (cin_isscopedecl(theline))	// private:, ...
  	    {
! 		lookfor = LOOKFOR_SCOPEDECL;	// class decl is this block
  		amount += curbuf->b_ind_scopedecl;
  	    }
  	    else
  	    {
  		if (curbuf->b_ind_case_break && cin_isbreak(theline))
! 		    // break; ...
  		    lookfor_break = TRUE;
  
  		lookfor = LOOKFOR_INITIAL;
! 		// b_ind_level from start of block
  		amount += curbuf->b_ind_level;
  	    }
  	    scope_amount = amount;
  	    whilelevel = 0;
  
! 	    // Search backwards.  If we find something we recognize, line up
! 	    // with that.
! 	    //
! 	    // If we're looking at an open brace, indent
! 	    // the usual amount relative to the conditional
! 	    // that opens the block.
  	    curwin->w_cursor = cur_curpos;
  	    for (;;)
  	    {
  		curwin->w_cursor.lnum--;
  		curwin->w_cursor.col = 0;
  
! 		// If we went all the way back to the start of our scope, line
! 		// up with it.
  		if (curwin->w_cursor.lnum <= ourscope)
  		{
! 		    // We reached end of scope:
! 		    // If looking for a enum or structure initialization
! 		    // go further back:
! 		    // If it is an initializer (enum xxx or xxx =), then
! 		    // don't add ind_continuation, otherwise it is a variable
! 		    // declaration:
! 		    // int x,
! 		    //     here; <-- add ind_continuation
  		    if (lookfor == LOOKFOR_ENUM_OR_INIT)
  		    {
  			if (curwin->w_cursor.lnum == 0
  				|| curwin->w_cursor.lnum
  					  < ourscope - curbuf->b_ind_maxparen)
  			{
! 			    // nothing found (abuse curbuf->b_ind_maxparen as
! 			    // limit) assume terminated line (i.e. a variable
! 			    // initialization)
  			    if (cont_amount > 0)
  				amount = cont_amount;
  			    else if (!curbuf->b_ind_js)
***************
*** 2738,2747 ****
  
  			l = ml_get_curline();
  
! 			/*
! 			 * If we're in a comment or raw string now, skip to
! 			 * the start of it.
! 			 */
  			trypos = ind_find_start_CORS(NULL);
  			if (trypos != NULL)
  			{
--- 2676,2683 ----
  
  			l = ml_get_curline();
  
! 			// If we're in a comment or raw string now, skip to
! 			// the start of it.
  			trypos = ind_find_start_CORS(NULL);
  			if (trypos != NULL)
  			{
***************
*** 2750,2758 ****
  			    continue;
  			}
  
! 			/*
! 			 * Skip preprocessor directives and blank lines.
! 			 */
  			if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum,
  								    &amount))
  			    continue;
--- 2686,2692 ----
  			    continue;
  			}
  
! 			// Skip preprocessor directives and blank lines.
  			if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum,
  								    &amount))
  			    continue;
***************
*** 2762,2802 ****
  
  			terminated = cin_isterminated(l, FALSE, TRUE);
  
! 			/*
! 			 * If we are at top level and the line looks like a
! 			 * function declaration, we are done
! 			 * (it's a variable declaration).
! 			 */
  			if (start_brace != BRACE_IN_COL0
  			     || !cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0))
  			{
! 			    /* if the line is terminated with another ','
! 			     * it is a continued variable initialization.
! 			     * don't add extra indent.
! 			     * TODO: does not work, if  a function
! 			     * declaration is split over multiple lines:
! 			     * cin_isfuncdecl returns FALSE then.
! 			     */
  			    if (terminated == ',')
  				break;
  
! 			    /* if it es a enum declaration or an assignment,
! 			     * we are done.
! 			     */
  			    if (terminated != ';' && cin_isinit())
  				break;
  
! 			    /* nothing useful found */
  			    if (terminated == 0 || terminated == '{')
  				continue;
  			}
  
  			if (terminated != ';')
  			{
! 			    /* Skip parens and braces. Position the cursor
! 			     * over the rightmost paren, so that matching it
! 			     * will take us back to the start of the line.
! 			     */					/* XXX */
  			    trypos = NULL;
  			    if (find_last_paren(l, '(', ')'))
  				trypos = find_match_paren(
--- 2696,2732 ----
  
  			terminated = cin_isterminated(l, FALSE, TRUE);
  
! 			// If we are at top level and the line looks like a
! 			// function declaration, we are done
! 			// (it's a variable declaration).
  			if (start_brace != BRACE_IN_COL0
  			     || !cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0))
  			{
! 			    // if the line is terminated with another ','
! 			    // it is a continued variable initialization.
! 			    // don't add extra indent.
! 			    // TODO: does not work, if  a function
! 			    // declaration is split over multiple lines:
! 			    // cin_isfuncdecl returns FALSE then.
  			    if (terminated == ',')
  				break;
  
! 			    // if it es a enum declaration or an assignment,
! 			    // we are done.
  			    if (terminated != ';' && cin_isinit())
  				break;
  
! 			    // nothing useful found
  			    if (terminated == 0 || terminated == '{')
  				continue;
  			}
  
  			if (terminated != ';')
  			{
! 			    // Skip parens and braces. Position the cursor
! 			    // over the rightmost paren, so that matching it
! 			    // will take us back to the start of the line.
! 			    // XXX
  			    trypos = NULL;
  			    if (find_last_paren(l, '(', ')'))
  				trypos = find_match_paren(
***************
*** 2813,2823 ****
  			    }
  			}
  
! 			/* it's a variable declaration, add indentation
! 			 * like in
! 			 * int a,
! 			 *    b;
! 			 */
  			if (cont_amount > 0)
  			    amount = cont_amount;
  			else
--- 2743,2752 ----
  			    }
  			}
  
! 			// it's a variable declaration, add indentation
! 			// like in
! 			// int a,
! 			//    b;
  			if (cont_amount > 0)
  			    amount = cont_amount;
  			else
***************
*** 2846,2855 ****
  
  			if (lookfor_cpp_namespace)
  			{
! 			    /*
! 			     * Looking for C++ namespace, need to look further
! 			     * back.
! 			     */
  			    if (curwin->w_cursor.lnum == ourscope)
  				continue;
  
--- 2775,2782 ----
  
  			if (lookfor_cpp_namespace)
  			{
! 			    // Looking for C++ namespace, need to look further
! 			    // back.
  			    if (curwin->w_cursor.lnum == ourscope)
  				continue;
  
***************
*** 2860,2867 ****
  
  			    l = ml_get_curline();
  
! 			    /* If we're in a comment or raw string now, skip
! 			     * to the start of it. */
  			    trypos = ind_find_start_CORS(NULL);
  			    if (trypos != NULL)
  			    {
--- 2787,2794 ----
  
  			    l = ml_get_curline();
  
! 			    // If we're in a comment or raw string now, skip
! 			    // to the start of it.
  			    trypos = ind_find_start_CORS(NULL);
  			    if (trypos != NULL)
  			    {
***************
*** 2870,2881 ****
  				continue;
  			    }
  
! 			    /* Skip preprocessor directives and blank lines. */
  			    if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum,
  								    &amount))
  				continue;
  
! 			    /* Finally the actual check for "namespace". */
  			    if (cin_is_cpp_namespace(l))
  			    {
  				amount += curbuf->b_ind_cpp_namespace
--- 2797,2808 ----
  				continue;
  			    }
  
! 			    // Skip preprocessor directives and blank lines.
  			    if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum,
  								    &amount))
  				continue;
  
! 			    // Finally the actual check for "namespace".
  			    if (cin_is_cpp_namespace(l))
  			    {
  				amount += curbuf->b_ind_cpp_namespace
***************
*** 2896,2905 ****
  		    break;
  		}
  
! 		/*
! 		 * If we're in a comment or raw string now, skip to the start
! 		 * of it.
! 		 */					    /* XXX */
  		if ((trypos = ind_find_start_CORS(&raw_string_start)) != NULL)
  		{
  		    curwin->w_cursor.lnum = trypos->lnum + 1;
--- 2823,2830 ----
  		    break;
  		}
  
! 		// If we're in a comment or raw string now, skip to the start
! 		// of it.  XXX
  		if ((trypos = ind_find_start_CORS(&raw_string_start)) != NULL)
  		{
  		    curwin->w_cursor.lnum = trypos->lnum + 1;
***************
*** 2909,2936 ****
  
  		l = ml_get_curline();
  
! 		/*
! 		 * If this is a switch() label, may line up relative to that.
! 		 * If this is a C++ scope declaration, do the same.
! 		 */
  		iscase = cin_iscase(l, FALSE);
  		if (iscase || cin_isscopedecl(l))
  		{
! 		    /* we are only looking for cpp base class
! 		     * declaration/initialization any longer */
  		    if (lookfor == LOOKFOR_CPP_BASECLASS)
  			break;
  
! 		    /* When looking for a "do" we are not interested in
! 		     * labels. */
  		    if (whilelevel > 0)
  			continue;
  
! 		    /*
! 		     *	case xx:
! 		     *	    c = 99 +	    <- this indent plus continuation
! 		     *->	   here;
! 		     */
  		    if (lookfor == LOOKFOR_UNTERM
  					   || lookfor == LOOKFOR_ENUM_OR_INIT)
  		    {
--- 2834,2857 ----
  
  		l = ml_get_curline();
  
! 		// If this is a switch() label, may line up relative to that.
! 		// If this is a C++ scope declaration, do the same.
  		iscase = cin_iscase(l, FALSE);
  		if (iscase || cin_isscopedecl(l))
  		{
! 		    // we are only looking for cpp base class
! 		    // declaration/initialization any longer
  		    if (lookfor == LOOKFOR_CPP_BASECLASS)
  			break;
  
! 		    // When looking for a "do" we are not interested in
! 		    // labels.
  		    if (whilelevel > 0)
  			continue;
  
! 		    //	case xx:
! 		    //	    c = 99 +	    <- this indent plus continuation
! 		    //->	   here;
  		    if (lookfor == LOOKFOR_UNTERM
  					   || lookfor == LOOKFOR_ENUM_OR_INIT)
  		    {
***************
*** 2941,2980 ****
  			break;
  		    }
  
! 		    /*
! 		     *	case xx:	<- line up with this case
! 		     *	    x = 333;
! 		     *	case yy:
! 		     */
  		    if (       (iscase && lookfor == LOOKFOR_CASE)
  			    || (iscase && lookfor_break)
  			    || (!iscase && lookfor == LOOKFOR_SCOPEDECL))
  		    {
! 			/*
! 			 * Check that this case label is not for another
! 			 * switch()
! 			 */				    /* XXX */
  			if ((trypos = find_start_brace()) == NULL
  						  || trypos->lnum == ourscope)
  			{
! 			    amount = get_indent();	/* XXX */
  			    break;
  			}
  			continue;
  		    }
  
! 		    n = get_indent_nolabel(curwin->w_cursor.lnum);  /* XXX */
  
! 		    /*
! 		     *	 case xx: if (cond)	    <- line up with this if
! 		     *		      y = y + 1;
! 		     * ->	  s = 99;
! 		     *
! 		     *	 case xx:
! 		     *	     if (cond)		<- line up with this line
! 		     *		 y = y + 1;
! 		     * ->    s = 99;
! 		     */
  		    if (lookfor == LOOKFOR_TERM)
  		    {
  			if (n)
--- 2862,2895 ----
  			break;
  		    }
  
! 		    //	case xx:	<- line up with this case
! 		    //	    x = 333;
! 		    //	case yy:
  		    if (       (iscase && lookfor == LOOKFOR_CASE)
  			    || (iscase && lookfor_break)
  			    || (!iscase && lookfor == LOOKFOR_SCOPEDECL))
  		    {
! 			// Check that this case label is not for another
! 			// switch()		    XXX
  			if ((trypos = find_start_brace()) == NULL
  						  || trypos->lnum == ourscope)
  			{
! 			    amount = get_indent();	// XXX
  			    break;
  			}
  			continue;
  		    }
  
! 		    n = get_indent_nolabel(curwin->w_cursor.lnum);  // XXX
  
! 		    //	 case xx: if (cond)	    <- line up with this if
! 		    //		      y = y + 1;
! 		    // ->	  s = 99;
! 		    //
! 		    //	 case xx:
! 		    //	     if (cond)		<- line up with this line
! 		    //		 y = y + 1;
! 		    // ->    s = 99;
  		    if (lookfor == LOOKFOR_TERM)
  		    {
  			if (n)
***************
*** 2984,2996 ****
  			    break;
  		    }
  
! 		    /*
! 		     *	 case xx: x = x + 1;	    <- line up with this x
! 		     * ->	  y = y + 1;
! 		     *
! 		     *	 case xx: if (cond)	    <- line up with this if
! 		     * ->	       y = y + 1;
! 		     */
  		    if (n)
  		    {
  			amount = n;
--- 2899,2909 ----
  			    break;
  		    }
  
! 		    //	 case xx: x = x + 1;	    <- line up with this x
! 		    // ->	  y = y + 1;
! 		    //
! 		    //	 case xx: if (cond)	    <- line up with this if
! 		    // ->	       y = y + 1;
  		    if (n)
  		    {
  			amount = n;
***************
*** 3006,3020 ****
  			break;
  		    }
  
! 		    /*
! 		     * Try to get the indent of a statement before the switch
! 		     * label.  If nothing is found, line up relative to the
! 		     * switch label.
! 		     *	    break;		<- may line up with this line
! 		     *	 case xx:
! 		     * ->   y = 1;
! 		     */
! 		    scope_amount = get_indent() + (iscase    /* XXX */
  					? curbuf->b_ind_case_code
  					: curbuf->b_ind_scopedecl_code);
  		    lookfor = curbuf->b_ind_case_break
--- 2919,2931 ----
  			break;
  		    }
  
! 		    // Try to get the indent of a statement before the switch
! 		    // label.  If nothing is found, line up relative to the
! 		    // switch label.
! 		    //	    break;		<- may line up with this line
! 		    //	 case xx:
! 		    // ->   y = 1;
! 		    scope_amount = get_indent() + (iscase    // XXX
  					? curbuf->b_ind_case_code
  					: curbuf->b_ind_scopedecl_code);
  		    lookfor = curbuf->b_ind_case_break
***************
*** 3022,3031 ****
  		    continue;
  		}
  
! 		/*
! 		 * Looking for a switch() label or C++ scope declaration,
! 		 * ignore other lines, skip {}-blocks.
! 		 */
  		if (lookfor == LOOKFOR_CASE || lookfor == LOOKFOR_SCOPEDECL)
  		{
  		    if (find_last_paren(l, '{', '}')
--- 2933,2940 ----
  		    continue;
  		}
  
! 		// Looking for a switch() label or C++ scope declaration,
! 		// ignore other lines, skip {}-blocks.
  		if (lookfor == LOOKFOR_CASE || lookfor == LOOKFOR_SCOPEDECL)
  		{
  		    if (find_last_paren(l, '{', '}')
***************
*** 3037,3045 ****
  		    continue;
  		}
  
! 		/*
! 		 * Ignore jump labels with nothing after them.
! 		 */
  		if (!curbuf->b_ind_js && cin_islabel())
  		{
  		    l = after_label(ml_get_curline());
--- 2946,2952 ----
  		    continue;
  		}
  
! 		// Ignore jump labels with nothing after them.
  		if (!curbuf->b_ind_js && cin_islabel())
  		{
  		    l = after_label(ml_get_curline());
***************
*** 3047,3067 ****
  			continue;
  		}
  
! 		/*
! 		 * Ignore #defines, #if, etc.
! 		 * Ignore comment and empty lines.
! 		 * (need to get the line again, cin_islabel() may have
! 		 * unlocked it)
! 		 */
  		l = ml_get_curline();
  		if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum, &amount)
  							     || cin_nocode(l))
  		    continue;
  
! 		/*
! 		 * Are we at the start of a cpp base class declaration or
! 		 * constructor initialization?
! 		 */						    /* XXX */
  		n = FALSE;
  		if (lookfor != LOOKFOR_TERM && curbuf->b_ind_cpp_baseclass > 0)
  		{
--- 2954,2970 ----
  			continue;
  		}
  
! 		// Ignore #defines, #if, etc.
! 		// Ignore comment and empty lines.
! 		// (need to get the line again, cin_islabel() may have
! 		// unlocked it)
  		l = ml_get_curline();
  		if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum, &amount)
  							     || cin_nocode(l))
  		    continue;
  
! 		// Are we at the start of a cpp base class declaration or
! 		// constructor initialization?  XXX
  		n = FALSE;
  		if (lookfor != LOOKFOR_TERM && curbuf->b_ind_cpp_baseclass > 0)
  		{
***************
*** 3079,3132 ****
  		    }
  		    else if (theline[0] == '{')
  		    {
! 			/* Need to find start of the declaration. */
  			lookfor = LOOKFOR_UNTERM;
  			ind_continuation = 0;
  			continue;
  		    }
  		    else
! 								     /* XXX */
  			amount = get_baseclass_amount(
  						cache_cpp_baseclass.lpos.col);
  		    break;
  		}
  		else if (lookfor == LOOKFOR_CPP_BASECLASS)
  		{
! 		    /* only look, whether there is a cpp base class
! 		     * declaration or initialization before the opening brace.
! 		     */
  		    if (cin_isterminated(l, TRUE, FALSE))
  			break;
  		    else
  			continue;
  		}
  
! 		/*
! 		 * What happens next depends on the line being terminated.
! 		 * If terminated with a ',' only consider it terminating if
! 		 * there is another unterminated statement behind, eg:
! 		 *   123,
! 		 *   sizeof
! 		 *	  here
! 		 * Otherwise check whether it is a enumeration or structure
! 		 * initialisation (not indented) or a variable declaration
! 		 * (indented).
! 		 */
  		terminated = cin_isterminated(l, FALSE, TRUE);
  
  		if (js_cur_has_key)
  		{
! 		    js_cur_has_key = 0; /* only check the first line */
  		    if (curbuf->b_ind_js && terminated == ',')
  		    {
! 			/* For Javascript we might be inside an object:
! 			 *   key: something,  <- align with this
! 			 *   key: something
! 			 * or:
! 			 *   key: something +  <- align with this
! 			 *       something,
! 			 *   key: something
! 			 */
  			lookfor = LOOKFOR_JS_KEY;
  		    }
  		}
--- 2982,3031 ----
  		    }
  		    else if (theline[0] == '{')
  		    {
! 			// Need to find start of the declaration.
  			lookfor = LOOKFOR_UNTERM;
  			ind_continuation = 0;
  			continue;
  		    }
  		    else
! 			// XXX
  			amount = get_baseclass_amount(
  						cache_cpp_baseclass.lpos.col);
  		    break;
  		}
  		else if (lookfor == LOOKFOR_CPP_BASECLASS)
  		{
! 		    // only look, whether there is a cpp base class
! 		    // declaration or initialization before the opening brace.
  		    if (cin_isterminated(l, TRUE, FALSE))
  			break;
  		    else
  			continue;
  		}
  
! 		// What happens next depends on the line being terminated.
! 		// If terminated with a ',' only consider it terminating if
! 		// there is another unterminated statement behind, eg:
! 		//   123,
! 		//   sizeof
! 		//	  here
! 		// Otherwise check whether it is a enumeration or structure
! 		// initialisation (not indented) or a variable declaration
! 		// (indented).
  		terminated = cin_isterminated(l, FALSE, TRUE);
  
  		if (js_cur_has_key)
  		{
! 		    js_cur_has_key = 0; // only check the first line
  		    if (curbuf->b_ind_js && terminated == ',')
  		    {
! 			// For Javascript we might be inside an object:
! 			//   key: something,  <- align with this
! 			//   key: something
! 			// or:
! 			//   key: something +  <- align with this
! 			//       something,
! 			//   key: something
  			lookfor = LOOKFOR_JS_KEY;
  		    }
  		}
***************
*** 3141,3156 ****
  						    >= curwin->w_cursor.lnum)
  			break;
  		    if (terminated == ',')
! 			/* line below current line is the one that starts a
! 			 * (possibly broken) line ending in a comma. */
  			break;
  		    else
  		    {
  			amount = get_indent();
  			if (curwin->w_cursor.lnum - 1 == ourscope)
! 			    /* line above is start of the scope, thus current
! 			     * line is the one that stars a (possibly broken)
! 			     * line ending in a comma. */
  			    break;
  		    }
  		}
--- 3040,3055 ----
  						    >= curwin->w_cursor.lnum)
  			break;
  		    if (terminated == ',')
! 			// line below current line is the one that starts a
! 			// (possibly broken) line ending in a comma.
  			break;
  		    else
  		    {
  			amount = get_indent();
  			if (curwin->w_cursor.lnum - 1 == ourscope)
! 			    // line above is start of the scope, thus current
! 			    // line is the one that stars a (possibly broken)
! 			    // line ending in a comma.
  			    break;
  		    }
  		}
***************
*** 3161,3178 ****
  		    if (lookfor != LOOKFOR_ENUM_OR_INIT &&
  			    (*skipwhite(l) == '[' || l[STRLEN(l) - 1] == '['))
  			amount += ind_continuation;
! 		    /*
! 		     * if we're in the middle of a paren thing,
! 		     * go back to the line that starts it so
! 		     * we can get the right prevailing indent
! 		     *	   if ( foo &&
! 		     *		    bar )
! 		     */
! 		    /*
! 		     * Position the cursor over the rightmost paren, so that
! 		     * matching it will take us back to the start of the line.
! 		     * Ignore a match before the start of the block.
! 		     */
  		    (void)find_last_paren(l, '(', ')');
  		    trypos = find_match_paren(corr_ind_maxparen(&cur_curpos));
  		    if (trypos != NULL && (trypos->lnum < tryposBrace->lnum
--- 3060,3074 ----
  		    if (lookfor != LOOKFOR_ENUM_OR_INIT &&
  			    (*skipwhite(l) == '[' || l[STRLEN(l) - 1] == '['))
  			amount += ind_continuation;
! 		    // if we're in the middle of a paren thing,
! 		    // go back to the line that starts it so
! 		    // we can get the right prevailing indent
! 		    //	   if ( foo &&
! 		    //		    bar )
! 
! 		    // Position the cursor over the rightmost paren, so that
! 		    // matching it will take us back to the start of the line.
! 		    // Ignore a match before the start of the block.
  		    (void)find_last_paren(l, '(', ')');
  		    trypos = find_match_paren(corr_ind_maxparen(&cur_curpos));
  		    if (trypos != NULL && (trypos->lnum < tryposBrace->lnum
***************
*** 3180,3201 ****
  				    && trypos->col < tryposBrace->col)))
  			trypos = NULL;
  
! 		    /*
! 		     * If we are looking for ',', we also look for matching
! 		     * braces.
! 		     */
  		    if (trypos == NULL && terminated == ','
  					      && find_last_paren(l, '{', '}'))
  			trypos = find_start_brace();
  
  		    if (trypos != NULL)
  		    {
! 			/*
! 			 * Check if we are on a case label now.  This is
! 			 * handled above.
! 			 *     case xx:  if ( asdf &&
! 			 *			asdf)
! 			 */
  			curwin->w_cursor = *trypos;
  			l = ml_get_curline();
  			if (cin_iscase(l, FALSE) || cin_isscopedecl(l))
--- 3076,3093 ----
  				    && trypos->col < tryposBrace->col)))
  			trypos = NULL;
  
! 		    // If we are looking for ',', we also look for matching
! 		    // braces.
  		    if (trypos == NULL && terminated == ','
  					      && find_last_paren(l, '{', '}'))
  			trypos = find_start_brace();
  
  		    if (trypos != NULL)
  		    {
! 			// Check if we are on a case label now.  This is
! 			// handled above.
! 			//     case xx:  if ( asdf &&
! 			//			asdf)
  			curwin->w_cursor = *trypos;
  			l = ml_get_curline();
  			if (cin_iscase(l, FALSE) || cin_isscopedecl(l))
***************
*** 3225,3282 ****
  			}
  		    }
  
! 		    /*
! 		     * Get indent and pointer to text for current line,
! 		     * ignoring any jump label.	    XXX
! 		     */
  		    if (curbuf->b_ind_js)
  			cur_amount = get_indent();
  		    else
  			cur_amount = skip_label(curwin->w_cursor.lnum, &l);
! 		    /*
! 		     * If this is just above the line we are indenting, and it
! 		     * starts with a '{', line it up with this line.
! 		     *		while (not)
! 		     * ->	{
! 		     *		}
! 		     */
  		    if (terminated != ',' && lookfor != LOOKFOR_TERM
  							 && theline[0] == '{')
  		    {
  			amount = cur_amount;
! 			/*
! 			 * Only add b_ind_open_extra when the current line
! 			 * doesn't start with a '{', which must have a match
! 			 * in the same line (scope is the same).  Probably:
! 			 *	{ 1, 2 },
! 			 * ->	{ 3, 4 }
! 			 */
  			if (*skipwhite(l) != '{')
  			    amount += curbuf->b_ind_open_extra;
  
  			if (curbuf->b_ind_cpp_baseclass && !curbuf->b_ind_js)
  			{
! 			    /* have to look back, whether it is a cpp base
! 			     * class declaration or initialization */
  			    lookfor = LOOKFOR_CPP_BASECLASS;
  			    continue;
  			}
  			break;
  		    }
  
! 		    /*
! 		     * Check if we are after an "if", "while", etc.
! 		     * Also allow "   } else".
! 		     */
  		    if (cin_is_cinword(l) || cin_iselse(skipwhite(l)))
  		    {
! 			/*
! 			 * Found an unterminated line after an if (), line up
! 			 * with the last one.
! 			 *   if (cond)
! 			 *	    100 +
! 			 * ->		here;
! 			 */
  			if (lookfor == LOOKFOR_UNTERM
  					   || lookfor == LOOKFOR_ENUM_OR_INIT)
  			{
--- 3117,3164 ----
  			}
  		    }
  
! 		    // Get indent and pointer to text for current line,
! 		    // ignoring any jump label.  XXX
  		    if (curbuf->b_ind_js)
  			cur_amount = get_indent();
  		    else
  			cur_amount = skip_label(curwin->w_cursor.lnum, &l);
! 		    // If this is just above the line we are indenting, and it
! 		    // starts with a '{', line it up with this line.
! 		    //		while (not)
! 		    // ->	{
! 		    //		}
  		    if (terminated != ',' && lookfor != LOOKFOR_TERM
  							 && theline[0] == '{')
  		    {
  			amount = cur_amount;
! 			// Only add b_ind_open_extra when the current line
! 			// doesn't start with a '{', which must have a match
! 			// in the same line (scope is the same).  Probably:
! 			//	{ 1, 2 },
! 			// ->	{ 3, 4 }
  			if (*skipwhite(l) != '{')
  			    amount += curbuf->b_ind_open_extra;
  
  			if (curbuf->b_ind_cpp_baseclass && !curbuf->b_ind_js)
  			{
! 			    // have to look back, whether it is a cpp base
! 			    // class declaration or initialization
  			    lookfor = LOOKFOR_CPP_BASECLASS;
  			    continue;
  			}
  			break;
  		    }
  
! 		    // Check if we are after an "if", "while", etc.
! 		    // Also allow "   } else".
  		    if (cin_is_cinword(l) || cin_iselse(skipwhite(l)))
  		    {
! 			// Found an unterminated line after an if (), line up
! 			// with the last one.
! 			//   if (cond)
! 			//	    100 +
! 			// ->		here;
  			if (lookfor == LOOKFOR_UNTERM
  					   || lookfor == LOOKFOR_ENUM_OR_INIT)
  			{
***************
*** 3287,3305 ****
  			    break;
  			}
  
! 			/*
! 			 * If this is just above the line we are indenting, we
! 			 * are finished.
! 			 *	    while (not)
! 			 * ->		here;
! 			 * Otherwise this indent can be used when the line
! 			 * before this is terminated.
! 			 *	yyy;
! 			 *	if (stat)
! 			 *	    while (not)
! 			 *		xxx;
! 			 * ->	here;
! 			 */
  			amount = cur_amount;
  			if (theline[0] == '{')
  			    amount += curbuf->b_ind_open_extra;
--- 3169,3185 ----
  			    break;
  			}
  
! 			// If this is just above the line we are indenting, we
! 			// are finished.
! 			//	    while (not)
! 			// ->		here;
! 			// Otherwise this indent can be used when the line
! 			// before this is terminated.
! 			//	yyy;
! 			//	if (stat)
! 			//	    while (not)
! 			//		xxx;
! 			// ->	here;
  			amount = cur_amount;
  			if (theline[0] == '{')
  			    amount += curbuf->b_ind_open_extra;
***************
*** 3310,3322 ****
  			    break;
  			}
  
! 			/*
! 			 * Special trick: when expecting the while () after a
! 			 * do, line up with the while()
! 			 *     do
! 			 *	    x = 1;
! 			 * ->  here
! 			 */
  			l = skipwhite(ml_get_curline());
  			if (cin_isdo(l))
  			{
--- 3190,3200 ----
  			    break;
  			}
  
! 			// Special trick: when expecting the while () after a
! 			// do, line up with the while()
! 			//     do
! 			//	    x = 1;
! 			// ->  here
  			l = skipwhite(ml_get_curline());
  			if (cin_isdo(l))
  			{
***************
*** 3325,3341 ****
  			    --whilelevel;
  			}
  
! 			/*
! 			 * When searching for a terminated line, don't use the
! 			 * one between the "if" and the matching "else".
! 			 * Need to use the scope of this "else".  XXX
! 			 * If whilelevel != 0 continue looking for a "do {".
! 			 */
  			if (cin_iselse(l) && whilelevel == 0)
  			{
! 			    /* If we're looking at "} else", let's make sure we
! 			     * find the opening brace of the enclosing scope,
! 			     * not the one from "if () {". */
  			    if (*l == '}')
  				curwin->w_cursor.col =
  					  (colnr_T)(l - ml_get_curline()) + 1;
--- 3203,3217 ----
  			    --whilelevel;
  			}
  
! 			// When searching for a terminated line, don't use the
! 			// one between the "if" and the matching "else".
! 			// Need to use the scope of this "else".  XXX
! 			// If whilelevel != 0 continue looking for a "do {".
  			if (cin_iselse(l) && whilelevel == 0)
  			{
! 			    // If we're looking at "} else", let's make sure we
! 			    // find the opening brace of the enclosing scope,
! 			    // not the one from "if () {".
  			    if (*l == '}')
  				curwin->w_cursor.col =
  					  (colnr_T)(l - ml_get_curline()) + 1;
***************
*** 3347,3370 ****
  			}
  		    }
  
! 		    /*
! 		     * If we're below an unterminated line that is not an
! 		     * "if" or something, we may line up with this line or
! 		     * add something for a continuation line, depending on
! 		     * the line before this one.
! 		     */
  		    else
  		    {
! 			/*
! 			 * Found two unterminated lines on a row, line up with
! 			 * the last one.
! 			 *   c = 99 +
! 			 *	    100 +
! 			 * ->	    here;
! 			 */
  			if (lookfor == LOOKFOR_UNTERM)
  			{
! 			    /* When line ends in a comma add extra indent */
  			    if (terminated == ',')
  				amount += ind_continuation;
  			    break;
--- 3223,3242 ----
  			}
  		    }
  
! 		    // If we're below an unterminated line that is not an
! 		    // "if" or something, we may line up with this line or
! 		    // add something for a continuation line, depending on
! 		    // the line before this one.
  		    else
  		    {
! 			// Found two unterminated lines on a row, line up with
! 			// the last one.
! 			//   c = 99 +
! 			//	    100 +
! 			// ->	    here;
  			if (lookfor == LOOKFOR_UNTERM)
  			{
! 			    // When line ends in a comma add extra indent
  			    if (terminated == ',')
  				amount += ind_continuation;
  			    break;
***************
*** 3372,3382 ****
  
  			if (lookfor == LOOKFOR_ENUM_OR_INIT)
  			{
! 			    /* Found two lines ending in ',', lineup with the
! 			     * lowest one, but check for cpp base class
! 			     * declaration/initialization, if it is an
! 			     * opening brace or we are looking just for
! 			     * enumerations/initializations. */
  			    if (terminated == ',')
  			    {
  				if (curbuf->b_ind_cpp_baseclass == 0)
--- 3244,3254 ----
  
  			if (lookfor == LOOKFOR_ENUM_OR_INIT)
  			{
! 			    // Found two lines ending in ',', lineup with the
! 			    // lowest one, but check for cpp base class
! 			    // declaration/initialization, if it is an
! 			    // opening brace or we are looking just for
! 			    // enumerations/initializations.
  			    if (terminated == ',')
  			    {
  				if (curbuf->b_ind_cpp_baseclass == 0)
***************
*** 3386,3404 ****
  				continue;
  			    }
  
! 			    /* Ignore unterminated lines in between, but
! 			     * reduce indent. */
  			    if (amount > cur_amount)
  				amount = cur_amount;
  			}
  			else
  			{
! 			    /*
! 			     * Found first unterminated line on a row, may
! 			     * line up with this line, remember its indent
! 			     *	    100 +
! 			     * ->	    here;
! 			     */
  			    l = ml_get_curline();
  			    amount = cur_amount;
  
--- 3258,3274 ----
  				continue;
  			    }
  
! 			    // Ignore unterminated lines in between, but
! 			    // reduce indent.
  			    if (amount > cur_amount)
  				amount = cur_amount;
  			}
  			else
  			{
! 			    // Found first unterminated line on a row, may
! 			    // line up with this line, remember its indent
! 			    //	    100 +
! 			    // ->	    here;
  			    l = ml_get_curline();
  			    amount = cur_amount;
  
***************
*** 3407,3439 ****
  					|| (n >=2 && l[n - 2] == ']')))
  				break;
  
! 			    /*
! 			     * If previous line ends in ',', check whether we
! 			     * are in an initialization or enum
! 			     * struct xxx =
! 			     * {
! 			     *      sizeof a,
! 			     *      124 };
! 			     * or a normal possible continuation line.
! 			     * but only, of no other statement has been found
! 			     * yet.
! 			     */
  			    if (lookfor == LOOKFOR_INITIAL && terminated == ',')
  			    {
  				if (curbuf->b_ind_js)
  				{
! 				    /* Search for a line ending in a comma
! 				     * and line up with the line below it
! 				     * (could be the current line).
! 				     * some = [
! 				     *     1,     <- line up here
! 				     *     2,
! 				     * some = [
! 				     *     3 +    <- line up here
! 				     *       4 *
! 				     *        5,
! 				     *     6,
! 				     */
  				    if (cin_iscomment(skipwhite(l)))
  					break;
  				    lookfor = LOOKFOR_COMMA;
--- 3277,3306 ----
  					|| (n >=2 && l[n - 2] == ']')))
  				break;
  
! 			    // If previous line ends in ',', check whether we
! 			    // are in an initialization or enum
! 			    // struct xxx =
! 			    // {
! 			    //      sizeof a,
! 			    //      124 };
! 			    // or a normal possible continuation line.
! 			    // but only, of no other statement has been found
! 			    // yet.
  			    if (lookfor == LOOKFOR_INITIAL && terminated == ',')
  			    {
  				if (curbuf->b_ind_js)
  				{
! 				    // Search for a line ending in a comma
! 				    // and line up with the line below it
! 				    // (could be the current line).
! 				    // some = [
! 				    //     1,     <- line up here
! 				    //     2,
! 				    // some = [
! 				    //     3 +    <- line up here
! 				    //       4 *
! 				    //        5,
! 				    //     6,
  				    if (cin_iscomment(skipwhite(l)))
  					break;
  				    lookfor = LOOKFOR_COMMA;
***************
*** 3444,3451 ****
  					if (trypos->lnum
  						 == curwin->w_cursor.lnum - 1)
  					{
! 					    /* Current line is first inside
! 					     * [], line up with it. */
  					    break;
  					}
  					ourscope = trypos->lnum;
--- 3311,3318 ----
  					if (trypos->lnum
  						 == curwin->w_cursor.lnum - 1)
  					{
! 					    // Current line is first inside
! 					    // [], line up with it.
  					    break;
  					}
  					ourscope = trypos->lnum;
***************
*** 3462,3468 ****
  				if (lookfor == LOOKFOR_INITIAL
  					&& *l != NUL
  					&& l[STRLEN(l) - 1] == '\\')
! 								/* XXX */
  				    cont_amount = cin_get_equal_amount(
  						       curwin->w_cursor.lnum);
  				if (lookfor != LOOKFOR_TERM
--- 3329,3335 ----
  				if (lookfor == LOOKFOR_INITIAL
  					&& *l != NUL
  					&& l[STRLEN(l) - 1] == '\\')
! 								// XXX
  				    cont_amount = cin_get_equal_amount(
  						       curwin->w_cursor.lnum);
  				if (lookfor != LOOKFOR_TERM
***************
*** 3475,3493 ****
  		    }
  		}
  
! 		/*
! 		 * Check if we are after a while (cond);
! 		 * If so: Ignore until the matching "do".
! 		 */
! 		else if (cin_iswhileofdo_end(terminated)) /* XXX */
  		{
! 		    /*
! 		     * Found an unterminated line after a while ();, line up
! 		     * with the last one.
! 		     *	    while (cond);
! 		     *	    100 +		<- line up with this one
! 		     * ->	    here;
! 		     */
  		    if (lookfor == LOOKFOR_UNTERM
  					   || lookfor == LOOKFOR_ENUM_OR_INIT)
  		    {
--- 3342,3356 ----
  		    }
  		}
  
! 		// Check if we are after a while (cond);
! 		// If so: Ignore until the matching "do".
! 		else if (cin_iswhileofdo_end(terminated)) // XXX
  		{
! 		    // Found an unterminated line after a while ();, line up
! 		    // with the last one.
! 		    //	    while (cond);
! 		    //	    100 +		<- line up with this one
! 		    // ->	    here;
  		    if (lookfor == LOOKFOR_UNTERM
  					   || lookfor == LOOKFOR_ENUM_OR_INIT)
  		    {
***************
*** 3501,3526 ****
  		    if (whilelevel == 0)
  		    {
  			lookfor = LOOKFOR_TERM;
! 			amount = get_indent();	    /* XXX */
  			if (theline[0] == '{')
  			    amount += curbuf->b_ind_open_extra;
  		    }
  		    ++whilelevel;
  		}
  
! 		/*
! 		 * We are after a "normal" statement.
! 		 * If we had another statement we can stop now and use the
! 		 * indent of that other statement.
! 		 * Otherwise the indent of the current statement may be used,
! 		 * search backwards for the next "normal" statement.
! 		 */
  		else
  		{
! 		    /*
! 		     * Skip single break line, if before a switch label. It
! 		     * may be lined up with the case label.
! 		     */
  		    if (lookfor == LOOKFOR_NOBREAK
  				  && cin_isbreak(skipwhite(ml_get_curline())))
  		    {
--- 3364,3385 ----
  		    if (whilelevel == 0)
  		    {
  			lookfor = LOOKFOR_TERM;
! 			amount = get_indent();	    // XXX
  			if (theline[0] == '{')
  			    amount += curbuf->b_ind_open_extra;
  		    }
  		    ++whilelevel;
  		}
  
! 		// We are after a "normal" statement.
! 		// If we had another statement we can stop now and use the
! 		// indent of that other statement.
! 		// Otherwise the indent of the current statement may be used,
! 		// search backwards for the next "normal" statement.
  		else
  		{
! 		    // Skip single break line, if before a switch label. It
! 		    // may be lined up with the case label.
  		    if (lookfor == LOOKFOR_NOBREAK
  				  && cin_isbreak(skipwhite(ml_get_curline())))
  		    {
***************
*** 3528,3558 ****
  			continue;
  		    }
  
! 		    /*
! 		     * Handle "do {" line.
! 		     */
  		    if (whilelevel > 0)
  		    {
  			l = cin_skipcomment(ml_get_curline());
  			if (cin_isdo(l))
  			{
! 			    amount = get_indent();	/* XXX */
  			    --whilelevel;
  			    continue;
  			}
  		    }
  
! 		    /*
! 		     * Found a terminated line above an unterminated line. Add
! 		     * the amount for a continuation line.
! 		     *	 x = 1;
! 		     *	 y = foo +
! 		     * ->	here;
! 		     * or
! 		     *	 int x = 1;
! 		     *	 int foo,
! 		     * ->	here;
! 		     */
  		    if (lookfor == LOOKFOR_UNTERM
  					   || lookfor == LOOKFOR_ENUM_OR_INIT)
  		    {
--- 3387,3413 ----
  			continue;
  		    }
  
! 		    // Handle "do {" line.
  		    if (whilelevel > 0)
  		    {
  			l = cin_skipcomment(ml_get_curline());
  			if (cin_isdo(l))
  			{
! 			    amount = get_indent();	// XXX
  			    --whilelevel;
  			    continue;
  			}
  		    }
  
! 		    // Found a terminated line above an unterminated line. Add
! 		    // the amount for a continuation line.
! 		    //	 x = 1;
! 		    //	 y = foo +
! 		    // ->	here;
! 		    // or
! 		    //	 int x = 1;
! 		    //	 int foo,
! 		    // ->	here;
  		    if (lookfor == LOOKFOR_UNTERM
  					   || lookfor == LOOKFOR_ENUM_OR_INIT)
  		    {
***************
*** 3563,3610 ****
  			break;
  		    }
  
! 		    /*
! 		     * Found a terminated line above a terminated line or "if"
! 		     * etc. line. Use the amount of the line below us.
! 		     *	 x = 1;				x = 1;
! 		     *	 if (asdf)		    y = 2;
! 		     *	     while (asdf)	  ->here;
! 		     *		here;
! 		     * ->foo;
! 		     */
  		    if (lookfor == LOOKFOR_TERM)
  		    {
  			if (!lookfor_break && whilelevel == 0)
  			    break;
  		    }
  
! 		    /*
! 		     * First line above the one we're indenting is terminated.
! 		     * To know what needs to be done look further backward for
! 		     * a terminated line.
! 		     */
  		    else
  		    {
! 			/*
! 			 * position the cursor over the rightmost paren, so
! 			 * that matching it will take us back to the start of
! 			 * the line.  Helps for:
! 			 *     func(asdr,
! 			 *	      asdfasdf);
! 			 *     here;
! 			 */
  term_again:
  			l = ml_get_curline();
  			if (find_last_paren(l, '(', ')')
  				&& (trypos = find_match_paren(
  					   curbuf->b_ind_maxparen)) != NULL)
  			{
! 			    /*
! 			     * Check if we are on a case label now.  This is
! 			     * handled above.
! 			     *	   case xx:  if ( asdf &&
! 			     *			    asdf)
! 			     */
  			    curwin->w_cursor = *trypos;
  			    l = ml_get_curline();
  			    if (cin_iscase(l, FALSE) || cin_isscopedecl(l))
--- 3418,3457 ----
  			break;
  		    }
  
! 		    // Found a terminated line above a terminated line or "if"
! 		    // etc. line. Use the amount of the line below us.
! 		    //	 x = 1;				x = 1;
! 		    //	 if (asdf)		    y = 2;
! 		    //	     while (asdf)	  ->here;
! 		    //		here;
! 		    // ->foo;
  		    if (lookfor == LOOKFOR_TERM)
  		    {
  			if (!lookfor_break && whilelevel == 0)
  			    break;
  		    }
  
! 		    // First line above the one we're indenting is terminated.
! 		    // To know what needs to be done look further backward for
! 		    // a terminated line.
  		    else
  		    {
! 			// position the cursor over the rightmost paren, so
! 			// that matching it will take us back to the start of
! 			// the line.  Helps for:
! 			//     func(asdr,
! 			//	      asdfasdf);
! 			//     here;
  term_again:
  			l = ml_get_curline();
  			if (find_last_paren(l, '(', ')')
  				&& (trypos = find_match_paren(
  					   curbuf->b_ind_maxparen)) != NULL)
  			{
! 			    // Check if we are on a case label now.  This is
! 			    // handled above.
! 			    //	   case xx:  if ( asdf &&
! 			    //			    asdf)
  			    curwin->w_cursor = *trypos;
  			    l = ml_get_curline();
  			    if (cin_iscase(l, FALSE) || cin_isscopedecl(l))
***************
*** 3615,3654 ****
  			    }
  			}
  
! 			/* When aligning with the case statement, don't align
! 			 * with a statement after it.
! 			 *  case 1: {   <-- don't use this { position
! 			 *	stat;
! 			 *  }
! 			 *  case 2:
! 			 *	stat;
! 			 * }
! 			 */
  			iscase = (curbuf->b_ind_keep_case_label
  						     && cin_iscase(l, FALSE));
  
! 			/*
! 			 * Get indent and pointer to text for current line,
! 			 * ignoring any jump label.
! 			 */
  			amount = skip_label(curwin->w_cursor.lnum, &l);
  
  			if (theline[0] == '{')
  			    amount += curbuf->b_ind_open_extra;
! 			/* See remark above: "Only add b_ind_open_extra.." */
  			l = skipwhite(l);
  			if (*l == '{')
  			    amount -= curbuf->b_ind_open_extra;
  			lookfor = iscase ? LOOKFOR_ANY : LOOKFOR_TERM;
  
! 			/*
! 			 * When a terminated line starts with "else" skip to
! 			 * the matching "if":
! 			 *       else 3;
! 			 *	     indent this;
! 			 * Need to use the scope of this "else".  XXX
! 			 * If whilelevel != 0 continue looking for a "do {".
! 			 */
  			if (lookfor == LOOKFOR_TERM
  				&& *l != '}'
  				&& cin_iselse(l)
--- 3462,3496 ----
  			    }
  			}
  
! 			// When aligning with the case statement, don't align
! 			// with a statement after it.
! 			//  case 1: {   <-- don't use this { position
! 			//	stat;
! 			//  }
! 			//  case 2:
! 			//	stat;
! 			// }
  			iscase = (curbuf->b_ind_keep_case_label
  						     && cin_iscase(l, FALSE));
  
! 			// Get indent and pointer to text for current line,
! 			// ignoring any jump label.
  			amount = skip_label(curwin->w_cursor.lnum, &l);
  
  			if (theline[0] == '{')
  			    amount += curbuf->b_ind_open_extra;
! 			// See remark above: "Only add b_ind_open_extra.."
  			l = skipwhite(l);
  			if (*l == '{')
  			    amount -= curbuf->b_ind_open_extra;
  			lookfor = iscase ? LOOKFOR_ANY : LOOKFOR_TERM;
  
! 			// When a terminated line starts with "else" skip to
! 			// the matching "if":
! 			//       else 3;
! 			//	     indent this;
! 			// Need to use the scope of this "else".  XXX
! 			// If whilelevel != 0 continue looking for a "do {".
  			if (lookfor == LOOKFOR_TERM
  				&& *l != '}'
  				&& cin_iselse(l)
***************
*** 3661,3677 ****
  			    continue;
  			}
  
! 			/*
! 			 * If we're at the end of a block, skip to the start of
! 			 * that block.
! 			 */
  			l = ml_get_curline();
! 			if (find_last_paren(l, '{', '}') /* XXX */
  				     && (trypos = find_start_brace()) != NULL)
  			{
  			    curwin->w_cursor = *trypos;
! 			    /* if not "else {" check for terminated again */
! 			    /* but skip block for "} else {" */
  			    l = cin_skipcomment(ml_get_curline());
  			    if (*l == '}' || !cin_iselse(l))
  				goto term_again;
--- 3503,3517 ----
  			    continue;
  			}
  
! 			// If we're at the end of a block, skip to the start of
! 			// that block.
  			l = ml_get_curline();
! 			if (find_last_paren(l, '{', '}') // XXX
  				     && (trypos = find_start_brace()) != NULL)
  			{
  			    curwin->w_cursor = *trypos;
! 			    // if not "else {" check for terminated again
! 			    // but skip block for "} else {"
  			    l = cin_skipcomment(ml_get_curline());
  			    if (*l == '}' || !cin_iselse(l))
  				goto term_again;
***************
*** 3684,3712 ****
  	}
        }
  
!       /* add extra indent for a comment */
        if (cin_iscomment(theline))
  	  amount += curbuf->b_ind_comment;
  
!       /* subtract extra left-shift for jump labels */
        if (curbuf->b_ind_jump_label > 0 && original_line_islabel)
  	  amount -= curbuf->b_ind_jump_label;
  
        goto theend;
      }
  
!     /*
!      * ok -- we're not inside any sort of structure at all!
!      *
!      * This means we're at the top level, and everything should
!      * basically just match where the previous line is, except
!      * for the lines immediately following a function declaration,
!      * which are K&R-style parameters and need to be indented.
!      *
!      * if our line starts with an open brace, forget about any
!      * prevailing indent and make sure it looks like the start
!      * of a function
!      */
  
      if (theline[0] == '{')
      {
--- 3524,3550 ----
  	}
        }
  
!       // add extra indent for a comment
        if (cin_iscomment(theline))
  	  amount += curbuf->b_ind_comment;
  
!       // subtract extra left-shift for jump labels
        if (curbuf->b_ind_jump_label > 0 && original_line_islabel)
  	  amount -= curbuf->b_ind_jump_label;
  
        goto theend;
      }
  
!     // ok -- we're not inside any sort of structure at all!
!     //
!     // This means we're at the top level, and everything should
!     // basically just match where the previous line is, except
!     // for the lines immediately following a function declaration,
!     // which are K&R-style parameters and need to be indented.
!     //
!     // if our line starts with an open brace, forget about any
!     // prevailing indent and make sure it looks like the start
!     // of a function
  
      if (theline[0] == '{')
      {
***************
*** 3714,3726 ****
  	goto theend;
      }
  
!     /*
!      * If the NEXT line is a function declaration, the current
!      * line needs to be indented as a function type spec.
!      * Don't do this if the current line looks like a comment or if the
!      * current line is terminated, ie. ends in ';', or if the current line
!      * contains { or }: "void f() {\n if (1)"
!      */
      if (cur_curpos.lnum < curbuf->b_ml.ml_line_count
  	    && !cin_nocode(theline)
  	    && vim_strchr(theline, '{') == NULL
--- 3552,3562 ----
  	goto theend;
      }
  
!     // If the NEXT line is a function declaration, the current
!     // line needs to be indented as a function type spec.
!     // Don't do this if the current line looks like a comment or if the
!     // current line is terminated, ie. ends in ';', or if the current line
!     // contains { or }: "void f() {\n if (1)"
      if (cur_curpos.lnum < curbuf->b_ml.ml_line_count
  	    && !cin_nocode(theline)
  	    && vim_strchr(theline, '{') == NULL
***************
*** 3735,3741 ****
  	goto theend;
      }
  
!     /* search backwards until we find something we recognize */
      amount = 0;
      curwin->w_cursor = cur_curpos;
      while (curwin->w_cursor.lnum > 1)
--- 3571,3577 ----
  	goto theend;
      }
  
!     // search backwards until we find something we recognize
      amount = 0;
      curwin->w_cursor = cur_curpos;
      while (curwin->w_cursor.lnum > 1)
***************
*** 3745,3754 ****
  
  	l = ml_get_curline();
  
! 	/*
! 	 * If we're in a comment or raw string now, skip to the start
! 	 * of it.
! 	 */						/* XXX */
  	if ((trypos = ind_find_start_CORS(NULL)) != NULL)
  	{
  	    curwin->w_cursor.lnum = trypos->lnum + 1;
--- 3581,3588 ----
  
  	l = ml_get_curline();
  
! 	// If we're in a comment or raw string now, skip to the start
! 	// of it.  XXX
  	if ((trypos = ind_find_start_CORS(NULL)) != NULL)
  	{
  	    curwin->w_cursor.lnum = trypos->lnum + 1;
***************
*** 3756,3765 ****
  	    continue;
  	}
  
! 	/*
! 	 * Are we at the start of a cpp base class declaration or
! 	 * constructor initialization?
! 	 */						    /* XXX */
  	n = FALSE;
  	if (curbuf->b_ind_cpp_baseclass != 0 && theline[0] != '{')
  	{
--- 3590,3597 ----
  	    continue;
  	}
  
! 	// Are we at the start of a cpp base class declaration or
! 	// constructor initialization?  XXX
  	n = FALSE;
  	if (curbuf->b_ind_cpp_baseclass != 0 && theline[0] != '{')
  	{
***************
*** 3768,3810 ****
  	}
  	if (n)
  	{
! 							     /* XXX */
  	    amount = get_baseclass_amount(cache_cpp_baseclass.lpos.col);
  	    break;
  	}
  
! 	/*
! 	 * Skip preprocessor directives and blank lines.
! 	 */
  	if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum, &amount))
  	    continue;
  
  	if (cin_nocode(l))
  	    continue;
  
! 	/*
! 	 * If the previous line ends in ',', use one level of
! 	 * indentation:
! 	 * int foo,
! 	 *     bar;
! 	 * do this before checking for '}' in case of eg.
! 	 * enum foobar
! 	 * {
! 	 *   ...
! 	 * } foo,
! 	 *   bar;
! 	 */
  	n = 0;
  	if (cin_ends_in(l, (char_u *)",", NULL)
  		     || (*l != NUL && (n = l[STRLEN(l) - 1]) == '\\'))
  	{
! 	    /* take us back to opening paren */
  	    if (find_last_paren(l, '(', ')')
  		    && (trypos = find_match_paren(
  				     curbuf->b_ind_maxparen)) != NULL)
  		curwin->w_cursor = *trypos;
  
! 	    /* For a line ending in ',' that is a continuation line go
  	     * back to the first line with a backslash:
  	     * char *foo = "bla\
  	     *		 bla",
--- 3600,3639 ----
  	}
  	if (n)
  	{
! 							     // XXX
  	    amount = get_baseclass_amount(cache_cpp_baseclass.lpos.col);
  	    break;
  	}
  
! 	// Skip preprocessor directives and blank lines.
  	if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum, &amount))
  	    continue;
  
  	if (cin_nocode(l))
  	    continue;
  
! 	// If the previous line ends in ',', use one level of
! 	// indentation:
! 	// int foo,
! 	//     bar;
! 	// do this before checking for '}' in case of eg.
! 	// enum foobar
! 	// {
! 	//   ...
! 	// } foo,
! 	//   bar;
  	n = 0;
  	if (cin_ends_in(l, (char_u *)",", NULL)
  		     || (*l != NUL && (n = l[STRLEN(l) - 1]) == '\\'))
  	{
! 	    // take us back to opening paren
  	    if (find_last_paren(l, '(', ')')
  		    && (trypos = find_match_paren(
  				     curbuf->b_ind_maxparen)) != NULL)
  		curwin->w_cursor = *trypos;
  
! 	    /*
! 	     * For a line ending in ',' that is a continuation line go
  	     * back to the first line with a backslash:
  	     * char *foo = "bla\
  	     *		 bla",
***************
*** 3819,3825 ****
  		curwin->w_cursor.col = 0;
  	    }
  
! 	    amount = get_indent();	    /* XXX */
  
  	    if (amount == 0)
  		amount = cin_first_id_amount();
--- 3648,3654 ----
  		curwin->w_cursor.col = 0;
  	    }
  
! 	    amount = get_indent();	    // XXX
  
  	    if (amount == 0)
  		amount = cin_first_id_amount();
***************
*** 3828,3874 ****
  	    break;
  	}
  
! 	/*
! 	 * If the line looks like a function declaration, and we're
! 	 * not in a comment, put it the left margin.
! 	 */
! 	if (cin_isfuncdecl(NULL, cur_curpos.lnum, 0))  /* XXX */
  	    break;
  	l = ml_get_curline();
  
! 	/*
! 	 * Finding the closing '}' of a previous function.  Put
! 	 * current line at the left margin.  For when 'cino' has "fs".
! 	 */
  	if (*skipwhite(l) == '}')
  	    break;
  
! 	/*			    (matching {)
! 	 * If the previous line ends on '};' (maybe followed by
! 	 * comments) align at column 0.  For example:
! 	 * char *string_array[] = { "foo",
! 	 *     / * x * / "b};ar" }; / * foobar * /
! 	 */
  	if (cin_ends_in(l, (char_u *)"};", NULL))
  	    break;
  
! 	/*
! 	 * If the previous line ends on '[' we are probably in an
! 	 * array constant:
! 	 * something = [
! 	 *     234,  <- extra indent
! 	 */
  	if (cin_ends_in(l, (char_u *)"[", NULL))
  	{
  	    amount = get_indent() + ind_continuation;
  	    break;
  	}
  
! 	/*
! 	 * Find a line only has a semicolon that belongs to a previous
! 	 * line ending in '}', e.g. before an #endif.  Don't increase
! 	 * indent then.
! 	 */
  	if (*(look = skipwhite(l)) == ';' && cin_nocode(look + 1))
  	{
  	    pos_T curpos_save = curwin->w_cursor;
--- 3657,3694 ----
  	    break;
  	}
  
! 	// If the line looks like a function declaration, and we're
! 	// not in a comment, put it the left margin.
! 	if (cin_isfuncdecl(NULL, cur_curpos.lnum, 0))  // XXX
  	    break;
  	l = ml_get_curline();
  
! 	// Finding the closing '}' of a previous function.  Put
! 	// current line at the left margin.  For when 'cino' has "fs".
  	if (*skipwhite(l) == '}')
  	    break;
  
! 	//			    (matching {)
! 	// If the previous line ends on '};' (maybe followed by
! 	// comments) align at column 0.  For example:
! 	// char *string_array[] = { "foo",
! 	//     / * x * / "b};ar" }; / * foobar * /
  	if (cin_ends_in(l, (char_u *)"};", NULL))
  	    break;
  
! 	// If the previous line ends on '[' we are probably in an
! 	// array constant:
! 	// something = [
! 	//     234,  <- extra indent
  	if (cin_ends_in(l, (char_u *)"[", NULL))
  	{
  	    amount = get_indent() + ind_continuation;
  	    break;
  	}
  
! 	// Find a line only has a semicolon that belongs to a previous
! 	// line ending in '}', e.g. before an #endif.  Don't increase
! 	// indent then.
  	if (*(look = skipwhite(l)) == ';' && cin_nocode(look + 1))
  	{
  	    pos_T curpos_save = curwin->w_cursor;
***************
*** 3887,3910 ****
  	    curwin->w_cursor = curpos_save;
  	}
  
! 	/*
! 	 * If the PREVIOUS line is a function declaration, the current
! 	 * line (and the ones that follow) needs to be indented as
! 	 * parameters.
! 	 */
  	if (cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0))
  	{
  	    amount = curbuf->b_ind_param;
  	    break;
  	}
  
! 	/*
! 	 * If the previous line ends in ';' and the line before the
! 	 * previous line ends in ',' or '\', ident to column zero:
! 	 * int foo,
! 	 *     bar;
! 	 * indent_to_0 here;
! 	 */
  	if (cin_ends_in(l, (char_u *)";", NULL))
  	{
  	    l = ml_get(curwin->w_cursor.lnum - 1);
--- 3707,3726 ----
  	    curwin->w_cursor = curpos_save;
  	}
  
! 	// If the PREVIOUS line is a function declaration, the current
! 	// line (and the ones that follow) needs to be indented as
! 	// parameters.
  	if (cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0))
  	{
  	    amount = curbuf->b_ind_param;
  	    break;
  	}
  
! 	// If the previous line ends in ';' and the line before the
! 	// previous line ends in ',' or '\', ident to column zero:
! 	// int foo,
! 	//     bar;
! 	// indent_to_0 here;
  	if (cin_ends_in(l, (char_u *)";", NULL))
  	{
  	    l = ml_get(curwin->w_cursor.lnum - 1);
***************
*** 3914,3939 ****
  	    l = ml_get_curline();
  	}
  
! 	/*
! 	 * Doesn't look like anything interesting -- so just
! 	 * use the indent of this line.
! 	 *
! 	 * Position the cursor over the rightmost paren, so that
! 	 * matching it will take us back to the start of the line.
! 	 */
  	find_last_paren(l, '(', ')');
  
  	if ((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)
  	    curwin->w_cursor = *trypos;
! 	amount = get_indent();	    /* XXX */
  	break;
      }
  
!     /* add extra indent for a comment */
      if (cin_iscomment(theline))
  	amount += curbuf->b_ind_comment;
  
!     /* add extra indent if the previous line ended in a backslash:
       *	      "asdfasdf\
       *		  here";
       *	    char *foo = "asdf\
--- 3730,3754 ----
  	    l = ml_get_curline();
  	}
  
! 	// Doesn't look like anything interesting -- so just
! 	// use the indent of this line.
! 	//
! 	// Position the cursor over the rightmost paren, so that
! 	// matching it will take us back to the start of the line.
  	find_last_paren(l, '(', ')');
  
  	if ((trypos = find_match_paren(curbuf->b_ind_maxparen)) != NULL)
  	    curwin->w_cursor = *trypos;
! 	amount = get_indent();	    // XXX
  	break;
      }
  
!     // add extra indent for a comment
      if (cin_iscomment(theline))
  	amount += curbuf->b_ind_comment;
  
!     /*
!      * add extra indent if the previous line ended in a backslash:
       *	      "asdfasdf\
       *		  here";
       *	    char *foo = "asdf\
***************
*** 3957,3963 ****
  	amount = 0;
  
  laterend:
!     /* put the cursor back where it belongs */
      curwin->w_cursor = cur_curpos;
  
      vim_free(linecopy);
--- 3772,3778 ----
  	amount = 0;
  
  laterend:
!     // put the cursor back where it belongs
      curwin->w_cursor = cur_curpos;
  
      vim_free(linecopy);
***************
*** 3995,4032 ****
  	look = cin_skipcomment(ml_get_curline());
  	if (cin_iselse(look)
  		|| cin_isif(look)
! 		|| cin_isdo(look)			    /* XXX */
  		|| cin_iswhileofdo(look, curwin->w_cursor.lnum))
  	{
! 	    /*
! 	     * if we've gone outside the braces entirely,
! 	     * we must be out of scope...
! 	     */
! 	    theirscope = find_start_brace();  /* XXX */
  	    if (theirscope == NULL)
  		break;
  
! 	    /*
! 	     * and if the brace enclosing this is further
! 	     * back than the one enclosing the else, we're
! 	     * out of luck too.
! 	     */
  	    if (theirscope->lnum < ourscope)
  		break;
  
! 	    /*
! 	     * and if they're enclosed in a *deeper* brace,
! 	     * then we can ignore it because it's in a
! 	     * different scope...
! 	     */
  	    if (theirscope->lnum > ourscope)
  		continue;
  
! 	    /*
! 	     * if it was an "else" (that's not an "else if")
! 	     * then we need to go back to another if, so
! 	     * increment elselevel
! 	     */
  	    look = cin_skipcomment(ml_get_curline());
  	    if (cin_iselse(look))
  	    {
--- 3810,3839 ----
  	look = cin_skipcomment(ml_get_curline());
  	if (cin_iselse(look)
  		|| cin_isif(look)
! 		|| cin_isdo(look)			    // XXX
  		|| cin_iswhileofdo(look, curwin->w_cursor.lnum))
  	{
! 	    // if we've gone outside the braces entirely,
! 	    // we must be out of scope...
! 	    theirscope = find_start_brace();  // XXX
  	    if (theirscope == NULL)
  		break;
  
! 	    // and if the brace enclosing this is further
! 	    // back than the one enclosing the else, we're
! 	    // out of luck too.
  	    if (theirscope->lnum < ourscope)
  		break;
  
! 	    // and if they're enclosed in a *deeper* brace,
! 	    // then we can ignore it because it's in a
! 	    // different scope...
  	    if (theirscope->lnum > ourscope)
  		continue;
  
! 	    // if it was an "else" (that's not an "else if")
! 	    // then we need to go back to another if, so
! 	    // increment elselevel
  	    look = cin_skipcomment(ml_get_curline());
  	    if (cin_iselse(look))
  	    {
***************
*** 4036,4073 ****
  		continue;
  	    }
  
! 	    /*
! 	     * if it was a "while" then we need to go back to
! 	     * another "do", so increment whilelevel.  XXX
! 	     */
  	    if (cin_iswhileofdo(look, curwin->w_cursor.lnum))
  	    {
  		++whilelevel;
  		continue;
  	    }
  
! 	    /* If it's an "if" decrement elselevel */
  	    look = cin_skipcomment(ml_get_curline());
  	    if (cin_isif(look))
  	    {
  		elselevel--;
! 		/*
! 		 * When looking for an "if" ignore "while"s that
! 		 * get in the way.
! 		 */
  		if (elselevel == 0 && lookfor == LOOKFOR_IF)
  		    whilelevel = 0;
  	    }
  
! 	    /* If it's a "do" decrement whilelevel */
  	    if (cin_isdo(look))
  		whilelevel--;
  
! 	    /*
! 	     * if we've used up all the elses, then
! 	     * this must be the if that we want!
! 	     * match the indent level of that if.
! 	     */
  	    if (elselevel <= 0 && whilelevel <= 0)
  	    {
  		return OK;
--- 3843,3874 ----
  		continue;
  	    }
  
! 	    // if it was a "while" then we need to go back to
! 	    // another "do", so increment whilelevel.  XXX
  	    if (cin_iswhileofdo(look, curwin->w_cursor.lnum))
  	    {
  		++whilelevel;
  		continue;
  	    }
  
! 	    // If it's an "if" decrement elselevel
  	    look = cin_skipcomment(ml_get_curline());
  	    if (cin_isif(look))
  	    {
  		elselevel--;
! 		// When looking for an "if" ignore "while"s that
! 		// get in the way.
  		if (elselevel == 0 && lookfor == LOOKFOR_IF)
  		    whilelevel = 0;
  	    }
  
! 	    // If it's a "do" decrement whilelevel
  	    if (cin_isdo(look))
  		whilelevel--;
  
! 	    // if we've used up all the elses, then
! 	    // this must be the if that we want!
! 	    // match the indent level of that if.
  	    if (elselevel <= 0 && whilelevel <= 0)
  	    {
  		return OK;
***************
*** 4093,4100 ****
      int		use_sandbox = was_set_insecurely((char_u *)"indentexpr",
  								   OPT_LOCAL);
  
!     /* Save and restore cursor position and curswant, in case it was changed
!      * via :normal commands */
      save_pos = curwin->w_cursor;
      save_curswant = curwin->w_curswant;
      save_set_curswant = curwin->w_set_curswant;
--- 3894,3901 ----
      int		use_sandbox = was_set_insecurely((char_u *)"indentexpr",
  								   OPT_LOCAL);
  
!     // Save and restore cursor position and curswant, in case it was changed
!     // via :normal commands
      save_pos = curwin->w_cursor;
      save_curswant = curwin->w_curswant;
      save_set_curswant = curwin->w_set_curswant;
***************
*** 4103,4110 ****
  	++sandbox;
      ++textlock;
  
!     /* Need to make a copy, the 'indentexpr' option could be changed while
!      * evaluating it. */
      inde_copy = vim_strsave(curbuf->b_p_inde);
      if (inde_copy != NULL)
      {
--- 3904,3911 ----
  	++sandbox;
      ++textlock;
  
!     // Need to make a copy, the 'indentexpr' option could be changed while
!     // evaluating it.
      inde_copy = vim_strsave(curbuf->b_p_inde);
      if (inde_copy != NULL)
      {
***************
*** 4116,4124 ****
  	--sandbox;
      --textlock;
  
!     /* Restore the cursor position so that 'indentexpr' doesn't need to.
!      * Pretend to be in Insert mode, allow cursor past end of line for "o"
!      * command. */
      save_State = State;
      State = INSERT;
      curwin->w_cursor = save_pos;
--- 3917,3925 ----
  	--sandbox;
      --textlock;
  
!     // Restore the cursor position so that 'indentexpr' doesn't need to.
!     // Pretend to be in Insert mode, allow cursor past end of line for "o"
!     // command.
      save_State = State;
      State = INSERT;
      curwin->w_cursor = save_pos;
***************
*** 4127,4133 ****
      check_cursor();
      State = save_State;
  
!     /* If there is an error, just keep the current indent. */
      if (indent < 0)
  	indent = get_indent();
  
--- 3928,3934 ----
      check_cursor();
      State = save_State;
  
!     // If there is an error, just keep the current indent.
      if (indent < 0)
  	indent = get_indent();
  
***************
*** 4163,4183 ****
      int		i;
  
      if (keytyped == NUL)
! 	/* Can happen with CTRL-Y and CTRL-E on a short line. */
  	return FALSE;
  
  #ifdef FEAT_EVAL
      if (*curbuf->b_p_inde != NUL)
! 	look = curbuf->b_p_indk;	/* 'indentexpr' set: use 'indentkeys' */
      else
  #endif
! 	look = curbuf->b_p_cink;	/* 'indentexpr' empty: use 'cinkeys' */
      while (*look)
      {
! 	/*
! 	 * Find out if we want to try a match with this key, depending on
! 	 * 'when' and a '*' or '!' before the key.
! 	 */
  	switch (when)
  	{
  	    case '*': try_match = (*look == '*'); break;
--- 3964,3982 ----
      int		i;
  
      if (keytyped == NUL)
! 	// Can happen with CTRL-Y and CTRL-E on a short line.
  	return FALSE;
  
  #ifdef FEAT_EVAL
      if (*curbuf->b_p_inde != NUL)
! 	look = curbuf->b_p_indk;	// 'indentexpr' set: use 'indentkeys'
      else
  #endif
! 	look = curbuf->b_p_cink;	// 'indentexpr' empty: use 'cinkeys'
      while (*look)
      {
! 	// Find out if we want to try a match with this key, depending on
! 	// 'when' and a '*' or '!' before the key.
  	switch (when)
  	{
  	    case '*': try_match = (*look == '*'); break;
***************
*** 4187,4196 ****
  	if (*look == '*' || *look == '!')
  	    ++look;
  
! 	/*
! 	 * If there is a '0', only accept a match if the line is empty.
! 	 * But may still match when typing last char of a word.
! 	 */
  	if (*look == '0')
  	{
  	    try_match_word = try_match;
--- 3986,3993 ----
  	if (*look == '*' || *look == '!')
  	    ++look;
  
! 	// If there is a '0', only accept a match if the line is empty.
! 	// But may still match when typing last char of a word.
  	if (*look == '0')
  	{
  	    try_match_word = try_match;
***************
*** 4201,4209 ****
  	else
  	    try_match_word = FALSE;
  
! 	/*
! 	 * does it look like a control character?
! 	 */
  	if (*look == '^'
  #ifdef EBCDIC
  		&& (Ctrl_chr(look[1]) != 0)
--- 3998,4004 ----
  	else
  	    try_match_word = FALSE;
  
! 	// does it look like a control character?
  	if (*look == '^'
  #ifdef EBCDIC
  		&& (Ctrl_chr(look[1]) != 0)
***************
*** 4216,4225 ****
  		return TRUE;
  	    look += 2;
  	}
! 	/*
! 	 * 'o' means "o" command, open forward.
! 	 * 'O' means "O" command, open backward.
! 	 */
  	else if (*look == 'o')
  	{
  	    if (try_match && keytyped == KEY_OPEN_FORW)
--- 4011,4018 ----
  		return TRUE;
  	    look += 2;
  	}
! 	// 'o' means "o" command, open forward.
! 	// 'O' means "O" command, open backward.
  	else if (*look == 'o')
  	{
  	    if (try_match && keytyped == KEY_OPEN_FORW)
***************
*** 4233,4242 ****
  	    ++look;
  	}
  
! 	/*
! 	 * 'e' means to check for "else" at start of line and just before the
! 	 * cursor.
! 	 */
  	else if (*look == 'e')
  	{
  	    if (try_match && keytyped == 'e' && curwin->w_cursor.col >= 4)
--- 4026,4033 ----
  	    ++look;
  	}
  
! 	// 'e' means to check for "else" at start of line and just before the
! 	// cursor.
  	else if (*look == 'e')
  	{
  	    if (try_match && keytyped == 'e' && curwin->w_cursor.col >= 4)
***************
*** 4249,4259 ****
  	    ++look;
  	}
  
! 	/*
! 	 * ':' only causes an indent if it is at the end of a label or case
! 	 * statement, or when it was before typing the ':' (to fix
! 	 * class::method for C++).
! 	 */
  	else if (*look == ':')
  	{
  	    if (try_match && keytyped == ':')
--- 4040,4048 ----
  	    ++look;
  	}
  
! 	// ':' only causes an indent if it is at the end of a label or case
! 	// statement, or when it was before typing the ':' (to fix
! 	// class::method for C++).
  	else if (*look == ':')
  	{
  	    if (try_match && keytyped == ':')
***************
*** 4261,4267 ****
  		p = ml_get_curline();
  		if (cin_iscase(p, FALSE) || cin_isscopedecl(p) || cin_islabel())
  		    return TRUE;
! 		/* Need to get the line again after cin_islabel(). */
  		p = ml_get_curline();
  		if (curwin->w_cursor.col > 2
  			&& p[curwin->w_cursor.col - 1] == ':'
--- 4050,4056 ----
  		p = ml_get_curline();
  		if (cin_iscase(p, FALSE) || cin_isscopedecl(p) || cin_islabel())
  		    return TRUE;
! 		// Need to get the line again after cin_islabel().
  		p = ml_get_curline();
  		if (curwin->w_cursor.col > 2
  			&& p[curwin->w_cursor.col - 1] == ':'
***************
*** 4280,4297 ****
  	}
  
  
! 	/*
! 	 * Is it a key in <>, maybe?
! 	 */
  	else if (*look == '<')
  	{
  	    if (try_match)
  	    {
! 		/*
! 		 * make up some named keys <o>, <O>, <e>, <0>, <>>, <<>, <*>,
! 		 * <:> and <!> so that people can re-indent on o, O, e, 0, <,
! 		 * >, *, : and ! keys if they really really want to.
! 		 */
  		if (vim_strchr((char_u *)"<>!*oOe0:", look[1]) != NULL
  						       && keytyped == look[1])
  		    return TRUE;
--- 4069,4082 ----
  	}
  
  
! 	// Is it a key in <>, maybe?
  	else if (*look == '<')
  	{
  	    if (try_match)
  	    {
! 		// make up some named keys <o>, <O>, <e>, <0>, <>>, <<>, <*>,
! 		// <:> and <!> so that people can re-indent on o, O, e, 0, <,
! 		// >, *, : and ! keys if they really really want to.
  		if (vim_strchr((char_u *)"<>!*oOe0:", look[1]) != NULL
  						       && keytyped == look[1])
  		    return TRUE;
***************
*** 4305,4313 ****
  		look++;
  	}
  
! 	/*
! 	 * Is it a word: "=word"?
! 	 */
  	else if (*look == '=' && look[1] != ',' && look[1] != NUL)
  	{
  	    ++look;
--- 4090,4096 ----
  		look++;
  	}
  
! 	// Is it a word: "=word"?
  	else if (*look == '=' && look[1] != ',' && look[1] != NUL)
  	{
  	    ++look;
***************
*** 4331,4338 ****
  		{
  		    char_u	*s;
  
! 		    /* Just completed a word, check if it starts with "look".
! 		     * search back for the start of a word. */
  		    line = ml_get_curline();
  		    if (has_mbyte)
  		    {
--- 4114,4121 ----
  		{
  		    char_u	*s;
  
! 		    // Just completed a word, check if it starts with "look".
! 		    // search back for the start of a word.
  		    line = ml_get_curline();
  		    if (has_mbyte)
  		    {
***************
*** 4357,4363 ****
  		}
  		else
  #endif
! 		    /* TODO: multi-byte */
  		    if (keytyped == (int)p[-1] || (icase && keytyped < 256
  			 && TOLOWER_LOC(keytyped) == TOLOWER_LOC((int)p[-1])))
  		{
--- 4140,4146 ----
  		}
  		else
  #endif
! 		    // TODO: multi-byte
  		    if (keytyped == (int)p[-1] || (icase && keytyped < 256
  			 && TOLOWER_LOC(keytyped) == TOLOWER_LOC((int)p[-1])))
  		{
***************
*** 4372,4379 ****
  		}
  		if (match && try_match_word && !try_match)
  		{
! 		    /* "0=word": Check if there are only blanks before the
! 		     * word. */
  		    if (getwhitecols_curline() !=
  				     (int)(curwin->w_cursor.col - (p - look)))
  			match = FALSE;
--- 4155,4162 ----
  		}
  		if (match && try_match_word && !try_match)
  		{
! 		    // "0=word": Check if there are only blanks before the
! 		    // word.
  		    if (getwhitecols_curline() !=
  				     (int)(curwin->w_cursor.col - (p - look)))
  			match = FALSE;
***************
*** 4384,4392 ****
  	    look = p;
  	}
  
! 	/*
! 	 * ok, it's a boring generic character.
! 	 */
  	else
  	{
  	    if (try_match && *look == keytyped)
--- 4167,4173 ----
  	    look = p;
  	}
  
! 	// ok, it's a boring generic character.
  	else
  	{
  	    if (try_match && *look == keytyped)
***************
*** 4395,4408 ****
  		++look;
  	}
  
! 	/*
! 	 * Skip over ", ".
! 	 */
  	look = skip_to_option_part(look);
      }
      return FALSE;
  }
! #endif /* FEAT_CINDENT */
  
  #if defined(FEAT_LISP) || defined(PROTO)
  
--- 4176,4187 ----
  		++look;
  	}
  
! 	// Skip over ", ".
  	look = skip_to_option_part(look);
      }
      return FALSE;
  }
! #endif // FEAT_CINDENT
  
  #if defined(FEAT_LISP) || defined(PROTO)
  
***************
*** 4450,4456 ****
      int		parencount, quotecount;
      int		vi_lisp;
  
!     /* Set vi_lisp to use the vi-compatible method */
      vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);
  
      realpos = curwin->w_cursor;
--- 4229,4235 ----
      int		parencount, quotecount;
      int		vi_lisp;
  
!     // Set vi_lisp to use the vi-compatible method
      vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL);
  
      realpos = curwin->w_cursor;
***************
*** 4467,4474 ****
      }
      if (pos != NULL)
      {
! 	/* Extra trick: Take the indent of the first previous non-white
! 	 * line that is at the same () level. */
  	amount = -1;
  	parencount = 0;
  
--- 4246,4253 ----
      }
      if (pos != NULL)
      {
! 	// Extra trick: Take the indent of the first previous non-white
! 	// line that is at the same () level.
  	amount = -1;
  	parencount = 0;
  
***************
*** 4494,4500 ****
  		{
  		    while (*++that && *that != '"')
  		    {
! 			/* skipping escaped characters in the string */
  			if (*that == '\\')
  			{
  			    if (*++that == NUL)
--- 4273,4279 ----
  		{
  		    while (*++that && *that != '"')
  		    {
! 			// skipping escaped characters in the string
  			if (*that == '\\')
  			{
  			    if (*++that == NUL)
***************
*** 4540,4552 ****
  		    col--;
  		}
  
! 		/*
! 		 * Some keywords require "body" indenting rules (the
! 		 * non-standard-lisp ones are Scheme special forms):
! 		 *
! 		 * (let ((a 1))    instead    (let ((a 1))
! 		 *   (...))	      of	   (...))
! 		 */
  
  		if (!vi_lisp && (*that == '(' || *that == '[')
  						      && lisp_match(that + 1))
--- 4319,4329 ----
  		    col--;
  		}
  
! 		// Some keywords require "body" indenting rules (the
! 		// non-standard-lisp ones are Scheme special forms):
! 		//
! 		// (let ((a 1))    instead    (let ((a 1))
! 		//   (...))	      of	   (...))
  
  		if (!vi_lisp && (*that == '(' || *that == '[')
  						      && lisp_match(that + 1))
***************
*** 4563,4572 ****
  			++that;
  		    }
  
! 		    if (*that && *that != ';') /* not a comment line */
  		    {
! 			/* test *that != '(' to accommodate first let/do
! 			 * argument if it is more than one line */
  			if (!vi_lisp && *that != '(' && *that != '[')
  			    firsttry++;
  
--- 4340,4349 ----
  			++that;
  		    }
  
! 		    if (*that && *that != ';') // not a comment line
  		    {
! 			// test *that != '(' to accommodate first let/do
! 			// argument if it is more than one line
  			if (!vi_lisp && *that != '(' && *that != '[')
  			    firsttry++;
  
***************
*** 4617,4629 ****
  	}
      }
      else
! 	amount = 0;	/* no matching '(' or '[' found, use zero indent */
  
      curwin->w_cursor = realpos;
  
      return amount;
  }
! #endif /* FEAT_LISP */
  
  #if defined(FEAT_CINDENT) || defined(PROTO)
  /*
--- 4394,4406 ----
  	}
      }
      else
! 	amount = 0;	// no matching '(' or '[' found, use zero indent
  
      curwin->w_cursor = realpos;
  
      return amount;
  }
! #endif // FEAT_LISP
  
  #if defined(FEAT_CINDENT) || defined(PROTO)
  /*
***************
*** 4658,4664 ****
      {
  	change_indent(INDENT_SET, amount, FALSE, 0, TRUE);
  	if (linewhite(curwin->w_cursor.lnum))
! 	    did_ai = TRUE;	/* delete the indent if the line stays empty */
      }
  }
  
--- 4435,4441 ----
      {
  	change_indent(INDENT_SET, amount, FALSE, 0, TRUE);
  	if (linewhite(curwin->w_cursor.lnum))
! 	    did_ai = TRUE;	// delete the indent if the line stays empty
      }
  }
  
*** ../vim-8.1.0873/src/version.c	2019-02-03 23:45:09.282345807 +0100
--- src/version.c	2019-02-04 20:26:52.174771873 +0100
***************
*** 785,786 ****
--- 785,788 ----
  {   /* Add new patch number below this line */
+ /**/
+     874,
  /**/

-- 
Veni, Vidi, VW -- I came, I saw, I drove around in a little car.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
