To: vim_dev@googlegroups.com
Subject: Patch 8.1.0806
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.1.0806
Problem:    Too many #ifdefs.
Solution:   Graduate FEAT_MBYTE, part 2.
Files:	    src/ex_cmds2.c, src/ex_docmd.c, src/ex_getln.c, src/gui_w32.c,
            src/gui_x11.c, src/hardcopy.c, src/if_xcmdsrv.c, src/json.c,
            src/kword_test.c, src/main.c, src/mbyte.c, src/memline.c,
            src/message.c, src/misc1.c, src/misc2.c, src/move.c, src/normal.c,
            src/ops.c, src/option.c, src/charset.c


*** ../vim-8.1.0805/src/ex_cmds2.c	2019-01-24 15:04:44.666887862 +0100
--- src/ex_cmds2.c	2019-01-24 15:09:55.708856796 +0100
***************
*** 5421,5427 ****
  #if (defined(FEAT_EVAL) && !((defined(HAVE_LOCALE_H) || defined(X_LOCALE)) \
  	    && defined(LC_MESSAGES))) \
  	|| ((defined(HAVE_LOCALE_H) || defined(X_LOCALE)) \
- 		&& (defined(FEAT_GETTEXT) || defined(FEAT_MBYTE)) \
  		&& !defined(LC_MESSAGES))
  /*
   * Get the language used for messages from the environment.
--- 5421,5426 ----
***************
*** 5485,5492 ****
  }
  #endif
  
! #if (defined(HAVE_LOCALE_H) || defined(X_LOCALE)) \
! 	&& (defined(FEAT_GETTEXT) || defined(FEAT_MBYTE))
  /*
   * ":language":  Set the language (locale).
   */
--- 5484,5490 ----
  }
  #endif
  
! #if defined(HAVE_LOCALE_H) || defined(X_LOCALE) \
  /*
   * ":language":  Set the language (locale).
   */
*** ../vim-8.1.0805/src/ex_docmd.c	2019-01-24 15:04:44.666887862 +0100
--- src/ex_docmd.c	2019-01-24 15:10:21.144699639 +0100
***************
*** 4300,4307 ****
  	    xp->xp_pattern = arg;
  	    break;
  
! #if (defined(HAVE_LOCALE_H) || defined(X_LOCALE)) \
! 	&& (defined(FEAT_GETTEXT) || defined(FEAT_MBYTE))
  	case CMD_language:
  	    p = skiptowhite(arg);
  	    if (*p == NUL)
--- 4300,4306 ----
  	    xp->xp_pattern = arg;
  	    break;
  
! #if defined(HAVE_LOCALE_H) || defined(X_LOCALE)
  	case CMD_language:
  	    p = skiptowhite(arg);
  	    if (*p == NUL)
***************
*** 5963,5970 ****
  #if defined(FEAT_CMDHIST)
      {EXPAND_HISTORY, "history"},
  #endif
! #if (defined(HAVE_LOCALE_H) || defined(X_LOCALE)) \
! 	&& (defined(FEAT_GETTEXT) || defined(FEAT_MBYTE))
      {EXPAND_LOCALES, "locale"},
  #endif
      {EXPAND_MAPCLEAR, "mapclear"},
--- 5962,5968 ----
  #if defined(FEAT_CMDHIST)
      {EXPAND_HISTORY, "history"},
  #endif
! #if defined(HAVE_LOCALE_H) || defined(X_LOCALE)
      {EXPAND_LOCALES, "locale"},
  #endif
      {EXPAND_MAPCLEAR, "mapclear"},
*** ../vim-8.1.0805/src/ex_getln.c	2019-01-24 15:04:44.670887836 +0100
--- src/ex_getln.c	2019-01-24 15:10:41.796571593 +0100
***************
*** 5253,5260 ****
  #ifdef FEAT_PROFILE
  	    {EXPAND_PROFILE, get_profile_name, TRUE, TRUE},
  #endif
! #if (defined(HAVE_LOCALE_H) || defined(X_LOCALE)) \
! 	&& (defined(FEAT_GETTEXT) || defined(FEAT_MBYTE))
  	    {EXPAND_LANGUAGE, get_lang_arg, TRUE, FALSE},
  	    {EXPAND_LOCALES, get_locales, TRUE, FALSE},
  #endif
--- 5253,5259 ----
  #ifdef FEAT_PROFILE
  	    {EXPAND_PROFILE, get_profile_name, TRUE, TRUE},
  #endif
! #if defined(HAVE_LOCALE_H) || defined(X_LOCALE)
  	    {EXPAND_LANGUAGE, get_lang_arg, TRUE, FALSE},
  	    {EXPAND_LOCALES, get_locales, TRUE, FALSE},
  #endif
*** ../vim-8.1.0805/src/gui_w32.c	2019-01-19 19:54:17.141981393 +0100
--- src/gui_w32.c	2019-01-24 15:12:02.496067677 +0100
***************
*** 30,38 ****
  #endif
  
  #if defined(FEAT_DIRECTX)
- # ifndef FEAT_MBYTE
- #  error FEAT_MBYTE is required for FEAT_DIRECTX.
- # endif
  static DWriteContext *s_dwc = NULL;
  static int s_directx_enabled = 0;
  static int s_directx_load_attempted = 0;
--- 30,35 ----
***************
*** 318,326 ****
  #ifdef MSWIN_FIND_REPLACE
  static UINT		s_findrep_msg = 0;	/* set in gui_w[16/32].c */
  static FINDREPLACE	s_findrep_struct;
- # ifdef FEAT_MBYTE
  static FINDREPLACEW	s_findrep_struct_w;
- # endif
  static HWND		s_findrep_hwnd = NULL;
  static int		s_findrep_is_find;	/* TRUE for find dialog, FALSE
  						   for find/replace dialog */
--- 315,321 ----
***************
*** 396,408 ****
  }
  #endif
  
! #if defined(FEAT_MBYTE) || defined(GLOBAL_IME)
!   /* use of WindowProc depends on wide_WindowProc */
! # define MyWindowProc vim_WindowProc
! #else
!   /* use ordinary WindowProc */
! # define MyWindowProc DefWindowProc
! #endif
  
  extern int current_font_height;	    /* this is in os_mswin.c */
  
--- 391,398 ----
  }
  #endif
  
! /* use of WindowProc depends on wide_WindowProc */
! #define MyWindowProc vim_WindowProc
  
  extern int current_font_height;	    /* this is in os_mswin.c */
  
***************
*** 724,730 ****
  {
      int		len;
      int		i;
- #ifdef FEAT_MBYTE
      WCHAR	wstring[2];
      char_u	*ws = NULL;
  
--- 714,719 ----
***************
*** 785,791 ****
      }
  
      if (len == 0)
- #endif
      {
  	string[0] = ch;
  	len = 1;
--- 774,779 ----
***************
*** 1118,1124 ****
  #endif
  
  #ifdef MSWIN_FIND_REPLACE
- # ifdef FEAT_MBYTE
  /*
   * copy useful data from structure LPFINDREPLACE to structure LPFINDREPLACEW
   */
--- 1106,1111 ----
***************
*** 1155,1161 ****
      vim_strncpy((char_u *)lpfr->lpstrReplaceWith, p, lpfr->wReplaceWithLen - 1);
      vim_free(p);
  }
- # endif
  
  /*
   * Handle a Find/Replace window message.
--- 1142,1147 ----
***************
*** 1166,1179 ****
      int	    flags = 0;
      int	    down;
  
- # ifdef FEAT_MBYTE
      /* If the OS is Windows NT, and 'encoding' differs from active codepage:
       * convert text from wide string. */
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	findrep_wtoa(&s_findrep_struct, &s_findrep_struct_w);
      }
- # endif
  
      if (s_findrep_struct.Flags & FR_DIALOGTERM)
  	/* Give main window the focus back. */
--- 1152,1163 ----
***************
*** 1318,1342 ****
      }
  }
  
! #if defined(FEAT_MBYTE) \
! 	|| defined(GLOBAL_IME) \
! 	|| defined(PROTO)
! # ifdef PROTO
  typedef int WINAPI;
! # endif
  
      LRESULT WINAPI
  vim_WindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
  {
! # ifdef GLOBAL_IME
      return global_ime_DefWindowProc(hwnd, message, wParam, lParam);
! # else
      if (wide_WindowProc)
  	return DefWindowProcW(hwnd, message, wParam, lParam);
      return DefWindowProc(hwnd, message, wParam, lParam);
  #endif
  }
- #endif
  
  /*
   * Called when the foreground or background color has been changed.
--- 1302,1322 ----
      }
  }
  
! #ifdef PROTO
  typedef int WINAPI;
! #endif
  
      LRESULT WINAPI
  vim_WindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
  {
! #ifdef GLOBAL_IME
      return global_ime_DefWindowProc(hwnd, message, wParam, lParam);
! #else
      if (wide_WindowProc)
  	return DefWindowProcW(hwnd, message, wParam, lParam);
      return DefWindowProc(hwnd, message, wParam, lParam);
  #endif
  }
  
  /*
   * Called when the foreground or background color has been changed.
***************
*** 1751,1760 ****
      rc.left = FILL_X(gui.col);
      rc.top = FILL_Y(gui.row);
      rc.right = rc.left + gui.char_width;
- #ifdef FEAT_MBYTE
      if (mb_lefthalve(gui.row, gui.col))
  	rc.right += gui.char_width;
- #endif
      rc.bottom = rc.top + gui.char_height;
      hbr = CreateSolidBrush(color);
      FrameRect(s_hdc, &rc, hbr);
--- 1731,1738 ----
***************
*** 2345,2351 ****
      return size.cx;
  }
  
- #ifdef FEAT_MBYTE
  /*
   * Return the width in pixels of the given text in the given DC, taking care
   * of 'encoding' to active codepage conversion.
--- 2323,2328 ----
***************
*** 2374,2382 ****
  
      return GetTextWidth(hdc, str, len);
  }
- #else
- # define GetTextWidthEnc(h, s, l) GetTextWidth((h), (s), (l))
- #endif
  
  static void get_work_area(RECT *spi_rect);
  
--- 2351,2356 ----
***************
*** 2451,2465 ****
  
      if (showit)
      {
! # ifdef FEAT_MBYTE
! #  ifndef TB_SETUNICODEFORMAT
      /* For older compilers.  We assume this never changes. */
! #   define TB_SETUNICODEFORMAT 0x2005
! #  endif
  	/* Enable/disable unicode support */
  	int uu = (enc_codepage >= 0 && (int)GetACP() != enc_codepage);
  	SendMessage(s_toolbarhwnd, TB_SETUNICODEFORMAT, (WPARAM)uu, (LPARAM)0);
- # endif
  	ShowWindow(s_toolbarhwnd, SW_SHOW);
      }
      else
--- 2425,2437 ----
  
      if (showit)
      {
! # ifndef TB_SETUNICODEFORMAT
      /* For older compilers.  We assume this never changes. */
! #  define TB_SETUNICODEFORMAT 0x2005
! # endif
  	/* Enable/disable unicode support */
  	int uu = (enc_codepage >= 0 && (int)GetACP() != enc_codepage);
  	SendMessage(s_toolbarhwnd, TB_SETUNICODEFORMAT, (WPARAM)uu, (LPARAM)0);
  	ShowWindow(s_toolbarhwnd, SW_SHOW);
      }
      else
***************
*** 2475,2481 ****
      static void
  add_tabline_popup_menu_entry(HMENU pmenu, UINT item_id, char_u *item_text)
  {
- #ifdef FEAT_MBYTE
      WCHAR	*wn = NULL;
  
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
--- 2447,2452 ----
***************
*** 2499,2505 ****
      }
  
      if (wn == NULL)
- #endif
      {
  	MENUITEMINFO	info;
  
--- 2470,2475 ----
***************
*** 2606,2625 ****
      int		nr = 0;
      int		curtabidx = 0;
      int		tabadded = 0;
- #ifdef FEAT_MBYTE
      static int	use_unicode = FALSE;
      int		uu;
      WCHAR	*wstr = NULL;
- #endif
  
      if (s_tabhwnd == NULL)
  	return;
  
! #ifdef FEAT_MBYTE
! # ifndef CCM_SETUNICODEFORMAT
      /* For older compilers.  We assume this never changes. */
! #  define CCM_SETUNICODEFORMAT 0x2005
! # endif
      uu = (enc_codepage >= 0 && (int)GetACP() != enc_codepage);
      if (uu != use_unicode)
      {
--- 2576,2592 ----
      int		nr = 0;
      int		curtabidx = 0;
      int		tabadded = 0;
      static int	use_unicode = FALSE;
      int		uu;
      WCHAR	*wstr = NULL;
  
      if (s_tabhwnd == NULL)
  	return;
  
! #ifndef CCM_SETUNICODEFORMAT
      /* For older compilers.  We assume this never changes. */
! # define CCM_SETUNICODEFORMAT 0x2005
! #endif
      uu = (enc_codepage >= 0 && (int)GetACP() != enc_codepage);
      if (uu != use_unicode)
      {
***************
*** 2627,2633 ****
  	SendMessage(s_tabhwnd, CCM_SETUNICODEFORMAT, (WPARAM)uu, (LPARAM)0);
  	use_unicode = uu;
      }
- #endif
  
      tie.mask = TCIF_TEXT;
      tie.iImage = -1;
--- 2594,2599 ----
***************
*** 2651,2657 ****
  
  	get_tabline_label(tp, FALSE);
  	tie.pszText = (LPSTR)NameBuff;
- #ifdef FEAT_MBYTE
  	wstr = NULL;
  	if (use_unicode)
  	{
--- 2617,2622 ----
***************
*** 2669,2675 ****
  	    }
  	}
  	if (wstr == NULL)
- #endif
  	{
  	    TabCtrl_SetItem(s_tabhwnd, nr, &tie);
  	}
--- 2634,2639 ----
***************
*** 2770,2776 ****
      static void
  set_window_title(HWND hwnd, char *title)
  {
- #ifdef FEAT_MBYTE
      if (title != NULL && enc_codepage >= 0 && enc_codepage != (int)GetACP())
      {
  	WCHAR	*wbuf;
--- 2734,2739 ----
***************
*** 2784,2790 ****
  	}
  	return;
      }
- #endif
      (void)SetWindowText(hwnd, (LPCSTR)title);
  }
  
--- 2747,2752 ----
***************
*** 2800,2806 ****
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
- # ifdef FEAT_MBYTE
  	    /* If the OS is Windows NT, and 'encoding' differs from active
  	     * codepage: convert text and use wide function. */
  	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
--- 2762,2767 ----
***************
*** 2810,2816 ****
  					(LPFINDREPLACEW) &s_findrep_struct_w);
  	    }
  	    else
- # endif
  		s_findrep_hwnd = FindText((LPFINDREPLACE) &s_findrep_struct);
  	}
  
--- 2771,2776 ----
***************
*** 2835,2841 ****
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
- # ifdef FEAT_MBYTE
  	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  		findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
--- 2795,2800 ----
***************
*** 2843,2849 ****
  					(LPFINDREPLACEW) &s_findrep_struct_w);
  	    }
  	    else
- # endif
  		s_findrep_hwnd = ReplaceText(
  					   (LPFINDREPLACE) &s_findrep_struct);
  	}
--- 2802,2807 ----
***************
*** 2931,2937 ****
  	out_flush();	    /* make sure all output has been processed */
  	(void)BeginPaint(hwnd, &ps);
  
- #ifdef FEAT_MBYTE
  	/* prevent multi-byte characters from misprinting on an invalid
  	 * rectangle */
  	if (has_mbyte)
--- 2889,2894 ----
***************
*** 2942,2948 ****
  	    ps.rcPaint.left = rect.left;
  	    ps.rcPaint.right = rect.right;
  	}
- #endif
  
  	if (!IsRectEmpty(&ps.rcPaint))
  	{
--- 2899,2904 ----
***************
*** 3255,3261 ****
      char	*font_name = lf.lfFaceName;
  
      charset_name = charset_id2name((int)lf.lfCharSet);
- #ifdef FEAT_MBYTE
      /* Convert a font name from the current codepage to 'encoding'.
       * TODO: Use Wide APIs (including LOGFONTW) instead of ANSI APIs. */
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
--- 3211,3216 ----
***************
*** 3264,3270 ****
  	acp_to_enc((char_u *)lf.lfFaceName, (int)strlen(lf.lfFaceName),
  						(char_u **)&font_name, &len);
      }
- #endif
      quality_name = quality_id2name((int)lf.lfQuality);
  
      res = (char *)alloc((unsigned)(strlen(font_name) + 20
--- 3219,3224 ----
***************
*** 3301,3310 ****
  	}
      }
  
- #ifdef FEAT_MBYTE
      if (font_name != lf.lfFaceName)
  	vim_free(font_name);
- #endif
      return (char_u *)res;
  }
  
--- 3255,3262 ----
***************
*** 3329,3335 ****
  }
  #endif
  
- #ifdef FEAT_MBYTE
  /*
   * Handler of gui.wide_font (p_guifontwide) changed notification.
   */
--- 3281,3286 ----
***************
*** 3338,3346 ****
  {
      LOGFONT lf;
  
! # ifdef FEAT_MBYTE_IME
      update_im_font();
! # endif
  
      gui_mch_free_font(gui.wide_ital_font);
      gui.wide_ital_font = NOFONT;
--- 3289,3297 ----
  {
      LOGFONT lf;
  
! #ifdef FEAT_MBYTE_IME
      update_im_font();
! #endif
  
      gui_mch_free_font(gui.wide_ital_font);
      gui.wide_ital_font = NOFONT;
***************
*** 3370,3376 ****
  	}
      }
  }
- #endif
  
  /*
   * Initialise vim to use the font with the given name.
--- 3321,3326 ----
***************
*** 3574,3586 ****
  
  #if defined(FEAT_BROWSE) || defined(PROTO)
  /*
-  * The file browser exists in two versions: with "W" uses wide characters,
-  * without "W" the current codepage.  When FEAT_MBYTE is defined and on
-  * Windows NT/2000/XP the "W" functions are used.
-  */
- 
- # ifdef FEAT_MBYTE
- /*
   * Wide version of convert_filter().
   */
      static WCHAR *
--- 3524,3529 ----
***************
*** 3600,3609 ****
  }
  
  /*
!  * Wide version of gui_mch_browse().  Keep in sync!
   */
      static char_u *
! gui_mch_browseW(
  	int saving,
  	char_u *title,
  	char_u *dflt,
--- 3543,3559 ----
  }
  
  /*
!  * Pop open a file browser and return the file selected, in allocated memory,
!  * or NULL if Cancel is hit.
!  *  saving  - TRUE if the file will be saved to, FALSE if it will be opened.
!  *  title   - Title message for the file browser dialog.
!  *  dflt    - Default name of file.
!  *  ext     - Default extension to be added to files without extensions.
!  *  initdir - directory in which to open the browser (NULL = current dir)
!  *  filter  - Filter for matched files to choose from.
   */
      static char_u *
! gui_mch_browse(
  	int saving,
  	char_u *title,
  	char_u *dflt,
***************
*** 3718,3724 ****
      vim_free(p);
      return q;
  }
- # endif /* FEAT_MBYTE */
  
  
  /*
--- 3668,3673 ----
***************
*** 3762,3867 ****
      return gui_mch_browse(0, title, (char_u *)_("Not Used"), NULL,
  			      initdir, (char_u *)_("Directory\t*.nothing\n"));
  }
- 
- /*
-  * Pop open a file browser and return the file selected, in allocated memory,
-  * or NULL if Cancel is hit.
-  *  saving  - TRUE if the file will be saved to, FALSE if it will be opened.
-  *  title   - Title message for the file browser dialog.
-  *  dflt    - Default name of file.
-  *  ext     - Default extension to be added to files without extensions.
-  *  initdir - directory in which to open the browser (NULL = current dir)
-  *  filter  - Filter for matched files to choose from.
-  *
-  * Keep in sync with gui_mch_browseW() above!
-  */
-     char_u *
- gui_mch_browse(
- 	int saving,
- 	char_u *title,
- 	char_u *dflt,
- 	char_u *ext,
- 	char_u *initdir,
- 	char_u *filter)
- {
- # ifdef FEAT_MBYTE
-     return gui_mch_browseW(saving, title, dflt, ext, initdir, filter);
- # else
-     OPENFILENAME	fileStruct;
-     char_u		fileBuf[MAXPATHL];
-     char_u		*initdirp = NULL;
-     char_u		*filterp;
-     char_u		*p;
- 
-     if (dflt == NULL)
- 	fileBuf[0] = NUL;
-     else
- 	vim_strncpy(fileBuf, dflt, MAXPATHL - 1);
- 
-     /* Convert the filter to Windows format. */
-     filterp = convert_filter(filter);
- 
-     vim_memset(&fileStruct, 0, sizeof(OPENFILENAME));
- #  ifdef OPENFILENAME_SIZE_VERSION_400
-     /* be compatible with Windows NT 4.0 */
-     fileStruct.lStructSize = OPENFILENAME_SIZE_VERSION_400;
- #  else
-     fileStruct.lStructSize = sizeof(fileStruct);
- #  endif
- 
-     fileStruct.lpstrTitle = (LPSTR)title;
-     fileStruct.lpstrDefExt = (LPSTR)ext;
- 
-     fileStruct.lpstrFile = (LPSTR)fileBuf;
-     fileStruct.nMaxFile = MAXPATHL;
-     fileStruct.lpstrFilter = (LPSTR)filterp;
-     fileStruct.hwndOwner = s_hwnd;		/* main Vim window is owner*/
-     /* has an initial dir been specified? */
-     if (initdir != NULL && *initdir != NUL)
-     {
- 	/* Must have backslashes here, no matter what 'shellslash' says */
- 	initdirp = vim_strsave(initdir);
- 	if (initdirp != NULL)
- 	    for (p = initdirp; *p != NUL; ++p)
- 		if (*p == '/')
- 		    *p = '\\';
- 	fileStruct.lpstrInitialDir = (LPSTR)initdirp;
-     }
- 
-     /*
-      * TODO: Allow selection of multiple files.  Needs another arg to this
-      * function to ask for it, and need to use OFN_ALLOWMULTISELECT below.
-      * Also, should we use OFN_FILEMUSTEXIST when opening?  Vim can edit on
-      * files that don't exist yet, so I haven't put it in.  What about
-      * OFN_PATHMUSTEXIST?
-      * Don't use OFN_OVERWRITEPROMPT, Vim has its own ":confirm" dialog.
-      */
-     fileStruct.Flags = (OFN_NOCHANGEDIR | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY);
- #  ifdef FEAT_SHORTCUT
-     if (curbuf->b_p_bin)
- 	fileStruct.Flags |= OFN_NODEREFERENCELINKS;
- #  endif
-     if (saving)
-     {
- 	if (!GetSaveFileName(&fileStruct))
- 	    return NULL;
-     }
-     else
-     {
- 	if (!GetOpenFileName(&fileStruct))
- 	    return NULL;
-     }
- 
-     vim_free(filterp);
-     vim_free(initdirp);
- 
-     /* Give focus back to main window (when using MDI). */
-     SetFocus(s_hwnd);
- 
-     /* Shorten the file name if possible */
-     return vim_strsave(shorten_fname1((char_u *)fileBuf));
- # endif
- }
  #endif /* FEAT_BROWSE */
  
      static void
--- 3711,3716 ----
***************
*** 3871,3879 ****
  {
  #define BUFPATHLEN _MAX_PATH
  #define DRAGQVAL 0xFFFFFFFF
- #ifdef FEAT_MBYTE
      WCHAR   wszFile[BUFPATHLEN];
- #endif
      char    szFile[BUFPATHLEN];
      UINT    cFiles = DragQueryFile(hDrop, DRAGQVAL, NULL, 0);
      UINT    i;
--- 3720,3726 ----
***************
*** 3894,3904 ****
      if (fnames != NULL)
  	for (i = 0; i < cFiles; ++i)
  	{
- #ifdef FEAT_MBYTE
  	    if (DragQueryFileW(hDrop, i, wszFile, BUFPATHLEN) > 0)
  		fnames[i] = utf16_to_enc(wszFile, NULL);
  	    else
- #endif
  	    {
  		DragQueryFile(hDrop, i, szFile, BUFPATHLEN);
  		fnames[i] = vim_strsave((char_u *)szFile);
--- 3741,3749 ----
***************
*** 4060,4072 ****
  
      *tofree = NULL;
  
- #ifdef FEAT_MBYTE
      /* Try using the Unicode version first, it takes care of conversion when
       * 'encoding' is changed. */
      argc = get_cmd_argsW(&argv);
      if (argc != 0)
  	goto done;
- #endif
  
      /* Handle the program name.  Remove the ".exe" extension, and find the 1st
       * non-space. */
--- 3905,3915 ----
***************
*** 4145,4151 ****
  		{
  		    if (pnew != NULL)
  			*pnew++ = *p;
- #ifdef FEAT_MBYTE
  		    /* Can't use mb_* functions, because 'encoding' is not
  		     * initialized yet here. */
  		    if (IsDBCSLeadByte(*p))
--- 3988,3993 ----
***************
*** 4154,4160 ****
  			if (pnew != NULL)
  			    *pnew++ = *p;
  		    }
- #endif
  		    ++p;
  		}
  	    }
--- 3996,4001 ----
***************
*** 4178,4186 ****
  	}
      }
  
- #ifdef FEAT_MBYTE
  done:
- #endif
      argv[argc] = NULL;		/* NULL-terminated list */
      *argvp = argv;
      return argc;
--- 4019,4025 ----
***************
*** 4381,4387 ****
      LPARAM     lParam;
  } NMTTDISPINFO_NEW;
  
- #ifdef FEAT_MBYTE
  typedef struct tagTOOLINFOW_NEW
  {
      UINT       cbSize;
--- 4220,4225 ----
***************
*** 4405,4411 ****
      LPARAM     lParam;
  } NMTTDISPINFOW_NEW;
  
- #endif
  
  typedef HRESULT (WINAPI* DLLGETVERSIONPROC)(DLLVERSIONINFO *);
  #ifndef TTM_SETMAXTIPWIDTH
--- 4243,4248 ----
***************
*** 4438,4444 ****
  } NMTTDISPINFOA, *LPNMTTDISPINFOA;
  #  define LPNMTTDISPINFO LPNMTTDISPINFOA
  
- #  ifdef FEAT_MBYTE
  typedef struct tagNMTTDISPINFOW {
      NMHDR	hdr;
      LPWSTR	lpszText;
--- 4275,4280 ----
***************
*** 4447,4453 ****
      UINT	uFlags;
      LPARAM	lParam;
  } NMTTDISPINFOW, *LPNMTTDISPINFOW;
- #  endif
  # endif
  #endif
  
--- 4283,4288 ----
***************
*** 4970,4978 ****
      case WM_NOTIFY:
  	switch (((LPNMHDR) lParam)->code)
  	{
- # ifdef FEAT_MBYTE
  	    case TTN_GETDISPINFOW:
- # endif
  	    case TTN_GETDISPINFO:
  		{
  		    LPNMHDR		hdr = (LPNMHDR)lParam;
--- 4805,4811 ----
***************
*** 5034,5040 ****
  # endif
  		    if (str != NULL)
  		    {
- # ifdef FEAT_MBYTE
  			if (hdr->code == TTN_GETDISPINFOW)
  			{
  			    LPNMTTDISPINFOW	lpdi = (LPNMTTDISPINFOW)lParam;
--- 4867,4872 ----
***************
*** 5049,5055 ****
  			    /* can't show tooltip if failed */
  			}
  			else
- # endif
  			{
  			    LPNMTTDISPINFO	lpdi = (LPNMTTDISPINFO)lParam;
  
--- 4881,4886 ----
***************
*** 5353,5363 ****
      const char szVimWndClass[] = VIM_CLASS;
      const char szTextAreaClass[] = "VimTextArea";
      WNDCLASS wndclass;
- #ifdef FEAT_MBYTE
      const WCHAR szVimWndClassW[] = VIM_CLASSW;
      const WCHAR szTextAreaClassW[] = L"VimTextArea";
      WNDCLASSW wndclassw;
- #endif
  #ifdef GLOBAL_IME
      ATOM	atom;
  #endif
--- 5184,5192 ----
***************
*** 5383,5389 ****
  
      s_brush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
  
- #ifdef FEAT_MBYTE
      /* First try using the wide version, so that we can use any title.
       * Otherwise only characters in the active codepage will work. */
      if (GetClassInfoW(s_hinst, szVimWndClassW, &wndclassw) == 0)
--- 5212,5217 ----
***************
*** 5410,5437 ****
      }
  
      if (!wide_WindowProc)
! #endif
! 
!     if (GetClassInfo(s_hinst, szVimWndClass, &wndclass) == 0)
!     {
! 	wndclass.style = CS_DBLCLKS;
! 	wndclass.lpfnWndProc = _WndProc;
! 	wndclass.cbClsExtra = 0;
! 	wndclass.cbWndExtra = 0;
! 	wndclass.hInstance = s_hinst;
! 	wndclass.hIcon = LoadIcon(wndclass.hInstance, "IDR_VIM");
! 	wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
! 	wndclass.hbrBackground = s_brush;
! 	wndclass.lpszMenuName = NULL;
! 	wndclass.lpszClassName = szVimWndClass;
  
! 	if ((
  #ifdef GLOBAL_IME
! 		    atom =
  #endif
! 		    RegisterClass(&wndclass)) == 0)
! 	    return FAIL;
!     }
  
      if (vim_parent_hwnd != NULL)
      {
--- 5238,5263 ----
      }
  
      if (!wide_WindowProc)
! 	if (GetClassInfo(s_hinst, szVimWndClass, &wndclass) == 0)
! 	{
! 	    wndclass.style = CS_DBLCLKS;
! 	    wndclass.lpfnWndProc = _WndProc;
! 	    wndclass.cbClsExtra = 0;
! 	    wndclass.cbWndExtra = 0;
! 	    wndclass.hInstance = s_hinst;
! 	    wndclass.hIcon = LoadIcon(wndclass.hInstance, "IDR_VIM");
! 	    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
! 	    wndclass.hbrBackground = s_brush;
! 	    wndclass.lpszMenuName = NULL;
! 	    wndclass.lpszClassName = szVimWndClass;
  
! 	    if ((
  #ifdef GLOBAL_IME
! 			atom =
  #endif
! 			RegisterClass(&wndclass)) == 0)
! 		return FAIL;
! 	}
  
      if (vim_parent_hwnd != NULL)
      {
***************
*** 5503,5509 ****
  #endif
  
      /* Create the text area window */
- #ifdef FEAT_MBYTE
      if (wide_WindowProc)
      {
  	if (GetClassInfoW(s_hinst, szTextAreaClassW, &wndclassw) == 0)
--- 5329,5334 ----
***************
*** 5532,5540 ****
  	    s_hwnd, NULL,
  	    s_hinst, NULL);
      }
!     else
! #endif
!     if (GetClassInfo(s_hinst, szTextAreaClass, &wndclass) == 0)
      {
  	wndclass.style = CS_OWNDC;
  	wndclass.lpfnWndProc = _TextAreaWndProc;
--- 5357,5363 ----
  	    s_hwnd, NULL,
  	    s_hinst, NULL);
      }
!     else if (GetClassInfo(s_hinst, szTextAreaClass, &wndclass) == 0)
      {
  	wndclass.style = CS_OWNDC;
  	wndclass.lpfnWndProc = _TextAreaWndProc;
***************
*** 5642,5648 ****
      s_findrep_struct.lpstrReplaceWith[0] = NUL;
      s_findrep_struct.wFindWhatLen = MSWIN_FR_BUFSIZE;
      s_findrep_struct.wReplaceWithLen = MSWIN_FR_BUFSIZE;
- # ifdef FEAT_MBYTE
      s_findrep_struct_w.lStructSize = sizeof(s_findrep_struct_w);
      s_findrep_struct_w.lpstrFindWhat =
  			      (LPWSTR)alloc(MSWIN_FR_BUFSIZE * sizeof(WCHAR));
--- 5465,5470 ----
***************
*** 5652,5658 ****
      s_findrep_struct_w.lpstrReplaceWith[0] = NUL;
      s_findrep_struct_w.wFindWhatLen = MSWIN_FR_BUFSIZE;
      s_findrep_struct_w.wReplaceWithLen = MSWIN_FR_BUFSIZE;
- # endif
  #endif
  
  #ifdef FEAT_EVAL
--- 5474,5479 ----
***************
*** 6149,6155 ****
  
  #endif /* FEAT_MBYTE_IME */
  
! #if defined(FEAT_MBYTE) && !defined(FEAT_MBYTE_IME) && defined(GLOBAL_IME)
  /* Win32 with GLOBAL IME */
  
  /*
--- 5970,5976 ----
  
  #endif /* FEAT_MBYTE_IME */
  
! #if !defined(FEAT_MBYTE_IME) && defined(GLOBAL_IME)
  /* Win32 with GLOBAL IME */
  
  /*
***************
*** 6186,6192 ****
  }
  #endif
  
- #ifdef FEAT_MBYTE
  /*
   * Convert latin9 text "text[len]" to ucs-2 in "unicodebuf".
   */
--- 6007,6012 ----
***************
*** 6212,6218 ****
  	*unicodebuf++ = c;
      }
  }
- #endif
  
  #ifdef FEAT_RIGHTLEFT
  /*
--- 6032,6037 ----
***************
*** 6319,6330 ****
      int		i;
      const RECT	*pcliprect = NULL;
      UINT	foptions = 0;
- #ifdef FEAT_MBYTE
      static WCHAR *unicodebuf = NULL;
      static int   *unicodepdy = NULL;
      static int	unibuflen = 0;
      int		n = 0;
- #endif
      int		y;
  
      /*
--- 6138,6147 ----
***************
*** 6354,6367 ****
  	 */
  	rc.left = FILL_X(col);
  	rc.top = FILL_Y(row);
- #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	{
  	    /* Compute the length in display cells. */
  	    rc.right = FILL_X(col + mb_string2cells(text, len));
  	}
  	else
- #endif
  	    rc.right = FILL_X(col + len);
  	rc.bottom = FILL_Y(row + 1);
  
--- 6171,6182 ----
***************
*** 6429,6435 ****
       * No check for DRAW_BOLD, Windows will have done it already.
       */
  
- #ifdef FEAT_MBYTE
      /* Check if there are any UTF-8 characters.  If not, use normal text
       * output to speed up output. */
      if (enc_utf8)
--- 6244,6249 ----
***************
*** 6437,6449 ****
  	    if (text[n] >= 0x80)
  		break;
  
! # if defined(FEAT_DIRECTX)
      /* Quick hack to enable DirectWrite.  To use DirectWrite (antialias), it is
       * required that unicode drawing routine, currently.  So this forces it
       * enabled. */
      if (IS_ENABLE_DIRECTX())
  	n = 0; /* Keep n < len, to enter block for unicode. */
! # endif
  
      /* Check if the Unicode buffer exists and is big enough.  Create it
       * with the same length as the multi-byte string, the number of wide
--- 6251,6263 ----
  	    if (text[n] >= 0x80)
  		break;
  
! #if defined(FEAT_DIRECTX)
      /* Quick hack to enable DirectWrite.  To use DirectWrite (antialias), it is
       * required that unicode drawing routine, currently.  So this forces it
       * enabled. */
      if (IS_ENABLE_DIRECTX())
  	n = 0; /* Keep n < len, to enter block for unicode. */
! #endif
  
      /* Check if the Unicode buffer exists and is big enough.  Create it
       * with the same length as the multi-byte string, the number of wide
***************
*** 6516,6522 ****
  	    i += utf_ptr2len_len(text + i, len - i);
  	    ++clen;
  	}
! # if defined(FEAT_DIRECTX)
  	if (IS_ENABLE_DIRECTX())
  	{
  	    /* Add one to "cells" for italics. */
--- 6330,6336 ----
  	    i += utf_ptr2len_len(text + i, len - i);
  	    ++clen;
  	}
! #if defined(FEAT_DIRECTX)
  	if (IS_ENABLE_DIRECTX())
  	{
  	    /* Add one to "cells" for italics. */
***************
*** 6526,6532 ****
  		    foptions, pcliprect, unicodepdy);
  	}
  	else
! # endif
  	    ExtTextOutW(s_hdc, TEXT_X(col), TEXT_Y(row),
  		    foptions, pcliprect, unicodebuf, wlen, unicodepdy);
  	len = cells;	/* used for underlining */
--- 6340,6346 ----
  		    foptions, pcliprect, unicodepdy);
  	}
  	else
! #endif
  	    ExtTextOutW(s_hdc, TEXT_X(col), TEXT_Y(row),
  		    foptions, pcliprect, unicodebuf, wlen, unicodepdy);
  	len = cells;	/* used for underlining */
***************
*** 6568,6574 ****
  	}
      }
      else
- #endif
      {
  #ifdef FEAT_RIGHTLEFT
  	/* Windows will mess up RL text, so we have to draw it character by
--- 6382,6387 ----
***************
*** 6690,6696 ****
  
      if (menu_is_menubar(menu->name))
      {
- #ifdef FEAT_MBYTE
  	WCHAR	*wn = NULL;
  
  	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
--- 6503,6508 ----
***************
*** 6719,6725 ****
  	}
  
  	if (wn == NULL)
- #endif
  	{
  	    MENUITEMINFO	info;
  
--- 6531,6536 ----
***************
*** 6847,6853 ****
      else
  #endif
      {
- #ifdef FEAT_MBYTE
  	WCHAR	*wn = NULL;
  
  	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
--- 6658,6663 ----
***************
*** 6865,6871 ****
  	    }
  	}
  	if (wn == NULL)
- #endif
  	    InsertMenu(parent->submenu_id, (UINT)idx,
  		(menu_is_separator(menu->name) ? MF_SEPARATOR : MF_STRING)
  							      | MF_BYPOSITION,
--- 6675,6680 ----
***************
*** 7059,7065 ****
  	/* If the edit box exists, copy the string. */
  	if (s_textfield != NULL)
  	{
- # ifdef FEAT_MBYTE
  	    /* If the OS is Windows NT, and 'encoding' differs from active
  	     * codepage: use wide function and convert text. */
  	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
--- 6868,6873 ----
***************
*** 7074,7080 ****
  	       vim_free(wp);
  	    }
  	    else
- # endif
  		GetDlgItemText(hwnd, DLG_NONBUTTON_CONTROL + 2,
  						(LPSTR)s_textfield, IOSIZE);
  	}
--- 6882,6887 ----
***************
*** 7306,7316 ****
  	last_white = NULL;
  	for (pend = pstart; *pend != NUL && *pend != '\n'; )
  	{
- #ifdef FEAT_MBYTE
  	    l = (*mb_ptr2len)(pend);
- #else
- 	    l = 1;
- #endif
  	    if (l == 1 && VIM_ISWHITE(*pend)
  					&& textWidth > maxDialogWidth * 3 / 4)
  		last_white = pend;
--- 7113,7119 ----
***************
*** 7693,7699 ****
      BOOL use_enc)
  {
      int		nChar = 0;
- #ifdef FEAT_MBYTE
      int		len = lstrlen(lpAnsiIn) + 1;	/* include NUL character */
      int		i;
      WCHAR	*wn;
--- 7496,7501 ----
***************
*** 7719,7734 ****
      for (i = 0; i < nChar; ++i)
  	if (lpWCStr[i] == (WORD)'\t')	/* replace tabs with spaces */
  	    lpWCStr[i] = (WORD)' ';
- #else
-     do
-     {
- 	if (*lpAnsiIn == '\t')
- 	    *lpWCStr++ = (WORD)' ';
- 	else
- 	    *lpWCStr++ = (WORD)*lpAnsiIn;
- 	nChar++;
-     } while (*lpAnsiIn++);
- #endif
  
      return nChar;
  }
--- 7521,7526 ----
***************
*** 8775,8781 ****
      return multiline_tip;
  }
  
- #ifdef FEAT_MBYTE
      static void
  make_tooltipw(BalloonEval *beval, char *text, POINT pt)
  {
--- 8567,8572 ----
***************
*** 8845,8851 ****
      mouse_event(MOUSEEVENTF_MOVE, (DWORD)-1, (DWORD)-1, 0, 0);
      vim_free(pti);
  }
- #endif
  
      static void
  make_tooltip(BalloonEval *beval, char *text, POINT pt)
--- 8636,8641 ----
***************
*** 8853,8865 ****
      TOOLINFO	*pti;
      int		ToolInfoSize;
  
- #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	make_tooltipw(beval, text, pt);
  	return;
      }
- #endif
  
      if (multiline_balloon_available() == TRUE)
  	ToolInfoSize = sizeof(TOOLINFO_NEW);
--- 8643,8653 ----
***************
*** 9072,9078 ****
  		info->uFlags |= TTF_DI_SETITEM;
  	    }
  	    break;
- #ifdef FEAT_MBYTE
  	case TTN_GETDISPINFOW:
  	    {
  		// if we get here then we have new common controls
--- 8860,8865 ----
***************
*** 9081,9087 ****
  		info->uFlags |= TTF_DI_SETITEM;
  	    }
  	    break;
- #endif
  	}
      }
  }
--- 8868,8873 ----
*** ../vim-8.1.0805/src/gui_x11.c	2019-01-17 17:13:25.920984090 +0100
--- src/gui_x11.c	2019-01-24 15:13:43.959427047 +0100
***************
*** 748,754 ****
      gui_focus_change(FALSE);
  }
  
! #if defined(X_HAVE_UTF8_STRING) && defined(FEAT_MBYTE)
  # if X_HAVE_UTF8_STRING
  #  define USE_UTF8LOOKUP
  # endif
--- 748,754 ----
      gui_focus_change(FALSE);
  }
  
! #if defined(X_HAVE_UTF8_STRING)
  # if X_HAVE_UTF8_STRING
  #  define USE_UTF8LOOKUP
  # endif
***************
*** 810,822 ****
  	if (status == XLookupNone || status == XLookupChars)
  	    key_sym = XK_VoidSymbol;
  
- # ifdef FEAT_MBYTE
  	/* Do conversion from 'termencoding' to 'encoding'.  When using
  	 * Xutf8LookupString() it has already been done. */
  	if (len > 0 && input_conv.vc_type != CONV_NONE
! #  ifdef USE_UTF8LOOKUP
  		&& !enc_utf8
! #  endif
  		)
  	{
  	    int		maxlen = len * 4 + 40;	/* guessed */
--- 810,821 ----
  	if (status == XLookupNone || status == XLookupChars)
  	    key_sym = XK_VoidSymbol;
  
  	/* Do conversion from 'termencoding' to 'encoding'.  When using
  	 * Xutf8LookupString() it has already been done. */
  	if (len > 0 && input_conv.vc_type != CONV_NONE
! # ifdef USE_UTF8LOOKUP
  		&& !enc_utf8
! # endif
  		)
  	{
  	    int		maxlen = len * 4 + 40;	/* guessed */
***************
*** 829,835 ****
  	    string_alloced = True;
  	    len = convert_input(p, len, maxlen);
  	}
- # endif
  
  	/* Translate CSI to K_CSI, otherwise it could be recognized as the
  	 * start of a special key. */
--- 828,833 ----
***************
*** 901,910 ****
  	    && (ev_press->state & Mod1Mask)
  	    && !(key_sym == XK_BackSpace || key_sym == XK_Delete)
  	    && (string[0] & 0x80) == 0
! #ifdef FEAT_MBYTE
! 	    && !enc_dbcs
! #endif
! 	    )
      {
  #if defined(FEAT_MENU) && defined(FEAT_GUI_MOTIF)
  	/* Ignore ALT keys when they are used for the menu only */
--- 899,905 ----
  	    && (ev_press->state & Mod1Mask)
  	    && !(key_sym == XK_BackSpace || key_sym == XK_Delete)
  	    && (string[0] & 0x80) == 0
! 	    && !enc_dbcs)
      {
  #if defined(FEAT_MENU) && defined(FEAT_GUI_MOTIF)
  	/* Ignore ALT keys when they are used for the menu only */
***************
*** 930,936 ****
  		&& !(key_sym == XK_Tab && (ev_press->state & ShiftMask)))
  	{
  	    string[0] |= 0x80;
- #ifdef FEAT_MBYTE
  	    if (enc_utf8) /* convert to utf-8 */
  	    {
  		string[1] = string[0] & 0xbf;
--- 925,930 ----
***************
*** 944,950 ****
  		else
  		    len = 2;
  	    }
- #endif
  	}
  	else
  	    ev_press->state |= Mod1Mask;
--- 938,943 ----
***************
*** 983,992 ****
      if (len == -3 || key_sym == XK_space || key_sym == XK_Tab
  	    || key_sym == XK_Return || key_sym == XK_Linefeed
  	    || key_sym == XK_Escape
! #ifdef FEAT_MBYTE
! 	    || (enc_dbcs && len == 1 && (ev_press->state & Mod1Mask))
! #endif
!        )
      {
  	modifiers = 0;
  	if (ev_press->state & ShiftMask)
--- 976,982 ----
      if (len == -3 || key_sym == XK_space || key_sym == XK_Tab
  	    || key_sym == XK_Return || key_sym == XK_Linefeed
  	    || key_sym == XK_Escape
! 	    || (enc_dbcs && len == 1 && (ev_press->state & Mod1Mask)))
      {
  	modifiers = 0;
  	if (ev_press->state & ShiftMask)
***************
*** 2375,2381 ****
      int		flags)
  {
      int			cells = len;
- #ifdef FEAT_MBYTE
      static void		*buf = NULL;
      static int		buflen = 0;
      char_u		*p;
--- 2365,2370 ----
***************
*** 2399,2415 ****
  	while (p < s + len)
  	{
  	    c = utf_ptr2char(p);
! # ifdef FEAT_XFONTSET
  	    if (current_fontset != NULL)
  	    {
! #  ifdef SMALL_WCHAR_T
  		if (c >= 0x10000)
  		    c = 0xbf;		/* show chars > 0xffff as ? */
! #  endif
  		((wchar_t *)buf)[wlen] = c;
  	    }
  	    else
! # endif
  	    {
  		if (c >= 0x10000)
  		    c = 0xbf;		/* show chars > 0xffff as ? */
--- 2388,2404 ----
  	while (p < s + len)
  	{
  	    c = utf_ptr2char(p);
! #ifdef FEAT_XFONTSET
  	    if (current_fontset != NULL)
  	    {
! # ifdef SMALL_WCHAR_T
  		if (c >= 0x10000)
  		    c = 0xbf;		/* show chars > 0xffff as ? */
! # endif
  		((wchar_t *)buf)[wlen] = c;
  	    }
  	    else
! #endif
  	    {
  		if (c >= 0x10000)
  		    c = 0xbf;		/* show chars > 0xffff as ? */
***************
*** 2431,2438 ****
  	}
      }
  
- #endif
- 
  #ifdef FEAT_XFONTSET
      if (current_fontset != NULL)
      {
--- 2420,2425 ----
***************
*** 2452,2463 ****
  
      if (flags & DRAW_TRANSP)
      {
- #ifdef FEAT_MBYTE
  	if (enc_utf8)
  	    XDrawString16(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),
  		    TEXT_Y(row), buf, wlen);
  	else
- #endif
  	    XDrawString(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),
  		    TEXT_Y(row), (char *)s, len);
      }
--- 2439,2448 ----
***************
*** 2472,2495 ****
  		FILL_Y(row), gui.char_width * cells, gui.char_height);
  	XSetForeground(gui.dpy, gui.text_gc, prev_fg_color);
  
- #ifdef FEAT_MBYTE
  	if (enc_utf8)
  	    XDrawString16(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),
  		    TEXT_Y(row), buf, wlen);
  	else
- #endif
  	    XDrawString(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),
  		    TEXT_Y(row), (char *)s, len);
      }
      else
      {
  	/* XmbDrawImageString has bug, don't use it for fontset. */
- #ifdef FEAT_MBYTE
  	if (enc_utf8)
  	    XDrawImageString16(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),
  		    TEXT_Y(row), buf, wlen);
  	else
- #endif
  	    XDrawImageString(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col),
  		    TEXT_Y(row), (char *)s, len);
      }
--- 2457,2476 ----
***************
*** 2497,2508 ****
      /* Bold trick: draw the text again with a one-pixel offset. */
      if (flags & DRAW_BOLD)
      {
- #ifdef FEAT_MBYTE
  	if (enc_utf8)
  	    XDrawString16(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col) + 1,
  		    TEXT_Y(row), buf, wlen);
  	else
- #endif
  	    XDrawString(gui.dpy, gui.wid, gui.text_gc, TEXT_X(col) + 1,
  		    TEXT_Y(row), (char *)s, len);
      }
--- 2478,2487 ----
***************
*** 2628,2637 ****
  {
      int		w = 1;
  
- #ifdef FEAT_MBYTE
      if (mb_lefthalve(gui.row, gui.col))
  	w = 2;
- #endif
      gui_mch_set_fg_color(color);
      XDrawRectangle(gui.dpy, gui.wid, gui.text_gc, FILL_X(gui.col),
  	    FILL_Y(gui.row), w * gui.char_width - 1, gui.char_height - 1);
--- 2607,2614 ----
*** ../vim-8.1.0805/src/hardcopy.c	2019-01-19 17:43:03.417449145 +0100
--- src/hardcopy.c	2019-01-24 15:16:45.286266663 +0100
***************
*** 102,108 ****
  static long_u	curr_fg;
  static int	page_count;
  
! #if defined(FEAT_MBYTE) && defined(FEAT_POSTSCRIPT)
  # define OPT_MBFONT_USECOURIER  0
  # define OPT_MBFONT_ASCII       1
  # define OPT_MBFONT_REGULAR     2
--- 102,108 ----
  static long_u	curr_fg;
  static int	page_count;
  
! #if defined(FEAT_POSTSCRIPT)
  # define OPT_MBFONT_USECOURIER  0
  # define OPT_MBFONT_ASCII       1
  # define OPT_MBFONT_REGULAR     2
***************
*** 149,155 ****
      return parse_list_options(p_popt, printer_opts, OPT_PRINT_NUM_OPTIONS);
  }
  
! #if (defined(FEAT_MBYTE) && defined(FEAT_POSTSCRIPT)) || defined(PROTO)
  /*
   * Parse 'printmbfont' and set the flags in "mbfont_opts".
   * Returns an error message or NULL;
--- 149,155 ----
      return parse_list_options(p_popt, printer_opts, OPT_PRINT_NUM_OPTIONS);
  }
  
! #if defined(FEAT_POSTSCRIPT) || defined(PROTO)
  /*
   * Parse 'printmbfont' and set the flags in "mbfont_opts".
   * Returns an error message or NULL;
***************
*** 456,464 ****
      int		page_line;
      char_u	*tbuf;
      char_u	*p;
- #ifdef FEAT_MBYTE
      int		l;
- #endif
  
      /* Also use the space for the line number. */
      if (prt_use_number())
--- 456,462 ----
***************
*** 513,536 ****
      mch_print_start_line(TRUE, page_line);
      for (p = tbuf; *p != NUL; )
      {
! 	if (mch_print_text_out(p,
! #ifdef FEAT_MBYTE
! 		(l = (*mb_ptr2len)(p))
! #else
! 		1
! #endif
! 		    ))
  	{
  	    ++page_line;
  	    if (page_line >= 0) /* out of room in header */
  		break;
  	    mch_print_start_line(TRUE, page_line);
  	}
- #ifdef FEAT_MBYTE
  	p += l;
- #else
- 	p++;
- #endif
      }
  
      vim_free(tbuf);
--- 511,524 ----
      mch_print_start_line(TRUE, page_line);
      for (p = tbuf; *p != NUL; )
      {
! 	if (mch_print_text_out(p, (l = (*mb_ptr2len)(p))))
  	{
  	    ++page_line;
  	    if (page_line >= 0) /* out of room in header */
  		break;
  	    mch_print_start_line(TRUE, page_line);
  	}
  	p += l;
      }
  
      vim_free(tbuf);
***************
*** 867,876 ****
      for (col = ppos->column; line[col] != NUL && !need_break; col += outputlen)
      {
  	outputlen = 1;
- #ifdef FEAT_MBYTE
  	if (has_mbyte && (outputlen = (*mb_ptr2len)(line + col)) < 1)
  	    outputlen = 1;
- #endif
  #ifdef FEAT_SYN_HL
  	/*
  	 * syntax highlighting stuff.
--- 855,862 ----
***************
*** 932,942 ****
  	else
  	{
  	    need_break = mch_print_text_out(line + col, outputlen);
- #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  		print_pos += (*mb_ptr2cells)(line + col);
  	    else
- #endif
  		print_pos++;
  	}
      }
--- 918,926 ----
***************
*** 1046,1052 ****
      {"Courier", "Courier-Bold", "Courier-Oblique", "Courier-BoldOblique"}
  };
  
- #ifdef FEAT_MBYTE
  /* Generic font metrics for multi-byte fonts */
  static struct prt_ps_font_S prt_ps_mb_font =
  {
--- 1030,1035 ----
***************
*** 1055,1061 ****
      -250, 805,
      {NULL, NULL, NULL, NULL}
  };
- #endif
  
  /* Pointer to current font set being used */
  static struct prt_ps_font_S* prt_ps_font;
--- 1038,1043 ----
***************
*** 1076,1082 ****
      int		has_charset;
  };
  
- #ifdef FEAT_MBYTE
  
  #define CS_JIS_C_1978   (0x01)
  #define CS_JIS_X_1983   (0x02)
--- 1058,1063 ----
***************
*** 1261,1267 ****
  	"KS_X_1992"
      }
  };
- #endif /* FEAT_MBYTE */
  
  struct prt_ps_resource_S
  {
--- 1242,1247 ----
***************
*** 1410,1416 ****
  static char_u prt_line_buffer[257];
  static garray_T prt_ps_buffer;
  
- # ifdef FEAT_MBYTE
  static int prt_do_conv;
  static vimconv_T prt_conv;
  
--- 1390,1395 ----
***************
*** 1422,1428 ****
  static int prt_half_width;
  static char *prt_ascii_encoding;
  static char_u prt_hexchar[] = "0123456789abcdef";
- # endif
  
      static void
  prt_write_file_raw_len(char_u *buffer, int bytes)
--- 1401,1406 ----
***************
*** 1494,1511 ****
      vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),
  			  "/_%s /VIM-%s /%s ref\n", new_name, encoding, font);
      prt_write_file(prt_line_buffer);
- #ifdef FEAT_MBYTE
      if (prt_out_mbyte)
  	sprintf((char *)prt_line_buffer, "/%s %d %f /_%s sffs\n",
  		       new_name, height, 500./prt_ps_courier_font.wx, new_name);
      else
- #endif
  	vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),
  			     "/%s %d /_%s ffs\n", new_name, height, new_name);
      prt_write_file(prt_line_buffer);
  }
  
- #ifdef FEAT_MBYTE
  /*
   * Write a line to define the CID font.
   */
--- 1472,1486 ----
***************
*** 1530,1536 ****
  				       "/%s %s d\n", new_name, original_name);
      prt_write_file(prt_line_buffer);
  }
- #endif
  
  /*
   * Convert a real value into an integer and fractional part as integers, with
--- 1505,1510 ----
***************
*** 1659,1676 ****
  	/* Draw the text
  	 * Note: we write text out raw - EBCDIC conversion is handled in the
  	 * PostScript world via the font encoding vector. */
- #ifdef FEAT_MBYTE
  	if (prt_out_mbyte)
  	    prt_write_string("<");
  	else
- #endif
  	    prt_write_string("(");
  	prt_write_file_raw_len(prt_ps_buffer.ga_data, prt_ps_buffer.ga_len);
- #ifdef FEAT_MBYTE
  	if (prt_out_mbyte)
  	    prt_write_string(">");
  	else
- #endif
  	    prt_write_string(")");
  	/* Add a moveto if need be and use the appropriate show procedure */
  	if (prt_do_moveto)
--- 1633,1646 ----
***************
*** 2150,2156 ****
      void
  mch_print_cleanup(void)
  {
- #ifdef FEAT_MBYTE
      if (prt_out_mbyte)
      {
  	int     i;
--- 2120,2125 ----
***************
*** 2171,2177 ****
  	convert_setup(&prt_conv, NULL, NULL);
  	prt_do_conv = FALSE;
      }
- #endif
      if (prt_ps_fd != NULL)
      {
  	fclose(prt_ps_fd);
--- 2140,2145 ----
***************
*** 2250,2262 ****
      if (prt_use_number())
      {
  	prt_number_width = PRINT_NUMBER_WIDTH * prt_char_width;
- #ifdef FEAT_MBYTE
  	/* If we are outputting multi-byte characters then line numbers will be
  	 * printed with half width characters
  	 */
  	if (prt_out_mbyte)
  	    prt_number_width /= 2;
- #endif
  	prt_left_margin += prt_number_width;
      }
      else
--- 2218,2228 ----
***************
*** 2265,2271 ****
      return (int)((prt_right_margin - prt_left_margin) / prt_char_width);
  }
  
- #ifdef FEAT_MBYTE
      static int
  prt_build_cid_fontname(int font, char_u *name, int name_len)
  {
--- 2231,2236 ----
***************
*** 2279,2285 ****
  
      return TRUE;
  }
- #endif
  
  /*
   * Get number of lines of text that fit on a page (excluding the header).
--- 2244,2249 ----
***************
*** 2315,2321 ****
      return lpp - prt_header_height();
  }
  
- #ifdef FEAT_MBYTE
      static int
  prt_match_encoding(
      char			*p_encoding,
--- 2279,2284 ----
***************
*** 2368,2374 ****
      }
      return FALSE;
  }
- #endif
  
      int
  mch_print_init(
--- 2331,2336 ----
***************
*** 2385,2398 ****
      double      right;
      double      top;
      double      bottom;
- #ifdef FEAT_MBYTE
      int		props;
      int		cmap = 0;
      char_u	*p_encoding;
      struct prt_ps_encoding_S *p_mbenc;
      struct prt_ps_encoding_S *p_mbenc_first;
      struct prt_ps_charset_S  *p_mbchar = NULL;
- #endif
  
  #if 0
      /*
--- 2347,2358 ----
***************
*** 2415,2421 ****
      /*
       * Set up font and encoding.
       */
- #ifdef FEAT_MBYTE
      p_encoding = enc_skip(p_penc);
      if (*p_encoding == NUL)
  	p_encoding = enc_skip(p_enc);
--- 2375,2380 ----
***************
*** 2542,2552 ****
  	prt_ps_font = &prt_ps_mb_font;
      }
      else
- #endif
      {
- #ifdef FEAT_MBYTE
  	prt_use_courier = FALSE;
- #endif
  	prt_ps_font = &prt_ps_courier_font;
      }
  
--- 2501,2508 ----
***************
*** 2699,2708 ****
      }
  
      prt_bufsiz = psettings->chars_per_line;
- #ifdef FEAT_MBYTE
      if (prt_out_mbyte)
  	prt_bufsiz *= 2;
- #endif
      ga_init2(&prt_ps_buffer, (int)sizeof(char), prt_bufsiz);
  
      prt_page_num = 0;
--- 2655,2662 ----
***************
*** 2781,2807 ****
      char	buffer[256];
      char_u      *p_encoding;
      char_u	*p;
- #ifdef FEAT_MBYTE
      struct prt_ps_resource_S *res_cidfont;
      struct prt_ps_resource_S *res_cmap;
- #endif
      int		retval = FALSE;
  
      res_prolog = (struct prt_ps_resource_S *)
  				      alloc(sizeof(struct prt_ps_resource_S));
      res_encoding = (struct prt_ps_resource_S *)
  				      alloc(sizeof(struct prt_ps_resource_S));
- #ifdef FEAT_MBYTE
      res_cidfont = (struct prt_ps_resource_S *)
  				      alloc(sizeof(struct prt_ps_resource_S));
      res_cmap = (struct prt_ps_resource_S *)
  				      alloc(sizeof(struct prt_ps_resource_S));
- #endif
      if (res_prolog == NULL || res_encoding == NULL
! #ifdef FEAT_MBYTE
! 	    || res_cidfont == NULL || res_cmap == NULL
! #endif
!        )
  	goto theend;
  
      /*
--- 2735,2754 ----
      char	buffer[256];
      char_u      *p_encoding;
      char_u	*p;
      struct prt_ps_resource_S *res_cidfont;
      struct prt_ps_resource_S *res_cmap;
      int		retval = FALSE;
  
      res_prolog = (struct prt_ps_resource_S *)
  				      alloc(sizeof(struct prt_ps_resource_S));
      res_encoding = (struct prt_ps_resource_S *)
  				      alloc(sizeof(struct prt_ps_resource_S));
      res_cidfont = (struct prt_ps_resource_S *)
  				      alloc(sizeof(struct prt_ps_resource_S));
      res_cmap = (struct prt_ps_resource_S *)
  				      alloc(sizeof(struct prt_ps_resource_S));
      if (res_prolog == NULL || res_encoding == NULL
! 	    || res_cidfont == NULL || res_cmap == NULL)
  	goto theend;
  
      /*
***************
*** 2863,2873 ****
  				prt_mediasize[prt_media].height,
  				(double)0, NULL, NULL);
      /* Define fonts needed */
- #ifdef FEAT_MBYTE
      if (!prt_out_mbyte || prt_use_courier)
- #endif
  	prt_dsc_font_resource("DocumentNeededResources", &prt_ps_courier_font);
- #ifdef FEAT_MBYTE
      if (prt_out_mbyte)
      {
  	prt_dsc_font_resource((prt_use_courier ? NULL
--- 2810,2817 ----
***************
*** 2875,2881 ****
  	if (!prt_custom_cmap)
  	    prt_dsc_resources(NULL, "cmap", prt_cmap);
      }
- #endif
  
      /* Search for external resources VIM supplies */
      if (!prt_find_resource("prolog", res_prolog))
--- 2819,2824 ----
***************
*** 2887,2893 ****
  	goto theend;
      if (!prt_check_resource(res_prolog, PRT_PROLOG_VERSION))
  	goto theend;
- #ifdef FEAT_MBYTE
      if (prt_out_mbyte)
      {
  	/* Look for required version of multi-byte printing procset */
--- 2830,2835 ----
***************
*** 2901,2923 ****
  	if (!prt_check_resource(res_cidfont, PRT_CID_PROLOG_VERSION))
  	    goto theend;
      }
- #endif
  
      /* Find an encoding to use for printing.
       * Check 'printencoding'. If not set or not found, then use 'encoding'. If
       * that cannot be found then default to "latin1".
       * Note: VIM specific encoding header is always skipped.
       */
- #ifdef FEAT_MBYTE
      if (!prt_out_mbyte)
      {
- #endif
  	p_encoding = enc_skip(p_penc);
  	if (*p_encoding == NUL
  		|| !prt_find_resource((char *)p_encoding, res_encoding))
  	{
  	    /* 'printencoding' not set or not supported - find alternate */
- #ifdef FEAT_MBYTE
  	    int		props;
  
  	    p_encoding = enc_skip(p_enc);
--- 2843,2861 ----
***************
*** 2925,2931 ****
  	    if (!(props & ENC_8BIT)
  		    || !prt_find_resource((char *)p_encoding, res_encoding))
  		/* 8-bit 'encoding' is not supported */
- #endif
  		{
  		/* Use latin1 as default printing encoding */
  		p_encoding = (char_u *)"latin1";
--- 2863,2868 ----
***************
*** 2941,2947 ****
  	    goto theend;
  	/* For the moment there are no checks on encoding resource files to
  	 * perform */
- #ifdef FEAT_MBYTE
      }
      else
      {
--- 2878,2883 ----
***************
*** 2989,3002 ****
  	if (!prt_open_resource(res_cmap))
  	    goto theend;
      }
- #endif
  
      /* List resources supplied */
      STRCPY(buffer, res_prolog->title);
      STRCAT(buffer, " ");
      STRCAT(buffer, res_prolog->version);
      prt_dsc_resources("DocumentSuppliedResources", "procset", buffer);
- #ifdef FEAT_MBYTE
      if (prt_out_mbyte)
      {
  	STRCPY(buffer, res_cidfont->title);
--- 2925,2936 ----
***************
*** 3013,3019 ****
  	}
      }
      if (!prt_out_mbyte || prt_use_courier)
- #endif
      {
  	STRCPY(buffer, res_encoding->title);
  	STRCAT(buffer, " ");
--- 2947,2952 ----
***************
*** 3035,3045 ****
      prt_dsc_noarg("BeginDefaults");
  
      /* List font resources most likely common to all pages */
- #ifdef FEAT_MBYTE
      if (!prt_out_mbyte || prt_use_courier)
- #endif
  	prt_dsc_font_resource("PageResources", &prt_ps_courier_font);
- #ifdef FEAT_MBYTE
      if (prt_out_mbyte)
      {
  	prt_dsc_font_resource((prt_use_courier ? NULL : "PageResources"),
--- 2968,2975 ----
***************
*** 3047,3053 ****
  	if (!prt_custom_cmap)
  	    prt_dsc_resources(NULL, "cmap", prt_cmap);
      }
- #endif
  
      /* Paper will be used for all pages */
      prt_dsc_textline("PageMedia", prt_mediasize[prt_media].name);
--- 2977,2982 ----
***************
*** 3062,3068 ****
      /* Add required procsets - NOTE: order is important! */
      if (!prt_add_resource(res_prolog))
  	goto theend;
- #ifdef FEAT_MBYTE
      if (prt_out_mbyte)
      {
  	/* Add CID font procset, and any user supplied CMap */
--- 2991,2996 ----
***************
*** 3071,3081 ****
  	if (prt_custom_cmap && !prt_add_resource(res_cmap))
  	    goto theend;
      }
- #endif
  
- #ifdef FEAT_MBYTE
      if (!prt_out_mbyte || prt_use_courier)
- #endif
  	/* There will be only one Roman font encoding to be included in the PS
  	 * file. */
  	if (!prt_add_resource(res_encoding))
--- 2999,3006 ----
***************
*** 3102,3115 ****
      prt_write_string("c\n");
  
      /* Font resource inclusion and definition */
- #ifdef FEAT_MBYTE
      if (!prt_out_mbyte || prt_use_courier)
      {
  	/* When using Courier for ASCII range when printing multi-byte, need to
  	 * pick up ASCII encoding to use with it. */
  	if (prt_use_courier)
  	    p_encoding = (char_u *)prt_ascii_encoding;
- #endif
  	prt_dsc_resources("IncludeResource", "font",
  			  prt_ps_courier_font.ps_fontname[PRT_PS_FONT_ROMAN]);
  	prt_def_font("F0", (char *)p_encoding, (int)prt_line_height,
--- 3027,3038 ----
***************
*** 3126,3132 ****
  			  prt_ps_courier_font.ps_fontname[PRT_PS_FONT_BOLDOBLIQUE]);
  	prt_def_font("F3", (char *)p_encoding, (int)prt_line_height,
  		     prt_ps_courier_font.ps_fontname[PRT_PS_FONT_BOLDOBLIQUE]);
- #ifdef FEAT_MBYTE
      }
      if (prt_out_mbyte)
      {
--- 3049,3054 ----
***************
*** 3182,3188 ****
  	    /* Use BOLD for BOLDOBLIQUE */
  	    prt_dup_cidfont("CF1", "CF3");
      }
- #endif
  
      /* Misc constant vars used for underlining and background rects */
      prt_def_var("UO", PRT_PS_FONT_TO_USER(prt_line_height,
--- 3104,3109 ----
***************
*** 3199,3208 ****
  theend:
      vim_free(res_prolog);
      vim_free(res_encoding);
- #ifdef FEAT_MBYTE
      vim_free(res_cidfont);
      vim_free(res_cmap);
- #endif
  
      return retval;
  }
--- 3120,3127 ----
***************
*** 3269,3280 ****
      prt_dsc_noarg("BeginPageSetup");
  
      prt_write_string("sv\n0 g\n");
- #ifdef FEAT_MBYTE
      prt_in_ascii = !prt_out_mbyte;
      if (prt_out_mbyte)
  	prt_write_string("CF0 sf\n");
      else
- #endif
  	prt_write_string("F0 sf\n");
      prt_fgcol = PRCOLOR_BLACK;
      prt_bgcol = PRCOLOR_WHITE;
--- 3188,3197 ----
***************
*** 3318,3326 ****
  
      prt_attribute_change = TRUE;
      prt_need_moveto = TRUE;
- #ifdef FEAT_MBYTE
      prt_half_width = FALSE;
- #endif
  }
  
      int
--- 3235,3241 ----
***************
*** 3332,3346 ****
      char_u      ch_buff[8];
      float       char_width;
      float       next_pos;
- #ifdef FEAT_MBYTE
      int		in_ascii;
      int		half_width;
      char_u	*tofree = NULL;
- #endif
  
      char_width = prt_char_width;
  
- #ifdef FEAT_MBYTE
      /* Ideally VIM would create a rearranged CID font to combine a Roman and
       * CJKV font to do what VIM is doing here - use a Roman font for characters
       * in the ASCII range, and the original CID font for everything else.
--- 3247,3258 ----
***************
*** 3392,3398 ****
  	    prt_attribute_change = TRUE;
  	}
      }
- #endif
  
      /* Output any required changes to the graphics state, after flushing any
       * text buffered so far.
--- 3304,3309 ----
***************
*** 3413,3423 ****
  	}
  	if (prt_need_font)
  	{
- #ifdef FEAT_MBYTE
  	    if (!prt_in_ascii)
  		prt_write_string("CF");
  	    else
- #endif
  		prt_write_string("F");
  	    prt_write_int(prt_font);
  	    prt_write_string("sf\n");
--- 3324,3332 ----
***************
*** 3459,3465 ****
  	prt_attribute_change = FALSE;
      }
  
- #ifdef FEAT_MBYTE
      if (prt_do_conv)
      {
  	/* Convert from multi-byte to 8-bit encoding */
--- 3368,3373 ----
***************
*** 3486,3492 ****
  	}
      }
      else
- #endif
      {
  	/* Add next character to buffer of characters to output.
  	 * Note: One printed character may require several PS characters to
--- 3394,3399 ----
***************
*** 3528,3537 ****
  	    ga_append(&prt_ps_buffer, ch);
      }
  
- #ifdef FEAT_MBYTE
      /* Need to free any translated characters */
      vim_free(tofree);
- #endif
  
      prt_text_run += char_width;
      prt_pos_x += char_width;
--- 3435,3442 ----
*** ../vim-8.1.0805/src/if_xcmdsrv.c	2019-01-19 18:23:38.017218438 +0100
--- src/if_xcmdsrv.c	2019-01-24 15:17:19.318047080 +0100
***************
*** 440,459 ****
       * comm window in the communication window.
       * Length must be computed exactly!
       */
- #ifdef FEAT_MBYTE
      length = STRLEN(name) + STRLEN(p_enc) + STRLEN(cmd) + 14;
- #else
-     length = STRLEN(name) + STRLEN(cmd) + 10;
- #endif
      property = (char_u *)alloc((unsigned)length + 30);
  
- #ifdef FEAT_MBYTE
      sprintf((char *)property, "%c%c%c-n %s%c-E %s%c-s %s",
  		      0, asExpr ? 'c' : 'k', 0, name, 0, p_enc, 0, cmd);
- #else
-     sprintf((char *)property, "%c%c%c-n %s%c-s %s",
- 		      0, asExpr ? 'c' : 'k', 0, name, 0, cmd);
- #endif
      if (name == loosename)
  	vim_free(loosename);
      /* Add a back reference to our comm window */
--- 440,450 ----
***************
*** 758,777 ****
      if (!WindowValid(dpy, win))
  	return -1;
  
- #ifdef FEAT_MBYTE
      length = STRLEN(p_enc) + STRLEN(str) + 14;
- #else
-     length = STRLEN(str) + 10;
- #endif
      if ((property = (char_u *)alloc((unsigned)length + 30)) != NULL)
      {
- #ifdef FEAT_MBYTE
  	sprintf((char *)property, "%cn%c-E %s%c-n %s%c-w %x",
  			    0, 0, p_enc, 0, str, 0, (unsigned int)commWindow);
- #else
- 	sprintf((char *)property, "%cn%c-n %s%c-w %x",
- 			    0, 0, str, 0, (unsigned int)commWindow);
- #endif
  	/* Add length of what "%x" resulted in. */
  	length += STRLEN(property + length);
  	res = AppendPropCarefully(dpy, win, commProperty, property, length + 1);
--- 749,759 ----
***************
*** 1334,1350 ****
  
  			/* Initialize the result property. */
  			ga_init2(&reply, 1, 100);
- #ifdef FEAT_MBYTE
  			(void)ga_grow(&reply, 50 + STRLEN(p_enc));
  			sprintf(reply.ga_data, "%cr%c-E %s%c-s %s%c-r ",
  						   0, 0, p_enc, 0, serial, 0);
  			reply.ga_len = 14 + STRLEN(p_enc) + STRLEN(serial);
- #else
- 			(void)ga_grow(&reply, 50);
- 			sprintf(reply.ga_data, "%cr%c-s %s%c-r ",
- 							     0, 0, serial, 0);
- 			reply.ga_len = 10 + STRLEN(serial);
- #endif
  
  			/* Evaluate the expression and return the result. */
  			if (res != NULL)
--- 1316,1325 ----
*** ../vim-8.1.0805/src/json.c	2019-01-20 15:30:36.885328746 +0100
--- src/json.c	2019-01-24 15:18:12.385703726 +0100
***************
*** 96,102 ****
  	ga_concat(gap, (char_u *)"\"\"");
      else
      {
! #if defined(FEAT_MBYTE) && defined(USE_ICONV)
  	vimconv_T   conv;
  	char_u	    *converted = NULL;
  
--- 96,102 ----
  	ga_concat(gap, (char_u *)"\"\"");
      else
      {
! #if defined(USE_ICONV)
  	vimconv_T   conv;
  	char_u	    *converted = NULL;
  
***************
*** 115,126 ****
  	while (*res != NUL)
  	{
  	    int c;
- #ifdef FEAT_MBYTE
  	    /* always use utf-8 encoding, ignore 'encoding' */
  	    c = utf_ptr2char(res);
- #else
- 	    c = *res;
- #endif
  
  	    switch (c)
  	    {
--- 115,122 ----
***************
*** 142,153 ****
  		default:
  		    if (c >= 0x20)
  		    {
- #ifdef FEAT_MBYTE
  			numbuf[utf_char2bytes(c, numbuf)] = NUL;
- #else
- 			numbuf[0] = c;
- 			numbuf[1] = NUL;
- #endif
  			ga_concat(gap, numbuf);
  		    }
  		    else
--- 138,144 ----
***************
*** 157,170 ****
  			ga_concat(gap, numbuf);
  		    }
  	    }
- #ifdef FEAT_MBYTE
  	    res += utf_ptr2len(res);
- #else
- 	    ++res;
- #endif
  	}
  	ga_append(gap, '"');
! #if defined(FEAT_MBYTE) && defined(USE_ICONV)
  	vim_free(converted);
  #endif
      }
--- 148,157 ----
  			ga_concat(gap, numbuf);
  		    }
  	    }
  	    res += utf_ptr2len(res);
  	}
  	ga_append(gap, '"');
! #if defined(USE_ICONV)
  	vim_free(converted);
  #endif
      }
***************
*** 421,431 ****
      {
  	/* The JSON is always expected to be utf-8, thus use utf functions
  	 * here. The string is converted below if needed. */
! 	if (*p == NUL || p[1] == NUL
! #ifdef FEAT_MBYTE
! 		|| utf_ptr2len(p) < utf_byte2len(*p)
! #endif
! 		)
  	{
  	    /* Not enough bytes to make a character or end of the string. Get
  	     * more if possible. */
--- 408,414 ----
      {
  	/* The JSON is always expected to be utf-8, thus use utf functions
  	 * here. The string is converted below if needed. */
! 	if (*p == NUL || p[1] == NUL || utf_ptr2len(p) < utf_byte2len(*p))
  	{
  	    /* Not enough bytes to make a character or end of the string. Get
  	     * more if possible. */
***************
*** 488,500 ****
  		    }
  		    if (res != NULL)
  		    {
- #ifdef FEAT_MBYTE
  			char_u	buf[NUMBUFLEN];
  			buf[utf_char2bytes((int)nr, buf)] = NUL;
  			ga_concat(&ga, buf);
- #else
- 			ga_append(&ga, (int)nr);
- #endif
  		    }
  		    break;
  		default:
--- 471,479 ----
***************
*** 511,521 ****
  	}
  	else
  	{
- #ifdef FEAT_MBYTE
  	    len = utf_ptr2len(p);
- #else
- 	    len = 1;
- #endif
  	    if (res != NULL)
  	    {
  		if (ga_grow(&ga, len) == FAIL)
--- 490,496 ----
***************
*** 538,544 ****
  	{
  	    ga_append(&ga, NUL);
  	    res->v_type = VAR_STRING;
! #if defined(FEAT_MBYTE) && defined(USE_ICONV)
  	    if (!enc_utf8)
  	    {
  		vimconv_T   conv;
--- 513,519 ----
  	{
  	    ga_append(&ga, NUL);
  	    res->v_type = VAR_STRING;
! #if defined(USE_ICONV)
  	    if (!enc_utf8)
  	    {
  		vimconv_T   conv;
*** ../vim-8.1.0805/src/kword_test.c	2017-01-28 16:33:18.000000000 +0100
--- src/kword_test.c	2019-01-24 15:18:32.497573317 +0100
***************
*** 21,27 ****
  /* This file has to be included because the tested functions are static */
  #include "charset.c"
  
- #ifdef FEAT_MBYTE
  /*
   * Test the results of vim_iswordc() and vim_iswordp() are matched.
   */
--- 21,26 ----
***************
*** 73,85 ****
  	}
      }
  }
- #endif
  
      int
  main(void)
  {
- #ifdef FEAT_MBYTE
      test_isword_funcs_utf8();
- #endif
      return 0;
  }
--- 72,81 ----
*** ../vim-8.1.0805/src/main.c	2019-01-19 21:06:55.344138786 +0100
--- src/main.c	2019-01-24 15:19:25.293230303 +0100
***************
*** 119,125 ****
       */
      mch_early_init();
  
! #if defined(WIN32) && defined(FEAT_MBYTE)
      /*
       * MinGW expands command line arguments, which confuses our code to
       * convert when 'encoding' changes.  Get the unexpanded arguments.
--- 119,125 ----
       */
      mch_early_init();
  
! #if defined(WIN32)
      /*
       * MinGW expands command line arguments, which confuses our code to
       * convert when 'encoding' changes.  Get the unexpanded arguments.
***************
*** 250,256 ****
  	params.fname = alist_name(&GARGLIST[0]);
      }
  
! #if defined(WIN32) && defined(FEAT_MBYTE)
      {
  	extern void set_alist_count(void);
  
--- 250,256 ----
  	params.fname = alist_name(&GARGLIST[0]);
      }
  
! #if defined(WIN32)
      {
  	extern void set_alist_count(void);
  
***************
*** 592,600 ****
      {
  	char_u	*enc = NULL;
  
- # ifdef FEAT_MBYTE
  	enc = p_menc;
- # endif
  	if (params.use_ef != NULL)
  	    set_string_option_direct((char_u *)"ef", -1,
  					   params.use_ef, OPT_FREE, SID_CARG);
--- 592,598 ----
***************
*** 813,819 ****
      /* Must come before the may_req_ calls. */
      starting = 0;
  
! #if defined(FEAT_TERMRESPONSE) && defined(FEAT_MBYTE)
      /* Must be done before redrawing, puts a few characters on the screen. */
      may_req_ambiguous_char_width();
  #endif
--- 811,817 ----
      /* Must come before the may_req_ calls. */
      starting = 0;
  
! #if defined(FEAT_TERMRESPONSE)
      /* Must be done before redrawing, puts a few characters on the screen. */
      may_req_ambiguous_char_width();
  #endif
***************
*** 926,934 ****
  {
      cmdline_init();
  
- #ifdef FEAT_MBYTE
      (void)mb_init();	/* init mb_bytelen_tab[] to ones */
- #endif
  #ifdef FEAT_EVAL
      eval_init();	/* init global variables */
  #endif
--- 924,930 ----
***************
*** 1549,1555 ****
      if (garbage_collect_at_exit)
  	garbage_collect(FALSE);
  #endif
! #if defined(WIN32) && defined(FEAT_MBYTE)
      free_cmd_argsW();
  #endif
  
--- 1545,1551 ----
      if (garbage_collect_at_exit)
  	garbage_collect(FALSE);
  #endif
! #if defined(WIN32)
      free_cmd_argsW();
  #endif
  
***************
*** 2501,2507 ****
  #endif
  		    );
  
! #if defined(FEAT_MBYTE) && defined(WIN32)
  	    {
  		/* Remember this argument has been added to the argument list.
  		 * Needed when 'encoding' is changed. */
--- 2497,2503 ----
  #endif
  		    );
  
! #if defined(WIN32)
  	    {
  		/* Remember this argument has been added to the argument list.
  		 * Needed when 'encoding' is changed. */
***************
*** 2584,2590 ****
  #if defined(WIN3264) && !defined(FEAT_GUI_W32)
  	if (is_cygpty_used())
  	{
! # if defined(FEAT_MBYTE) && defined(HAVE_BIND_TEXTDOMAIN_CODESET) \
  	&& defined(FEAT_GETTEXT)
  	    char    *s, *tofree = NULL;
  
--- 2580,2586 ----
  #if defined(WIN3264) && !defined(FEAT_GUI_W32)
  	if (is_cygpty_used())
  	{
! # if defined(HAVE_BIND_TEXTDOMAIN_CODESET) \
  	&& defined(FEAT_GETTEXT)
  	    char    *s, *tofree = NULL;
  
***************
*** 3660,3668 ****
  	{
  	    cmdsrv_main(&parmp->argc, parmp->argv,
  				    parmp->serverName_arg, &parmp->serverStr);
- # ifdef FEAT_MBYTE
  	    parmp->serverStrEnc = vim_strsave(p_enc);
- # endif
  	}
  
  	/* If we're still running, get the name to register ourselves.
--- 3656,3662 ----
***************
*** 4281,4287 ****
      char_u	*res = data;
  
      *tofree = NULL;
- # ifdef FEAT_MBYTE
      if (client_enc != NULL && p_enc != NULL)
      {
  	vimconv_T	vimconv;
--- 4275,4280 ----
***************
*** 4298,4304 ****
  	}
  	convert_setup(&vimconv, NULL, NULL);
      }
- # endif
      return res;
  }
  #endif
--- 4291,4296 ----
*** ../vim-8.1.0805/src/mbyte.c	2019-01-20 15:30:36.885328746 +0100
--- src/mbyte.c	2019-01-24 15:21:25.168448247 +0100
***************
*** 136,143 ****
  # endif
  #endif
  
- #if defined(FEAT_MBYTE) || defined(PROTO)
- 
  static int dbcs_char2len(int c);
  static int dbcs_char2bytes(int c, char_u *buf);
  static int dbcs_ptr2len(char_u *p);
--- 136,141 ----
***************
*** 211,219 ****
  }
  #endif
  
- #endif
  
- #if defined(FEAT_MBYTE) || defined(FEAT_POSTSCRIPT) || defined(PROTO)
  /*
   * Canonical encoding names and their properties.
   * "iso-8859-n" is handled by enc_canonize() directly.
--- 209,215 ----
***************
*** 456,464 ****
      return -1;
  }
  
- #endif
- 
- #if defined(FEAT_MBYTE) || defined(PROTO)
  
  /*
   * Find canonical encoding "name" in the list and return its properties.
--- 452,457 ----
***************
*** 4294,4302 ****
  	return col - 1;
      return col;
  }
- #endif
  
- #if defined(FEAT_MBYTE) || defined(FEAT_POSTSCRIPT) || defined(PROTO)
  static int enc_alias_search(char_u *name);
  
  /*
--- 4287,4293 ----
***************
*** 4325,4331 ****
      char_u	*p, *s;
      int		i;
  
- # ifdef FEAT_MBYTE
      if (STRCMP(enc, "default") == 0)
      {
  	/* Use the default encoding as it's found by set_init_1(). */
--- 4316,4321 ----
***************
*** 4334,4340 ****
  	    r = (char_u *)"latin1";
  	return vim_strsave(r);
      }
- # endif
  
      /* copy "enc" to allocated memory, with room for two '-' */
      r = alloc((unsigned)(STRLEN(enc) + 3));
--- 4324,4329 ----
***************
*** 4406,4420 ****
  	    return enc_alias_table[i].canon;
      return -1;
  }
- #endif
  
- #if defined(FEAT_MBYTE) || defined(PROTO)
  
! # ifdef HAVE_LANGINFO_H
! #  include <langinfo.h>
! # endif
  
! # ifndef FEAT_GUI_W32
  /*
   * Get the canonicalized encoding from the specified locale string "locale"
   * or from the environment variables LC_ALL, LC_CTYPE and LANG.
--- 4395,4407 ----
  	    return enc_alias_table[i].canon;
      return -1;
  }
  
  
! #ifdef HAVE_LANGINFO_H
! # include <langinfo.h>
! #endif
  
! #ifndef FEAT_GUI_W32
  /*
   * Get the canonicalized encoding from the specified locale string "locale"
   * or from the environment variables LC_ALL, LC_CTYPE and LANG.
***************
*** 4472,4478 ****
  
      return enc_canonize((char_u *)buf);
  }
! # endif
  
  /*
   * Get the canonicalized encoding of the current locale.
--- 4459,4465 ----
  
      return enc_canonize((char_u *)buf);
  }
! #endif
  
  /*
   * Get the canonicalized encoding of the current locale.
***************
*** 4481,4487 ****
      char_u *
  enc_locale(void)
  {
! # ifdef WIN3264
      char	buf[50];
      long	acp = GetACP();
  
--- 4468,4474 ----
      char_u *
  enc_locale(void)
  {
! #ifdef WIN3264
      char	buf[50];
      long	acp = GetACP();
  
***************
*** 4493,4511 ****
  	sprintf(buf, "cp%ld", acp);
  
      return enc_canonize((char_u *)buf);
! # else
      char	*s;
  
! #  ifdef HAVE_NL_LANGINFO_CODESET
      if ((s = nl_langinfo(CODESET)) == NULL || *s == NUL)
! #  endif
! #  if defined(HAVE_LOCALE_H) || defined(X_LOCALE)
  	if ((s = setlocale(LC_CTYPE, NULL)) == NULL || *s == NUL)
! #  endif
  	    s = NULL;
  
      return enc_locale_env(s);
! # endif
  }
  
  # if defined(WIN3264) || defined(PROTO) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)
--- 4480,4498 ----
  	sprintf(buf, "cp%ld", acp);
  
      return enc_canonize((char_u *)buf);
! #else
      char	*s;
  
! # ifdef HAVE_NL_LANGINFO_CODESET
      if ((s = nl_langinfo(CODESET)) == NULL || *s == NUL)
! # endif
! # if defined(HAVE_LOCALE_H) || defined(X_LOCALE)
  	if ((s = setlocale(LC_CTYPE, NULL)) == NULL || *s == NUL)
! # endif
  	    s = NULL;
  
      return enc_locale_env(s);
! #endif
  }
  
  # if defined(WIN3264) || defined(PROTO) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)
***************
*** 4800,4806 ****
  #  endif /* DYNAMIC_ICONV */
  # endif /* USE_ICONV */
  
- #endif /* FEAT_MBYTE */
  
  #ifdef FEAT_GUI
  # define USE_IMACTIVATEFUNC (!gui.in_use && *p_imaf != NUL)
--- 4787,4792 ----
***************
*** 4810,4817 ****
  # define USE_IMSTATUSFUNC (*p_imsf != NUL)
  #endif
  
! #if defined(FEAT_EVAL) && defined(FEAT_MBYTE) \
! 	&& (defined(FEAT_XIM) || defined(IME_WITHOUT_XIM))
      static void
  call_imactivatefunc(int active)
  {
--- 4796,4802 ----
  # define USE_IMSTATUSFUNC (*p_imsf != NUL)
  #endif
  
! #if defined(FEAT_EVAL) && (defined(FEAT_XIM) || defined(IME_WITHOUT_XIM))
      static void
  call_imactivatefunc(int active)
  {
***************
*** 6482,6488 ****
      int
  im_get_status(void)
  {
! #  if defined(FEAT_MBYTE) && defined(FEAT_EVAL)
      if (USE_IMSTATUSFUNC)
  	return call_imstatusfunc();
  #  endif
--- 6467,6473 ----
      int
  im_get_status(void)
  {
! #  if defined(FEAT_EVAL)
      if (USE_IMSTATUSFUNC)
  	return call_imstatusfunc();
  #  endif
***************
*** 6492,6498 ****
      void
  im_set_active(int active_arg)
  {
! #  if defined(FEAT_MBYTE) && defined(FEAT_EVAL)
      int	    active = !p_imdisable && active_arg;
  
      if (USE_IMACTIVATEFUNC && active != im_get_status())
--- 6477,6483 ----
      void
  im_set_active(int active_arg)
  {
! #  if defined(FEAT_EVAL)
      int	    active = !p_imdisable && active_arg;
  
      if (USE_IMACTIVATEFUNC && active != im_get_status())
***************
*** 6513,6519 ****
  
  #endif /* FEAT_XIM */
  
- #if defined(FEAT_MBYTE) || defined(PROTO)
  
  /*
   * Setup "vcp" for conversion from "from" to "to".
--- 6498,6503 ----
***************
*** 6548,6557 ****
      int		to_is_utf8;
  
      /* Reset to no conversion. */
! # ifdef USE_ICONV
      if (vcp->vc_type == CONV_ICONV && vcp->vc_fd != (iconv_t)-1)
  	iconv_close(vcp->vc_fd);
! # endif
      vcp->vc_type = CONV_NONE;
      vcp->vc_factor = 1;
      vcp->vc_fail = FALSE;
--- 6532,6541 ----
      int		to_is_utf8;
  
      /* Reset to no conversion. */
! #ifdef USE_ICONV
      if (vcp->vc_type == CONV_ICONV && vcp->vc_fd != (iconv_t)-1)
  	iconv_close(vcp->vc_fd);
! #endif
      vcp->vc_type = CONV_NONE;
      vcp->vc_factor = 1;
      vcp->vc_fail = FALSE;
***************
*** 6624,6630 ****
  	vcp->vc_type = CONV_UTF8_MAC;
      }
  #endif
! # ifdef USE_ICONV
      else
      {
  	/* Use iconv() for conversion. */
--- 6608,6614 ----
  	vcp->vc_type = CONV_UTF8_MAC;
      }
  #endif
! #ifdef USE_ICONV
      else
      {
  	/* Use iconv() for conversion. */
***************
*** 6637,6643 ****
  	    vcp->vc_factor = 4;	/* could be longer too... */
  	}
      }
! # endif
      if (vcp->vc_type == CONV_NONE)
  	return FAIL;
  
--- 6621,6627 ----
  	    vcp->vc_factor = 4;	/* could be longer too... */
  	}
      }
! #endif
      if (vcp->vc_type == CONV_NONE)
  	return FAIL;
  
***************
*** 6958,6961 ****
  
      return retval;
  }
- #endif
--- 6942,6944 ----
*** ../vim-8.1.0805/src/memline.c	2019-01-19 17:43:03.417449145 +0100
--- src/memline.c	2019-01-24 15:21:52.472269571 +0100
***************
*** 240,248 ****
  static void ml_upd_block0(buf_T *buf, upd_block0_T what);
  static void set_b0_fname(ZERO_BL *, buf_T *buf);
  static void set_b0_dir_flag(ZERO_BL *b0p, buf_T *buf);
- #ifdef FEAT_MBYTE
  static void add_b0_fenc(ZERO_BL *b0p, buf_T *buf);
- #endif
  static time_t swapfile_info(char_u *);
  static int recov_file_names(char_u **, char_u *, int prepend_dot);
  static int ml_append_int(buf_T *, linenr_T, char_u *, colnr_T, int, int);
--- 240,246 ----
***************
*** 1033,1042 ****
  	}
      }
  
- #ifdef FEAT_MBYTE
      /* Also add the 'fileencoding' if there is room. */
      add_b0_fenc(b0p, curbuf);
- #endif
  }
  
  /*
--- 1031,1038 ----
***************
*** 1054,1060 ****
  	b0p->b0_flags &= ~B0_SAME_DIR;
  }
  
- #ifdef FEAT_MBYTE
  /*
   * When there is room, add the 'fileencoding' to block zero.
   */
--- 1050,1055 ----
***************
*** 1066,1078 ****
      int		n;
      int		size = B0_FNAME_SIZE_NOCRYPT;
  
! # ifdef FEAT_CRYPT
      /* Without encryption use the same offset as in Vim 7.2 to be compatible.
       * With encryption it's OK to move elsewhere, the swap file is not
       * compatible anyway. */
      if (*buf->b_p_key != NUL)
  	size = B0_FNAME_SIZE_CRYPT;
! # endif
  
      n = (int)STRLEN(buf->b_p_fenc);
      if ((int)STRLEN(b0p->b0_fname) + n + 1 > size)
--- 1061,1073 ----
      int		n;
      int		size = B0_FNAME_SIZE_NOCRYPT;
  
! #ifdef FEAT_CRYPT
      /* Without encryption use the same offset as in Vim 7.2 to be compatible.
       * With encryption it's OK to move elsewhere, the swap file is not
       * compatible anyway. */
      if (*buf->b_p_key != NUL)
  	size = B0_FNAME_SIZE_CRYPT;
! #endif
  
      n = (int)STRLEN(buf->b_p_fenc);
      if ((int)STRLEN(b0p->b0_fname) + n + 1 > size)
***************
*** 1085,1091 ****
  	b0p->b0_flags |= B0_HAS_FENC;
      }
  }
- #endif
  
  
  /*
--- 1080,1085 ----
***************
*** 5103,5111 ****
  	    b0p->b0_dirty = buf->b_changed ? B0_DIRTY : 0;
  	    b0p->b0_flags = (b0p->b0_flags & ~B0_FF_MASK)
  						  | (get_fileformat(buf) + 1);
- #ifdef FEAT_MBYTE
  	    add_b0_fenc(b0p, buf);
- #endif
  	    hp->bh_flags |= BH_DIRTY;
  	    mf_sync(buf->b_ml.ml_mfp, MFS_ZERO);
  	    break;
--- 5097,5103 ----
***************
*** 5682,5691 ****
      }
      check_cursor();
  
- # ifdef FEAT_MBYTE
      /* Make sure the cursor is on the first byte of a multi-byte char. */
      if (has_mbyte)
  	mb_adjust_cursor();
- # endif
  }
  #endif
--- 5674,5681 ----
*** ../vim-8.1.0805/src/message.c	2019-01-20 15:30:36.885328746 +0100
--- src/message.c	2019-01-24 15:25:35.298805375 +0100
***************
*** 219,225 ****
  	    room = (int)(Rows - msg_row - 1) * Columns + sc_col - 1;
  	if (len > room && room > 0)
  	{
- #ifdef FEAT_MBYTE
  	    if (enc_utf8)
  		/* may have up to 18 bytes per cell (6 per char, up to two
  		 * composing chars) */
--- 219,224 ----
***************
*** 228,234 ****
  		/* may have up to 2 bytes per cell for euc-jp */
  		len = (room + 2) * 2;
  	    else
- #endif
  		len = room + 2;
  	    buf = alloc(len);
  	    if (buf != NULL)
--- 227,232 ----
***************
*** 274,280 ****
  	    break;
  	len += n;
  	buf[e] = s[e];
- #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	    for (n = (*mb_ptr2len)(s + e); --n > 0; )
  	    {
--- 272,277 ----
***************
*** 282,293 ****
  		    break;
  		buf[e] = s[e];
  	    }
- #endif
      }
  
      /* Last part: End of the string. */
      i = e;
- #ifdef FEAT_MBYTE
      if (enc_dbcs != 0)
      {
  	/* For DBCS going backwards in a string is slow, but
--- 279,288 ----
***************
*** 317,323 ****
  	}
      }
      else
- #endif
      {
  	for (i = (int)STRLEN(s); len + (n = ptr2cells(s + i - 1)) <= room; --i)
  	    len += n;
--- 312,317 ----
***************
*** 852,858 ****
      if ((force || (shortmess(SHM_TRUNC) && !exmode_active))
  	    && (n = (int)STRLEN(s) - room) > 0)
      {
- #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	{
  	    int	size = vim_strsize(s);
--- 846,851 ----
***************
*** 868,874 ****
  	    }
  	    --n;
  	}
- #endif
  	s += n;
  	*s = '<';
      }
--- 861,866 ----
***************
*** 1388,1398 ****
      void
  msg_putchar_attr(int c, int attr)
  {
- #ifdef FEAT_MBYTE
      char_u	buf[MB_MAXBYTES + 1];
- #else
-     char_u	buf[4];
- #endif
  
      if (IS_SPECIAL(c))
      {
--- 1380,1386 ----
***************
*** 1402,1415 ****
  	buf[3] = NUL;
      }
      else
-     {
- #ifdef FEAT_MBYTE
  	buf[(*mb_char2bytes)(c, buf)] = NUL;
- #else
- 	buf[0] = c;
- 	buf[1] = NUL;
- #endif
-     }
      msg_puts_attr((char *)buf, attr);
  }
  
--- 1390,1396 ----
***************
*** 1478,1484 ****
      char_u *
  msg_outtrans_one(char_u *p, int attr)
  {
- #ifdef FEAT_MBYTE
      int		l;
  
      if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)
--- 1459,1464 ----
***************
*** 1486,1492 ****
  	msg_outtrans_len_attr(p, l, attr);
  	return p + l;
      }
- #endif
      msg_puts_attr((char *)transchar_byte(*p), attr);
      return p + 1;
  }
--- 1466,1471 ----
***************
*** 1498,1507 ****
      char_u	*str = msgstr;
      char_u	*plain_start = msgstr;
      char_u	*s;
- #ifdef FEAT_MBYTE
      int		mb_l;
      int		c;
- #endif
  
      /* if MSG_HIST flag set, add message to history */
      if (attr & MSG_HIST)
--- 1477,1484 ----
***************
*** 1510,1521 ****
  	attr &= ~MSG_HIST;
      }
  
- #ifdef FEAT_MBYTE
      /* If the string starts with a composing character first draw a space on
       * which the composing char can be drawn. */
      if (enc_utf8 && utf_iscomposing(utf_ptr2char(msgstr)))
  	msg_puts_attr(" ", attr);
- #endif
  
      /*
       * Go over the string.  Special characters are translated and printed.
--- 1487,1496 ----
***************
*** 1523,1529 ****
       */
      while (--len >= 0)
      {
- #ifdef FEAT_MBYTE
  	if (enc_utf8)
  	    /* Don't include composing chars after the end. */
  	    mb_l = utfc_ptr2len_len(str, len + 1);
--- 1498,1503 ----
***************
*** 1553,1559 ****
  	    str += mb_l;
  	}
  	else
- #endif
  	{
  	    s = transchar_byte(*str);
  	    if (s[1] != NUL)
--- 1527,1532 ----
***************
*** 1639,1648 ****
  	len = vim_strsize((char_u *)text);
  	/* Highlight special keys */
  	msg_puts_attr(text, len > 1
! #ifdef FEAT_MBYTE
! 		&& (*mb_ptr2len)((char_u *)text) <= 1
! #endif
! 		? attr : 0);
  	retval += len;
      }
      return retval;
--- 1612,1618 ----
  	len = vim_strsize((char_u *)text);
  	/* Highlight special keys */
  	msg_puts_attr(text, len > 1
! 		&& (*mb_ptr2len)((char_u *)text) <= 1 ? attr : 0);
  	retval += len;
      }
      return retval;
***************
*** 1685,1691 ****
      int			modifiers = 0;
      int			special = FALSE;
  
- #ifdef FEAT_MBYTE
      if (has_mbyte)
      {
  	char_u	*p;
--- 1655,1660 ----
***************
*** 1696,1702 ****
  	if (p != NULL)
  	    return p;
      }
- #endif
  
      c = *str;
      if (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)
--- 1665,1670 ----
***************
*** 1716,1722 ****
  	    special = TRUE;
      }
  
- #ifdef FEAT_MBYTE
      if (has_mbyte && !IS_SPECIAL(c))
      {
  	int len = (*mb_ptr2len)(str);
--- 1684,1689 ----
***************
*** 1734,1740 ****
  	*sp = str + len;
      }
      else
- #endif
  	*sp = str + 1;
  
      /* Make unprintable characters in <> form, also <M-Space> and <Tab>.
--- 1701,1706 ----
***************
*** 1778,1787 ****
      int		n;
      int		attr = 0;
      char_u	*trail = NULL;
- #ifdef FEAT_MBYTE
      int		l;
      char_u	buf[MB_MAXBYTES + 1];
- #endif
  
      if (curwin->w_p_list)
  	list = TRUE;
--- 1744,1751 ----
***************
*** 1811,1817 ****
  	    else
  		c = *p_extra++;
  	}
- #ifdef FEAT_MBYTE
  	else if (has_mbyte && (l = (*mb_ptr2len)(s)) > 1)
  	{
  	    col += (*mb_ptr2cells)(s);
--- 1775,1780 ----
***************
*** 1831,1837 ****
  	    s += l;
  	    continue;
  	}
- #endif
  	else
  	{
  	    attr = 0;
--- 1794,1799 ----
***************
*** 1906,1912 ****
      msg_clr_eos();
  }
  
- #ifdef FEAT_MBYTE
  /*
   * Use screen_puts() to output one multi-byte character.
   * Return the pointer "s" advanced to the next character.
--- 1868,1873 ----
***************
*** 1952,1958 ****
      }
      return s + l;
  }
- #endif
  
  /*
   * Output a string to the screen at position msg_row, msg_col.
--- 1913,1918 ----
***************
*** 2069,2078 ****
      char_u	*s = str;
      char_u	*t_s = str;	/* string from "t_s" to "s" is still todo */
      int		t_col = 0;	/* screen cells todo, 0 when "t_s" not used */
- #ifdef FEAT_MBYTE
      int		l;
      int		cw;
- #endif
      char_u	*sb_str = str;
      int		sb_col = msg_col;
      int		wrap;
--- 2029,2036 ----
***************
*** 2091,2110 ****
  		    cmdmsg_rl
  		    ? (
  			msg_col <= 1
! 			|| (*s == TAB && msg_col <= 7)
! # ifdef FEAT_MBYTE
! 			|| (has_mbyte && (*mb_ptr2cells)(s) > 1 && msg_col <= 2)
! # endif
! 		      )
  		    :
  #endif
  		      (msg_col + t_col >= Columns - 1
  		       || (*s == TAB && msg_col + t_col >= ((Columns - 1) & ~7))
- # ifdef FEAT_MBYTE
  		       || (has_mbyte && (*mb_ptr2cells)(s) > 1
! 					    && msg_col + t_col >= Columns - 2)
! # endif
! 		      ))))
  	{
  	    /*
  	     * The screen is scrolled up when at the last row (some terminals
--- 2049,2062 ----
  		    cmdmsg_rl
  		    ? (
  			msg_col <= 1
! 		      || (*s == TAB && msg_col <= 7)
! 		      || (has_mbyte && (*mb_ptr2cells)(s) > 1 && msg_col <= 2))
  		    :
  #endif
  		      (msg_col + t_col >= Columns - 1
  		       || (*s == TAB && msg_col + t_col >= ((Columns - 1) & ~7))
  		       || (has_mbyte && (*mb_ptr2cells)(s) > 1
! 					 && msg_col + t_col >= Columns - 2)))))
  	{
  	    /*
  	     * The screen is scrolled up when at the last row (some terminals
***************
*** 2133,2139 ****
  #endif
  	       )
  	    {
- #ifdef FEAT_MBYTE
  		if (has_mbyte)
  		{
  		    if (enc_utf8 && maxlen >= 0)
--- 2085,2090 ----
***************
*** 2144,2150 ****
  		    s = screen_puts_mbyte(s, l, attr);
  		}
  		else
- #endif
  		    msg_screen_putchar(*s++, attr);
  		did_last_char = TRUE;
  	    }
--- 2095,2100 ----
***************
*** 2188,2198 ****
  
  	wrap = *s == '\n'
  		    || msg_col + t_col >= Columns
- #ifdef FEAT_MBYTE
  		    || (has_mbyte && (*mb_ptr2cells)(s) > 1
! 					    && msg_col + t_col >= Columns - 1)
! #endif
! 		    ;
  	if (t_col > 0 && (wrap || *s == '\r' || *s == '\b'
  						 || *s == '\t' || *s == BELL))
  	    /* output any postponed text */
--- 2138,2145 ----
  
  	wrap = *s == '\n'
  		    || msg_col + t_col >= Columns
  		    || (has_mbyte && (*mb_ptr2cells)(s) > 1
! 					    && msg_col + t_col >= Columns - 1);
  	if (t_col > 0 && (wrap || *s == '\r' || *s == '\b'
  						 || *s == '\t' || *s == BELL))
  	    /* output any postponed text */
***************
*** 2233,2239 ****
  	    vim_beep(BO_SH);
  	else
  	{
- #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  	    {
  		cw = (*mb_ptr2cells)(s);
--- 2180,2185 ----
***************
*** 2248,2289 ****
  		cw = 1;
  		l = 1;
  	    }
! #endif
  	    /* When drawing from right to left or when a double-wide character
  	     * doesn't fit, draw a single character here.  Otherwise collect
  	     * characters and draw them all at once later. */
- #if defined(FEAT_RIGHTLEFT) || defined(FEAT_MBYTE)
  	    if (
  # ifdef FEAT_RIGHTLEFT
! 		    cmdmsg_rl
! #  ifdef FEAT_MBYTE
! 		    ||
! #  endif
  # endif
! # ifdef FEAT_MBYTE
! 		    (cw > 1 && msg_col + t_col >= Columns - 1)
! # endif
! 		    )
  	    {
- # ifdef FEAT_MBYTE
  		if (l > 1)
  		    s = screen_puts_mbyte(s, l, attr) - 1;
  		else
- # endif
  		    msg_screen_putchar(*s, attr);
  	    }
  	    else
- #endif
  	    {
  		/* postpone this character until later */
  		if (t_col == 0)
  		    t_s = s;
- #ifdef FEAT_MBYTE
  		t_col += cw;
  		s += l - 1;
- #else
- 		++t_col;
- #endif
  	    }
  	}
  	++s;
--- 2194,2221 ----
  		cw = 1;
  		l = 1;
  	    }
! 
  	    /* When drawing from right to left or when a double-wide character
  	     * doesn't fit, draw a single character here.  Otherwise collect
  	     * characters and draw them all at once later. */
  	    if (
  # ifdef FEAT_RIGHTLEFT
! 		    cmdmsg_rl ||
  # endif
! 		    (cw > 1 && msg_col + t_col >= Columns - 1))
  	    {
  		if (l > 1)
  		    s = screen_puts_mbyte(s, l, attr) - 1;
  		else
  		    msg_screen_putchar(*s, attr);
  	    }
  	    else
  	    {
  		/* postpone this character until later */
  		if (t_col == 0)
  		    t_s = s;
  		t_col += cw;
  		s += l - 1;
  	    }
  	}
  	++s;
***************
*** 2601,2612 ****
      screen_puts_len(t_s, (int)(s - t_s), msg_row, msg_col, attr);
      msg_col += *t_col;
      *t_col = 0;
- #ifdef FEAT_MBYTE
      /* If the string starts with a composing character don't increment the
       * column position for it. */
      if (enc_utf8 && utf_iscomposing(utf_ptr2char(t_s)))
  	--msg_col;
- #endif
      if (msg_col >= Columns)
      {
  	msg_col = 0;
--- 2533,2542 ----
***************
*** 2643,2656 ****
      char_u	buf[4];
      char_u	*p;
  #ifdef WIN3264
! # if defined(FEAT_MBYTE) && !defined(FEAT_GUI_MSWIN)
      char_u	*ccp = NULL;
  
  # endif
      if (!(silent_mode && p_verbose == 0))
  	mch_settmode(TMODE_COOK);	/* handle '\r' and '\n' correctly */
  
! # if defined(FEAT_MBYTE) && !defined(FEAT_GUI_MSWIN)
      if (enc_codepage >= 0 && (int)GetConsoleCP() != enc_codepage)
      {
  	int	inlen = (int)STRLEN(str);
--- 2573,2586 ----
      char_u	buf[4];
      char_u	*p;
  #ifdef WIN3264
! # if !defined(FEAT_GUI_MSWIN)
      char_u	*ccp = NULL;
  
  # endif
      if (!(silent_mode && p_verbose == 0))
  	mch_settmode(TMODE_COOK);	/* handle '\r' and '\n' correctly */
  
! # if !defined(FEAT_GUI_MSWIN)
      if (enc_codepage >= 0 && (int)GetConsoleCP() != enc_codepage)
      {
  	int	inlen = (int)STRLEN(str);
***************
*** 2708,2714 ****
      msg_didout = TRUE;	    /* assume that line is not empty */
  
  #ifdef WIN3264
! # if defined(FEAT_MBYTE) && !defined(FEAT_GUI_MSWIN)
      vim_free(ccp);
  # endif
      if (!(silent_mode && p_verbose == 0))
--- 2638,2644 ----
      msg_didout = TRUE;	    /* assume that line is not empty */
  
  #ifdef WIN3264
! # if !defined(FEAT_GUI_MSWIN)
      vim_free(ccp);
  # endif
      if (!(silent_mode && p_verbose == 0))
***************
*** 3646,3652 ****
  		retval = 1;
  		for (i = 0; hotkeys[i]; ++i)
  		{
- #ifdef FEAT_MBYTE
  		    if (has_mbyte)
  		    {
  			if ((*mb_ptr2char)(hotkeys + i) == c)
--- 3576,3581 ----
***************
*** 3654,3660 ****
  			i += (*mb_ptr2len)(hotkeys + i) - 1;
  		    }
  		    else
- #endif
  			if (hotkeys[i] == c)
  			    break;
  		    ++retval;
--- 3583,3588 ----
***************
*** 3690,3696 ****
      char_u	*to,
      int		lowercase)	/* make character lower case */
  {
- #ifdef FEAT_MBYTE
      int		len;
      int		c;
  
--- 3618,3623 ----
***************
*** 3709,3715 ****
  	}
      }
      else
- #endif
      {
  	if (lowercase)
  	    *to = (char_u)TOLOWER_LOC(*from);
--- 3636,3641 ----
***************
*** 3735,3745 ****
      int		dfltbutton)
  {
      int		len = 0;
! #ifdef FEAT_MBYTE
! # define HOTK_LEN (has_mbyte ? MB_MAXBYTES : 1)
! #else
! # define HOTK_LEN 1
! #endif
      int		lenhotkey = HOTK_LEN;	/* count first button */
      char_u	*hotk = NULL;
      char_u	*msgp = NULL;
--- 3661,3667 ----
      int		dfltbutton)
  {
      int		len = 0;
! #define HOTK_LEN (has_mbyte ? MB_MAXBYTES : 1)
      int		lenhotkey = HOTK_LEN;	/* count first button */
      char_u	*hotk = NULL;
      char_u	*msgp = NULL;
***************
*** 3771,3781 ****
  		    *msgp++ = ' ';	    /* '\n' -> ', ' */
  
  		    /* advance to next hotkey and set default hotkey */
- #ifdef FEAT_MBYTE
  		    if (has_mbyte)
  			hotkp += STRLEN(hotkp);
  		    else
- #endif
  			++hotkp;
  		    hotkp[copy_char(r + 1, hotkp, TRUE)] = NUL;
  		    if (dfltbutton)
--- 3693,3701 ----
***************
*** 4583,4589 ****
  			str_arg_l = (q == NULL) ? precision
  						      : (size_t)(q - str_arg);
  		    }
- # ifdef FEAT_MBYTE
  		    if (fmt_spec == 'S')
  		    {
  			if (min_field_width != 0)
--- 4503,4508 ----
***************
*** 4600,4606 ****
  			    str_arg_l = precision = p1 - (char_u *)str_arg;
  			}
  		    }
- # endif
  		    break;
  
  		default:
--- 4519,4524 ----
*** ../vim-8.1.0805/src/misc1.c	2019-01-20 15:30:36.889328720 +0100
--- src/misc1.c	2019-01-24 15:29:11.881374564 +0100
***************
*** 843,853 ****
  	p = saved_line + curwin->w_cursor.col;
  	while (*p != NUL)
  	{
- #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  		p += replace_push_mb(p);
  	    else
- #endif
  		replace_push(*p++);
  	}
  	saved_line[curwin->w_cursor.col] = NUL;
--- 843,851 ----
***************
*** 1296,1302 ****
  			    ;
  			++p;
  
- #ifdef FEAT_MBYTE
  			/* Compute the length of the replaced characters in
  			 * screen characters, not bytes. */
  			{
--- 1294,1299 ----
***************
*** 1317,1328 ****
  					(size_t)((leader + lead_len) - endp));
  			    lead_len += l;
  			}
- #else
- 			if (p < leader + lead_repl_len)
- 			    p = leader;
- 			else
- 			    p -= lead_repl_len;
- #endif
  			mch_memmove(p, lead_repl, (size_t)lead_repl_len);
  			if (p + lead_repl_len > leader + lead_len)
  			    p[lead_repl_len] = NUL;
--- 1314,1319 ----
***************
*** 1330,1336 ****
  			/* blank-out any other chars from the old leader. */
  			while (--p >= leader)
  			{
- #ifdef FEAT_MBYTE
  			    int l = mb_head_off(leader, p);
  
  			    if (l > 1)
--- 1321,1326 ----
***************
*** 1346,1361 ****
  				lead_len -= l;
  				*p = ' ';
  			    }
! 			    else
! #endif
! 			    if (!VIM_ISWHITE(*p))
  				*p = ' ';
  			}
  		    }
  		    else		    /* left adjusted leader */
  		    {
  			p = skipwhite(leader);
! #ifdef FEAT_MBYTE
  			/* Compute the length of the replaced characters in
  			 * screen characters, not bytes. Move the part that is
  			 * not to be overwritten. */
--- 1336,1349 ----
  				lead_len -= l;
  				*p = ' ';
  			    }
! 			    else if (!VIM_ISWHITE(*p))
  				*p = ' ';
  			}
  		    }
  		    else		    /* left adjusted leader */
  		    {
  			p = skipwhite(leader);
! 
  			/* Compute the length of the replaced characters in
  			 * screen characters, not bytes. Move the part that is
  			 * not to be overwritten. */
***************
*** 1378,1384 ****
  				lead_len += lead_repl_len - i;
  			    }
  			}
- #endif
  			mch_memmove(p, lead_repl, (size_t)lead_repl_len);
  
  			/* Replace any remaining non-white chars in the old
--- 1366,1371 ----
***************
*** 1396,1402 ****
  				}
  				else
  				{
- #ifdef FEAT_MBYTE
  				    int	    l = (*mb_ptr2len)(p);
  
  				    if (l > 1)
--- 1383,1388 ----
***************
*** 1412,1418 ****
  						     (leader + lead_len) - p);
  					lead_len -= l - 1;
  				    }
- #endif
  				    *p = ' ';
  				}
  			    }
--- 1398,1403 ----
***************
*** 1537,1547 ****
  	if (curbuf->b_p_ai || (flags & OPENLINE_DELSPACES))
  	{
  	    while ((*p_extra == ' ' || *p_extra == '\t')
- #ifdef FEAT_MBYTE
  		    && (!enc_utf8
! 			       || !utf_iscomposing(utf_ptr2char(p_extra + 1)))
! #endif
! 		    )
  	    {
  		if (REPLACE_NORMAL(State))
  		    replace_push(*p_extra);
--- 1522,1529 ----
  	if (curbuf->b_p_ai || (flags & OPENLINE_DELSPACES))
  	{
  	    while ((*p_extra == ' ' || *p_extra == '\t')
  		    && (!enc_utf8
! 			       || !utf_iscomposing(utf_ptr2char(p_extra + 1))))
  	    {
  		if (REPLACE_NORMAL(State))
  		    replace_push(*p_extra);
***************
*** 2320,2326 ****
  ins_bytes_len(char_u *p, int len)
  {
      int		i;
- #ifdef FEAT_MBYTE
      int		n;
  
      if (has_mbyte)
--- 2302,2307 ----
***************
*** 2334,2340 ****
  	    ins_char_bytes(p + i, n);
  	}
      else
- #endif
  	for (i = 0; i < len; ++i)
  	    ins_char(p[i]);
  }
--- 2315,2320 ----
***************
*** 2350,2367 ****
  ins_char(int c)
  {
      char_u	buf[MB_MAXBYTES + 1];
!     int		n = 1;
! 
! #ifdef FEAT_MBYTE
!     n = (*mb_char2bytes)(c, buf);
  
      /* When "c" is 0x100, 0x200, etc. we don't want to insert a NUL byte.
       * Happens for CTRL-Vu9900. */
      if (buf[0] == 0)
  	buf[0] = '\n';
- #else
-     buf[0] = c;
- #endif
  
      ins_char_bytes(buf, n);
  }
--- 2330,2341 ----
  ins_char(int c)
  {
      char_u	buf[MB_MAXBYTES + 1];
!     int		n = (*mb_char2bytes)(c, buf);
  
      /* When "c" is 0x100, 0x200, etc. we don't want to insert a NUL byte.
       * Happens for CTRL-Vu9900. */
      if (buf[0] == 0)
  	buf[0] = '\n';
  
      ins_char_bytes(buf, n);
  }
***************
*** 2401,2409 ****
  	    colnr_T	new_vcol = 0;   /* init for GCC */
  	    colnr_T	vcol;
  	    int		old_list;
- #ifndef FEAT_MBYTE
- 	    char_u	cbuf[2];
- #endif
  
  	    /*
  	     * Disable 'list' temporarily, unless 'cpo' contains the 'L' flag.
--- 2375,2380 ----
***************
*** 2421,2433 ****
  	     * cells.  May result in adding spaces to fill a gap.
  	     */
  	    getvcol(curwin, &curwin->w_cursor, NULL, &vcol, NULL);
- #ifndef FEAT_MBYTE
- 	    cbuf[0] = c;
- 	    cbuf[1] = NUL;
- 	    new_vcol = vcol + chartabsize(cbuf, vcol);
- #else
  	    new_vcol = vcol + chartabsize(buf, vcol);
- #endif
  	    while (oldp[col + oldlen] != NUL && vcol < new_vcol)
  	    {
  		vcol += chartabsize(oldp + col + oldlen, vcol);
--- 2392,2398 ----
***************
*** 2435,2445 ****
  		 * position. */
  		if (vcol > new_vcol && oldp[col + oldlen] == TAB)
  		    break;
- #ifdef FEAT_MBYTE
  		oldlen += (*mb_ptr2len)(oldp + col + oldlen);
- #else
- 		++oldlen;
- #endif
  		/* Deleted a bit too much, insert spaces. */
  		if (vcol > new_vcol)
  		    newlen += vcol - new_vcol;
--- 2400,2406 ----
***************
*** 2449,2459 ****
  	else if (oldp[col] != NUL)
  	{
  	    /* normal replace */
- #ifdef FEAT_MBYTE
  	    oldlen = (*mb_ptr2len)(oldp + col);
- #else
- 	    oldlen = 1;
- #endif
  	}
  
  
--- 2410,2416 ----
***************
*** 2464,2474 ****
  	replace_push(NUL);
  	for (i = 0; i < oldlen; ++i)
  	{
- #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  		i += replace_push_mb(oldp + col + i) - 1;
  	    else
- #endif
  		replace_push(oldp[col + i]);
  	}
      }
--- 2421,2429 ----
***************
*** 2488,2500 ****
  					    (size_t)(linelen - col - oldlen));
  
      /* Insert or overwrite the new character. */
- #ifdef FEAT_MBYTE
      mch_memmove(p, buf, charlen);
      i = charlen;
- #else
-     *p = c;
-     i = 1;
- #endif
  
      /* Fill with spaces when necessary. */
      while (i < newlen)
--- 2443,2450 ----
***************
*** 2517,2527 ****
  #endif
         )
      {
- #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	    showmatch(mb_ptr2char(buf));
  	else
- #endif
  	    showmatch(c);
      }
  
--- 2467,2475 ----
***************
*** 2530,2540 ****
  #endif
      {
  	/* Normal insert: move cursor right */
- #ifdef FEAT_MBYTE
  	curwin->w_cursor.col += charlen;
- #else
- 	++curwin->w_cursor.col;
- #endif
      }
      /*
       * TODO: should try to update w_row here, to avoid recomputing it later.
--- 2478,2484 ----
***************
*** 2586,2592 ****
      int
  del_char(int fixpos)
  {
- #ifdef FEAT_MBYTE
      if (has_mbyte)
      {
  	/* Make sure the cursor is at the start of a character. */
--- 2530,2535 ----
***************
*** 2595,2605 ****
  	    return FAIL;
  	return del_chars(1L, fixpos);
      }
- #endif
      return del_bytes(1L, fixpos, TRUE);
  }
  
- #if defined(FEAT_MBYTE) || defined(PROTO)
  /*
   * Like del_bytes(), but delete characters instead of bytes.
   */
--- 2538,2546 ----
***************
*** 2620,2626 ****
      }
      return del_bytes(bytes, fixpos, TRUE);
  }
- #endif
  
  /*
   * Delete "count" bytes under the cursor.
--- 2561,2566 ----
***************
*** 2662,2668 ****
  	return FAIL;
      }
  
- #ifdef FEAT_MBYTE
      /* If 'delcombine' is set and deleting (less than) one character, only
       * delete the last combining character. */
      if (p_deco && use_delcombine && enc_utf8
--- 2602,2607 ----
***************
*** 2685,2691 ****
  	    fixpos = 0;
  	}
      }
- #endif
  
      /*
       * When count is too big, reduce it.
--- 2624,2629 ----
***************
*** 2708,2718 ****
  #ifdef FEAT_VIRTUALEDIT
  	    curwin->w_cursor.coladd = 0;
  #endif
- #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  		curwin->w_cursor.col -=
  			    (*mb_head_off)(oldp, oldp + curwin->w_cursor.col);
- #endif
  	}
  	count = oldlen - col;
  	movelen = 1;
--- 2646,2654 ----
***************
*** 2847,2866 ****
      if (pos->col == MAXCOL)
  	return NUL;
      ptr = ml_get_pos(pos);
- #ifdef FEAT_MBYTE
      if (has_mbyte)
  	return (*mb_ptr2char)(ptr);
- #endif
      return (int)*ptr;
  }
  
      int
  gchar_cursor(void)
  {
- #ifdef FEAT_MBYTE
      if (has_mbyte)
  	return (*mb_ptr2char)(ml_get_cursor());
- #endif
      return (int)*ml_get_cursor();
  }
  
--- 2783,2798 ----
***************
*** 3681,3687 ****
  	    }
  	    break;
  	}
- #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	{
  	    if (MB_BYTE2LEN(n) > len)
--- 3613,3618 ----
***************
*** 3689,3695 ****
  	    buf[len >= buflen ? buflen - 1 : len] = NUL;
  	    n = (*mb_ptr2char)(buf);
  	}
- #endif
  #ifdef UNIX
  	if (n == intr_char)
  	    n = ESC;
--- 3620,3625 ----
***************
*** 4023,4029 ****
      if (var != NULL && *var == NUL)	/* empty is same as not set */
  	var = NULL;
  
- # ifdef FEAT_MBYTE
      if (enc_utf8 && var != NULL)
      {
  	int	len;
--- 3953,3958 ----
***************
*** 4038,4044 ****
  	    return;
  	}
      }
- # endif
  
      /*
       * Default home dir is C:/
--- 3967,3972 ----
***************
*** 4437,4443 ****
  
      if (p != NULL)
      {
! #if defined(FEAT_MBYTE) && defined(WIN3264)
  	if (enc_utf8)
  	{
  	    int	    len;
--- 4365,4371 ----
  
      if (p != NULL)
      {
! #if defined(WIN3264)
  	if (enc_utf8)
  	{
  	    int	    len;
***************
*** 4481,4487 ****
  	    else
  		p = mch_getenv((char_u *)"VIM");
  
! #if defined(FEAT_MBYTE) && defined(WIN3264)
  	    if (enc_utf8)
  	    {
  		int	len;
--- 4409,4415 ----
  	    else
  		p = mch_getenv((char_u *)"VIM");
  
! #if defined(WIN3264)
  	    if (enc_utf8)
  	    {
  		int	len;
***************
*** 5332,5338 ****
  	    *d++ = *s;		    /* copy next char */
  	    if (*s != '~' && *s != '.') /* and leading "~" and "." */
  		skip = TRUE;
- # ifdef FEAT_MBYTE
  	    if (has_mbyte)
  	    {
  		int l = mb_ptr2len(s);
--- 5260,5265 ----
***************
*** 5340,5346 ****
  		while (--l > 0)
  		    *d++ = *++s;
  	    }
- # endif
  	}
      }
  }
--- 5267,5272 ----
***************
*** 10155,10164 ****
      static int	stardepth = 0;	    /* depth for "**" expansion */
      WIN32_FIND_DATA	fb;
      HANDLE		hFind = (HANDLE)0;
- # ifdef FEAT_MBYTE
      WIN32_FIND_DATAW    wfb;
      WCHAR		*wn = NULL;	/* UCS-2 name, NULL when not used. */
- # endif
      char_u		*matchname;
      int			ok;
  
--- 10081,10088 ----
***************
*** 10170,10177 ****
  	    return 0;
      }
  
!     /* Make room for file name.  When doing encoding conversion the actual
!      * length may be quite a bit longer, thus use the maximum possible length. */
      buf = alloc((int)MAXPATHL);
      if (buf == NULL)
  	return 0;
--- 10094,10101 ----
  	    return 0;
      }
  
!     // Make room for file name.  When doing encoding conversion the actual
!     // length may be quite a bit longer, thus use the maximum possible length.
      buf = alloc((int)MAXPATHL);
      if (buf == NULL)
  	return 0;
***************
*** 10199,10205 ****
  	else if (path_end >= path + wildoff
  			 && vim_strchr((char_u *)"*?[~", *path_end) != NULL)
  	    e = p;
- # ifdef FEAT_MBYTE
  	if (has_mbyte)
  	{
  	    len = (*mb_ptr2len)(path_end);
--- 10123,10128 ----
***************
*** 10208,10214 ****
  	    path_end += len;
  	}
  	else
- # endif
  	    *p++ = *path_end++;
      }
      e = p;
--- 10131,10136 ----
***************
*** 10269,10275 ****
  
      /* Scan all files in the directory with "dir/ *.*" */
      STRCPY(s, "*.*");
- # ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	/* The active codepage differs from 'encoding'.  Attempt using the
--- 10191,10196 ----
***************
*** 10286,10302 ****
      }
  
      if (wn == NULL)
- # endif
  	hFind = FindFirstFile((LPCSTR)buf, &fb);
      ok = (hFind != INVALID_HANDLE_VALUE);
  
      while (ok)
      {
- # ifdef FEAT_MBYTE
  	if (wn != NULL)
  	    p = utf16_to_enc(wfb.cFileName, NULL);   /* p is allocated here */
  	else
- # endif
  	    p = (char_u *)fb.cFileName;
  	/* Ignore entries starting with a dot, unless when asked for.  Accept
  	 * all entries found with "matchname". */
--- 10207,10220 ----
***************
*** 10341,10354 ****
  	    }
  	}
  
- # ifdef FEAT_MBYTE
  	if (wn != NULL)
  	{
  	    vim_free(p);
  	    ok = FindNextFileW(hFind, &wfb);
  	}
  	else
- # endif
  	    ok = FindNextFile(hFind, &fb);
  
  	/* If no more matches and no match was used, try expanding the name
--- 10259,10270 ----
***************
*** 10357,10363 ****
  	{
  	    STRCPY(s, matchname);
  	    FindClose(hFind);
- # ifdef FEAT_MBYTE
  	    if (wn != NULL)
  	    {
  		vim_free(wn);
--- 10273,10278 ----
***************
*** 10366,10372 ****
  		    hFind = FindFirstFileW(wn, &wfb);
  	    }
  	    if (wn == NULL)
- # endif
  		hFind = FindFirstFile((LPCSTR)buf, &fb);
  	    ok = (hFind != INVALID_HANDLE_VALUE);
  	    VIM_CLEAR(matchname);
--- 10281,10286 ----
***************
*** 10374,10382 ****
      }
  
      FindClose(hFind);
- # ifdef FEAT_MBYTE
      vim_free(wn);
- # endif
      vim_free(buf);
      vim_regfree(regmatch.regprog);
      vim_free(matchname);
--- 10288,10294 ----
***************
*** 10480,10486 ****
  			     || (!p_fic && (flags & EW_ICASE)
  					     && isalpha(PTR2CHAR(path_end)))))
  	    e = p;
- #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	{
  	    len = (*mb_ptr2len)(path_end);
--- 10392,10397 ----
***************
*** 10489,10495 ****
  	    path_end += len;
  	}
  	else
- #endif
  	    *p++ = *path_end++;
      }
      e = p;
--- 10400,10405 ----
*** ../vim-8.1.0805/src/misc2.c	2019-01-20 15:30:36.889328720 +0100
--- src/misc2.c	2019-01-24 15:31:04.464628741 +0100
***************
*** 73,79 ****
   * Get the screen position of character col with a coladd in the cursor line.
   */
      int
! getviscol2(colnr_T col, colnr_T coladd)
  {
      colnr_T	x;
      pos_T	pos;
--- 73,79 ----
   * Get the screen position of character col with a coladd in the cursor line.
   */
      int
! getviscol2(colnr_T col, colnr_T coladd UNUSED)
  {
      colnr_T	x;
      pos_T	pos;
***************
*** 320,330 ****
      }
  #endif
  
- #ifdef FEAT_MBYTE
      /* prevent from moving onto a trail byte */
      if (has_mbyte)
  	mb_adjustpos(curbuf, pos);
- #endif
  
      if (col < wcol)
  	return FAIL;
--- 320,328 ----
***************
*** 358,364 ****
  	p = ml_get_pos(lp);
  	if (*p != NUL)	/* still within line, move to next char (may be NUL) */
  	{
- #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  	    {
  		int l = (*mb_ptr2len)(p);
--- 356,361 ----
***************
*** 366,372 ****
  		lp->col += l;
  		return ((p[l] != NUL) ? 0 : 2);
  	    }
- #endif
  	    lp->col++;
  #ifdef FEAT_VIRTUALEDIT
  	    lp->coladd = 0;
--- 363,368 ----
***************
*** 424,433 ****
  	/* past end of line */
  	p = ml_get(lp->lnum);
  	lp->col = (colnr_T)STRLEN(p);
- #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	    lp->col -= (*mb_head_off)(p, p + lp->col);
- #endif
  	return 0;
      }
  
--- 420,427 ----
***************
*** 435,447 ****
      {
  	/* still within line */
  	lp->col--;
- #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	{
  	    p = ml_get(lp->lnum);
  	    lp->col -= (*mb_head_off)(p, p + lp->col);
  	}
- #endif
  	return 0;
      }
  
--- 429,439 ----
***************
*** 451,460 ****
  	lp->lnum--;
  	p = ml_get(lp->lnum);
  	lp->col = (colnr_T)STRLEN(p);
- #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	    lp->col -= (*mb_head_off)(p, p + lp->col);
- #endif
  	return 1;
      }
  
--- 443,450 ----
***************
*** 608,618 ****
  	else
  	{
  	    win->w_cursor.col = len - 1;
- #ifdef FEAT_MBYTE
  	    /* Move the cursor to the head byte. */
  	    if (has_mbyte)
  		mb_adjustpos(win->w_buffer, &win->w_cursor);
- #endif
  	}
      }
      else if (win->w_cursor.col < 0)
--- 598,606 ----
***************
*** 1394,1402 ****
      char_u	*p2;
      char_u	*escaped_string;
      unsigned	length;
- #ifdef FEAT_MBYTE
      int		l;
- #endif
  
      /*
       * First count the number of backslashes required.
--- 1382,1388 ----
***************
*** 1405,1418 ****
      length = 1;				/* count the trailing NUL */
      for (p = string; *p; p++)
      {
- #ifdef FEAT_MBYTE
  	if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)
  	{
  	    length += l;		/* count a multibyte char */
  	    p += l - 1;
  	    continue;
  	}
- #endif
  	if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))
  	    ++length;			/* count a backslash */
  	++length;			/* count an ordinary char */
--- 1391,1402 ----
***************
*** 1423,1429 ****
  	p2 = escaped_string;
  	for (p = string; *p; p++)
  	{
- #ifdef FEAT_MBYTE
  	    if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)
  	    {
  		mch_memmove(p2, p, (size_t)l);
--- 1407,1412 ----
***************
*** 1431,1437 ****
  		p += l - 1;		/* skip multibyte char  */
  		continue;
  	    }
- #endif
  	    if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))
  		*p2++ = cc;
  	    *p2++ = *p;
--- 1414,1419 ----
***************
*** 1642,1648 ****
      if (res != NULL)
  	while (*p != NUL)
  	{
- # ifdef FEAT_MBYTE
  	    int		l;
  
  	    if (enc_utf8)
--- 1624,1629 ----
***************
*** 1685,1691 ****
  	    else if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)
  		p += l;		/* skip multi-byte character */
  	    else
- # endif
  	    {
  		*p = TOUPPER_LOC(*p); /* note that toupper() can be a macro */
  		p++;
--- 1666,1671 ----
***************
*** 1711,1717 ****
      if (res != NULL)
  	while (*p != NUL)
  	{
- # ifdef FEAT_MBYTE
  	    int		l;
  
  	    if (enc_utf8)
--- 1691,1696 ----
***************
*** 1754,1760 ****
  	    else if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)
  		p += l;		/* skip multi-byte character */
  	    else
- # endif
  	    {
  		*p = TOLOWER_LOC(*p); /* note that tolower() can be a macro */
  		p++;
--- 1733,1738 ----
***************
*** 1943,1949 ****
      int		b;
  
      p = string;
- #ifdef FEAT_MBYTE
      if (enc_utf8 && c >= 0x80)
      {
  	while (*p != NUL)
--- 1921,1926 ----
***************
*** 1980,1986 ****
  	}
  	return NULL;
      }
- #endif
      while ((b = *p) != NUL)
      {
  	if (b == c)
--- 1957,1962 ----
***************
*** 2713,2723 ****
       * When not a known special key, and not a printable character, try to
       * extract modifiers.
       */
!     if (c > 0
! #ifdef FEAT_MBYTE
! 	    && (*mb_char2len)(c) == 1
! #endif
!        )
      {
  	if (table_idx < 0
  		&& (!vim_isprintc(c) || (c & 0x7f) == ' ')
--- 2689,2695 ----
       * When not a known special key, and not a printable character, try to
       * extract modifiers.
       */
!     if (c > 0 && (*mb_char2len)(c) == 1)
      {
  	if (table_idx < 0
  		&& (!vim_isprintc(c) || (c & 0x7f) == ' ')
***************
*** 2760,2771 ****
  	/* Not a special key, only modifiers, output directly */
  	else
  	{
- #ifdef FEAT_MBYTE
  	    if (has_mbyte && (*mb_char2len)(c) > 1)
  		idx += (*mb_char2bytes)(c, string + idx);
! 	    else
! #endif
! 	    if (vim_isprintc(c))
  		string[idx++] = c;
  	    else
  	    {
--- 2732,2740 ----
  	/* Not a special key, only modifiers, output directly */
  	else
  	{
  	    if (has_mbyte && (*mb_char2len)(c) > 1)
  		idx += (*mb_char2bytes)(c, string + idx);
! 	    else if (vim_isprintc(c))
  		string[idx++] = c;
  	    else
  	    {
***************
*** 2825,2834 ****
  	dst[dlen++] = KEY2TERMCAP0(key);
  	dst[dlen++] = KEY2TERMCAP1(key);
      }
- #ifdef FEAT_MBYTE
      else if (has_mbyte && !keycode)
  	dlen += (*mb_char2bytes)(key, dst + dlen);
- #endif
      else if (keycode)
  	dlen = (int)(add_char2buf(key, dst + dlen) - dst);
      else
--- 2794,2801 ----
***************
*** 2873,2883 ****
  	    last_dash = bp;
  	    if (bp[1] != NUL)
  	    {
- #ifdef FEAT_MBYTE
  		if (has_mbyte)
  		    l = mb_ptr2len(bp + 1);
  		else
- #endif
  		    l = 1;
  		/* Anything accepted, like <C-?>.
  		 * <C-"> or <M-"> are not special in strings as " is
--- 2840,2848 ----
***************
*** 2935,2945 ****
  		/* Modifier with single letter, or special key name.  */
  		if (in_string && last_dash[1] == '\\' && last_dash[2] == '"')
  		    off = 2;
- #ifdef FEAT_MBYTE
  		if (has_mbyte)
  		    l = mb_ptr2len(last_dash + off);
  		else
- #endif
  		    l = 1;
  		if (modifiers != 0 && last_dash[l + off] == '>')
  		    key = PTR2CHAR(last_dash + off);
--- 2900,2908 ----
***************
*** 3028,3037 ****
      if (!(modifiers & MOD_MASK_CMD))
  #endif
      if ((modifiers & MOD_MASK_ALT) && key < 0x80
! #ifdef FEAT_MBYTE
! 	    && !enc_dbcs		/* avoid creating a lead byte */
! #endif
! 	    )
      {
  	key |= 0x80;
  	modifiers &= ~MOD_MASK_ALT;	/* remove the META modifier */
--- 2991,2997 ----
      if (!(modifiers & MOD_MASK_CMD))
  #endif
      if ((modifiers & MOD_MASK_ALT) && key < 0x80
! 	    && !enc_dbcs)		// avoid creating a lead byte
      {
  	key |= 0x80;
  	modifiers &= ~MOD_MASK_ALT;	/* remove the META modifier */
***************
*** 3377,3383 ****
      return State;
  }
  
- #if defined(FEAT_MBYTE) || defined(PROTO)
  /*
   * Return TRUE if "p" points to just after a path separator.
   * Takes care of multi-byte characters.
--- 3337,3342 ----
***************
*** 3389,3395 ****
      return p > b && vim_ispathsep(p[-1])
  			     && (!has_mbyte || (*mb_head_off)(b, p - 1) == 0);
  }
- #endif
  
  /*
   * Return TRUE if file names "f1" and "f2" are in the same directory.
--- 3348,3353 ----
***************
*** 6376,6383 ****
  
  #endif
  
! #if (defined(FEAT_MBYTE) && defined(FEAT_QUICKFIX)) \
! 	|| defined(FEAT_SPELL) || defined(PROTO)
  /*
   * Return TRUE if string "s" contains a non-ASCII character (128 or higher).
   * When "s" is NULL FALSE is returned.
--- 6334,6340 ----
  
  #endif
  
! #if defined(FEAT_QUICKFIX) || defined(FEAT_SPELL) || defined(PROTO)
  /*
   * Return TRUE if string "s" contains a non-ASCII character (128 or higher).
   * When "s" is NULL FALSE is returned.
*** ../vim-8.1.0805/src/move.c	2019-01-11 11:55:12.930066044 +0100
--- src/move.c	2019-01-24 15:31:26.516482525 +0100
***************
*** 934,940 ****
  }
  
  /*
!  * compute curwin->w_wcol and curwin->w_virtcol.
   * Also updates curwin->w_wrow and curwin->w_cline_row.
   * Also updates curwin->w_leftcol.
   */
--- 934,940 ----
  }
  
  /*
!  * Compute curwin->w_wcol and curwin->w_virtcol.
   * Also updates curwin->w_wrow and curwin->w_cline_row.
   * Also updates curwin->w_leftcol.
   */
***************
*** 2845,2855 ****
  		validate_cursor();
  # endif
  	    restart_edit = restart_edit_save;
- # ifdef FEAT_MBYTE
  	    /* Correct cursor for multi-byte character. */
  	    if (has_mbyte)
  		mb_adjust_cursor();
- # endif
  	    redraw_later(VALID);
  
  	    /* Only scroll when 'scrollbind' hasn't done this. */
--- 2845,2853 ----
*** ../vim-8.1.0805/src/normal.c	2019-01-19 17:43:03.421449119 +0100
--- src/normal.c	2019-01-24 15:41:20.432534170 +0100
***************
*** 477,487 ****
      int		top, bot;
      int		c;
  
- #ifdef FEAT_MBYTE
      /* A multi-byte character is never a command. */
      if (cmdchar >= 0x100)
  	return -1;
- #endif
  
      /* We use the absolute value of the character.  Special keys have a
       * negative value, but are sorted on their absolute value. */
--- 477,485 ----
***************
*** 1036,1042 ****
  		}
  	    }
  
- #ifdef FEAT_MBYTE
  	    /* When getting a text character and the next character is a
  	     * multi-byte character, it could be a composing character.
  	     * However, don't wait for it to arrive. Also, do enable mapping,
--- 1034,1039 ----
***************
*** 1058,1064 ****
  		    ca.ncharC2 = c;
  	    }
  	    ++no_mapping;
- #endif
  	}
  	--no_mapping;
  	--allow_keys;
--- 1055,1060 ----
***************
*** 1255,1264 ****
      checkpcmark();		/* check if we moved since setting pcmark */
      vim_free(ca.searchbuf);
  
- #ifdef FEAT_MBYTE
      if (has_mbyte)
  	mb_adjust_cursor();
- #endif
  
      if (curwin->w_p_scb && toplevel)
      {
--- 1251,1258 ----
***************
*** 1745,1751 ****
  	    }
  	}
  
- #ifdef FEAT_MBYTE
  	/* Include the trailing byte of a multi-byte char. */
  	if (has_mbyte && oap->inclusive)
  	{
--- 1739,1744 ----
***************
*** 1755,1761 ****
  	    if (l > 1)
  		oap->end.col += l - 1;
  	}
- #endif
  	curwin->w_set_curswant = TRUE;
  
  	/*
--- 1748,1753 ----
***************
*** 3133,3144 ****
  		{
  		    find_start_of_word(&VIsual);
  		    if (*p_sel == 'e' && *ml_get_cursor() != NUL)
- #ifdef FEAT_MBYTE
  			curwin->w_cursor.col +=
  					 (*mb_ptr2len)(ml_get_cursor());
- #else
- 			++curwin->w_cursor.col;
- #endif
  		    find_end_of_word(&curwin->w_cursor);
  		}
  	    }
--- 3125,3132 ----
***************
*** 3180,3188 ****
      while (pos->col > 0)
      {
  	col = pos->col - 1;
- #ifdef FEAT_MBYTE
  	col -= (*mb_head_off)(line, line + col);
- #endif
  	if (get_mouse_class(line + col) != cclass)
  	    break;
  	pos->col = col;
--- 3168,3174 ----
***************
*** 3204,3221 ****
      if (*p_sel == 'e' && pos->col > 0)
      {
  	--pos->col;
- #ifdef FEAT_MBYTE
  	pos->col -= (*mb_head_off)(line, line + pos->col);
- #endif
      }
      cclass = get_mouse_class(line + pos->col);
      while (line[pos->col] != NUL)
      {
- #ifdef FEAT_MBYTE
  	col = pos->col + (*mb_ptr2len)(line + pos->col);
- #else
- 	col = pos->col + 1;
- #endif
  	if (get_mouse_class(line + col) != cclass)
  	{
  	    if (*p_sel == 'e')
--- 3190,3201 ----
***************
*** 3238,3247 ****
  {
      int		c;
  
- #ifdef FEAT_MBYTE
      if (has_mbyte && MB_BYTE2LEN(p[0]) > 1)
  	return mb_get_class(p);
- #endif
  
      c = *p;
      if (c == ' ' || c == '\t')
--- 3218,3225 ----
***************
*** 3431,3441 ****
      char_u	*ptr;
      int		col = 0;	    /* init to shut up GCC */
      int		i;
- #ifdef FEAT_MBYTE
      int		this_class = 0;
      int		prev_class;
      int		prevcol;
- #endif
      int		bn = 0;	    /* bracket nesting */
  
      /*
--- 3409,3417 ----
***************
*** 3449,3455 ****
  	 * 1. skip to start of identifier/string
  	 */
  	col = startcol;
- #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	{
  	    while (ptr[col] != NUL)
--- 3425,3430 ----
***************
*** 3464,3470 ****
  	    }
  	}
  	else
- #endif
  	    while (ptr[col] != NUL
  		    && (i == 0 ? !vim_iswordc(ptr[col]) : VIM_ISWHITE(ptr[col]))
  		    && (!(find_type & FIND_EVAL) || ptr[col] != ']')
--- 3439,3444 ----
***************
*** 3477,3483 ****
  	/*
  	 * 2. Back up to start of identifier/string.
  	 */
- #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	{
  	    /* Remember class of character under cursor. */
--- 3451,3456 ----
***************
*** 3510,3516 ****
  		break;
  	}
  	else
- #endif
  	{
  	    while (col > 0
  		    && ((i == 0
--- 3483,3488 ----
***************
*** 3532,3542 ****
  	}
      }
  
!     if (ptr[col] == NUL || (i == 0 && (
! #ifdef FEAT_MBYTE
! 		has_mbyte ? this_class != 2 :
! #endif
! 		!vim_iswordc(ptr[col]))))
      {
  	/*
  	 * didn't find an identifier or string
--- 3504,3511 ----
  	}
      }
  
!     if (ptr[col] == NUL || (i == 0
! 		&& (has_mbyte ? this_class != 2 : !vim_iswordc(ptr[col]))))
      {
  	/*
  	 * didn't find an identifier or string
***************
*** 3556,3562 ****
      bn = 0;
      startcol -= col;
      col = 0;
- #ifdef FEAT_MBYTE
      if (has_mbyte)
      {
  	/* Search for point of changing multibyte character class. */
--- 3525,3530 ----
***************
*** 3571,3577 ****
  	    col += (*mb_ptr2len)(ptr + col);
      }
      else
- #endif
  	while ((i == 0 ? vim_iswordc(ptr[col])
  		       : (ptr[col] != NUL && !VIM_ISWHITE(ptr[col])))
  		    || ((find_type & FIND_EVAL)
--- 3539,3544 ----
***************
*** 3787,3797 ****
  	    }
  	    while ((*p_sel != 'e') ? s <= e : s < e)
  	    {
- # ifdef FEAT_MBYTE
  		l = (*mb_ptr2len)(s);
- # else
- 		l = (*s == NUL) ? 0 : 1;
- # endif
  		if (l == 0)
  		{
  		    ++bytes;
--- 3754,3760 ----
***************
*** 4558,4564 ****
      else
  	coladvance(curwin->w_curswant);
  
- #if defined(FEAT_LINEBREAK) || defined(FEAT_MBYTE)
      if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)
      {
  	colnr_T virtcol;
--- 4521,4526 ----
***************
*** 4570,4579 ****
  	 */
  	validate_virtcol();
  	virtcol = curwin->w_virtcol;
! # if defined(FEAT_LINEBREAK)
  	if (virtcol > (colnr_T)width1 && *p_sbr != NUL)
  	    virtcol -= vim_strsize(p_sbr);
! # endif
  
  	if (virtcol > curwin->w_curswant
  		&& (curwin->w_curswant < (colnr_T)width1
--- 4532,4541 ----
  	 */
  	validate_virtcol();
  	virtcol = curwin->w_virtcol;
! #if defined(FEAT_LINEBREAK)
  	if (virtcol > (colnr_T)width1 && *p_sbr != NUL)
  	    virtcol -= vim_strsize(p_sbr);
! #endif
  
  	if (virtcol > curwin->w_curswant
  		&& (curwin->w_curswant < (colnr_T)width1
***************
*** 4582,4588 ****
  						      > (colnr_T)width2 / 2)))
  	    --curwin->w_cursor.col;
      }
- #endif
  
      if (atend)
  	curwin->w_curswant = MAXCOL;	    /* stick in the last column */
--- 4544,4549 ----
***************
*** 5768,5774 ****
  	    /* put a backslash before \ and some others */
  	    if (vim_strchr(aux_ptr, *ptr) != NULL)
  		*p++ = '\\';
- #ifdef FEAT_MBYTE
  	    /* When current byte is a part of multibyte character, copy all
  	     * bytes of that character. */
  	    if (has_mbyte)
--- 5729,5734 ----
***************
*** 5779,5785 ****
  		for (i = 0; i < len && n >= 1; ++i, --n)
  		    *p++ = *ptr++;
  	    }
- #endif
  	    *p++ = *ptr++;
  	}
  	*p = NUL;
--- 5739,5744 ----
***************
*** 5790,5800 ****
       */
      if (cmdchar == '*' || cmdchar == '#')
      {
! 	if (!g_cmd && (
! #ifdef FEAT_MBYTE
! 		has_mbyte ? vim_iswordp(mb_prevptr(ml_get_curline(), ptr)) :
! #endif
! 		vim_iswordc(ptr[-1])))
  	    STRCAT(buf, "\\>");
  #ifdef FEAT_CMDHIST
  	/* put pattern in search history */
--- 5749,5757 ----
       */
      if (cmdchar == '*' || cmdchar == '#')
      {
! 	if (!g_cmd && (has_mbyte
! 		    ? vim_iswordp(mb_prevptr(ml_get_curline(), ptr))
! 		    : vim_iswordc(ptr[-1])))
  	    STRCAT(buf, "\\>");
  #ifdef FEAT_CMDHIST
  	/* put pattern in search history */
***************
*** 5844,5854 ****
  	    *pp = ml_get_pos(&VIsual);
  	    *lenp = curwin->w_cursor.col - VIsual.col + 1;
  	}
- #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	    /* Correct the length to include the whole last character. */
  	    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;
- #endif
      }
      reset_VIsual_and_resel();
      return OK;
--- 5801,5809 ----
***************
*** 6058,6069 ****
  	    else
  #endif
  	    {
- #ifdef FEAT_MBYTE
  		if (has_mbyte)
  		    curwin->w_cursor.col +=
  					 (*mb_ptr2len)(ml_get_cursor());
  		else
- #endif
  		    ++curwin->w_cursor.col;
  	    }
  	}
--- 6013,6022 ----
***************
*** 6129,6139 ****
  
  		    if (*cp != NUL)
  		    {
- #ifdef FEAT_MBYTE
  			if (has_mbyte)
  			    curwin->w_cursor.col += (*mb_ptr2len)(cp);
  			else
- #endif
  			    ++curwin->w_cursor.col;
  		    }
  		    cap->retval |= CA_NO_ADJ_OP_END;
--- 6082,6090 ----
***************
*** 7060,7069 ****
      /* Abort if not enough characters to replace. */
      ptr = ml_get_cursor();
      if (STRLEN(ptr) < (unsigned)cap->count1
! #ifdef FEAT_MBYTE
! 	    || (has_mbyte && mb_charlen(ptr) < cap->count1)
! #endif
! 	    )
      {
  	clearopbeep(cap->oap);
  	return;
--- 7011,7017 ----
      /* Abort if not enough characters to replace. */
      ptr = ml_get_cursor();
      if (STRLEN(ptr) < (unsigned)cap->count1
! 	    || (has_mbyte && mb_charlen(ptr) < cap->count1))
      {
  	clearopbeep(cap->oap);
  	return;
***************
*** 7098,7108 ****
  	 * autoindent.	The insert command depends on being on the last
  	 * character of a line or not.
  	 */
- #ifdef FEAT_MBYTE
  	(void)del_chars(cap->count1, FALSE);	/* delete the characters */
- #else
- 	(void)del_bytes(cap->count1, FALSE, FALSE); /* delete the characters */
- #endif
  	stuffcharReadbuff('\r');
  	stuffcharReadbuff(ESC);
  
--- 7046,7052 ----
***************
*** 7115,7121 ****
  				       NUL, 'r', NUL, had_ctrl_v, cap->nchar);
  
  	curbuf->b_op_start = curwin->w_cursor;
- #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	{
  	    int		old_State = State;
--- 7059,7064 ----
***************
*** 7151,7157 ****
  	    }
  	}
  	else
- #endif
  	{
  	    /*
  	     * Replace the characters within one line.
--- 7094,7099 ----
***************
*** 7194,7205 ****
  			       (colnr_T)(curwin->w_cursor.col - cap->count1));
  	}
  	--curwin->w_cursor.col;	    /* cursor on the last replaced char */
- #ifdef FEAT_MBYTE
  	/* if the character on the left of the current cursor is a multi-byte
  	 * character, move two characters left */
  	if (has_mbyte)
  	    mb_adjust_cursor();
- #endif
  	curbuf->b_op_end = curwin->w_cursor;
  	curwin->w_set_curswant = TRUE;
  	set_last_insert(cap->nchar);
--- 7136,7145 ----
***************
*** 8202,8208 ****
  		    validate_virtcol();
  		    curwin->w_curswant = curwin->w_virtcol;
  		    curwin->w_set_curswant = FALSE;
- #if defined(FEAT_LINEBREAK) || defined(FEAT_MBYTE)
  		    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)
  		    {
  			/*
--- 8142,8147 ----
***************
*** 8213,8219 ****
  			if (curwin->w_virtcol > (colnr_T)i)
  			    --curwin->w_cursor.col;
  		    }
- #endif
  		}
  		else if (nv_screengo(oap, FORWARD, cap->count1 - 1) == FAIL)
  		    clearopbeep(oap);
--- 8152,8157 ----
***************
*** 8328,8334 ****
  	do_ascii(NULL);
  	break;
  
- #ifdef FEAT_MBYTE
      /*
       * "g8": Display the bytes used for the UTF-8 character under the
       * cursor.	It is displayed in hex.
--- 8266,8271 ----
***************
*** 8340,8346 ****
  	else
  	    show_utf8();
  	break;
- #endif
  
      /* "g<": show scrollback text */
      case '<':
--- 8277,8282 ----
***************
*** 8843,8853 ****
  		)
      {
  	--curwin->w_cursor.col;
- #ifdef FEAT_MBYTE
  	/* prevent cursor from moving on the trail byte */
  	if (has_mbyte)
  	    mb_adjust_cursor();
- #endif
  	oap->inclusive = TRUE;
      }
  }
--- 8779,8787 ----
***************
*** 8879,8889 ****
      if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'
  	    && gchar_cursor() != NUL && LT_POS(VIsual, curwin->w_cursor))
      {
- #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	    inc_cursor();
  	else
- #endif
  	    ++curwin->w_cursor.col;
  	cap->oap->inclusive = FALSE;
      }
--- 8813,8821 ----
***************
*** 8913,8921 ****
  	if (pp->col > 0)
  	{
  	    --pp->col;
- #ifdef FEAT_MBYTE
  	    mb_adjustpos(curbuf, pp);
- #endif
  	}
  	else if (pp->lnum > 1)
  	{
--- 8845,8851 ----
***************
*** 9646,9656 ****
  
      oap->block_mode = TRUE;
  
- #ifdef FEAT_MBYTE
      /* prevent from moving onto a trail byte */
      if (has_mbyte)
  	mb_adjustpos(curwin->w_buffer, &oap->end);
- #endif
  
      getvvcol(curwin, &(oap->start), &oap->start_vcol, NULL, &oap->end_vcol);
  
--- 9576,9584 ----
*** ../vim-8.1.0805/src/ops.c	2019-01-20 15:30:36.889328720 +0100
--- src/ops.c	2019-01-24 15:44:26.003148115 +0100
***************
*** 97,105 ****
  static int	put_in_typebuf(char_u *s, int esc, int colon,
  								 int silent);
  static void	stuffescaped(char_u *arg, int literally);
- #ifdef FEAT_MBYTE
  static void	mb_adjust_opend(oparg_T *oap);
- #endif
  static void	free_yank_all(void);
  static int	yank_copy_line(struct block_def *bd, long y_idx);
  #ifdef FEAT_CLIPBOARD
--- 97,103 ----
***************
*** 421,427 ****
  	ws_vcol = bd.start_vcol - bd.pre_whitesp;
  	if (bd.startspaces)
  	{
- #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  	    {
  		if ((*mb_ptr2len)(bd.textstart) == 1)
--- 419,424 ----
***************
*** 433,439 ****
  		}
  	    }
  	    else
- #endif
  		++bd.textstart;
  	}
  	for ( ; VIM_ISWHITE(*bd.textstart); )
--- 430,435 ----
***************
*** 632,638 ****
  	    }
  	}
  
- #ifdef FEAT_MBYTE
  	if (has_mbyte && spaces > 0)
  	{
  	    int off;
--- 628,633 ----
***************
*** 650,656 ****
  	    spaces -= off;
  	    count -= off;
  	}
- #endif
  
  	newp = alloc_check((unsigned)(STRLEN(oldp)) + s_len + count + 1);
  	if (newp == NULL)
--- 645,650 ----
***************
*** 1491,1501 ****
  	/* stuff a single special character */
  	if (*arg != NUL)
  	{
- #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  		c = mb_cptr2char_adv(&arg);
  	    else
- #endif
  		c = *arg++;
  	    if (literally && ((c < ' ' && c != TAB) || c == DEL))
  		stuffcharReadbuff(Ctrl_V);
--- 1485,1493 ----
***************
*** 1774,1783 ****
      adjust_clip_reg(&oap->regname);
  #endif
  
- #ifdef FEAT_MBYTE
      if (has_mbyte)
  	mb_adjust_opend(oap);
- #endif
  
      /*
       * Imitate the strange Vi behaviour: If the delete spans more than one
--- 1766,1773 ----
***************
*** 2109,2115 ****
      return OK;
  }
  
- #ifdef FEAT_MBYTE
  /*
   * Adjust end of operating area for ending on a multi-byte character.
   * Used for deletion.
--- 2099,2104 ----
***************
*** 2125,2134 ****
  	oap->end.col += mb_tail_off(p, p + oap->end.col);
      }
  }
- #endif
  
- 
- #ifdef FEAT_MBYTE
  /*
   * Replace the character under the cursor with "c".
   * This takes care of multi-byte characters.
--- 2114,2120 ----
***************
*** 2144,2150 ****
      /* Backup to the replaced character. */
      dec_cursor();
  }
- #endif
  
  /*
   * Replace a whole area with one character.
--- 2130,2135 ----
***************
*** 2153,2161 ****
  op_replace(oparg_T *oap, int c)
  {
      int			n, numc;
- #ifdef FEAT_MBYTE
      int			num_chars;
- #endif
      char_u		*newp, *oldp;
      size_t		oldlen;
      struct block_def	bd;
--- 2138,2144 ----
***************
*** 2176,2185 ****
  	c = NL;
      }
  
- #ifdef FEAT_MBYTE
      if (has_mbyte)
  	mb_adjust_opend(oap);
- #endif
  
      if (u_save((linenr_T)(oap->start.lnum - 1),
  				       (linenr_T)(oap->end.lnum + 1)) == FAIL)
--- 2159,2166 ----
***************
*** 2230,2236 ****
  	    if (bd.is_short && (!virtual_op || bd.is_MAX))
  		numc -= (oap->end_vcol - bd.end_vcol) + 1;
  
- #ifdef FEAT_MBYTE
  	    /* A double-wide character can be replaced only up to half the
  	     * times. */
  	    if ((*mb_char2cells)(c) > 1)
--- 2211,2216 ----
***************
*** 2246,2252 ****
  	    /* Compute bytes needed, move character count to num_chars. */
  	    num_chars = numc;
  	    numc *= (*mb_char2len)(c);
- #endif
  	    /* oldlen includes textlen, so don't double count */
  	    n += numc - bd.textlen;
  
--- 2226,2231 ----
***************
*** 2266,2272 ****
  	     * literally. */
  	    if (had_ctrl_v_cr || (c != '\r' && c != '\n'))
  	    {
- #ifdef FEAT_MBYTE
  		if (has_mbyte)
  		{
  		    n = (int)STRLEN(newp);
--- 2245,2250 ----
***************
*** 2274,2280 ****
  			n += (*mb_char2bytes)(c, newp + n);
  		}
  		else
- #endif
  		    vim_memset(newp + STRLEN(newp), c, (size_t)numc);
  		if (!bd.is_short)
  		{
--- 2252,2257 ----
***************
*** 2324,2330 ****
  	    n = gchar_cursor();
  	    if (n != NUL)
  	    {
- #ifdef FEAT_MBYTE
  		if ((*mb_char2len)(c) > 1 || (*mb_char2len)(n) > 1)
  		{
  		    /* This is slow, but it handles replacing a single-byte
--- 2301,2306 ----
***************
*** 2334,2340 ****
  		    replace_character(c);
  		}
  		else
- #endif
  		{
  #ifdef FEAT_VIRTUALEDIT
  		    if (n == TAB)
--- 2310,2315 ----
***************
*** 2372,2382 ****
  		curwin->w_cursor.col -= (virtcols + 1);
  		for (; virtcols >= 0; virtcols--)
  		{
- # ifdef FEAT_MBYTE
                     if ((*mb_char2len)(c) > 1)
  		       replace_character(c);
                     else
- # endif
  			PBYTE(curwin->w_cursor, c);
  		   if (inc(&curwin->w_cursor) == -1)
  		       break;
--- 2347,2355 ----
***************
*** 2530,2536 ****
  
      for (todo = length; todo > 0; --todo)
      {
- # ifdef FEAT_MBYTE
  	if (has_mbyte)
  	{
  	    int len = (*mb_ptr2len)(ml_get_pos(pos));
--- 2503,2508 ----
***************
*** 2539,2545 ****
  	    if (len > 0)
  		todo -= len - 1;
  	}
- # endif
  	did_change |= swapchar(op_type, pos);
  	if (inc(pos) == -1)    /* at end of file */
  	    break;
--- 2511,2516 ----
***************
*** 2566,2572 ****
      if (c >= 0x80 && op_type == OP_ROT13)
  	return FALSE;
  
- #ifdef FEAT_MBYTE
      if (op_type == OP_UPPER && c == 0xdf
  		      && (enc_latin1like || STRCMP(p_enc, "iso-8859-2") == 0))
      {
--- 2537,2542 ----
***************
*** 2583,2589 ****
  
      if (enc_dbcs != 0 && c >= 0x100)	/* No lower/uppercase letter */
  	return FALSE;
- #endif
      nc = c;
      if (MB_ISLOWER(c))
      {
--- 2553,2558 ----
***************
*** 2601,2607 ****
      }
      if (nc != c)
      {
- #ifdef FEAT_MBYTE
  	if (enc_utf8 && (c >= 0x80 || nc >= 0x80))
  	{
  	    pos_T   sp = curwin->w_cursor;
--- 2570,2575 ----
***************
*** 2613,2619 ****
  	    curwin->w_cursor = sp;
  	}
  	else
- #endif
  	    PBYTE(*pos, nc);
  	return TRUE;
      }
--- 2581,2586 ----
***************
*** 3216,3228 ****
  			{
  			    getvcol(curwin, &oap->end, &cs, NULL, &ce);
  			    if (p[endcol] == NUL || (cs + oap->end.coladd < ce
- # ifdef FEAT_MBYTE
  					/* Don't add space for double-wide
  					 * char; endcol will be on last byte
  					 * of multi-byte char. */
! 					&& (*mb_head_off)(p, p + endcol) == 0
! # endif
! 					))
  			    {
  				if (oap->start.lnum == oap->end.lnum
  					    && oap->start.col == oap->end.col)
--- 3183,3192 ----
  			{
  			    getvcol(curwin, &oap->end, &cs, NULL, &ce);
  			    if (p[endcol] == NUL || (cs + oap->end.coladd < ce
  					/* Don't add space for double-wide
  					 * char; endcol will be on last byte
  					 * of multi-byte char. */
! 					&& (*mb_head_off)(p, p + endcol) == 0))
  			    {
  				if (oap->start.lnum == oap->end.lnum
  					    && oap->start.col == oap->end.col)
***************
*** 3745,3756 ****
  #endif
  		getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);
  
- #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  		/* move to start of next multi-byte character */
  		curwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());
  	    else
- #endif
  #ifdef FEAT_VIRTUALEDIT
  	    if (c != TAB || ve_flags != VE_ALL)
  #endif
--- 3709,3718 ----
***************
*** 3820,3829 ****
  		bd.startspaces = incr - bd.endspaces;
  		--bd.textcol;
  		delcount = 1;
- #ifdef FEAT_MBYTE
  		if (has_mbyte)
  		    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);
- #endif
  		if (oldp[bd.textcol] != TAB)
  		{
  		    /* Only a Tab can be split into spaces.  Other
--- 3782,3789 ----
***************
*** 3919,3925 ****
  	     * char */
  	    if (dir == FORWARD && gchar_cursor() != NUL)
  	    {
- #ifdef FEAT_MBYTE
  		if (has_mbyte)
  		{
  		    int bytelen = (*mb_ptr2len)(ml_get_cursor());
--- 3879,3884 ----
***************
*** 3933,3939 ****
  		    }
  		}
  		else
- #endif
  		{
  		    ++col;
  		    if (yanklen)
--- 3892,3897 ----
***************
*** 4279,4289 ****
      int		name;
      int		attr;
      char_u	*arg = eap->arg;
- #ifdef FEAT_MBYTE
      int		clen;
- #else
- # define clen 1
- #endif
  
      if (arg != NULL && *arg == NUL)
  	arg = NULL;
--- 4237,4243 ----
***************
*** 4344,4356 ****
  		}
  		for (p = yb->y_array[j]; *p && (n -= ptr2cells(p)) >= 0; ++p)
  		{
- #ifdef FEAT_MBYTE
  		    clen = (*mb_ptr2len)(p);
- #endif
  		    msg_outtrans_len(p, clen);
- #ifdef FEAT_MBYTE
  		    p += clen - 1;
- #endif
  		}
  	    }
  	    if (n > 1 && yb->y_type == MLINE)
--- 4298,4306 ----
***************
*** 4438,4460 ****
      int		skip_esc)	    /* if TRUE, ignore trailing ESC */
  {
      int		n;
- #ifdef FEAT_MBYTE
      int		l;
- #endif
  
      n = (int)Columns - 6;
      while (*p != NUL
  	    && !(*p == ESC && skip_esc && *(p + 1) == NUL)
  	    && (n -= ptr2cells(p)) >= 0)
      {
- #ifdef FEAT_MBYTE
  	if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)
  	{
  	    msg_outtrans_len(p, l);
  	    p += l;
  	}
  	else
- #endif
  	    msg_outtrans_len(p++, 1);
      }
      ui_breakcheck();
--- 4388,4406 ----
***************
*** 4631,4642 ****
  	{
  	    curr = skipwhite(curr);
  	    if (*curr != ')' && currsize != 0 && endcurr1 != TAB
- #ifdef FEAT_MBYTE
  		    && (!has_format_option(FO_MBYTE_JOIN)
  			|| (mb_ptr2char(curr) < 0x100 && endcurr1 < 0x100))
  		    && (!has_format_option(FO_MBYTE_JOIN2)
  			|| mb_ptr2char(curr) < 0x100 || endcurr1 < 0x100)
- #endif
  	       )
  	    {
  		/* don't add a space if the line is ending in a space */
--- 4577,4586 ----
***************
*** 4657,4663 ****
  	endcurr1 = endcurr2 = NUL;
  	if (insert_space && currsize > 0)
  	{
- #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  	    {
  		cend = curr + currsize;
--- 4601,4606 ----
***************
*** 4670,4676 ****
  		}
  	    }
  	    else
- #endif
  	    {
  		endcurr1 = *(curr + currsize - 1);
  		if (currsize > 1)
--- 4613,4618 ----
***************
*** 5715,5734 ****
  	    while (col > 0 && vim_isbdigit(ptr[col]))
  	    {
  		--col;
- #ifdef FEAT_MBYTE
  		if (has_mbyte)
  		    col -= (*mb_head_off)(ptr, ptr + col);
- #endif
  	    }
  
  	if (dohex)
  	    while (col > 0 && vim_isxdigit(ptr[col]))
  	    {
  		--col;
- #ifdef FEAT_MBYTE
  		if (has_mbyte)
  		    col -= (*mb_head_off)(ptr, ptr + col);
- #endif
  	    }
  
  	if (       dobin
--- 5657,5672 ----
***************
*** 5737,5746 ****
  		    && (ptr[col] == 'X'
  			|| ptr[col] == 'x')
  		    && ptr[col - 1] == '0'
- #ifdef FEAT_MBYTE
  		    && (!has_mbyte ||
  			!(*mb_head_off)(ptr, ptr + col - 1))
- #endif
  		    && vim_isxdigit(ptr[col + 1]))))
  	{
  
--- 5675,5682 ----
***************
*** 5751,5760 ****
  	    while (col > 0 && vim_isdigit(ptr[col]))
  	    {
  		col--;
- #ifdef FEAT_MBYTE
  		if (has_mbyte)
  		    col -= (*mb_head_off)(ptr, ptr + col);
- #endif
  	    }
  	}
  
--- 5687,5694 ----
***************
*** 5763,5790 ****
  		&& (ptr[col] == 'X'
  		    || ptr[col] == 'x')
  		&& ptr[col - 1] == '0'
- #ifdef FEAT_MBYTE
  		&& (!has_mbyte ||
  		    !(*mb_head_off)(ptr, ptr + col - 1))
- #endif
  		&& vim_isxdigit(ptr[col + 1])) ||
  	    (       dobin
  		&& col > 0
  		&& (ptr[col] == 'B'
  		    || ptr[col] == 'b')
  		&& ptr[col - 1] == '0'
- #ifdef FEAT_MBYTE
  		&& (!has_mbyte ||
  		    !(*mb_head_off)(ptr, ptr + col - 1))
- #endif
  		&& vim_isbdigit(ptr[col + 1])))
  	{
  	    /* Found hexadecimal or binary number, move to its start. */
  	    --col;
- #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  		col -= (*mb_head_off)(ptr, ptr + col);
- #endif
  	}
  	else
  	{
--- 5697,5718 ----
***************
*** 5803,5812 ****
  		    && !(doalp && ASCII_ISALPHA(ptr[col])))
  	    {
  		--col;
- #ifdef FEAT_MBYTE
  		if (has_mbyte)
  		    col -= (*mb_head_off)(ptr, ptr + col);
- #endif
  	    }
  	}
      }
--- 5731,5738 ----
***************
*** 5827,5837 ****
  	    goto theend;
  
  	if (col > pos->col && ptr[col - 1] == '-'
! #ifdef FEAT_MBYTE
! 		&& (!has_mbyte ||
! 		    !(*mb_head_off)(ptr, ptr + col - 1))
! #endif
! 	   )
  	{
  	    negative = TRUE;
  	    was_positive = FALSE;
--- 5753,5759 ----
  	    goto theend;
  
  	if (col > pos->col && ptr[col - 1] == '-'
! 		&& (!has_mbyte || !(*mb_head_off)(ptr, ptr + col - 1)))
  	{
  	    negative = TRUE;
  	    was_positive = FALSE;
***************
*** 5895,5904 ****
      else
      {
  	if (col > 0 && ptr[col - 1] == '-'
- #ifdef FEAT_MBYTE
  		&& (!has_mbyte ||
  		    !(*mb_head_off)(ptr, ptr + col - 1))
- #endif
  		&& !visual)
  	{
  	    /* negative number */
--- 5817,5824 ----
***************
*** 6539,6545 ****
      if (dpy != NULL && str != NULL && motion_type >= 0
  					       && len < 1024*1024 && len > 0)
      {
- #ifdef FEAT_MBYTE
  	int ok = TRUE;
  
  	/* The CUT_BUFFER0 is supposed to always contain latin1.  Convert from
--- 6459,6464 ----
***************
*** 6579,6585 ****
  	/* Do not store the string if conversion failed.  Better to use any
  	 * other selection than garbled text. */
  	if (ok)
- #endif
  	{
  	    XStoreBuffer(dpy, (char *)str, (int)len, 0);
  	    XFlush(dpy);
--- 6498,6503 ----
***************
*** 7349,7359 ****
  	else if (!vim_isspace(line[i]))
  	    is_word = 1;
  	++chars;
- #ifdef FEAT_MBYTE
  	i += (*mb_ptr2len)(line + i);
- #else
- 	++i;
- #endif
      }
  
      if (is_word)
--- 7267,7273 ----
***************
*** 7384,7392 ****
      char_u	buf2[40];
      linenr_T	lnum;
      varnumber_T	byte_count = 0;
- #ifdef FEAT_MBYTE
      varnumber_T	bom_count  = 0;
- #endif
      varnumber_T	byte_count_cursor = 0;
      varnumber_T	char_count = 0;
      varnumber_T	char_count_cursor = 0;
--- 7298,7304 ----
***************
*** 7609,7620 ****
  	    }
  	}
  
- #ifdef FEAT_MBYTE
  	bom_count = bomb_size();
  	if (bom_count > 0)
  	    vim_snprintf((char *)IObuff + STRLEN(IObuff), IOSIZE,
! 				   _("(+%lld for BOM)"), (long_long_T)bom_count);
! #endif
  	if (dict == NULL)
  	{
  	    /* Don't shorten this message, the user asked for it. */
--- 7521,7530 ----
  	    }
  	}
  
  	bom_count = bomb_size();
  	if (bom_count > 0)
  	    vim_snprintf((char *)IObuff + STRLEN(IObuff), IOSIZE,
! 				 _("(+%lld for BOM)"), (long_long_T)bom_count);
  	if (dict == NULL)
  	{
  	    /* Don't shorten this message, the user asked for it. */
***************
*** 7629,7639 ****
      {
  	dict_add_number(dict, "words", word_count);
  	dict_add_number(dict, "chars", char_count);
! 	dict_add_number(dict, "bytes", byte_count
! # ifdef FEAT_MBYTE
! 		+ bom_count
! # endif
! 		);
  	dict_add_number(dict, VIsual_active ? "visual_bytes" : "cursor_bytes",
  		byte_count_cursor);
  	dict_add_number(dict, VIsual_active ? "visual_chars" : "cursor_chars",
--- 7539,7545 ----
      {
  	dict_add_number(dict, "words", word_count);
  	dict_add_number(dict, "chars", char_count);
! 	dict_add_number(dict, "bytes", byte_count + bom_count);
  	dict_add_number(dict, VIsual_active ? "visual_bytes" : "cursor_bytes",
  		byte_count_cursor);
  	dict_add_number(dict, VIsual_active ? "visual_chars" : "cursor_chars",
*** ../vim-8.1.0805/src/option.c	2019-01-20 15:30:36.889328720 +0100
--- src/option.c	2019-01-24 15:50:26.424493073 +0100
***************
*** 66,74 ****
  #endif
  #define PV_BIN		OPT_BUF(BV_BIN)
  #define PV_BL		OPT_BUF(BV_BL)
! #ifdef FEAT_MBYTE
! # define PV_BOMB	OPT_BUF(BV_BOMB)
! #endif
  #define PV_CI		OPT_BUF(BV_CI)
  #ifdef FEAT_CINDENT
  # define PV_CIN		OPT_BUF(BV_CIN)
--- 66,72 ----
  #endif
  #define PV_BIN		OPT_BUF(BV_BIN)
  #define PV_BL		OPT_BUF(BV_BL)
! #define PV_BOMB		OPT_BUF(BV_BOMB)
  #define PV_CI		OPT_BUF(BV_CI)
  #ifdef FEAT_CINDENT
  # define PV_CIN		OPT_BUF(BV_CIN)
***************
*** 101,109 ****
  #define PV_FIXEOL	OPT_BUF(BV_FIXEOL)
  #define PV_EP		OPT_BOTH(OPT_BUF(BV_EP))
  #define PV_ET		OPT_BUF(BV_ET)
! #ifdef FEAT_MBYTE
! # define PV_FENC	OPT_BUF(BV_FENC)
! #endif
  #if defined(FEAT_BEVAL) && defined(FEAT_EVAL)
  # define PV_BEXPR	OPT_BOTH(OPT_BUF(BV_BEXPR))
  #endif
--- 99,105 ----
  #define PV_FIXEOL	OPT_BUF(BV_FIXEOL)
  #define PV_EP		OPT_BOTH(OPT_BUF(BV_EP))
  #define PV_ET		OPT_BUF(BV_ET)
! #define PV_FENC		OPT_BUF(BV_FENC)
  #if defined(FEAT_BEVAL) && defined(FEAT_EVAL)
  # define PV_BEXPR	OPT_BOTH(OPT_BUF(BV_BEXPR))
  #endif
***************
*** 137,145 ****
  # define PV_LISP	OPT_BUF(BV_LISP)
  # define PV_LW		OPT_BOTH(OPT_BUF(BV_LW))
  #endif
! #ifdef FEAT_MBYTE
! # define PV_MENC	OPT_BOTH(OPT_BUF(BV_MENC))
! #endif
  #define PV_MA		OPT_BUF(BV_MA)
  #define PV_ML		OPT_BUF(BV_ML)
  #define PV_MOD		OPT_BUF(BV_MOD)
--- 133,139 ----
  # define PV_LISP	OPT_BUF(BV_LISP)
  # define PV_LW		OPT_BOTH(OPT_BUF(BV_LW))
  #endif
! #define PV_MENC		OPT_BOTH(OPT_BUF(BV_MENC))
  #define PV_MA		OPT_BUF(BV_MA)
  #define PV_ML		OPT_BUF(BV_ML)
  #define PV_MOD		OPT_BUF(BV_MOD)
***************
*** 281,289 ****
   */
  static int	p_ai;
  static int	p_bin;
- #ifdef FEAT_MBYTE
  static int	p_bomb;
- #endif
  static char_u	*p_bh;
  static char_u	*p_bt;
  static int	p_bl;
--- 275,281 ----
***************
*** 312,320 ****
  static int	p_eol;
  static int	p_fixeol;
  static int	p_et;
- #ifdef FEAT_MBYTE
  static char_u	*p_fenc;
- #endif
  static char_u	*p_ff;
  static char_u	*p_fo;
  static char_u	*p_flp;
--- 304,310 ----
***************
*** 554,566 ****
  #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCTX_INIT},
      {"ambiwidth",  "ambw",  P_STRING|P_VI_DEF|P_RCLR,
- #if defined(FEAT_MBYTE)
  			    (char_u *)&p_ambw, PV_NONE,
  			    {(char_u *)"single", (char_u *)0L}
- #else
- 			    (char_u *)NULL, PV_NONE,
- 			    {(char_u *)0L, (char_u *)0L}
- #endif
  			    SCTX_INIT},
      {"autochdir",  "acd",   P_BOOL|P_VI_DEF,
  #ifdef FEAT_AUTOCHDIR
--- 544,551 ----
***************
*** 680,690 ****
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)TRUE, (char_u *)0L} SCTX_INIT},
      {"bomb",	    NULL,   P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
- #ifdef FEAT_MBYTE
  			    (char_u *)&p_bomb, PV_BOMB,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCTX_INIT},
      {"breakat",	    "brk",  P_STRING|P_VI_DEF|P_RALL|P_FLAGLIST,
  #ifdef FEAT_LINEBREAK
--- 665,671 ----
***************
*** 736,748 ****
  			    {(char_u *)"", (char_u *)0L}
  			    SCTX_INIT},
      {"casemap",	    "cmp",   P_STRING|P_VI_DEF|P_ONECOMMA|P_NODUP,
- #ifdef FEAT_MBYTE
  			    (char_u *)&p_cmp, PV_NONE,
  			    {(char_u *)"internal,keepascii", (char_u *)0L}
- #else
- 			    (char_u *)NULL, PV_NONE,
- 			    {(char_u *)0L, (char_u *)0L}
- #endif
  			    SCTX_INIT},
      {"cdpath",	    "cd",   P_STRING|P_EXPAND|P_VI_DEF|P_COMMA|P_NODUP,
  #ifdef FEAT_SEARCHPATH
--- 717,724 ----
***************
*** 763,769 ****
  #endif
  			    SCTX_INIT},
      {"charconvert",  "ccv", P_STRING|P_VI_DEF|P_SECURE,
! #if defined(FEAT_MBYTE) && defined(FEAT_EVAL)
  			    (char_u *)&p_ccv, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
  #else
--- 739,745 ----
  #endif
  			    SCTX_INIT},
      {"charconvert",  "ccv", P_STRING|P_VI_DEF|P_SECURE,
! #if defined(FEAT_EVAL)
  			    (char_u *)&p_ccv, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
  #else
***************
*** 1016,1026 ****
  #endif
  			    SCTX_INIT},
      {"delcombine", "deco",  P_BOOL|P_VI_DEF|P_VIM,
- #ifdef FEAT_MBYTE
  			    (char_u *)&p_deco, PV_NONE,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCTX_INIT},
      {"dictionary",  "dict", P_STRING|P_EXPAND|P_VI_DEF|P_ONECOMMA|P_NODUP|P_NDNAME,
  #ifdef FEAT_INS_EXPAND
--- 992,998 ----
***************
*** 1077,1098 ****
  			    (char_u *)&p_ed, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L} SCTX_INIT},
      {"emoji",  "emo",	    P_BOOL|P_VI_DEF|P_RCLR,
- #if defined(FEAT_MBYTE)
  			    (char_u *)&p_emoji, PV_NONE,
  			    {(char_u *)TRUE, (char_u *)0L}
- #else
- 			    (char_u *)NULL, PV_NONE,
- 			    {(char_u *)0L, (char_u *)0L}
- #endif
  			    SCTX_INIT},
      {"encoding",    "enc",  P_STRING|P_VI_DEF|P_RCLR|P_NO_ML,
- #ifdef FEAT_MBYTE
  			    (char_u *)&p_enc, PV_NONE,
  			    {(char_u *)ENC_DFLT, (char_u *)0L}
- #else
- 			    (char_u *)NULL, PV_NONE,
- 			    {(char_u *)0L, (char_u *)0L}
- #endif
  			    SCTX_INIT},
      {"endofline",   "eol",  P_BOOL|P_NO_MKRC|P_VI_DEF|P_RSTAT,
  			    (char_u *)&p_eol, PV_EOL,
--- 1049,1060 ----
***************
*** 1138,1159 ****
  			    {(char_u *)FALSE, (char_u *)0L} SCTX_INIT},
      {"fileencoding","fenc", P_STRING|P_ALLOCED|P_VI_DEF|P_RSTAT|P_RBUF
  								   |P_NO_MKRC,
- #ifdef FEAT_MBYTE
  			    (char_u *)&p_fenc, PV_FENC,
  			    {(char_u *)"", (char_u *)0L}
- #else
- 			    (char_u *)NULL, PV_NONE,
- 			    {(char_u *)0L, (char_u *)0L}
- #endif
  			    SCTX_INIT},
      {"fileencodings","fencs", P_STRING|P_VI_DEF|P_ONECOMMA,
- #ifdef FEAT_MBYTE
  			    (char_u *)&p_fencs, PV_NONE,
  			    {(char_u *)"ucs-bom", (char_u *)0L}
- #else
- 			    (char_u *)NULL, PV_NONE,
- 			    {(char_u *)0L, (char_u *)0L}
- #endif
  			    SCTX_INIT},
      {"fileformat",  "ff",   P_STRING|P_ALLOCED|P_VI_DEF|P_RSTAT|P_NO_MKRC
  								  |P_CURSWANT,
--- 1100,1111 ----
***************
*** 1416,1422 ****
  #endif
  			    SCTX_INIT},
      {"guifontwide", "gfw",  P_STRING|P_VI_DEF|P_RCLR|P_ONECOMMA|P_NODUP,
! #if defined(FEAT_GUI) && defined(FEAT_MBYTE)
  			    (char_u *)&p_guifontwide, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
  #else
--- 1368,1374 ----
  #endif
  			    SCTX_INIT},
      {"guifontwide", "gfw",  P_STRING|P_VI_DEF|P_RCLR|P_ONECOMMA|P_NODUP,
! #if defined(FEAT_GUI)
  			    (char_u *)&p_guifontwide, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
  #else
***************
*** 1533,1539 ****
  			    (char_u *)&p_ic, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L} SCTX_INIT},
      {"imactivatefunc","imaf",P_STRING|P_VI_DEF|P_SECURE,
! #if defined(FEAT_EVAL) && defined(FEAT_MBYTE)
  			    (char_u *)&p_imaf, PV_NONE,
  			    {(char_u *)"", (char_u *)NULL}
  # else
--- 1485,1491 ----
  			    (char_u *)&p_ic, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L} SCTX_INIT},
      {"imactivatefunc","imaf",P_STRING|P_VI_DEF|P_SECURE,
! #if defined(FEAT_EVAL)
  			    (char_u *)&p_imaf, PV_NONE,
  			    {(char_u *)"", (char_u *)NULL}
  # else
***************
*** 1549,1566 ****
  #endif
  			    {(char_u *)"", (char_u *)0L} SCTX_INIT},
      {"imcmdline",   "imc",  P_BOOL|P_VI_DEF,
- #ifdef FEAT_MBYTE
  			    (char_u *)&p_imcmdline, PV_NONE,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCTX_INIT},
      {"imdisable",   "imd",  P_BOOL|P_VI_DEF,
- #ifdef FEAT_MBYTE
  			    (char_u *)&p_imdisable, PV_NONE,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  #ifdef __sgi
  			    {(char_u *)TRUE, (char_u *)0L}
  #else
--- 1501,1510 ----
***************
*** 1576,1582 ****
  			    {(char_u *)B_IMODE_USE_INSERT, (char_u *)0L}
  			    SCTX_INIT},
      {"imstatusfunc","imsf",P_STRING|P_VI_DEF|P_SECURE,
! #if defined(FEAT_EVAL) && defined(FEAT_MBYTE)
  			    (char_u *)&p_imsf, PV_NONE,
  			    {(char_u *)"", (char_u *)NULL}
  #else
--- 1520,1526 ----
  			    {(char_u *)B_IMODE_USE_INSERT, (char_u *)0L}
  			    SCTX_INIT},
      {"imstatusfunc","imsf",P_STRING|P_VI_DEF|P_SECURE,
! #if defined(FEAT_EVAL)
  			    (char_u *)&p_imsf, PV_NONE,
  			    {(char_u *)"", (char_u *)NULL}
  #else
***************
*** 1872,1884 ****
  #endif
  			    SCTX_INIT},
      {"makeencoding","menc", P_STRING|P_VI_DEF,
- #ifdef FEAT_MBYTE
  			    (char_u *)&p_menc, PV_MENC,
  			    {(char_u *)"", (char_u *)0L}
- #else
- 			    (char_u *)NULL, PV_NONE,
- 			    {(char_u *)0L, (char_u *)0L}
- #endif
  			    SCTX_INIT},
      {"makeprg",	    "mp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  #ifdef FEAT_QUICKFIX
--- 1816,1823 ----
***************
*** 1901,1911 ****
  			    (char_u *)&p_mat, PV_NONE,
  			    {(char_u *)5L, (char_u *)0L} SCTX_INIT},
      {"maxcombine",  "mco",  P_NUM|P_VI_DEF|P_CURSWANT,
- #ifdef FEAT_MBYTE
  			    (char_u *)&p_mco, PV_NONE,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)2, (char_u *)0L} SCTX_INIT},
      {"maxfuncdepth", "mfd", P_NUM|P_VI_DEF,
  #ifdef FEAT_EVAL
--- 1840,1846 ----
***************
*** 2197,2203 ****
  #endif
  			    SCTX_INIT},
     {"printmbcharset", "pmbcs",  P_STRING|P_VI_DEF,
! #if defined(FEAT_POSTSCRIPT) && defined(FEAT_MBYTE)
  			    (char_u *)&p_pmcs, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
  #else
--- 2132,2138 ----
  #endif
  			    SCTX_INIT},
     {"printmbcharset", "pmbcs",  P_STRING|P_VI_DEF,
! #if defined(FEAT_POSTSCRIPT)
  			    (char_u *)&p_pmcs, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
  #else
***************
*** 2206,2212 ****
  #endif
  			    SCTX_INIT},
      {"printmbfont", "pmbfn",  P_STRING|P_VI_DEF,
! #if defined(FEAT_POSTSCRIPT) && defined(FEAT_MBYTE)
  			    (char_u *)&p_pmfn, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
  #else
--- 2141,2147 ----
  #endif
  			    SCTX_INIT},
      {"printmbfont", "pmbfn",  P_STRING|P_VI_DEF,
! #if defined(FEAT_POSTSCRIPT)
  			    (char_u *)&p_pmfn, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
  #else
***************
*** 2748,2760 ****
  #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCTX_INIT},
      {"termencoding", "tenc", P_STRING|P_VI_DEF|P_RCLR,
- #ifdef FEAT_MBYTE
  			    (char_u *)&p_tenc, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
- #else
- 			    (char_u *)NULL, PV_NONE,
- 			    {(char_u *)0L, (char_u *)0L}
- #endif
  			    SCTX_INIT},
      {"termguicolors", "tgc", P_BOOL|P_VI_DEF|P_VIM|P_RCLR,
  #ifdef FEAT_TERMGUICOLORS
--- 2683,2690 ----
***************
*** 3238,3246 ****
  
  #define PARAM_COUNT (sizeof(options) / sizeof(struct vimoption))
  
- #ifdef FEAT_MBYTE
  static char *(p_ambw_values[]) = {"single", "double", NULL};
- #endif
  static char *(p_bg_values[]) = {"light", "dark", NULL};
  static char *(p_nf_values[]) = {"bin", "octal", "hex", "alpha", NULL};
  static char *(p_ff_values[]) = {FF_UNIX, FF_DOS, FF_MAC, NULL};
--- 3168,3174 ----
***************
*** 3643,3649 ****
  
      didset_options2();
  
- #ifdef FEAT_MBYTE
  # if defined(WIN3264) && defined(FEAT_GETTEXT)
      /*
       * If $LANG isn't set, try to get a good value for it.  This makes the
--- 3571,3576 ----
***************
*** 3727,3733 ****
  	    }
  #endif
  
! # if defined(WIN3264) && !defined(FEAT_GUI)
  	    /* Win32 console: When GetACP() returns a different value from
  	     * GetConsoleCP() set 'termencoding'. */
  	    if (GetACP() != GetConsoleCP())
--- 3654,3660 ----
  	    }
  #endif
  
! #if defined(WIN3264) && !defined(FEAT_GUI)
  	    /* Win32 console: When GetACP() returns a different value from
  	     * GetConsoleCP() set 'termencoding'. */
  	    if (GetACP() != GetConsoleCP())
***************
*** 3750,3760 ****
  		else
  		    p_tenc = empty_option;
  	    }
! # endif
! # if defined(WIN3264) && defined(FEAT_MBYTE)
  	    /* $HOME may have characters in active code page. */
  	    init_homedir();
! # endif
  	}
  	else
  	{
--- 3677,3687 ----
  		else
  		    p_tenc = empty_option;
  	    }
! #endif
! #if defined(WIN3264)
  	    /* $HOME may have characters in active code page. */
  	    init_homedir();
! #endif
  	}
  	else
  	{
***************
*** 3762,3768 ****
  	    p_enc = save_enc;
  	}
      }
- #endif
  
  #ifdef FEAT_MULTI_LANG
      /* Set the default for 'helplang'. */
--- 3689,3694 ----
***************
*** 3859,3877 ****
  
      for (i = 0; !istermoption(&options[i]); i++)
  	if (!(options[i].flags & P_NODEFAULT)
- #if defined(FEAT_MBYTE) || defined(FEAT_CRYPT)
  		&& (opt_flags == 0
! 		    || (TRUE
! # if defined(FEAT_MBYTE)
! 			&& options[i].var != (char_u *)&p_enc
! # endif
  # if defined(FEAT_CRYPT)
  			&& options[i].var != (char_u *)&p_cm
  			&& options[i].var != (char_u *)&p_key
  # endif
! 			))
! #endif
! 			)
  	    set_option_default(i, opt_flags, p_cp);
  
      /* The 'scroll' option must be computed for all windows. */
--- 3785,3797 ----
  
      for (i = 0; !istermoption(&options[i]); i++)
  	if (!(options[i].flags & P_NODEFAULT)
  		&& (opt_flags == 0
! 		    || (options[i].var != (char_u *)&p_enc
  # if defined(FEAT_CRYPT)
  			&& options[i].var != (char_u *)&p_cm
  			&& options[i].var != (char_u *)&p_key
  # endif
! 			)))
  	    set_option_default(i, opt_flags, p_cp);
  
      /* The 'scroll' option must be computed for all windows. */
***************
*** 5018,5024 ****
  #endif
  								    )
  				    ++arg;	/* remove backslash */
- #ifdef FEAT_MBYTE
  				if (has_mbyte
  					&& (i = (*mb_ptr2len)(arg)) > 1)
  				{
--- 4938,4943 ----
***************
*** 5028,5034 ****
  				    s += i;
  				}
  				else
- #endif
  				    *s++ = *arg++;
  			    }
  			    *s = NUL;
--- 4947,4952 ----
***************
*** 5596,5604 ****
      /* initialize the table for 'iskeyword' et.al. */
      (void)init_chartab();
  
- #ifdef FEAT_MBYTE
      (void)opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, TRUE);
- #endif
      (void)opt_strings_flags(p_bkc, p_bkc_values, &bkc_flags, TRUE);
      (void)opt_strings_flags(p_bo, p_bo_values, &bo_flags, TRUE);
  #ifdef FEAT_SESSION
--- 5514,5520 ----
***************
*** 5689,5697 ****
  {
      check_string_option(&buf->b_p_bh);
      check_string_option(&buf->b_p_bt);
- #ifdef FEAT_MBYTE
      check_string_option(&buf->b_p_fenc);
- #endif
      check_string_option(&buf->b_p_ff);
  #ifdef FEAT_FIND_ID
      check_string_option(&buf->b_p_def);
--- 5605,5611 ----
***************
*** 5780,5788 ****
      check_string_option(&buf->b_p_lw);
  #endif
      check_string_option(&buf->b_p_bkc);
- #ifdef FEAT_MBYTE
      check_string_option(&buf->b_p_menc);
- #endif
  #ifdef FEAT_VARTABS
      check_string_option(&buf->b_p_vsts);
      check_string_option(&buf->b_p_vts);
--- 5694,5700 ----
***************
*** 6318,6324 ****
      }
  
      /* 'ambiwidth' */
- #ifdef FEAT_MBYTE
      else if (varp == &p_ambw || varp == &p_emoji)
      {
  	if (check_opt_strings(p_ambw, p_ambw_values, FALSE) != OK)
--- 6230,6235 ----
***************
*** 6328,6334 ****
  	else if (set_chars_option(&p_fcs) != NULL)
  	    errmsg = _("E835: Conflicts with value of 'fillchars'");
      }
- #endif
  
      /* 'background' */
      else if (varp == &p_bg)
--- 6239,6244 ----
***************
*** 6404,6410 ****
  	    errmsg = e_invarg;
      }
  
- #ifdef FEAT_MBYTE
      /* 'encoding', 'fileencoding', 'termencoding' and 'makeencoding' */
      else if (varp == &p_enc || gvarp == &p_fenc || varp == &p_tenc
  							   || gvarp == &p_menc)
--- 6314,6319 ----
***************
*** 6419,6428 ****
  		errmsg = e_invarg;
  	    else
  	    {
! # ifdef FEAT_TITLE
  		/* May show a "+" in the title now. */
  		redraw_titles();
! # endif
  		/* Add 'fileencoding' to the swap file. */
  		ml_setflags(curbuf);
  	    }
--- 6328,6337 ----
  		errmsg = e_invarg;
  	    else
  	    {
! #ifdef FEAT_TITLE
  		/* May show a "+" in the title now. */
  		redraw_titles();
! #endif
  		/* Add 'fileencoding' to the swap file. */
  		ml_setflags(curbuf);
  	    }
***************
*** 6439,6467 ****
  	    if (varp == &p_enc)
  	    {
  		errmsg = mb_init();
! # ifdef FEAT_TITLE
  		redraw_titles();
! # endif
  	    }
  	}
  
! # if defined(FEAT_GUI_GTK)
  	if (errmsg == NULL && varp == &p_tenc && gui.in_use)
  	{
  	    /* GTK+ 2 uses only a single encoding, and that is UTF-8. */
  	    if (STRCMP(p_tenc, "utf-8") != 0)
  		errmsg = N_("E617: Cannot be changed in the GTK+ 2 GUI");
  	}
! # endif
  
  	if (errmsg == NULL)
  	{
! # ifdef FEAT_KEYMAP
  	    /* When 'keymap' is used and 'encoding' changes, reload the keymap
  	     * (with another encoding). */
  	    if (varp == &p_enc && *curbuf->b_p_keymap != NUL)
  		(void)keymap_init();
! # endif
  
  	    /* When 'termencoding' is not empty and 'encoding' changes or when
  	     * 'termencoding' changes, need to setup for keyboard input and
--- 6348,6376 ----
  	    if (varp == &p_enc)
  	    {
  		errmsg = mb_init();
! #ifdef FEAT_TITLE
  		redraw_titles();
! #endif
  	    }
  	}
  
! #if defined(FEAT_GUI_GTK)
  	if (errmsg == NULL && varp == &p_tenc && gui.in_use)
  	{
  	    /* GTK+ 2 uses only a single encoding, and that is UTF-8. */
  	    if (STRCMP(p_tenc, "utf-8") != 0)
  		errmsg = N_("E617: Cannot be changed in the GTK+ 2 GUI");
  	}
! #endif
  
  	if (errmsg == NULL)
  	{
! #ifdef FEAT_KEYMAP
  	    /* When 'keymap' is used and 'encoding' changes, reload the keymap
  	     * (with another encoding). */
  	    if (varp == &p_enc && *curbuf->b_p_keymap != NUL)
  		(void)keymap_init();
! #endif
  
  	    /* When 'termencoding' is not empty and 'encoding' changes or when
  	     * 'termencoding' changes, need to setup for keyboard input and
***************
*** 6477,6490 ****
  		}
  	    }
  
! # if defined(WIN3264) && defined(FEAT_MBYTE)
  	    /* $HOME may have characters in active code page. */
  	    if (varp == &p_enc)
  		init_homedir();
! # endif
  	}
      }
- #endif
  
  #if defined(FEAT_POSTSCRIPT)
      else if (varp == &p_penc)
--- 6386,6398 ----
  		}
  	    }
  
! #if defined(WIN3264)
  	    /* $HOME may have characters in active code page. */
  	    if (varp == &p_enc)
  		init_homedir();
! #endif
  	}
      }
  
  #if defined(FEAT_POSTSCRIPT)
      else if (varp == &p_penc)
***************
*** 6684,6690 ****
      /* 'matchpairs' */
      else if (gvarp == &p_mps)
      {
- #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	{
  	    for (p = *varp; *p != NUL; ++p)
--- 6592,6597 ----
***************
*** 6711,6717 ****
  	    }
  	}
  	else
- #endif
  	{
  	    /* Check for "x:y,x:y" */
  	    for (p = *varp; *p != NUL; p += 4)
--- 6618,6623 ----
***************
*** 6971,6977 ****
  	redraw_gui_only = TRUE;
      }
  # endif
- # ifdef FEAT_MBYTE
      else if (varp == &p_guifontwide)
      {
  	if (STRCMP(p_guifontwide, "*") == 0)
--- 6877,6882 ----
***************
*** 6980,6986 ****
  	    errmsg = N_("E534: Invalid wide font");
  	redraw_gui_only = TRUE;
      }
- # endif
  #endif
  
  #ifdef CURSOR_SHAPE
--- 6885,6890 ----
***************
*** 7001,7007 ****
  #ifdef FEAT_PRINTER
      else if (varp == &p_popt)
  	errmsg = parse_printoptions();
! # if defined(FEAT_MBYTE) && defined(FEAT_POSTSCRIPT)
      else if (varp == &p_pmfn)
  	errmsg = parse_printmbfont();
  # endif
--- 6905,6911 ----
  #ifdef FEAT_PRINTER
      else if (varp == &p_popt)
  	errmsg = parse_printoptions();
! # if defined(FEAT_POSTSCRIPT)
      else if (varp == &p_pmfn)
  	errmsg = parse_printmbfont();
  # endif
***************
*** 7395,7408 ****
  	    errmsg = e_invarg;
      }
  
- #ifdef FEAT_MBYTE
      /* 'casemap' */
      else if (varp == &p_cmp)
      {
  	if (opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, TRUE) != OK)
  	    errmsg = e_invarg;
      }
- #endif
  
  #ifdef FEAT_DIFF
      /* 'diffopt' */
--- 7299,7310 ----
***************
*** 8022,8054 ****
  		{
  		    c1 = c2 = c3 = 0;
  		    s = p + len + 1;
- #ifdef FEAT_MBYTE
  		    c1 = mb_ptr2char_adv(&s);
  		    if (mb_char2cells(c1) > 1)
  			continue;
- #else
- 		    c1 = *s++;
- #endif
  		    if (tab[i].cp == &lcs_tab2)
  		    {
  			if (*s == NUL)
  			    continue;
- #ifdef FEAT_MBYTE
  			c2 = mb_ptr2char_adv(&s);
  			if (mb_char2cells(c2) > 1)
  			    continue;
- #else
- 			c2 = *s++;
- #endif
  			if (!(*s == ',' || *s == NUL))
  			{
- #ifdef FEAT_MBYTE
  			    c3 = mb_ptr2char_adv(&s);
  			    if (mb_char2cells(c3) > 1)
  				continue;
- #else
- 			    c3 = *s++;
- #endif
  			}
  		    }
  
--- 7924,7944 ----
***************
*** 8506,8518 ****
      {
  	redraw_titles();
      }
- # ifdef FEAT_MBYTE
      /* when 'bomb' is changed, redraw the window title and tab page text */
      else if ((int *)varp == &curbuf->b_p_bomb)
      {
  	redraw_titles();
      }
- # endif
  #endif
  
      /* when 'bin' is set also set some other options */
--- 8396,8406 ----
***************
*** 8891,8900 ****
  #endif
  	    }
  
- # ifdef FEAT_MBYTE
  	    /* set 'delcombine' */
  	    p_deco = TRUE;
- # endif
  
  # ifdef FEAT_KEYMAP
  	    /* Force-set the necessary keymap for arabic */
--- 8779,8786 ----
***************
*** 9210,9216 ****
      }
  #endif
  
- #ifdef FEAT_MBYTE
      /* 'maxcombine' */
      else if (pp == &p_mco)
      {
--- 9096,9101 ----
***************
*** 9220,9226 ****
  	    p_mco = 0;
  	screenclear();	    /* will re-allocate the screen */
      }
- #endif
  
      else if (pp == &curbuf->b_p_iminsert)
      {
--- 9105,9110 ----
***************
*** 10078,10084 ****
      return (char_u *)NULL;
  }
  
- #if defined(FEAT_MBYTE) || defined(PROTO)
      char_u *
  get_encoding_default(void)
  {
--- 9962,9967 ----
***************
*** 10089,10095 ****
  	return options[i].def_val[VI_DEFAULT];
      return (char_u *)NULL;
  }
- #endif
  
  /*
   * Translate a string like "t_xx", "<t_xx>" or "<S-Tab>" to a key number.
--- 9972,9977 ----
***************
*** 10794,10804 ****
  	    clear_string_option(&buf->b_p_lw);
  	    break;
  #endif
- #ifdef FEAT_MBYTE
  	case PV_MENC:
  	    clear_string_option(&buf->b_p_menc);
  	    break;
- #endif
      }
  }
  #endif
--- 10676,10684 ----
***************
*** 10853,10861 ****
  	    case PV_LW:   return (char_u *)&(curbuf->b_p_lw);
  #endif
  	    case PV_BKC:  return (char_u *)&(curbuf->b_p_bkc);
- #ifdef FEAT_MBYTE
  	    case PV_MENC: return (char_u *)&(curbuf->b_p_menc);
- #endif
  	}
  	return NULL; /* "cannot happen" */
      }
--- 10733,10739 ----
***************
*** 10931,10940 ****
  	case PV_LW:	return *curbuf->b_p_lw != NUL
  				    ? (char_u *)&(curbuf->b_p_lw) : p->var;
  #endif
- #ifdef FEAT_MBYTE
  	case PV_MENC:	return *curbuf->b_p_menc != NUL
  				    ? (char_u *)&(curbuf->b_p_menc) : p->var;
- #endif
  
  #ifdef FEAT_ARABIC
  	case PV_ARAB:	return (char_u *)&(curwin->w_p_arab);
--- 10809,10816 ----
***************
*** 11000,11008 ****
  
  	case PV_AI:	return (char_u *)&(curbuf->b_p_ai);
  	case PV_BIN:	return (char_u *)&(curbuf->b_p_bin);
- #ifdef FEAT_MBYTE
  	case PV_BOMB:	return (char_u *)&(curbuf->b_p_bomb);
- #endif
  	case PV_BH:	return (char_u *)&(curbuf->b_p_bh);
  	case PV_BT:	return (char_u *)&(curbuf->b_p_bt);
  	case PV_BL:	return (char_u *)&(curbuf->b_p_bl);
--- 10876,10882 ----
***************
*** 11031,11039 ****
  	case PV_EOL:	return (char_u *)&(curbuf->b_p_eol);
  	case PV_FIXEOL:	return (char_u *)&(curbuf->b_p_fixeol);
  	case PV_ET:	return (char_u *)&(curbuf->b_p_et);
- #ifdef FEAT_MBYTE
  	case PV_FENC:	return (char_u *)&(curbuf->b_p_fenc);
- #endif
  	case PV_FF:	return (char_u *)&(curbuf->b_p_ff);
  	case PV_FT:	return (char_u *)&(curbuf->b_p_ft);
  	case PV_FO:	return (char_u *)&(curbuf->b_p_fo);
--- 10905,10911 ----
***************
*** 11378,11386 ****
  		free_buf_options(buf, TRUE);
  		buf->b_p_ro = FALSE;		/* don't copy readonly */
  		buf->b_p_tx = p_tx;
- #ifdef FEAT_MBYTE
  		buf->b_p_fenc = vim_strsave(p_fenc);
- #endif
  		switch (*p_ffs)
  		{
  		    case 'm':
--- 11250,11256 ----
***************
*** 11410,11418 ****
  	    buf->b_p_wm_nopaste = p_wm_nopaste;
  	    buf->b_p_wm_nobin = p_wm_nobin;
  	    buf->b_p_bin = p_bin;
- #ifdef FEAT_MBYTE
  	    buf->b_p_bomb = p_bomb;
- #endif
  	    buf->b_p_fixeol = p_fixeol;
  	    buf->b_p_et = p_et;
  	    buf->b_p_et_nobin = p_et_nobin;
--- 11280,11286 ----
***************
*** 11549,11557 ****
  #ifdef FEAT_LISP
  	    buf->b_p_lw = empty_option;
  #endif
- #ifdef FEAT_MBYTE
  	    buf->b_p_menc = empty_option;
- #endif
  
  	    /*
  	     * Don't copy the options set by ex_help(), use the saved values,
--- 11417,11423 ----
***************
*** 12137,12149 ****
   *
   * langmap_mapchar[] maps any of 256 chars to an ASCII char used for Vim
   * commands.
!  * When FEAT_MBYTE is defined langmap_mapga.ga_data is a sorted table of
!  * langmap_entry_T.  This does the same as langmap_mapchar[] for characters >=
!  * 256.
!  */
! # if defined(FEAT_MBYTE) || defined(PROTO)
! /*
!  * With multi-byte support use growarray for 'langmap' chars >= 256
   */
  typedef struct
  {
--- 12003,12012 ----
   *
   * langmap_mapchar[] maps any of 256 chars to an ASCII char used for Vim
   * commands.
!  * langmap_mapga.ga_data is a sorted table of langmap_entry_T.  This does the
!  * same as langmap_mapchar[] for characters >= 256.
!  *
!  * Use growarray for 'langmap' chars >= 256
   */
  typedef struct
  {
***************
*** 12217,12223 ****
      }
      return c;  /* no entry found, return "c" unmodified */
  }
- # endif
  
      static void
  langmap_init(void)
--- 12080,12085 ----
***************
*** 12226,12234 ****
  
      for (i = 0; i < 256; i++)
  	langmap_mapchar[i] = i;	 /* we init with a one-to-one map */
- # ifdef FEAT_MBYTE
      ga_init2(&langmap_mapga, sizeof(langmap_entry_T), 8);
- # endif
  }
  
  /*
--- 12088,12094 ----
***************
*** 12242,12250 ****
      char_u  *p2;
      int	    from, to;
  
- #ifdef FEAT_MBYTE
      ga_clear(&langmap_mapga);		    /* clear the previous map first */
- #endif
      langmap_init();			    /* back to one-to-one map */
  
      for (p = p_langmap; p[0] != NUL; )
--- 12102,12108 ----
***************
*** 12268,12278 ****
  	    }
  	    if (p[0] == '\\' && p[1] != NUL)
  		++p;
- #ifdef FEAT_MBYTE
  	    from = (*mb_ptr2char)(p);
- #else
- 	    from = p[0];
- #endif
  	    to = NUL;
  	    if (p2 == NULL)
  	    {
--- 12126,12132 ----
***************
*** 12281,12291 ****
  		{
  		    if (p[0] == '\\')
  			++p;
- #ifdef FEAT_MBYTE
  		    to = (*mb_ptr2char)(p);
- #else
- 		    to = p[0];
- #endif
  		}
  	    }
  	    else
--- 12135,12141 ----
***************
*** 12294,12304 ****
  		{
  		    if (p2[0] == '\\')
  			++p2;
- #ifdef FEAT_MBYTE
  		    to = (*mb_ptr2char)(p2);
- #else
- 		    to = p2[0];
- #endif
  		}
  	    }
  	    if (to == NUL)
--- 12144,12150 ----
***************
*** 12308,12318 ****
  		return;
  	    }
  
- #ifdef FEAT_MBYTE
  	    if (from >= 256)
  		langmap_set_entry(from, to);
  	    else
- #endif
  		langmap_mapchar[from & 255] = to;
  
  	    /* Advance to next pair */
--- 12154,12162 ----
***************
*** 12813,12819 ****
  {
      buf->b_start_ffc = *buf->b_p_ff;
      buf->b_start_eol = buf->b_p_eol;
- #ifdef FEAT_MBYTE
      buf->b_start_bomb = buf->b_p_bomb;
  
      /* Only use free/alloc when necessary, they take time. */
--- 12657,12662 ----
***************
*** 12823,12829 ****
  	vim_free(buf->b_start_fenc);
  	buf->b_start_fenc = vim_strsave(buf->b_p_fenc);
      }
- #endif
  }
  
  /*
--- 12666,12671 ----
***************
*** 12850,12864 ****
  	return TRUE;
      if ((buf->b_p_bin || !buf->b_p_fixeol) && buf->b_start_eol != buf->b_p_eol)
  	return TRUE;
- #ifdef FEAT_MBYTE
      if (!buf->b_p_bin && buf->b_start_bomb != buf->b_p_bomb)
  	return TRUE;
      if (buf->b_start_fenc == NULL)
  	return (*buf->b_p_fenc != NUL);
      return (STRCMP(buf->b_start_fenc, buf->b_p_fenc) != 0);
- #else
-     return FALSE;
- #endif
  }
  
  /*
--- 12692,12702 ----
***************
*** 13244,13250 ****
      ptr = curbuf->b_p_mps;
      while (*ptr != NUL)
      {
- #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	{
  	    char_u *prev;
--- 13082,13087 ----
***************
*** 13284,13290 ****
  	    ptr += mb_ptr2len(ptr);
  	}
  	else
- #endif
  	{
  	    if (*ptr == *initc)
  	    {
--- 13121,13126 ----
*** ../vim-8.1.0805/src/charset.c	2019-01-24 15:04:44.662887892 +0100
--- src/charset.c	2019-01-24 15:52:54.887433134 +0100
***************
*** 1266,1272 ****
  #endif
         )
      {
- 	head = 0;
  	for (;;)
  	{
  	    head = 0;
--- 1266,1271 ----
*** ../vim-8.1.0805/src/version.c	2019-01-24 15:04:44.674887811 +0100
--- src/version.c	2019-01-24 15:50:45.136358654 +0100
***************
*** 793,794 ****
--- 793,796 ----
  {   /* Add new patch number below this line */
+ /**/
+     806,
  /**/

-- 
"Never be afraid to tell the world who you are."
                                        -- Anonymous

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
