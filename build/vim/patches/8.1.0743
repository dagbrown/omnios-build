To: vim_dev@googlegroups.com
Subject: Patch 8.1.07
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.1.0743
Problem:    Giving error messages is not flexible.
Solution:   Add semsg().  Change argument from "char_u *" to "char *", also
            for msg() and get rid of most MSG macros. (Ozaki Kiichi, closes
            #3302)  Also make emsg() accept a "char *" argument.  Get rid of
            an enormous number of type casts.
Files:	    src/blob.c, src/blowfish.c, src/buffer.c, src/channel.c,
            src/crypt.c, src/dict.c, src/diff.c, src/digraph.c, src/edit.c,
            src/eval.c, src/evalfunc.c, src/ex_cmds.c, src/ex_cmds.h,
            src/ex_cmds2.c, src/ex_docmd.c, src/ex_eval.c, src/ex_getln.c,
            src/farsi.h, src/fileio.c, src/fold.c, src/getchar.c,
            src/globals.h, src/gui.c, src/gui_at_fs.c, src/gui_at_sb.c,
            src/gui_beval.c, src/gui_gtk_x11.c, src/gui_mac.c,
            src/gui_photon.c, src/gui_w32.c, src/gui_x11.c, src/hangulin.c,
            src/hardcopy.c, src/hashtab.c, src/if_cscope.c, src/if_lua.c,
            src/if_mzsch.c, src/if_perl.xs, src/if_py_both.h, src/if_python.c,
            src/if_python3.c, src/if_ruby.c, src/if_tcl.c, src/if_xcmdsrv.c,
            src/json.c, src/list.c, src/main.c, src/mark.c, src/mbyte.c,
            src/memfile.c, src/memline.c, src/menu.c, src/message.c,
            src/misc1.c, src/misc2.c, src/netbeans.c, src/normal.c, src/ops.c,
            src/option.c, src/os_amiga.c, src/os_mswin.c, src/os_unix.c,
            src/os_win32.c, src/popupmnu.c, src/proto.h, src/proto/buffer.pro,
            src/proto/digraph.pro, src/proto/ex_docmd.pro,
            src/proto/ex_eval.pro, src/proto/ex_getln.pro,
            src/proto/hardcopy.pro, src/proto/mbyte.pro,
            src/proto/message.pro, src/proto/misc2.pro, src/proto/option.pro,
            src/proto/spell.pro, src/quickfix.c, src/regexp.c,
            src/regexp_nfa.c, src/search.c, src/sign.c, src/spell.c,
            src/spellfile.c, src/structs.h, src/syntax.c, src/tag.c,
            src/term.c, src/terminal.c, src/textprop.c, src/ui.c, src/undo.c,
            src/userfunc.c, src/version.c, src/vim.h, src/window.c,


*** ../vim-8.1.0742/src/blob.c	2019-01-13 17:48:00.994125660 +0100
--- src/blob.c	2019-01-13 19:41:46.622522001 +0100
***************
*** 161,167 ****
      if (fwrite(blob->bv_ga.ga_data, 1, blob->bv_ga.ga_len, fd)
  						  < (size_t)blob->bv_ga.ga_len)
      {
! 	EMSG(_(e_write));
  	return FAIL;
      }
      return OK;
--- 161,167 ----
      if (fwrite(blob->bv_ga.ga_data, 1, blob->bv_ga.ga_len, fd)
  						  < (size_t)blob->bv_ga.ga_len)
      {
! 	emsg(_(e_write));
  	return FAIL;
      }
      return OK;
*** ../vim-8.1.0742/src/blowfish.c	2018-09-30 21:43:17.175693433 +0200
--- src/blowfish.c	2019-01-13 19:42:48.281805731 +0100
***************
*** 419,425 ****
      keylen = (int)STRLEN(key) / 2;
      if (keylen == 0)
      {
! 	IEMSG(_("E831: bf_key_init() called with empty password"));
  	return;
      }
      for (i = 0; i < keylen; i++)
--- 419,425 ----
      keylen = (int)STRLEN(key) / 2;
      if (keylen == 0)
      {
! 	iemsg(_("E831: bf_key_init() called with empty password"));
  	return;
      }
      for (i = 0; i < keylen; i++)
***************
*** 522,528 ****
       * warning. */
      if (ui != 0xffffffffUL || ui + 1 != 0) {
  	err++;
! 	EMSG(_("E820: sizeof(uint32_t) != 4"));
      }
  
      if (!bf_check_tables(pax_init, sbx_init, 0x6ffa520a))
--- 522,528 ----
       * warning. */
      if (ui != 0xffffffffUL || ui + 1 != 0) {
  	err++;
! 	emsg(_("E820: sizeof(uint32_t) != 4"));
      }
  
      if (!bf_check_tables(pax_init, sbx_init, 0x6ffa520a))
***************
*** 543,549 ****
  	if (memcmp(bk.uc, bf_test_data[i].cryptxt, 8) != 0)
  	{
  	    if (err == 0 && memcmp(bk.uc, bf_test_data[i].badcryptxt, 8) == 0)
! 		EMSG(_("E817: Blowfish big/little endian use wrong"));
  	    err++;
  	}
      }
--- 543,549 ----
  	if (memcmp(bk.uc, bf_test_data[i].cryptxt, 8) != 0)
  	{
  	    if (err == 0 && memcmp(bk.uc, bf_test_data[i].badcryptxt, 8) == 0)
! 		emsg(_("E817: Blowfish big/little endian use wrong"));
  	    err++;
  	}
      }
***************
*** 669,680 ****
  {
      if (sha256_self_test() == FAIL)
      {
! 	EMSG(_("E818: sha256 test failed"));
  	return FAIL;
      }
      if (bf_self_test() == FAIL)
      {
! 	EMSG(_("E819: Blowfish test failed"));
  	return FAIL;
      }
      return OK;
--- 669,680 ----
  {
      if (sha256_self_test() == FAIL)
      {
! 	emsg(_("E818: sha256 test failed"));
  	return FAIL;
      }
      if (bf_self_test() == FAIL)
      {
! 	emsg(_("E819: Blowfish test failed"));
  	return FAIL;
      }
      return OK;
*** ../vim-8.1.0742/src/buffer.c	2019-01-01 13:20:05.940711222 +0100
--- src/buffer.c	2019-01-13 22:46:39.950915356 +0100
***************
*** 162,171 ****
  	 */
  	if (curbuf == NULL)
  	{
! 	    EMSG(_("E82: Cannot allocate any buffer, exiting..."));
  	    getout(2);
  	}
! 	EMSG(_("E83: Cannot allocate buffer, using other one..."));
  	enter_buffer(curbuf);
  #ifdef FEAT_SYN_HL
  	if (old_tw != curbuf->b_p_tw)
--- 162,171 ----
  	 */
  	if (curbuf == NULL)
  	{
! 	    emsg(_("E82: Cannot allocate any buffer, exiting..."));
  	    getout(2);
  	}
! 	emsg(_("E83: Cannot allocate buffer, using other one..."));
  	enter_buffer(curbuf);
  #ifdef FEAT_SYN_HL
  	if (old_tw != curbuf->b_p_tw)
***************
*** 396,402 ****
  {
      sprintf((char *)buf->b_key, "%x", buf->b_fnum);
      if (hash_add(&buf_hashtab, buf->b_key) == FAIL)
! 	EMSG(_("E931: Buffer cannot be registered"));
  }
  
      static void
--- 396,402 ----
  {
      sprintf((char *)buf->b_key, "%x", buf->b_fnum);
      if (hash_add(&buf_hashtab, buf->b_key) == FAIL)
! 	emsg(_("E931: Buffer cannot be registered"));
  }
  
      static void
***************
*** 430,436 ****
  	    }
      }
      if (!can_unload)
! 	EMSG(_("E937: Attempt to delete a buffer that is in use"));
      return can_unload;
  }
  
--- 430,436 ----
  	    }
      }
      if (!can_unload)
! 	emsg(_("E937: Attempt to delete a buffer that is in use"));
      return can_unload;
  }
  
***************
*** 548,554 ****
  	{
  	    /* Autocommands deleted the buffer. */
  aucmd_abort:
! 	    EMSG(_(e_auabort));
  	    return;
  	}
  	--buf->b_locked;
--- 548,554 ----
  	{
  	    /* Autocommands deleted the buffer. */
  aucmd_abort:
! 	    emsg(_(e_auabort));
  	    return;
  	}
  	--buf->b_locked;
***************
*** 1115,1121 ****
   *
   * Returns error message or NULL
   */
!     char_u *
  do_bufdel(
      int		command,
      char_u	*arg,		/* pointer to extra arguments */
--- 1115,1121 ----
   *
   * Returns error message or NULL
   */
!     char *
  do_bufdel(
      int		command,
      char_u	*arg,		/* pointer to extra arguments */
***************
*** 1126,1132 ****
  {
      int		do_current = 0;	/* delete current buffer? */
      int		deleted = 0;	/* number of buffers deleted */
!     char_u	*errormsg = NULL; /* return value */
      int		bnr;		/* buffer number */
      char_u	*p;
  
--- 1126,1132 ----
  {
      int		do_current = 0;	/* delete current buffer? */
      int		deleted = 0;	/* number of buffers deleted */
!     char	*errormsg = NULL; /* return value */
      int		bnr;		/* buffer number */
      char_u	*p;
  
***************
*** 1139,1145 ****
  	if (addr_count == 2)
  	{
  	    if (*arg)		/* both range and argument is not allowed */
! 		return (char_u *)_(e_trailing);
  	    bnr = start_bnr;
  	}
  	else	/* addr_count == 1 */
--- 1139,1145 ----
  	if (addr_count == 2)
  	{
  	    if (*arg)		/* both range and argument is not allowed */
! 		return _(e_trailing);
  	    bnr = start_bnr;
  	}
  	else	/* addr_count == 1 */
***************
*** 1197,1214 ****
  		STRCPY(IObuff, _("E516: No buffers were deleted"));
  	    else
  		STRCPY(IObuff, _("E517: No buffers were wiped out"));
! 	    errormsg = IObuff;
  	}
  	else if (deleted >= p_report)
  	{
  	    if (command == DOBUF_UNLOAD)
! 		smsg((char_u *)NGETTEXT("%d buffer unloaded",
  			    "%d buffers unloaded", deleted), deleted);
  	    else if (command == DOBUF_DEL)
! 		smsg((char_u *)NGETTEXT("%d buffer deleted",
  			    "%d buffers deleted", deleted), deleted);
  	    else
! 		smsg((char_u *)NGETTEXT("%d buffer wiped out",
  			    "%d buffers wiped out", deleted), deleted);
  	}
      }
--- 1197,1214 ----
  		STRCPY(IObuff, _("E516: No buffers were deleted"));
  	    else
  		STRCPY(IObuff, _("E517: No buffers were wiped out"));
! 	    errormsg = (char *)IObuff;
  	}
  	else if (deleted >= p_report)
  	{
  	    if (command == DOBUF_UNLOAD)
! 		smsg(NGETTEXT("%d buffer unloaded",
  			    "%d buffers unloaded", deleted), deleted);
  	    else if (command == DOBUF_DEL)
! 		smsg(NGETTEXT("%d buffer deleted",
  			    "%d buffers deleted", deleted), deleted);
  	    else
! 		smsg(NGETTEXT("%d buffer wiped out",
  			    "%d buffers wiped out", deleted), deleted);
  	}
      }
***************
*** 1233,1239 ****
  
      if (action == DOBUF_UNLOAD)
      {
! 	EMSG(_("E90: Cannot unload last buffer"));
  	return FAIL;
      }
  
--- 1233,1239 ----
  
      if (action == DOBUF_UNLOAD)
      {
! 	emsg(_("E90: Cannot unload last buffer"));
  	return FAIL;
      }
  
***************
*** 1307,1313 ****
  	}
  	if (!bufIsChanged(buf))
  	{
! 	    EMSG(_("E84: No modified buffer found"));
  	    return FAIL;
  	}
      }
--- 1307,1313 ----
  	}
  	if (!bufIsChanged(buf))
  	{
! 	    emsg(_("E84: No modified buffer found"));
  	    return FAIL;
  	}
      }
***************
*** 1346,1352 ****
  	    if (bp == buf)
  	    {
  		/* back where we started, didn't find anything. */
! 		EMSG(_("E85: There is no listed buffer"));
  		return FAIL;
  	    }
  	}
--- 1346,1352 ----
  	    if (bp == buf)
  	    {
  		/* back where we started, didn't find anything. */
! 		emsg(_("E85: There is no listed buffer"));
  		return FAIL;
  	    }
  	}
***************
*** 1358,1369 ****
  	{
  	    /* don't warn when deleting */
  	    if (!unload)
! 		EMSGN(_(e_nobufnr), count);
  	}
  	else if (dir == FORWARD)
! 	    EMSG(_("E87: Cannot go beyond last buffer"));
  	else
! 	    EMSG(_("E88: Cannot go before first buffer"));
  	return FAIL;
      }
  
--- 1358,1369 ----
  	{
  	    /* don't warn when deleting */
  	    if (!unload)
! 		semsg(_(e_nobufnr), count);
  	}
  	else if (dir == FORWARD)
! 	    emsg(_("E87: Cannot go beyond last buffer"));
  	else
! 	    emsg(_("E88: Cannot go before first buffer"));
  	return FAIL;
      }
  
***************
*** 1407,1413 ****
  	    else
  #endif
  	    {
! 		EMSGN(_("E89: No write since last change for buffer %ld (add ! to override)"),
  								 buf->b_fnum);
  		return FAIL;
  	    }
--- 1407,1413 ----
  	    else
  #endif
  	    {
! 		semsg(_("E89: No write since last change for buffer %ld (add ! to override)"),
  								 buf->b_fnum);
  		return FAIL;
  	    }
***************
*** 1832,1841 ****
  {
  #ifdef FEAT_TERMINAL
      if (term_job_running(curbuf->b_term))
! 	EMSG(_("E948: Job still running (add ! to end the job)"));
      else
  #endif
! 	EMSG(_("E37: No write since last change (add ! to override)"));
  }
  
      void
--- 1832,1841 ----
  {
  #ifdef FEAT_TERMINAL
      if (term_job_running(curbuf->b_term))
! 	emsg(_("E948: Job still running (add ! to end the job)"));
      else
  #endif
! 	emsg(_("E37: No write since last change (add ! to override)"));
  }
  
      void
***************
*** 1843,1852 ****
  {
  #ifdef FEAT_TERMINAL
      if (term_job_running(buf->b_term))
! 	EMSG(_("E948: Job still running"));
      else
  #endif
! 	EMSG(_("E37: No write since last change"));
  }
  
  /*
--- 1843,1852 ----
  {
  #ifdef FEAT_TERMINAL
      if (term_job_running(buf->b_term))
! 	emsg(_("E948: Job still running"));
      else
  #endif
! 	emsg(_("E37: No write since last change"));
  }
  
  /*
***************
*** 2057,2063 ****
  	buf->b_fnum = top_file_num++;
  	if (top_file_num < 0)		/* wrap around (may cause duplicates) */
  	{
! 	    EMSG(_("W14: Warning: List of file names overflow"));
  	    if (emsg_silent == 0)
  	    {
  		out_flush();
--- 2057,2063 ----
  	buf->b_fnum = top_file_num++;
  	if (top_file_num < 0)		/* wrap around (may cause duplicates) */
  	{
! 	    emsg(_("W14: Warning: List of file names overflow"));
  	    if (emsg_silent == 0)
  	    {
  		out_flush();
***************
*** 2281,2289 ****
      if (buf == NULL)
      {
  	if ((options & GETF_ALT) && n == 0)
! 	    EMSG(_(e_noalt));
  	else
! 	    EMSGN(_("E92: Buffer %ld not found"), n);
  	return FAIL;
      }
  
--- 2281,2289 ----
      if (buf == NULL)
      {
  	if ((options & GETF_ALT) && n == 0)
! 	    emsg(_(e_noalt));
  	else
! 	    semsg(_("E92: Buffer %ld not found"), n);
  	return FAIL;
      }
  
***************
*** 2568,2576 ****
      }
  
      if (match == -2)
! 	EMSG2(_("E93: More than one match for %s"), pattern);
      else if (match < 0)
! 	EMSG2(_("E94: No matching buffer for %s"), pattern);
      return match;
  }
  
--- 2568,2576 ----
      }
  
      if (match == -2)
! 	semsg(_("E93: More than one match for %s"), pattern);
      else if (match < 0)
! 	semsg(_("E94: No matching buffer for %s"), pattern);
      return match;
  }
  
***************
*** 3172,3178 ****
  	    if (obuf->b_ml.ml_mfp != NULL)	/* it's loaded, fail */
  	    {
  		if (message)
! 		    EMSG(_("E95: Buffer with this name already exists"));
  		vim_free(ffname);
  		return FAIL;
  	    }
--- 3172,3178 ----
  	    if (obuf->b_ml.ml_mfp != NULL)	/* it's loaded, fail */
  	    {
  		if (message)
! 		    emsg(_("E95: Buffer with this name already exists"));
  		vim_free(ffname);
  		return FAIL;
  	    }
***************
*** 3298,3304 ****
      if (buflist_name_nr(0, &fname, &dummy) == FAIL)
      {
  	if (errmsg)
! 	    EMSG(_(e_noalt));
  	return NULL;
      }
      return fname;
--- 3298,3304 ----
      if (buflist_name_nr(0, &fname, &dummy) == FAIL)
      {
  	if (errmsg)
! 	    emsg(_(e_noalt));
  	return NULL;
      }
      return fname;
***************
*** 5730,5736 ****
  {
      if (bt_dontwrite(buf))
      {
! 	EMSG(_("E382: Cannot write, 'buftype' option is set"));
  	return TRUE;
      }
      return FALSE;
--- 5730,5736 ----
  {
      if (bt_dontwrite(buf))
      {
! 	emsg(_("E382: Cannot write, 'buftype' option is set"));
  	return TRUE;
      }
      return FALSE;
*** ../vim-8.1.0742/src/channel.c	2019-01-12 22:47:01.256088105 +0100
--- src/channel.c	2019-01-13 19:45:23.292118673 +0100
***************
*** 116,122 ****
  	file = fopen((char *)fname, *opt == 'w' ? "w" : "a");
  	if (file == NULL)
  	{
! 	    EMSG2(_(e_notopen), fname);
  	    return;
  	}
      }
--- 116,122 ----
  	file = fopen((char *)fname, *opt == 'w' ? "w" : "a");
  	if (file == NULL)
  	{
! 	    semsg(_(e_notopen), fname);
  	    return;
  	}
      }
***************
*** 209,216 ****
  
  #ifdef _WIN32
  # undef PERROR
! # define PERROR(msg) (void)emsg3((char_u *)"%s: %s", \
! 	(char_u *)msg, (char_u *)strerror_win32(errno))
  
      static char *
  strerror_win32(int eno)
--- 209,215 ----
  
  #ifdef _WIN32
  # undef PERROR
! # define PERROR(msg) (void)semsg("%s: %s", msg, strerror_win32(errno))
  
      static char *
  strerror_win32(int eno)
***************
*** 942,948 ****
      if (argvars[1].v_type != VAR_UNKNOWN
  	 && (argvars[1].v_type != VAR_DICT || argvars[1].vval.v_dict == NULL))
      {
! 	EMSG(_(e_invarg));
  	return NULL;
      }
  
--- 941,947 ----
      if (argvars[1].v_type != VAR_UNKNOWN
  	 && (argvars[1].v_type != VAR_DICT || argvars[1].vval.v_dict == NULL))
      {
! 	emsg(_(e_invarg));
  	return NULL;
      }
  
***************
*** 950,956 ****
      p = vim_strchr(address, ':');
      if (p == NULL)
      {
! 	EMSG2(_(e_invarg2), address);
  	return NULL;
      }
      *p++ = NUL;
--- 949,955 ----
      p = vim_strchr(address, ':');
      if (p == NULL)
      {
! 	semsg(_(e_invarg2), address);
  	return NULL;
      }
      *p++ = NUL;
***************
*** 958,964 ****
      if (*address == NUL || port <= 0 || *rest != NUL)
      {
  	p[-1] = ':';
! 	EMSG2(_(e_invarg2), address);
  	return NULL;
      }
  
--- 957,963 ----
      if (*address == NUL || port <= 0 || *rest != NUL)
      {
  	p[-1] = ':';
! 	semsg(_(e_invarg2), address);
  	return NULL;
      }
  
***************
*** 971,977 ****
  	goto theend;
      if (opt.jo_timeout < 0)
      {
! 	EMSG(_(e_invarg));
  	goto theend;
      }
  
--- 970,976 ----
  	goto theend;
      if (opt.jo_timeout < 0)
      {
! 	emsg(_(e_invarg));
  	goto theend;
      }
  
***************
*** 1233,1239 ****
  	{
  	    buf = buflist_findnr(opt->jo_io_buf[PART_OUT]);
  	    if (buf == NULL)
! 		EMSGN(_(e_nobufnr), (long)opt->jo_io_buf[PART_OUT]);
  	}
  	else
  	{
--- 1232,1238 ----
  	{
  	    buf = buflist_findnr(opt->jo_io_buf[PART_OUT]);
  	    if (buf == NULL)
! 		semsg(_(e_nobufnr), (long)opt->jo_io_buf[PART_OUT]);
  	}
  	else
  	{
***************
*** 1251,1257 ****
  
  	    if (!buf->b_p_ma && !channel->ch_part[PART_OUT].ch_nomodifiable)
  	    {
! 		EMSG(_(e_modifiable));
  	    }
  	    else
  	    {
--- 1250,1256 ----
  
  	    if (!buf->b_p_ma && !channel->ch_part[PART_OUT].ch_nomodifiable)
  	    {
! 		emsg(_(e_modifiable));
  	    }
  	    else
  	    {
***************
*** 1280,1286 ****
  	{
  	    buf = buflist_findnr(opt->jo_io_buf[PART_ERR]);
  	    if (buf == NULL)
! 		EMSGN(_(e_nobufnr), (long)opt->jo_io_buf[PART_ERR]);
  	}
  	else
  	{
--- 1279,1285 ----
  	{
  	    buf = buflist_findnr(opt->jo_io_buf[PART_ERR]);
  	    if (buf == NULL)
! 		semsg(_(e_nobufnr), (long)opt->jo_io_buf[PART_ERR]);
  	}
  	else
  	{
***************
*** 1297,1303 ****
  						!opt->jo_modifiable[PART_ERR];
  	    if (!buf->b_p_ma && !channel->ch_part[PART_ERR].ch_nomodifiable)
  	    {
! 		EMSG(_(e_modifiable));
  	    }
  	    else
  	    {
--- 1296,1302 ----
  						!opt->jo_modifiable[PART_ERR];
  	    if (!buf->b_p_ma && !channel->ch_part[PART_ERR].ch_nomodifiable)
  	    {
! 		emsg(_(e_modifiable));
  	    }
  	    else
  	    {
***************
*** 1619,1625 ****
      int		dummy;
  
      if (safe_to_invoke_callback == 0)
! 	IEMSG("INTERNAL: Invoking callback when it is not safe");
  
      argv[0].v_type = VAR_CHANNEL;
      argv[0].vval.v_channel = channel;
--- 1618,1624 ----
      int		dummy;
  
      if (safe_to_invoke_callback == 0)
! 	iemsg("INTERNAL: Invoking callback when it is not safe");
  
      argv[0].v_type = VAR_CHANNEL;
      argv[0].vval.v_channel = channel;
***************
*** 2237,2243 ****
      {
  	ch_error(channel, "received command with non-string argument");
  	if (p_verbose > 2)
! 	    EMSG(_("E903: received command with non-string argument"));
  	return;
      }
      arg = argv[1].vval.v_string;
--- 2236,2242 ----
      {
  	ch_error(channel, "received command with non-string argument");
  	if (p_verbose > 2)
! 	    emsg(_("E903: received command with non-string argument"));
  	return;
      }
      arg = argv[1].vval.v_string;
***************
*** 2289,2301 ****
  	{
  	    ch_error(channel, "last argument for expr/call must be a number");
  	    if (p_verbose > 2)
! 		EMSG(_("E904: last argument for expr/call must be a number"));
  	}
  	else if (is_call && argv[2].v_type != VAR_LIST)
  	{
  	    ch_error(channel, "third argument for call must be a list");
  	    if (p_verbose > 2)
! 		EMSG(_("E904: third argument for call must be a list"));
  	}
  	else
  	{
--- 2288,2300 ----
  	{
  	    ch_error(channel, "last argument for expr/call must be a number");
  	    if (p_verbose > 2)
! 		emsg(_("E904: last argument for expr/call must be a number"));
  	}
  	else if (is_call && argv[2].v_type != VAR_LIST)
  	{
  	    ch_error(channel, "third argument for call must be a list");
  	    if (p_verbose > 2)
! 		emsg(_("E904: third argument for call must be a list"));
  	}
  	else
  	{
***************
*** 2351,2357 ****
      else if (p_verbose > 2)
      {
  	ch_error(channel, "Received unknown command: %s", (char *)cmd);
! 	EMSG2(_("E905: received unknown command: %s"), cmd);
      }
  }
  
--- 2350,2356 ----
      else if (p_verbose > 2)
      {
  	ch_error(channel, "Received unknown command: %s", (char *)cmd);
! 	semsg(_("E905: received unknown command: %s"), cmd);
      }
  }
  
***************
*** 3769,3775 ****
  	if (!channel->ch_error && fun != NULL)
  	{
  	    ch_error(channel, "%s(): write while not connected", fun);
! 	    EMSG2(_("E630: %s(): write while not connected"), fun);
  	}
  	channel->ch_error = TRUE;
  	return FAIL;
--- 3768,3774 ----
  	if (!channel->ch_error && fun != NULL)
  	{
  	    ch_error(channel, "%s(): write while not connected", fun);
! 	    semsg(_("E630: %s(): write while not connected"), fun);
  	}
  	channel->ch_error = TRUE;
  	return FAIL;
***************
*** 3916,3922 ****
  	    if (!channel->ch_error && fun != NULL)
  	    {
  		ch_error(channel, "%s(): write failed", fun);
! 		EMSG2(_("E631: %s(): write failed"), fun);
  	    }
  	    channel->ch_error = TRUE;
  	    return FAIL;
--- 3915,3921 ----
  	    if (!channel->ch_error && fun != NULL)
  	    {
  		ch_error(channel, "%s(): write failed", fun);
! 		semsg(_("E631: %s(): write failed"), fun);
  	    }
  	    channel->ch_error = TRUE;
  	    return FAIL;
***************
*** 3964,3970 ****
      {
  	if (eval)
  	{
! 	    EMSG2(_("E917: Cannot use a callback with %s()"), fun);
  	    return NULL;
  	}
  	channel_set_req_callback(channel, *part_read,
--- 3963,3969 ----
      {
  	if (eval)
  	{
! 	    semsg(_("E917: Cannot use a callback with %s()"), fun);
  	    return NULL;
  	}
  	channel_set_req_callback(channel, *part_read,
***************
*** 4005,4011 ****
      ch_mode = channel_get_mode(channel, part_send);
      if (ch_mode == MODE_RAW || ch_mode == MODE_NL)
      {
! 	EMSG(_("E912: cannot use ch_evalexpr()/ch_sendexpr() with a raw or nl channel"));
  	return;
      }
  
--- 4004,4010 ----
      ch_mode = channel_get_mode(channel, part_send);
      if (ch_mode == MODE_RAW || ch_mode == MODE_NL)
      {
! 	emsg(_("E912: cannot use ch_evalexpr()/ch_sendexpr() with a raw or nl channel"));
  	return;
      }
  
***************
*** 4478,4484 ****
  	*modep = MODE_JSON;
      else
      {
! 	EMSG2(_(e_invarg2), val);
  	return FAIL;
      }
      return OK;
--- 4477,4483 ----
  	*modep = MODE_JSON;
      else
      {
! 	semsg(_(e_invarg2), val);
  	return FAIL;
      }
      return OK;
***************
*** 4502,4508 ****
  	opt->jo_io[part] = JIO_OUT;
      else
      {
! 	EMSG2(_(e_invarg2), val);
  	return FAIL;
      }
      return OK;
--- 4501,4507 ----
  	opt->jo_io[part] = JIO_OUT;
      else
      {
! 	semsg(_(e_invarg2), val);
  	return FAIL;
      }
      return OK;
***************
*** 4576,4582 ****
  	return OK;
      if (tv->v_type != VAR_DICT)
      {
! 	EMSG(_(e_dictreq));
  	return FAIL;
      }
      dict = tv->vval.v_dict;
--- 4575,4581 ----
  	return OK;
      if (tv->v_type != VAR_DICT)
      {
! 	emsg(_(e_dictreq));
  	return FAIL;
      }
      dict = tv->vval.v_dict;
***************
*** 4665,4676 ****
  		opt->jo_io_buf[part] = tv_get_number(item);
  		if (opt->jo_io_buf[part] <= 0)
  		{
! 		    EMSG3(_(e_invargNval), hi->hi_key, tv_get_string(item));
  		    return FAIL;
  		}
  		if (buflist_findnr(opt->jo_io_buf[part]) == NULL)
  		{
! 		    EMSGN(_(e_nobufnr), (long)opt->jo_io_buf[part]);
  		    return FAIL;
  		}
  	    }
--- 4664,4675 ----
  		opt->jo_io_buf[part] = tv_get_number(item);
  		if (opt->jo_io_buf[part] <= 0)
  		{
! 		    semsg(_(e_invargNval), hi->hi_key, tv_get_string(item));
  		    return FAIL;
  		}
  		if (buflist_findnr(opt->jo_io_buf[part]) == NULL)
  		{
! 		    semsg(_(e_nobufnr), (long)opt->jo_io_buf[part]);
  		    return FAIL;
  		}
  	    }
***************
*** 4714,4720 ****
  		*lp = tv_get_number(item);
  		if (*lp < 0)
  		{
! 		    EMSG3(_(e_invargNval), hi->hi_key, tv_get_string(item));
  		    return FAIL;
  		}
  	    }
--- 4713,4719 ----
  		*lp = tv_get_number(item);
  		if (*lp < 0)
  		{
! 		    semsg(_(e_invargNval), hi->hi_key, tv_get_string(item));
  		    return FAIL;
  		}
  	    }
***************
*** 4725,4731 ****
  		opt->jo_set |= JO_CHANNEL;
  		if (item->v_type != VAR_CHANNEL)
  		{
! 		    EMSG2(_(e_invargval), "channel");
  		    return FAIL;
  		}
  		opt->jo_channel = item->vval.v_channel;
--- 4724,4730 ----
  		opt->jo_set |= JO_CHANNEL;
  		if (item->v_type != VAR_CHANNEL)
  		{
! 		    semsg(_(e_invargval), "channel");
  		    return FAIL;
  		}
  		opt->jo_channel = item->vval.v_channel;
***************
*** 4738,4744 ****
  		opt->jo_callback = get_callback(item, &opt->jo_partial);
  		if (opt->jo_callback == NULL)
  		{
! 		    EMSG2(_(e_invargval), "callback");
  		    return FAIL;
  		}
  	    }
--- 4737,4743 ----
  		opt->jo_callback = get_callback(item, &opt->jo_partial);
  		if (opt->jo_callback == NULL)
  		{
! 		    semsg(_(e_invargval), "callback");
  		    return FAIL;
  		}
  	    }
***************
*** 4750,4756 ****
  		opt->jo_out_cb = get_callback(item, &opt->jo_out_partial);
  		if (opt->jo_out_cb == NULL)
  		{
! 		    EMSG2(_(e_invargval), "out_cb");
  		    return FAIL;
  		}
  	    }
--- 4749,4755 ----
  		opt->jo_out_cb = get_callback(item, &opt->jo_out_partial);
  		if (opt->jo_out_cb == NULL)
  		{
! 		    semsg(_(e_invargval), "out_cb");
  		    return FAIL;
  		}
  	    }
***************
*** 4762,4768 ****
  		opt->jo_err_cb = get_callback(item, &opt->jo_err_partial);
  		if (opt->jo_err_cb == NULL)
  		{
! 		    EMSG2(_(e_invargval), "err_cb");
  		    return FAIL;
  		}
  	    }
--- 4761,4767 ----
  		opt->jo_err_cb = get_callback(item, &opt->jo_err_partial);
  		if (opt->jo_err_cb == NULL)
  		{
! 		    semsg(_(e_invargval), "err_cb");
  		    return FAIL;
  		}
  	    }
***************
*** 4774,4780 ****
  		opt->jo_close_cb = get_callback(item, &opt->jo_close_partial);
  		if (opt->jo_close_cb == NULL)
  		{
! 		    EMSG2(_(e_invargval), "close_cb");
  		    return FAIL;
  		}
  	    }
--- 4773,4779 ----
  		opt->jo_close_cb = get_callback(item, &opt->jo_close_partial);
  		if (opt->jo_close_cb == NULL)
  		{
! 		    semsg(_(e_invargval), "close_cb");
  		    return FAIL;
  		}
  	    }
***************
*** 4787,4793 ****
  		    never = TRUE;
  		else if (STRCMP(val, "auto") != 0)
  		{
! 		    EMSG3(_(e_invargNval), "drop", val);
  		    return FAIL;
  		}
  		opt->jo_drop_never = never;
--- 4786,4792 ----
  		    never = TRUE;
  		else if (STRCMP(val, "auto") != 0)
  		{
! 		    semsg(_(e_invargNval), "drop", val);
  		    return FAIL;
  		}
  		opt->jo_drop_never = never;
***************
*** 4800,4806 ****
  		opt->jo_exit_cb = get_callback(item, &opt->jo_exit_partial);
  		if (opt->jo_exit_cb == NULL)
  		{
! 		    EMSG2(_(e_invargval), "exit_cb");
  		    return FAIL;
  		}
  	    }
--- 4799,4805 ----
  		opt->jo_exit_cb = get_callback(item, &opt->jo_exit_partial);
  		if (opt->jo_exit_cb == NULL)
  		{
! 		    semsg(_(e_invargval), "exit_cb");
  		    return FAIL;
  		}
  	    }
***************
*** 4813,4819 ****
  		opt->jo_term_name = tv_get_string_chk(item);
  		if (opt->jo_term_name == NULL)
  		{
! 		    EMSG2(_(e_invargval), "term_name");
  		    return FAIL;
  		}
  	    }
--- 4812,4818 ----
  		opt->jo_term_name = tv_get_string_chk(item);
  		if (opt->jo_term_name == NULL)
  		{
! 		    semsg(_(e_invargval), "term_name");
  		    return FAIL;
  		}
  	    }
***************
*** 4824,4830 ****
  		val = tv_get_string(item);
  		if (STRCMP(val, "open") != 0 && STRCMP(val, "close") != 0)
  		{
! 		    EMSG3(_(e_invargNval), "term_finish", val);
  		    return FAIL;
  		}
  		opt->jo_set2 |= JO2_TERM_FINISH;
--- 4823,4829 ----
  		val = tv_get_string(item);
  		if (STRCMP(val, "open") != 0 && STRCMP(val, "close") != 0)
  		{
! 		    semsg(_(e_invargNval), "term_finish", val);
  		    return FAIL;
  		}
  		opt->jo_set2 |= JO2_TERM_FINISH;
***************
*** 4848,4854 ****
  		}
  		if (p == NULL)
  		{
! 		    EMSG2(_(e_invargval), "term_opencmd");
  		    return FAIL;
  		}
  	    }
--- 4847,4853 ----
  		}
  		if (p == NULL)
  		{
! 		    semsg(_(e_invargval), "term_opencmd");
  		    return FAIL;
  		}
  	    }
***************
*** 4862,4868 ****
  		p = opt->jo_eof_chars = tv_get_string_chk(item);
  		if (p == NULL)
  		{
! 		    EMSG2(_(e_invargval), "eof_chars");
  		    return FAIL;
  		}
  	    }
--- 4861,4867 ----
  		p = opt->jo_eof_chars = tv_get_string_chk(item);
  		if (p == NULL)
  		{
! 		    semsg(_(e_invargval), "eof_chars");
  		    return FAIL;
  		}
  	    }
***************
*** 4928,4934 ****
  		if (item == NULL || item->v_type != VAR_LIST
  			|| item->vval.v_list == NULL)
  		{
! 		    EMSG2(_(e_invargval), "ansi_colors");
  		    return FAIL;
  		}
  
--- 4927,4933 ----
  		if (item == NULL || item->v_type != VAR_LIST
  			|| item->vval.v_list == NULL)
  		{
! 		    semsg(_(e_invargval), "ansi_colors");
  		    return FAIL;
  		}
  
***************
*** 4951,4957 ****
  
  		if (n != 16 || li != NULL)
  		{
! 		    EMSG2(_(e_invargval), "ansi_colors");
  		    return FAIL;
  		}
  
--- 4950,4956 ----
  
  		if (n != 16 || li != NULL)
  		{
! 		    semsg(_(e_invargval), "ansi_colors");
  		    return FAIL;
  		}
  
***************
*** 4966,4972 ****
  		    break;
  		if (item->v_type != VAR_DICT)
  		{
! 		    EMSG2(_(e_invargval), "env");
  		    return FAIL;
  		}
  		opt->jo_set2 |= JO2_ENV;
--- 4965,4971 ----
  		    break;
  		if (item->v_type != VAR_DICT)
  		{
! 		    semsg(_(e_invargval), "env");
  		    return FAIL;
  		}
  		opt->jo_set2 |= JO2_ENV;
***************
*** 4985,4991 ****
  #endif
  				)
  		{
! 		    EMSG2(_(e_invargval), "cwd");
  		    return FAIL;
  		}
  		opt->jo_set2 |= JO2_CWD;
--- 4984,4990 ----
  #endif
  				)
  		{
! 		    semsg(_(e_invargval), "cwd");
  		    return FAIL;
  		}
  		opt->jo_set2 |= JO2_CWD;
***************
*** 5030,5036 ****
  		    opt->jo_part = PART_OUT;
  		else
  		{
! 		    EMSG3(_(e_invargNval), "part", val);
  		    return FAIL;
  		}
  	    }
--- 5029,5035 ----
  		    opt->jo_part = PART_OUT;
  		else
  		{
! 		    semsg(_(e_invargNval), "part", val);
  		    return FAIL;
  		}
  	    }
***************
*** 5050,5056 ****
  							     opt->jo_soe_buf);
  		if (opt->jo_stoponexit == NULL)
  		{
! 		    EMSG2(_(e_invargval), "stoponexit");
  		    return FAIL;
  		}
  	    }
--- 5049,5055 ----
  							     opt->jo_soe_buf);
  		if (opt->jo_stoponexit == NULL)
  		{
! 		    semsg(_(e_invargval), "stoponexit");
  		    return FAIL;
  		}
  	    }
***************
*** 5067,5073 ****
  	}
      if (todo > 0)
      {
! 	EMSG2(_(e_invarg2), hi->hi_key);
  	return FAIL;
      }
  
--- 5066,5072 ----
  	}
      if (todo > 0)
      {
! 	semsg(_(e_invarg2), hi->hi_key);
  	return FAIL;
      }
  
***************
*** 5098,5104 ****
      }
      else
      {
! 	EMSG2(_(e_invarg2), tv_get_string(tv));
  	return NULL;
      }
      if (channel != NULL && reading)
--- 5097,5103 ----
      }
      else
      {
! 	semsg(_(e_invarg2), tv_get_string(tv));
  	return NULL;
      }
      if (channel != NULL && reading)
***************
*** 5108,5114 ****
      if (check_open && (channel == NULL || (!channel_is_open(channel)
  					     && !(reading && has_readahead))))
      {
! 	EMSG(_("E906: not an open channel"));
  	return NULL;
      }
      return channel;
--- 5107,5113 ----
      if (check_open && (channel == NULL || (!channel_is_open(channel)
  					     && !(reading && has_readahead))))
      {
! 	emsg(_("E906: not an open channel"));
  	return NULL;
      }
      return channel;
***************
*** 5662,5668 ****
  		&& (!(opt.jo_set & (JO_OUT_NAME << (part - PART_OUT)))
  		    || *opt.jo_io_name[part] == NUL))
  	{
! 	    EMSG(_("E920: _io file requires _name to be set"));
  	    goto theend;
  	}
  
--- 5661,5667 ----
  		&& (!(opt.jo_set & (JO_OUT_NAME << (part - PART_OUT)))
  		    || *opt.jo_io_name[part] == NUL))
  	{
! 	    emsg(_("E920: _io file requires _name to be set"));
  	    goto theend;
  	}
  
***************
*** 5675,5685 ****
  	{
  	    buf = buflist_findnr(opt.jo_io_buf[PART_IN]);
  	    if (buf == NULL)
! 		EMSGN(_(e_nobufnr), (long)opt.jo_io_buf[PART_IN]);
  	}
  	else if (!(opt.jo_set & JO_IN_NAME))
  	{
! 	    EMSG(_("E915: in_io buffer requires in_buf or in_name to be set"));
  	}
  	else
  	    buf = buflist_find_by_name(opt.jo_io_name[PART_IN], FALSE);
--- 5674,5684 ----
  	{
  	    buf = buflist_findnr(opt.jo_io_buf[PART_IN]);
  	    if (buf == NULL)
! 		semsg(_(e_nobufnr), (long)opt.jo_io_buf[PART_IN]);
  	}
  	else if (!(opt.jo_set & JO_IN_NAME))
  	{
! 	    emsg(_("E915: in_io buffer requires in_buf or in_name to be set"));
  	}
  	else
  	    buf = buflist_find_by_name(opt.jo_io_name[PART_IN], FALSE);
***************
*** 5697,5703 ****
  	    }
  	    else
  		s = opt.jo_io_name[PART_IN];
! 	    EMSG2(_("E918: buffer must be loaded: %s"), s);
  	    goto theend;
  	}
  	job->jv_in_buf = buf;
--- 5696,5702 ----
  	    }
  	    else
  		s = opt.jo_io_name[PART_IN];
! 	    semsg(_("E918: buffer must be loaded: %s"), s);
  	    goto theend;
  	}
  	job->jv_in_buf = buf;
***************
*** 5726,5732 ****
  	cmd = argvars[0].vval.v_string;
  	if (cmd == NULL || *cmd == NUL)
  	{
! 	    EMSG(_(e_invarg));
  	    goto theend;
  	}
  
--- 5725,5731 ----
  	cmd = argvars[0].vval.v_string;
  	if (cmd == NULL || *cmd == NUL)
  	{
! 	    emsg(_(e_invarg));
  	    goto theend;
  	}
  
***************
*** 5737,5743 ****
  	    || argvars[0].vval.v_list == NULL
  	    || argvars[0].vval.v_list->lv_len < 1)
      {
! 	EMSG(_(e_invarg));
  	goto theend;
      }
      else
--- 5736,5742 ----
  	    || argvars[0].vval.v_list == NULL
  	    || argvars[0].vval.v_list->lv_len < 1)
      {
! 	emsg(_(e_invarg));
  	goto theend;
      }
      else
***************
*** 5898,5904 ****
  	arg = tv_get_string_chk(&argvars[1]);
  	if (arg == NULL)
  	{
! 	    EMSG(_(e_invarg));
  	    return 0;
  	}
      }
--- 5897,5903 ----
  	arg = tv_get_string_chk(&argvars[1]);
  	if (arg == NULL)
  	{
! 	    emsg(_(e_invarg));
  	    return 0;
  	}
      }
*** ../vim-8.1.0742/src/crypt.c	2018-02-10 18:34:22.000000000 +0100
--- src/crypt.c	2019-01-13 19:44:56.116404066 +0100
***************
*** 162,168 ****
  
      i = (int)STRLEN(crypt_magic_head);
      if (len >= i && memcmp(ptr, crypt_magic_head, i) == 0)
! 	EMSG(_("E821: File is encrypted with unknown method"));
  
      return -1;
  }
--- 162,168 ----
  
      i = (int)STRLEN(crypt_magic_head);
      if (len >= i && memcmp(ptr, crypt_magic_head, i) == 0)
! 	emsg(_("E821: File is encrypted with unknown method"));
  
      return -1;
  }
*** ../vim-8.1.0742/src/dict.c	2018-12-26 22:57:37.978550895 +0100
--- src/dict.c	2019-01-13 19:45:30.144047338 +0100
***************
*** 644,650 ****
  	    goto failret;
  	if (**arg != ':')
  	{
! 	    EMSG2(_("E720: Missing colon in Dictionary: %s"), *arg);
  	    clear_tv(&tvkey);
  	    goto failret;
  	}
--- 644,650 ----
  	    goto failret;
  	if (**arg != ':')
  	{
! 	    semsg(_("E720: Missing colon in Dictionary: %s"), *arg);
  	    clear_tv(&tvkey);
  	    goto failret;
  	}
***************
*** 671,677 ****
  	    item = dict_find(d, key, -1);
  	    if (item != NULL)
  	    {
! 		EMSG2(_("E721: Duplicate key in Dictionary: \"%s\""), key);
  		clear_tv(&tvkey);
  		clear_tv(&tv);
  		goto failret;
--- 671,677 ----
  	    item = dict_find(d, key, -1);
  	    if (item != NULL)
  	    {
! 		semsg(_("E721: Duplicate key in Dictionary: \"%s\""), key);
  		clear_tv(&tvkey);
  		clear_tv(&tv);
  		goto failret;
***************
*** 691,697 ****
  	    break;
  	if (**arg != ',')
  	{
! 	    EMSG2(_("E722: Missing comma in Dictionary: %s"), *arg);
  	    goto failret;
  	}
  	*arg = skipwhite(*arg + 1);
--- 691,697 ----
  	    break;
  	if (**arg != ',')
  	{
! 	    semsg(_("E722: Missing comma in Dictionary: %s"), *arg);
  	    goto failret;
  	}
  	*arg = skipwhite(*arg + 1);
***************
*** 699,705 ****
  
      if (**arg != '}')
      {
! 	EMSG2(_("E723: Missing end of Dictionary '}': %s"), *arg);
  failret:
  	if (evaluate)
  	    dict_free(d);
--- 699,705 ----
  
      if (**arg != '}')
      {
! 	semsg(_("E723: Missing end of Dictionary '}': %s"), *arg);
  failret:
  	if (evaluate)
  	    dict_free(d);
***************
*** 753,759 ****
  	    }
  	    else if (*action == 'e')
  	    {
! 		EMSG2(_("E737: Key already exists: %s"), hi2->hi_key);
  		break;
  	    }
  	    else if (*action == 'f' && HI2DI(hi2) != di1)
--- 753,759 ----
  	    }
  	    else if (*action == 'e')
  	    {
! 		semsg(_("E737: Key already exists: %s"), hi2->hi_key);
  		break;
  	    }
  	    else if (*action == 'f' && HI2DI(hi2) != di1)
***************
*** 835,841 ****
  
      if (argvars[0].v_type != VAR_DICT)
      {
! 	EMSG(_(e_dictreq));
  	return;
      }
      if ((d = argvars[0].vval.v_dict) == NULL)
--- 835,841 ----
  
      if (argvars[0].v_type != VAR_DICT)
      {
! 	emsg(_(e_dictreq));
  	return;
      }
      if ((d = argvars[0].vval.v_dict) == NULL)
*** ../vim-8.1.0742/src/diff.c	2018-12-04 22:24:12.189693629 +0100
--- src/diff.c	2019-01-13 19:45:48.871853608 +0100
***************
*** 173,179 ****
  	    return;
  	}
  
!     EMSGN(_("E96: Cannot diff more than %ld buffers"), DB_COUNT);
  }
  
  /*
--- 173,179 ----
  	    return;
  	}
  
!     semsg(_("E96: Cannot diff more than %ld buffers"), DB_COUNT);
  }
  
  /*
***************
*** 724,731 ****
  	if (p_verbose > 0)
  	{
  	    verbose_enter();
! 	    smsg((char_u *)
! 		 _("Not enough memory to use internal diff for buffer \"%s\""),
  								 buf->b_fname);
  	    verbose_leave();
  	}
--- 724,730 ----
  	if (p_verbose > 0)
  	{
  	    verbose_enter();
! 	    smsg(_("Not enough memory to use internal diff for buffer \"%s\""),
  								 buf->b_fname);
  	    verbose_leave();
  	}
***************
*** 1050,1057 ****
      if (!ok)
      {
  	if (io_error)
! 	    EMSG(_("E810: Cannot read or write temp files"));
! 	EMSG(_("E97: Cannot create diffs"));
  	diff_a_works = MAYBE;
  #if defined(MSWIN)
  	diff_bin_works = MAYBE;
--- 1049,1056 ----
      if (!ok)
      {
  	if (io_error)
! 	    emsg(_("E810: Cannot read or write temp files"));
! 	emsg(_("E97: Cannot create diffs"));
  	diff_a_works = MAYBE;
  #if defined(MSWIN)
  	diff_bin_works = MAYBE;
***************
*** 1093,1099 ****
  		&diffio->dio_new.din_mmfile,
  		&param, &emit_cfg, &emit_cb) < 0)
      {
! 	EMSG(_("E960: Problem creating the internal diff"));
  	return FAIL;
      }
      return OK;
--- 1092,1098 ----
  		&diffio->dio_new.din_mmfile,
  		&param, &emit_cfg, &emit_cb) < 0)
      {
! 	emsg(_("E960: Problem creating the internal diff"));
  	return FAIL;
      }
      return OK;
***************
*** 1273,1279 ****
      if (dirbuf[0] != NUL)
      {
  	if (mch_chdir((char *)dirbuf) != 0)
! 	    EMSG(_(e_prev_dir));
  	shorten_fnames(TRUE);
      }
  #endif
--- 1272,1278 ----
      if (dirbuf[0] != NUL)
      {
  	if (mch_chdir((char *)dirbuf) != 0)
! 	    emsg(_(e_prev_dir));
  	shorten_fnames(TRUE);
      }
  #endif
***************
*** 1291,1297 ****
  
      /* Only continue if the output file was created. */
      if (mch_stat((char *)tmp_new, &st) < 0 || st.st_size == 0)
! 	EMSG(_("E816: Cannot read patch output"));
      else
      {
  	if (curbuf->b_fname != NULL)
--- 1290,1296 ----
  
      /* Only continue if the output file was created. */
      if (mch_stat((char *)tmp_new, &st) < 0 || st.st_size == 0)
! 	emsg(_("E816: Cannot read patch output"));
      else
      {
  	if (curbuf->b_fname != NULL)
***************
*** 1596,1602 ****
  	fd = mch_fopen((char *)dout->dout_fname, "r");
  	if (fd == NULL)
  	{
! 	    EMSG(_("E98: Cannot read diff output"));
  	    return;
  	}
      }
--- 1595,1601 ----
  	fd = mch_fopen((char *)dout->dout_fname, "r");
  	if (fd == NULL)
  	{
! 	    emsg(_("E98: Cannot read diff output"));
  	    return;
  	}
      }
***************
*** 1662,1668 ****
  	}
  	else
  	{
! 	    EMSG(_("E959: Invalid diff format."));
  	    break;
  	}
  
--- 1661,1667 ----
  	}
  	else
  	{
! 	    emsg(_("E959: Invalid diff format."));
  	    break;
  	}
  
***************
*** 2572,2578 ****
      idx_cur = diff_buf_idx(curbuf);
      if (idx_cur == DB_COUNT)
      {
! 	EMSG(_("E99: Current buffer is not in diff mode"));
  	return;
      }
  
--- 2571,2577 ----
      idx_cur = diff_buf_idx(curbuf);
      if (idx_cur == DB_COUNT)
      {
! 	emsg(_("E99: Current buffer is not in diff mode"));
  	return;
      }
  
***************
*** 2591,2599 ****
  	if (idx_other == DB_COUNT)
  	{
  	    if (found_not_ma)
! 		EMSG(_("E793: No other buffer in diff mode is modifiable"));
  	    else
! 		EMSG(_("E100: No other buffer in diff mode"));
  	    return;
  	}
  
--- 2590,2598 ----
  	if (idx_other == DB_COUNT)
  	{
  	    if (found_not_ma)
! 		emsg(_("E793: No other buffer in diff mode is modifiable"));
  	    else
! 		emsg(_("E100: No other buffer in diff mode"));
  	    return;
  	}
  
***************
*** 2603,2609 ****
  		    && curtab->tp_diffbuf[i] != NULL
  		    && (eap->cmdidx != CMD_diffput || curtab->tp_diffbuf[i]->b_p_ma))
  	    {
! 		EMSG(_("E101: More than two buffers in diff mode, don't know which one to use"));
  		return;
  	    }
      }
--- 2602,2608 ----
  		    && curtab->tp_diffbuf[i] != NULL
  		    && (eap->cmdidx != CMD_diffput || curtab->tp_diffbuf[i]->b_p_ma))
  	    {
! 		emsg(_("E101: More than two buffers in diff mode, don't know which one to use"));
  		return;
  	    }
      }
***************
*** 2626,2632 ****
  	buf = buflist_findnr(i);
  	if (buf == NULL)
  	{
! 	    EMSG2(_("E102: Can't find buffer \"%s\""), eap->arg);
  	    return;
  	}
  	if (buf == curbuf)
--- 2625,2631 ----
  	buf = buflist_findnr(i);
  	if (buf == NULL)
  	{
! 	    semsg(_("E102: Can't find buffer \"%s\""), eap->arg);
  	    return;
  	}
  	if (buf == curbuf)
***************
*** 2634,2640 ****
  	idx_other = diff_buf_idx(buf);
  	if (idx_other == DB_COUNT)
  	{
! 	    EMSG2(_("E103: Buffer \"%s\" is not in diff mode"), eap->arg);
  	    return;
  	}
      }
--- 2633,2639 ----
  	idx_other = diff_buf_idx(buf);
  	if (idx_other == DB_COUNT)
  	{
! 	    semsg(_("E103: Buffer \"%s\" is not in diff mode"), eap->arg);
  	    return;
  	}
      }
***************
*** 2678,2684 ****
  	change_warning(0);
  	if (diff_buf_idx(curbuf) != idx_to)
  	{
! 	    EMSG(_("E787: Buffer changed unexpectedly"));
  	    goto theend;
  	}
      }
--- 2677,2683 ----
  	change_warning(0);
  	if (diff_buf_idx(curbuf) != idx_to)
  	{
! 	    emsg(_("E787: Buffer changed unexpectedly"));
  	    goto theend;
  	}
      }
*** ../vim-8.1.0742/src/digraph.c	2018-12-14 18:52:57.169528762 +0100
--- src/digraph.c	2019-01-13 20:13:21.377826929 +0100
***************
*** 2218,2235 ****
  	char2 = *str++;
  	if (char2 == 0)
  	{
! 	    EMSG(_(e_invarg));
  	    return;
  	}
  	if (char1 == ESC || char2 == ESC)
  	{
! 	    EMSG(_("E104: Escape not allowed in digraph"));
  	    return;
  	}
  	str = skipwhite(str);
  	if (!VIM_ISDIGIT(*str))
  	{
! 	    EMSG(_(e_number_exp));
  	    return;
  	}
  	n = getdigits(&str);
--- 2218,2235 ----
  	char2 = *str++;
  	if (char2 == 0)
  	{
! 	    emsg(_(e_invarg));
  	    return;
  	}
  	if (char1 == ESC || char2 == ESC)
  	{
! 	    emsg(_("E104: Escape not allowed in digraph"));
  	    return;
  	}
  	str = skipwhite(str);
  	if (!VIM_ISDIGIT(*str))
  	{
! 	    emsg(_(e_number_exp));
  	    return;
  	}
  	n = getdigits(&str);
***************
*** 2446,2452 ****
   * used when setting the option, not later when the value has already been
   * checked.
   */
!     char_u *
  keymap_init(void)
  {
      curbuf->b_kmap_state &= ~KEYMAP_INIT;
--- 2446,2452 ----
   * used when setting the option, not later when the value has already been
   * checked.
   */
!     char *
  keymap_init(void)
  {
      curbuf->b_kmap_state &= ~KEYMAP_INIT;
***************
*** 2487,2493 ****
  	    if (source_runtime(buf, 0) == FAIL)
  	    {
  		vim_free(buf);
! 		return (char_u *)N_("E544: Keymap file not found");
  	    }
  	}
  	vim_free(buf);
--- 2487,2493 ----
  	    if (source_runtime(buf, 0) == FAIL)
  	    {
  		vim_free(buf);
! 		return N_("E544: Keymap file not found");
  	    }
  	}
  	vim_free(buf);
***************
*** 2513,2519 ****
  
      if (!getline_equal(eap->getline, eap->cookie, getsourceline))
      {
! 	EMSG(_("E105: Using :loadkeymap not in a sourced file"));
  	return;
      }
  
--- 2513,2519 ----
  
      if (!getline_equal(eap->getline, eap->cookie, getsourceline))
      {
! 	emsg(_("E105: Using :loadkeymap not in a sourced file"));
  	return;
      }
  
***************
*** 2552,2558 ****
  		    || *kp->from == NUL || *kp->to == NUL)
  	    {
  		if (kp->to != NULL && *kp->to == NUL)
! 		    EMSG(_("E791: Empty keymap entry"));
  		vim_free(kp->from);
  		vim_free(kp->to);
  	    }
--- 2552,2558 ----
  		    || *kp->from == NUL || *kp->to == NUL)
  	    {
  		if (kp->to != NULL && *kp->to == NUL)
! 		    emsg(_("E791: Empty keymap entry"));
  		vim_free(kp->from);
  		vim_free(kp->to);
  	    }
*** ../vim-8.1.0742/src/edit.c	2019-01-11 22:15:00.519123428 +0100
--- src/edit.c	2019-01-13 19:46:26.947465113 +0100
***************
*** 360,366 ****
      /* Don't allow inserting in the sandbox. */
      if (sandbox != 0)
      {
! 	EMSG(_(e_sandbox));
  	return FALSE;
      }
  #endif
--- 360,366 ----
      /* Don't allow inserting in the sandbox. */
      if (sandbox != 0)
      {
! 	emsg(_(e_sandbox));
  	return FALSE;
      }
  #endif
***************
*** 368,374 ****
       * caller of getcmdline() may get confused. */
      if (textlock != 0)
      {
! 	EMSG(_(e_secure));
  	return FALSE;
      }
  
--- 368,374 ----
       * caller of getcmdline() may get confused. */
      if (textlock != 0)
      {
! 	emsg(_(e_secure));
  	return FALSE;
      }
  
***************
*** 376,382 ****
      /* Don't allow recursive insert mode when busy with completion. */
      if (compl_started || compl_busy || pum_visible())
      {
! 	EMSG(_(e_secure));
  	return FALSE;
      }
      ins_compl_clear();	    /* clear stuff for CTRL-X mode */
--- 376,382 ----
      /* Don't allow recursive insert mode when busy with completion. */
      if (compl_started || compl_busy || pum_visible())
      {
! 	emsg(_(e_secure));
  	return FALSE;
      }
      ins_compl_clear();	    /* clear stuff for CTRL-X mode */
***************
*** 476,482 ****
  	if (p_fkmap && p_ri)
  	{
  	    beep_flush();
! 	    EMSG(farsi_text_3);	    /* encoded in Farsi */
  	    State = INSERT;
  	}
  	else
--- 476,482 ----
  	if (p_fkmap && p_ri)
  	{
  	    beep_flush();
! 	    emsg(farsi_text_3);	    /* encoded in Farsi */
  	    State = INSERT;
  	}
  	else
***************
*** 4262,4275 ****
  
      if (curwin_save != curwin || curbuf_save != curbuf)
      {
! 	EMSG(_(e_complwin));
  	goto theend;
      }
      curwin->w_cursor = pos;	/* restore the cursor position */
      validate_cursor();
      if (!EQUAL_POS(curwin->w_cursor, pos))
      {
! 	EMSG(_(e_compldel));
  	goto theend;
      }
  
--- 4262,4275 ----
  
      if (curwin_save != curwin || curbuf_save != curbuf)
      {
! 	emsg(_(e_complwin));
  	goto theend;
      }
      curwin->w_cursor = pos;	/* restore the cursor position */
      validate_cursor();
      if (!EQUAL_POS(curwin->w_cursor, pos))
      {
! 	emsg(_(e_compldel));
  	goto theend;
      }
  
***************
*** 5567,5573 ****
  					  ? curbuf->b_p_cfu : curbuf->b_p_ofu;
  	    if (*funcname == NUL)
  	    {
! 		EMSG2(_(e_notset), ctrl_x_mode == CTRL_X_FUNCTION
  					     ? "completefunc" : "omnifunc");
  		/* restore did_ai, so that adding comment leader works */
  		did_ai = save_did_ai;
--- 5567,5573 ----
  					  ? curbuf->b_p_cfu : curbuf->b_p_ofu;
  	    if (*funcname == NUL)
  	    {
! 		semsg(_(e_notset), ctrl_x_mode == CTRL_X_FUNCTION
  					     ? "completefunc" : "omnifunc");
  		/* restore did_ai, so that adding comment leader works */
  		did_ai = save_did_ai;
***************
*** 5587,5600 ****
  	    State = save_State;
  	    if (curwin_save != curwin || curbuf_save != curbuf)
  	    {
! 		EMSG(_(e_complwin));
  		return FAIL;
  	    }
  	    curwin->w_cursor = pos;	/* restore the cursor position */
  	    validate_cursor();
  	    if (!EQUAL_POS(curwin->w_cursor, pos))
  	    {
! 		EMSG(_(e_compldel));
  		return FAIL;
  	    }
  
--- 5587,5600 ----
  	    State = save_State;
  	    if (curwin_save != curwin || curbuf_save != curbuf)
  	    {
! 		emsg(_(e_complwin));
  		return FAIL;
  	    }
  	    curwin->w_cursor = pos;	/* restore the cursor position */
  	    validate_cursor();
  	    if (!EQUAL_POS(curwin->w_cursor, pos))
  	    {
! 		emsg(_(e_compldel));
  		return FAIL;
  	    }
  
***************
*** 7678,7684 ****
      ptr = get_last_insert();
      if (ptr == NULL)
      {
! 	EMSG(_(e_noinstext));
  	return FAIL;
      }
  
--- 7678,7684 ----
      ptr = get_last_insert();
      if (ptr == NULL)
      {
! 	emsg(_(e_noinstext));
  	return FAIL;
      }
  
***************
*** 8969,8975 ****
      if (p_fkmap && p_ri)
      {
  	beep_flush();
! 	EMSG(farsi_text_3);	/* encoded in Farsi */
  	return;
      }
  #endif
--- 8969,8975 ----
      if (p_fkmap && p_ri)
      {
  	beep_flush();
! 	emsg(farsi_text_3);	/* encoded in Farsi */
  	return;
      }
  #endif
*** ../vim-8.1.0742/src/eval.c	2019-01-13 17:48:00.994125660 +0100
--- src/eval.c	2019-01-13 19:47:04.091092657 +0100
***************
*** 301,307 ****
  	p = &vimvars[i];
  	if (STRLEN(p->vv_name) > 16)
  	{
! 	    IEMSG("INTERNAL: name too long, increase size of dictitem16_T");
  	    getout(1);
  	}
  	STRCPY(p->vv_di.di_key, p->vv_name);
--- 301,307 ----
  	p = &vimvars[i];
  	if (STRLEN(p->vv_name) > 16)
  	{
! 	    iemsg("INTERNAL: name too long, increase size of dictitem16_T");
  	    getout(1);
  	}
  	STRCPY(p->vv_di.di_key, p->vv_name);
***************
*** 448,454 ****
      /* Catch a bad name early. */
      if (!eval_isnamec1(*name))
      {
! 	EMSG(_(e_invarg));
  	return FAIL;
      }
  
--- 448,454 ----
      /* Catch a bad name early. */
      if (!eval_isnamec1(*name))
      {
! 	emsg(_(e_invarg));
  	return FAIL;
      }
  
***************
*** 475,483 ****
  	clear_lval(redir_lval);
  	if (redir_endp != NULL && *redir_endp != NUL)
  	    /* Trailing characters are present after the variable name */
! 	    EMSG(_(e_trailing));
  	else
! 	    EMSG(_(e_invarg));
  	redir_endp = NULL;  /* don't store a value, only cleanup */
  	var_redir_stop();
  	return FAIL;
--- 475,483 ----
  	clear_lval(redir_lval);
  	if (redir_endp != NULL && *redir_endp != NUL)
  	    /* Trailing characters are present after the variable name */
! 	    emsg(_(e_trailing));
  	else
! 	    emsg(_(e_invarg));
  	redir_endp = NULL;  /* don't store a value, only cleanup */
  	var_redir_stop();
  	return FAIL;
***************
*** 734,740 ****
  	if (*s != NUL)  /* check for trailing chars after expr */
  	{
  	    clear_tv(rettv);
! 	    EMSG2(_(e_invexpr2), s);
  	    return FAIL;
  	}
      }
--- 734,740 ----
  	if (*s != NUL)  /* check for trailing chars after expr */
  	{
  	    clear_tv(rettv);
! 	    semsg(_(e_invexpr2), s);
  	    return FAIL;
  	}
      }
***************
*** 1202,1208 ****
  	 * ":let" without "=": list variables
  	 */
  	if (*arg == '[')
! 	    EMSG(_(e_invarg));
  	else if (!ends_excmd(*arg))
  	    /* ":let var1 var2" */
  	    arg = list_arg_vars(eap, arg, &first);
--- 1202,1208 ----
  	 * ":let" without "=": list variables
  	 */
  	if (*arg == '[')
! 	    emsg(_(e_invarg));
  	else if (!ends_excmd(*arg))
  	    /* ":let var1 var2" */
  	    arg = list_arg_vars(eap, arg, &first);
***************
*** 1288,1306 ****
       */
      if (tv->v_type != VAR_LIST || (l = tv->vval.v_list) == NULL)
      {
! 	EMSG(_(e_listreq));
  	return FAIL;
      }
  
      i = list_len(l);
      if (semicolon == 0 && var_count < i)
      {
! 	EMSG(_("E687: Less targets than List items"));
  	return FAIL;
      }
      if (var_count - semicolon > i)
      {
! 	EMSG(_("E688: More targets than List items"));
  	return FAIL;
      }
  
--- 1288,1306 ----
       */
      if (tv->v_type != VAR_LIST || (l = tv->vval.v_list) == NULL)
      {
! 	emsg(_(e_listreq));
  	return FAIL;
      }
  
      i = list_len(l);
      if (semicolon == 0 && var_count < i)
      {
! 	emsg(_("E687: Less targets than List items"));
  	return FAIL;
      }
      if (var_count - semicolon > i)
      {
! 	emsg(_("E688: More targets than List items"));
  	return FAIL;
      }
  
***************
*** 1374,1380 ****
  	    s = skip_var_one(p);
  	    if (s == p)
  	    {
! 		EMSG2(_(e_invarg2), p);
  		return NULL;
  	    }
  	    ++*var_count;
--- 1374,1380 ----
  	    s = skip_var_one(p);
  	    if (s == p)
  	    {
! 		semsg(_(e_invarg2), p);
  		return NULL;
  	    }
  	    ++*var_count;
***************
*** 1386,1399 ****
  	    {
  		if (*semicolon == 1)
  		{
! 		    EMSG(_("Double ; in list of variables"));
  		    return NULL;
  		}
  		*semicolon = 1;
  	    }
  	    else if (*p != ',')
  	    {
! 		EMSG2(_(e_invarg2), p);
  		return NULL;
  	    }
  	}
--- 1386,1399 ----
  	    {
  		if (*semicolon == 1)
  		{
! 		    emsg(_("Double ; in list of variables"));
  		    return NULL;
  		}
  		*semicolon = 1;
  	    }
  	    else if (*p != ',')
  	    {
! 		semsg(_(e_invarg2), p);
  		return NULL;
  	    }
  	}
***************
*** 1534,1540 ****
  	    if (!VIM_ISWHITE(*arg) && !ends_excmd(*arg))
  	    {
  		emsg_severe = TRUE;
! 		EMSG(_(e_trailing));
  		break;
  	    }
  	}
--- 1534,1540 ----
  	    if (!VIM_ISWHITE(*arg) && !ends_excmd(*arg))
  	    {
  		emsg_severe = TRUE;
! 		emsg(_(e_trailing));
  		break;
  	    }
  	}
***************
*** 1550,1556 ****
  		if (len < 0 && !aborting())
  		{
  		    emsg_severe = TRUE;
! 		    EMSG2(_(e_invarg2), arg);
  		    break;
  		}
  		error = TRUE;
--- 1550,1556 ----
  		if (len < 0 && !aborting())
  		{
  		    emsg_severe = TRUE;
! 		    semsg(_(e_invarg2), arg);
  		    break;
  		}
  		error = TRUE;
***************
*** 1581,1587 ****
  				case 's': list_script_vars(first); break;
  				case 'l': list_func_vars(first); break;
  				default:
! 					  EMSG2(_("E738: Can't list variables for %s"), name);
  			    }
  			}
  			else
--- 1581,1587 ----
  				case 's': list_script_vars(first); break;
  				case 'l': list_func_vars(first); break;
  				default:
! 					  semsg(_("E738: Can't list variables for %s"), name);
  			    }
  			}
  			else
***************
*** 1647,1660 ****
  	name = arg;
  	len = get_env_len(&arg);
  	if (len == 0)
! 	    EMSG2(_(e_invarg2), name - 1);
  	else
  	{
  	    if (op != NULL && (*op == '+' || *op == '-'))
! 		EMSG2(_(e_letwrong), op);
  	    else if (endchars != NULL
  			     && vim_strchr(endchars, *skipwhite(arg)) == NULL)
! 		EMSG(_(e_letunexp));
  	    else if (!check_secure())
  	    {
  		c1 = name[len];
--- 1647,1660 ----
  	name = arg;
  	len = get_env_len(&arg);
  	if (len == 0)
! 	    semsg(_(e_invarg2), name - 1);
  	else
  	{
  	    if (op != NULL && (*op == '+' || *op == '-'))
! 		semsg(_(e_letwrong), op);
  	    else if (endchars != NULL
  			     && vim_strchr(endchars, *skipwhite(arg)) == NULL)
! 		emsg(_(e_letunexp));
  	    else if (!check_secure())
  	    {
  		c1 = name[len];
***************
*** 1701,1707 ****
  	p = find_option_end(&arg, &opt_flags);
  	if (p == NULL || (endchars != NULL
  			      && vim_strchr(endchars, *skipwhite(p)) == NULL))
! 	    EMSG(_(e_letunexp));
  	else
  	{
  	    long	n;
--- 1701,1707 ----
  	p = find_option_end(&arg, &opt_flags);
  	if (p == NULL || (endchars != NULL
  			      && vim_strchr(endchars, *skipwhite(p)) == NULL))
! 	    emsg(_(e_letunexp));
  	else
  	{
  	    long	n;
***************
*** 1722,1728 ****
  		if ((opt_type == 1 && *op == '.')
  			|| (opt_type == 0 && *op != '.'))
  		{
! 		    EMSG2(_(e_letwrong), op);
  		    s = NULL;  /* don't set the value */
  		}
  		else
--- 1722,1728 ----
  		if ((opt_type == 1 && *op == '.')
  			|| (opt_type == 0 && *op != '.'))
  		{
! 		    semsg(_(e_letwrong), op);
  		    s = NULL;  /* don't set the value */
  		}
  		else
***************
*** 1759,1768 ****
      {
  	++arg;
  	if (op != NULL && (*op == '+' || *op == '-'))
! 	    EMSG2(_(e_letwrong), op);
  	else if (endchars != NULL
  			 && vim_strchr(endchars, *skipwhite(arg + 1)) == NULL)
! 	    EMSG(_(e_letunexp));
  	else
  	{
  	    char_u	*ptofree = NULL;
--- 1759,1768 ----
      {
  	++arg;
  	if (op != NULL && (*op == '+' || *op == '-'))
! 	    semsg(_(e_letwrong), op);
  	else if (endchars != NULL
  			 && vim_strchr(endchars, *skipwhite(arg + 1)) == NULL)
! 	    emsg(_(e_letunexp));
  	else
  	{
  	    char_u	*ptofree = NULL;
***************
*** 1799,1805 ****
  	if (p != NULL && lv.ll_name != NULL)
  	{
  	    if (endchars != NULL && vim_strchr(endchars, *skipwhite(p)) == NULL)
! 		EMSG(_(e_letunexp));
  	    else
  	    {
  		set_var_lval(&lv, p, tv, copy, op);
--- 1799,1805 ----
  	if (p != NULL && lv.ll_name != NULL)
  	{
  	    if (endchars != NULL && vim_strchr(endchars, *skipwhite(p)) == NULL)
! 		emsg(_(e_letunexp));
  	    else
  	    {
  		set_var_lval(&lv, p, tv, copy, op);
***************
*** 1810,1816 ****
      }
  
      else
! 	EMSG2(_(e_invarg2), arg);
  
      return arg_end;
  }
--- 1810,1816 ----
      }
  
      else
! 	semsg(_(e_invarg2), arg);
  
      return arg_end;
  }
***************
*** 1875,1881 ****
  	if (unlet && !VIM_ISWHITE(*p) && !ends_excmd(*p)
  						    && *p != '[' && *p != '.')
  	{
! 	    EMSG(_(e_trailing));
  	    return NULL;
  	}
  
--- 1875,1881 ----
  	if (unlet && !VIM_ISWHITE(*p) && !ends_excmd(*p)
  						    && *p != '[' && *p != '.')
  	{
! 	    emsg(_(e_trailing));
  	    return NULL;
  	}
  
***************
*** 1888,1894 ****
  	    if (!aborting() && !quiet)
  	    {
  		emsg_severe = TRUE;
! 		EMSG2(_(e_invarg2), name);
  		return NULL;
  	    }
  	}
--- 1888,1894 ----
  	    if (!aborting() && !quiet)
  	    {
  		emsg_severe = TRUE;
! 		semsg(_(e_invarg2), name);
  		return NULL;
  	    }
  	}
***************
*** 1908,1914 ****
      v = find_var(lp->ll_name, (flags & GLV_READ_ONLY) ? NULL : &ht,
  						      flags & GLV_NO_AUTOLOAD);
      if (v == NULL && !quiet)
! 	EMSG2(_(e_undefvar), lp->ll_name);
      *p = cc;
      if (v == NULL)
  	return NULL;
--- 1908,1914 ----
      v = find_var(lp->ll_name, (flags & GLV_READ_ONLY) ? NULL : &ht,
  						      flags & GLV_NO_AUTOLOAD);
      if (v == NULL && !quiet)
! 	semsg(_(e_undefvar), lp->ll_name);
      *p = cc;
      if (v == NULL)
  	return NULL;
***************
*** 1928,1940 ****
  					   && lp->ll_tv->vval.v_blob != NULL))
  	{
  	    if (!quiet)
! 		EMSG(_("E689: Can only index a List, Dictionary or Blob"));
  	    return NULL;
  	}
  	if (lp->ll_range)
  	{
  	    if (!quiet)
! 		EMSG(_("E708: [:] must come last"));
  	    return NULL;
  	}
  
--- 1928,1940 ----
  					   && lp->ll_tv->vval.v_blob != NULL))
  	{
  	    if (!quiet)
! 		emsg(_("E689: Can only index a List, Dictionary or Blob"));
  	    return NULL;
  	}
  	if (lp->ll_range)
  	{
  	    if (!quiet)
! 		emsg(_("E708: [:] must come last"));
  	    return NULL;
  	}
  
***************
*** 1947,1953 ****
  	    if (len == 0)
  	    {
  		if (!quiet)
! 		    EMSG(_(e_emptykey));
  		return NULL;
  	    }
  	    p = key + len;
--- 1947,1953 ----
  	    if (len == 0)
  	    {
  		if (!quiet)
! 		    emsg(_(e_emptykey));
  		return NULL;
  	    }
  	    p = key + len;
***************
*** 1977,1983 ****
  		if (lp->ll_tv->v_type == VAR_DICT)
  		{
  		    if (!quiet)
! 			EMSG(_(e_dictrange));
  		    clear_tv(&var1);
  		    return NULL;
  		}
--- 1977,1983 ----
  		if (lp->ll_tv->v_type == VAR_DICT)
  		{
  		    if (!quiet)
! 			emsg(_(e_dictrange));
  		    clear_tv(&var1);
  		    return NULL;
  		}
***************
*** 1988,1994 ****
  						&& rettv->vval.v_blob != NULL))
  		{
  		    if (!quiet)
! 			EMSG(_("E709: [:] requires a List or Blob value"));
  		    clear_tv(&var1);
  		    return NULL;
  		}
--- 1988,1994 ----
  						&& rettv->vval.v_blob != NULL))
  		{
  		    if (!quiet)
! 			emsg(_("E709: [:] requires a List or Blob value"));
  		    clear_tv(&var1);
  		    return NULL;
  		}
***************
*** 2019,2025 ****
  	    if (*p != ']')
  	    {
  		if (!quiet)
! 		    EMSG(_(e_missbrac));
  		clear_tv(&var1);
  		clear_tv(&var2);
  		return NULL;
--- 2019,2025 ----
  	    if (*p != ']')
  	    {
  		if (!quiet)
! 		    emsg(_(e_missbrac));
  		clear_tv(&var1);
  		clear_tv(&var2);
  		return NULL;
***************
*** 2075,2081 ****
  		/* Can't add "v:" variable. */
  		if (lp->ll_dict == &vimvardict)
  		{
! 		    EMSG2(_(e_illvar), name);
  		    return NULL;
  		}
  
--- 2075,2081 ----
  		/* Can't add "v:" variable. */
  		if (lp->ll_dict == &vimvardict)
  		{
! 		    semsg(_(e_illvar), name);
  		    return NULL;
  		}
  
***************
*** 2083,2089 ****
  		if (*p == '[' || *p == '.' || unlet)
  		{
  		    if (!quiet)
! 			EMSG2(_(e_dictkey), key);
  		    clear_tv(&var1);
  		    return NULL;
  		}
--- 2083,2089 ----
  		if (*p == '[' || *p == '.' || unlet)
  		{
  		    if (!quiet)
! 			semsg(_(e_dictkey), key);
  		    clear_tv(&var1);
  		    return NULL;
  		}
***************
*** 2126,2132 ****
  		    || (lp->ll_range && lp->ll_n1 == bloblen))
  	    {
  		if (!quiet)
! 		    EMSGN(_(e_blobidx), lp->ll_n1);
  		clear_tv(&var2);
  		return NULL;
  	    }
--- 2126,2132 ----
  		    || (lp->ll_range && lp->ll_n1 == bloblen))
  	    {
  		if (!quiet)
! 		    semsg(_(e_blobidx), lp->ll_n1);
  		clear_tv(&var2);
  		return NULL;
  	    }
***************
*** 2139,2145 ****
  			|| lp->ll_n2 < lp->ll_n1)
  		{
  		    if (!quiet)
! 			EMSGN(_(e_blobidx), lp->ll_n2);
  		    return NULL;
  		}
  	    }
--- 2139,2145 ----
  			|| lp->ll_n2 < lp->ll_n1)
  		{
  		    if (!quiet)
! 			semsg(_(e_blobidx), lp->ll_n2);
  		    return NULL;
  		}
  	    }
***************
*** 2173,2179 ****
  	    {
  		clear_tv(&var2);
  		if (!quiet)
! 		    EMSGN(_(e_listidx), lp->ll_n1);
  		return NULL;
  	    }
  
--- 2173,2179 ----
  	    {
  		clear_tv(&var2);
  		if (!quiet)
! 		    semsg(_(e_listidx), lp->ll_n1);
  		return NULL;
  	    }
  
***************
*** 2194,2200 ****
  		    if (ni == NULL)
  		    {
  			if (!quiet)
! 			    EMSGN(_(e_listidx), lp->ll_n2);
  			return NULL;
  		    }
  		    lp->ll_n2 = list_idx_of_item(lp->ll_list, ni);
--- 2194,2200 ----
  		    if (ni == NULL)
  		    {
  			if (!quiet)
! 			    semsg(_(e_listidx), lp->ll_n2);
  			return NULL;
  		    }
  		    lp->ll_n2 = list_idx_of_item(lp->ll_list, ni);
***************
*** 2206,2212 ****
  		if (lp->ll_n2 < lp->ll_n1)
  		{
  		    if (!quiet)
! 			EMSGN(_(e_listidx), lp->ll_n2);
  		    return NULL;
  		}
  	    }
--- 2206,2212 ----
  		if (lp->ll_n2 < lp->ll_n1)
  		{
  		    if (!quiet)
! 			semsg(_(e_listidx), lp->ll_n2);
  		    return NULL;
  		}
  	    }
***************
*** 2256,2262 ****
  
  	    if (op != NULL && *op != '=')
  	    {
! 		EMSG2(_(e_letwrong), op);
  		return;
  	    }
  
--- 2256,2262 ----
  
  	    if (op != NULL && *op != '=')
  	    {
! 		semsg(_(e_letwrong), op);
  		return;
  	    }
  
***************
*** 2269,2275 ****
  
  		if (lp->ll_n2 - lp->ll_n1 + 1 != blob_len(rettv->vval.v_blob))
  		{
! 		    EMSG(_("E972: Blob value does not have the right number of bytes"));
  		    return;
  		}
  		if (lp->ll_empty2)
--- 2269,2275 ----
  
  		if (lp->ll_n2 - lp->ll_n1 + 1 != blob_len(rettv->vval.v_blob))
  		{
! 		    emsg(_("E972: Blob value does not have the right number of bytes"));
  		    return;
  		}
  		if (lp->ll_empty2)
***************
*** 2374,2384 ****
  	    ++lp->ll_n1;
  	}
  	if (ri != NULL)
! 	    EMSG(_("E710: List value has more items than target"));
  	else if (lp->ll_empty2
  		? (lp->ll_li != NULL && lp->ll_li->li_next != NULL)
  		: lp->ll_n1 != lp->ll_n2)
! 	    EMSG(_("E711: List value has not enough items"));
      }
      else
      {
--- 2374,2384 ----
  	    ++lp->ll_n1;
  	}
  	if (ri != NULL)
! 	    emsg(_("E710: List value has more items than target"));
  	else if (lp->ll_empty2
  		? (lp->ll_li != NULL && lp->ll_li->li_next != NULL)
  		: lp->ll_n1 != lp->ll_n2)
! 	    emsg(_("E711: List value has not enough items"));
      }
      else
      {
***************
*** 2389,2395 ****
  	{
  	    if (op != NULL && *op != '=')
  	    {
! 		EMSG2(_(e_letwrong), op);
  		return;
  	    }
  
--- 2389,2395 ----
  	{
  	    if (op != NULL && *op != '=')
  	    {
! 		semsg(_(e_letwrong), op);
  		return;
  	    }
  
***************
*** 2544,2550 ****
  	}
      }
  
!     EMSG2(_(e_letwrong), op);
      return FAIL;
  }
  
--- 2544,2550 ----
  	}
      }
  
!     semsg(_(e_letwrong), op);
      return FAIL;
  }
  
***************
*** 2580,2586 ****
      expr = skipwhite(expr);
      if (expr[0] != 'i' || expr[1] != 'n' || !VIM_ISWHITE(expr[2]))
      {
! 	EMSG(_("E690: Missing \"in\" after :for"));
  	return fi;
      }
  
--- 2580,2586 ----
      expr = skipwhite(expr);
      if (expr[0] != 'i' || expr[1] != 'n' || !VIM_ISWHITE(expr[2]))
      {
! 	emsg(_("E690: Missing \"in\" after :for"));
  	return fi;
      }
  
***************
*** 2623,2629 ****
  	    }
  	    else
  	    {
! 		EMSG(_(e_listreq));
  		clear_tv(&tv);
  	    }
  	}
--- 2623,2629 ----
  	    }
  	    else
  	    {
! 		emsg(_(e_listreq));
  		clear_tv(&tv);
  	    }
  	}
***************
*** 2860,2866 ****
  
  	    if (get_env_len(&arg) == 0)
  	    {
! 		EMSG2(_(e_invarg2), name - 1);
  		return;
  	    }
  	    vim_unsetenv(name);
--- 2860,2866 ----
  
  	    if (get_env_len(&arg) == 0)
  	    {
! 		semsg(_(e_invarg2), name - 1);
  		return;
  	    }
  	    vim_unsetenv(name);
***************
*** 2879,2885 ****
  	    if (name_end != NULL)
  	    {
  		emsg_severe = TRUE;
! 		EMSG(_(e_trailing));
  	    }
  	    if (!(eap->skip || error))
  		clear_lval(&lv);
--- 2879,2885 ----
  	    if (name_end != NULL)
  	    {
  		emsg_severe = TRUE;
! 		emsg(_(e_trailing));
  	    }
  	    if (!(eap->skip || error))
  		clear_lval(&lv);
***************
*** 3022,3028 ****
      }
      if (forceit)
  	return OK;
!     EMSG2(_("E108: No such variable: \"%s\""), name);
      return FAIL;
  }
  
--- 3022,3028 ----
      }
      if (forceit)
  	return OK;
!     semsg(_("E108: No such variable: \"%s\""), name);
      return FAIL;
  }
  
***************
*** 3059,3065 ****
  			&& di->di_tv.v_type != VAR_LIST)
  	    /* For historic reasons this error is not given for a list or dict.
  	     * E.g., the b: dict could be locked/unlocked. */
! 	    EMSG2(_("E940: Cannot lock or unlock variable %s"), lp->ll_name);
  	else
  	{
  	    if (lock)
--- 3059,3065 ----
  			&& di->di_tv.v_type != VAR_LIST)
  	    /* For historic reasons this error is not given for a list or dict.
  	     * E.g., the b: dict could be locked/unlocked. */
! 	    semsg(_("E940: Cannot lock or unlock variable %s"), lp->ll_name);
  	else
  	{
  	    if (lock)
***************
*** 3108,3114 ****
  
      if (recurse >= DICT_MAXNEST)
      {
! 	EMSG(_("E743: variable nested too deep for (un)lock"));
  	return;
      }
      if (deep == 0)
--- 3108,3114 ----
  
      if (recurse >= DICT_MAXNEST)
      {
! 	emsg(_("E743: variable nested too deep for (un)lock"));
  	return;
      }
      if (deep == 0)
***************
*** 3393,3399 ****
  	 */
  	if (!aborting() && did_emsg == did_emsg_before
  					  && called_emsg == called_emsg_before)
! 	    EMSG2(_(e_invexpr2), arg);
  	ret = FAIL;
      }
      if (nextcmd != NULL)
--- 3393,3399 ----
  	 */
  	if (!aborting() && did_emsg == did_emsg_before
  					  && called_emsg == called_emsg_before)
! 	    semsg(_(e_invexpr2), arg);
  	ret = FAIL;
      }
      if (nextcmd != NULL)
***************
*** 3451,3457 ****
  	 */
  	if ((*arg)[0] != ':')
  	{
! 	    EMSG(_("E109: Missing ':' after '?'"));
  	    if (evaluate && result)
  		clear_tv(rettv);
  	    return FAIL;
--- 3451,3457 ----
  	 */
  	if ((*arg)[0] != ':')
  	{
! 	    emsg(_("E109: Missing ':' after '?'"));
  	    if (evaluate && result)
  		clear_tv(rettv);
  	    return FAIL;
***************
*** 4058,4064 ****
  		}
  		else
  		{
! 		    EMSG(_("E804: Cannot use '%' with Float"));
  		    return FAIL;
  		}
  		rettv->v_type = VAR_FLOAT;
--- 4058,4064 ----
  		}
  		else
  		{
! 		    emsg(_("E804: Cannot use '%' with Float"));
  		    return FAIL;
  		}
  		rettv->v_type = VAR_FLOAT;
***************
*** 4223,4229 ****
  			{
  			    if (blob != NULL)
  			    {
! 				EMSG(_("E973: Blob literal should have an even number of hex characters"));
  				ga_clear(&blob->bv_ga);
  				VIM_CLEAR(blob);
  			    }
--- 4223,4229 ----
  			{
  			    if (blob != NULL)
  			    {
! 				emsg(_("E973: Blob literal should have an even number of hex characters"));
  				ga_clear(&blob->bv_ga);
  				VIM_CLEAR(blob);
  			    }
***************
*** 4314,4320 ****
  		    ++*arg;
  		else if (ret == OK)
  		{
! 		    EMSG(_("E110: Missing ')'"));
  		    clear_tv(rettv);
  		    ret = FAIL;
  		}
--- 4314,4320 ----
  		    ++*arg;
  		else if (ret == OK)
  		{
! 		    emsg(_("E110: Missing ')'"));
  		    clear_tv(rettv);
  		    ret = FAIL;
  		}
***************
*** 4488,4506 ****
  	case VAR_FUNC:
  	case VAR_PARTIAL:
  	    if (verbose)
! 		EMSG(_("E695: Cannot index a Funcref"));
  	    return FAIL;
  	case VAR_FLOAT:
  #ifdef FEAT_FLOAT
  	    if (verbose)
! 		EMSG(_(e_float_as_string));
  	    return FAIL;
  #endif
  	case VAR_SPECIAL:
  	case VAR_JOB:
  	case VAR_CHANNEL:
  	    if (verbose)
! 		EMSG(_("E909: Cannot index a special variable"));
  	    return FAIL;
  	case VAR_UNKNOWN:
  	    if (evaluate)
--- 4488,4506 ----
  	case VAR_FUNC:
  	case VAR_PARTIAL:
  	    if (verbose)
! 		emsg(_("E695: Cannot index a Funcref"));
  	    return FAIL;
  	case VAR_FLOAT:
  #ifdef FEAT_FLOAT
  	    if (verbose)
! 		emsg(_(e_float_as_string));
  	    return FAIL;
  #endif
  	case VAR_SPECIAL:
  	case VAR_JOB:
  	case VAR_CHANNEL:
  	    if (verbose)
! 		emsg(_("E909: Cannot index a special variable"));
  	    return FAIL;
  	case VAR_UNKNOWN:
  	    if (evaluate)
***************
*** 4577,4583 ****
  	if (**arg != ']')
  	{
  	    if (verbose)
! 		EMSG(_(e_missbrac));
  	    clear_tv(&var1);
  	    if (range)
  		clear_tv(&var2);
--- 4577,4583 ----
  	if (**arg != ']')
  	{
  	    if (verbose)
! 		emsg(_(e_missbrac));
  	    clear_tv(&var1);
  	    if (range)
  		clear_tv(&var2);
***************
*** 4711,4717 ****
  			rettv->vval.v_number = v;
  		    }
  		    else
! 			EMSGN(_(e_blobidx), n1);
  		}
  		break;
  
--- 4711,4717 ----
  			rettv->vval.v_number = v;
  		    }
  		    else
! 			semsg(_(e_blobidx), n1);
  		}
  		break;
  
***************
*** 4726,4732 ****
  		    if (!range)
  		    {
  			if (verbose)
! 			    EMSGN(_(e_listidx), n1);
  			return FAIL;
  		    }
  		    n1 = len;
--- 4726,4732 ----
  		    if (!range)
  		    {
  			if (verbose)
! 			    semsg(_(e_listidx), n1);
  			return FAIL;
  		    }
  		    n1 = len;
***************
*** 4770,4776 ****
  		if (range)
  		{
  		    if (verbose)
! 			EMSG(_(e_dictrange));
  		    if (len == -1)
  			clear_tv(&var1);
  		    return FAIL;
--- 4770,4776 ----
  		if (range)
  		{
  		    if (verbose)
! 			emsg(_(e_dictrange));
  		    if (len == -1)
  			clear_tv(&var1);
  		    return FAIL;
***************
*** 4791,4797 ****
  		    item = dict_find(rettv->vval.v_dict, key, (int)len);
  
  		    if (item == NULL && verbose)
! 			EMSG2(_(e_dictkey), key);
  		    if (len == -1)
  			clear_tv(&var1);
  		    if (item == NULL)
--- 4791,4797 ----
  		    item = dict_find(rettv->vval.v_dict, key, (int)len);
  
  		    if (item == NULL && verbose)
! 			semsg(_(e_dictkey), key);
  		    if (len == -1)
  			clear_tv(&var1);
  		    if (item == NULL)
***************
*** 4836,4842 ****
      if (option_end == NULL)
      {
  	if (rettv != NULL)
! 	    EMSG2(_("E112: Option name missing: %s"), *arg);
  	return FAIL;
      }
  
--- 4836,4842 ----
      if (option_end == NULL)
      {
  	if (rettv != NULL)
! 	    semsg(_("E112: Option name missing: %s"), *arg);
  	return FAIL;
      }
  
***************
*** 4854,4860 ****
      if (opt_type == -3)			/* invalid name */
      {
  	if (rettv != NULL)
! 	    EMSG2(_("E113: Unknown option: %s"), *arg);
  	ret = FAIL;
      }
      else if (rettv != NULL)
--- 4854,4860 ----
      if (opt_type == -3)			/* invalid name */
      {
  	if (rettv != NULL)
! 	    semsg(_("E113: Unknown option: %s"), *arg);
  	ret = FAIL;
      }
      else if (rettv != NULL)
***************
*** 4917,4923 ****
  
      if (*p != '"')
      {
! 	EMSG2(_("E114: Missing quote: %s"), *arg);
  	return FAIL;
      }
  
--- 4917,4923 ----
  
      if (*p != '"')
      {
! 	semsg(_("E114: Missing quote: %s"), *arg);
  	return FAIL;
      }
  
***************
*** 5054,5060 ****
  
      if (*p != '\'')
      {
! 	EMSG2(_("E115: Missing quote: %s"), *arg);
  	return FAIL;
      }
  
--- 5054,5060 ----
  
      if (*p != '\'')
      {
! 	semsg(_("E115: Missing quote: %s"), *arg);
  	return FAIL;
      }
  
***************
*** 5798,5804 ****
  	     * flooding the user with errors.  And stop iterating over lists
  	     * and dicts. */
  	    did_echo_string_emsg = TRUE;
! 	    EMSG(_("E724: variable nested too deep for displaying"));
  	}
  	*tofree = NULL;
  	return (char_u *)"{E724}";
--- 5798,5804 ----
  	     * flooding the user with errors.  And stop iterating over lists
  	     * and dicts. */
  	    did_echo_string_emsg = TRUE;
! 	    emsg(_("E724: variable nested too deep for displaying"));
  	}
  	*tofree = NULL;
  	return (char_u *)"{E724}";
***************
*** 6439,6445 ****
      // Only give an error when there is something, otherwise it will be
      // reported at a higher level.
      if (len == 0 && verbose && **arg != NUL)
! 	EMSG2(_(e_invexpr2), *arg);
  
      return len;
  }
--- 6439,6445 ----
      // Only give an error when there is something, otherwise it will be
      // reported at a higher level.
      if (len == 0 && verbose && **arg != NUL)
! 	semsg(_(e_invexpr2), *arg);
  
      return len;
  }
***************
*** 6937,6943 ****
      if (tv == NULL)
      {
  	if (rettv != NULL && verbose)
! 	    EMSG2(_(e_undefvar), name);
  	ret = FAIL;
      }
      else if (rettv != NULL)
--- 6937,6943 ----
      if (tv == NULL)
      {
  	if (rettv != NULL && verbose)
! 	    semsg(_(e_undefvar), name);
  	ret = FAIL;
      }
      else if (rettv != NULL)
***************
*** 7251,7262 ****
  	    return varp->vval.v_number;
  	case VAR_FLOAT:
  #ifdef FEAT_FLOAT
! 	    EMSG(_("E805: Using a Float as a Number"));
  	    break;
  #endif
  	case VAR_FUNC:
  	case VAR_PARTIAL:
! 	    EMSG(_("E703: Using a Funcref as a Number"));
  	    break;
  	case VAR_STRING:
  	    if (varp->vval.v_string != NULL)
--- 7251,7262 ----
  	    return varp->vval.v_number;
  	case VAR_FLOAT:
  #ifdef FEAT_FLOAT
! 	    emsg(_("E805: Using a Float as a Number"));
  	    break;
  #endif
  	case VAR_FUNC:
  	case VAR_PARTIAL:
! 	    emsg(_("E703: Using a Funcref as a Number"));
  	    break;
  	case VAR_STRING:
  	    if (varp->vval.v_string != NULL)
***************
*** 7264,7289 ****
  						    STR2NR_ALL, &n, NULL, 0);
  	    return n;
  	case VAR_LIST:
! 	    EMSG(_("E745: Using a List as a Number"));
  	    break;
  	case VAR_DICT:
! 	    EMSG(_("E728: Using a Dictionary as a Number"));
  	    break;
  	case VAR_SPECIAL:
  	    return varp->vval.v_number == VVAL_TRUE ? 1 : 0;
  	    break;
  	case VAR_JOB:
  #ifdef FEAT_JOB_CHANNEL
! 	    EMSG(_("E910: Using a Job as a Number"));
  	    break;
  #endif
  	case VAR_CHANNEL:
  #ifdef FEAT_JOB_CHANNEL
! 	    EMSG(_("E913: Using a Channel as a Number"));
  	    break;
  #endif
  	case VAR_BLOB:
! 	    EMSG(_("E974: Using a Blob as a Number"));
  	    break;
  	case VAR_UNKNOWN:
  	    internal_error("tv_get_number(UNKNOWN)");
--- 7264,7289 ----
  						    STR2NR_ALL, &n, NULL, 0);
  	    return n;
  	case VAR_LIST:
! 	    emsg(_("E745: Using a List as a Number"));
  	    break;
  	case VAR_DICT:
! 	    emsg(_("E728: Using a Dictionary as a Number"));
  	    break;
  	case VAR_SPECIAL:
  	    return varp->vval.v_number == VVAL_TRUE ? 1 : 0;
  	    break;
  	case VAR_JOB:
  #ifdef FEAT_JOB_CHANNEL
! 	    emsg(_("E910: Using a Job as a Number"));
  	    break;
  #endif
  	case VAR_CHANNEL:
  #ifdef FEAT_JOB_CHANNEL
! 	    emsg(_("E913: Using a Channel as a Number"));
  	    break;
  #endif
  	case VAR_BLOB:
! 	    emsg(_("E974: Using a Blob as a Number"));
  	    break;
  	case VAR_UNKNOWN:
  	    internal_error("tv_get_number(UNKNOWN)");
***************
*** 7308,7339 ****
  	    return varp->vval.v_float;
  	case VAR_FUNC:
  	case VAR_PARTIAL:
! 	    EMSG(_("E891: Using a Funcref as a Float"));
  	    break;
  	case VAR_STRING:
! 	    EMSG(_("E892: Using a String as a Float"));
  	    break;
  	case VAR_LIST:
! 	    EMSG(_("E893: Using a List as a Float"));
  	    break;
  	case VAR_DICT:
! 	    EMSG(_("E894: Using a Dictionary as a Float"));
  	    break;
  	case VAR_SPECIAL:
! 	    EMSG(_("E907: Using a special value as a Float"));
  	    break;
  	case VAR_JOB:
  # ifdef FEAT_JOB_CHANNEL
! 	    EMSG(_("E911: Using a Job as a Float"));
  	    break;
  # endif
  	case VAR_CHANNEL:
  # ifdef FEAT_JOB_CHANNEL
! 	    EMSG(_("E914: Using a Channel as a Float"));
  	    break;
  # endif
  	case VAR_BLOB:
! 	    EMSG(_("E975: Using a Blob as a Float"));
  	    break;
  	case VAR_UNKNOWN:
  	    internal_error("tv_get_float(UNKNOWN)");
--- 7308,7339 ----
  	    return varp->vval.v_float;
  	case VAR_FUNC:
  	case VAR_PARTIAL:
! 	    emsg(_("E891: Using a Funcref as a Float"));
  	    break;
  	case VAR_STRING:
! 	    emsg(_("E892: Using a String as a Float"));
  	    break;
  	case VAR_LIST:
! 	    emsg(_("E893: Using a List as a Float"));
  	    break;
  	case VAR_DICT:
! 	    emsg(_("E894: Using a Dictionary as a Float"));
  	    break;
  	case VAR_SPECIAL:
! 	    emsg(_("E907: Using a special value as a Float"));
  	    break;
  	case VAR_JOB:
  # ifdef FEAT_JOB_CHANNEL
! 	    emsg(_("E911: Using a Job as a Float"));
  	    break;
  # endif
  	case VAR_CHANNEL:
  # ifdef FEAT_JOB_CHANNEL
! 	    emsg(_("E914: Using a Channel as a Float"));
  	    break;
  # endif
  	case VAR_BLOB:
! 	    emsg(_("E975: Using a Blob as a Float"));
  	    break;
  	case VAR_UNKNOWN:
  	    internal_error("tv_get_float(UNKNOWN)");
***************
*** 7391,7407 ****
  	    return buf;
  	case VAR_FUNC:
  	case VAR_PARTIAL:
! 	    EMSG(_("E729: using Funcref as a String"));
  	    break;
  	case VAR_LIST:
! 	    EMSG(_("E730: using List as a String"));
  	    break;
  	case VAR_DICT:
! 	    EMSG(_("E731: using Dictionary as a String"));
  	    break;
  	case VAR_FLOAT:
  #ifdef FEAT_FLOAT
! 	    EMSG(_(e_float_as_string));
  	    break;
  #endif
  	case VAR_STRING:
--- 7391,7407 ----
  	    return buf;
  	case VAR_FUNC:
  	case VAR_PARTIAL:
! 	    emsg(_("E729: using Funcref as a String"));
  	    break;
  	case VAR_LIST:
! 	    emsg(_("E730: using List as a String"));
  	    break;
  	case VAR_DICT:
! 	    emsg(_("E731: using Dictionary as a String"));
  	    break;
  	case VAR_FLOAT:
  #ifdef FEAT_FLOAT
! 	    emsg(_(e_float_as_string));
  	    break;
  #endif
  	case VAR_STRING:
***************
*** 7412,7418 ****
  	    STRCPY(buf, get_var_special_name(varp->vval.v_number));
  	    return buf;
          case VAR_BLOB:
! 	    EMSG(_("E976: using Blob as a String"));
  	    break;
  	case VAR_JOB:
  #ifdef FEAT_JOB_CHANNEL
--- 7412,7418 ----
  	    STRCPY(buf, get_var_special_name(varp->vval.v_number));
  	    return buf;
          case VAR_BLOB:
! 	    emsg(_("E976: using Blob as a String"));
  	    break;
  	case VAR_JOB:
  #ifdef FEAT_JOB_CHANNEL
***************
*** 7457,7463 ****
  #endif
  	    break;
  	case VAR_UNKNOWN:
! 	    EMSG(_("E908: using an invalid value as a String"));
  	    break;
      }
      return NULL;
--- 7457,7463 ----
  #endif
  	    break;
  	case VAR_UNKNOWN:
! 	    emsg(_("E908: using an invalid value as a String"));
  	    break;
      }
      return NULL;
***************
*** 7839,7845 ****
      ht = find_var_ht(name, &varname);
      if (ht == NULL || *varname == NUL)
      {
! 	EMSG2(_(e_illvar), name);
  	return;
      }
      v = find_var_in_ht(ht, 0, varname, TRUE);
--- 7839,7845 ----
      ht = find_var_ht(name, &varname);
      if (ht == NULL || *varname == NUL)
      {
! 	semsg(_(e_illvar), name);
  	return;
      }
      v = find_var_in_ht(ht, 0, varname, TRUE);
***************
*** 7894,7900 ****
  	    }
  	    else if (v->di_tv.v_type != tv->v_type)
  	    {
! 		EMSG2(_("E963: setting %s to value with wrong type"), name);
  		return;
  	    }
  	}
--- 7894,7900 ----
  	    }
  	    else if (v->di_tv.v_type != tv->v_type)
  	    {
! 		semsg(_("E963: setting %s to value with wrong type"), name);
  		return;
  	    }
  	}
***************
*** 7906,7912 ****
  	/* Can't add "v:" variable. */
  	if (ht == &vimvarht)
  	{
! 	    EMSG2(_(e_illvar), name);
  	    return;
  	}
  
--- 7906,7912 ----
  	/* Can't add "v:" variable. */
  	if (ht == &vimvarht)
  	{
! 	    semsg(_(e_illvar), name);
  	    return;
  	}
  
***************
*** 7946,7957 ****
  {
      if (flags & DI_FLAGS_RO)
      {
! 	EMSG2(_(e_readonlyvar), use_gettext ? (char_u *)_(name) : name);
  	return TRUE;
      }
      if ((flags & DI_FLAGS_RO_SBX) && sandbox)
      {
! 	EMSG2(_(e_readonlysbx), use_gettext ? (char_u *)_(name) : name);
  	return TRUE;
      }
      return FALSE;
--- 7946,7957 ----
  {
      if (flags & DI_FLAGS_RO)
      {
! 	semsg(_(e_readonlyvar), use_gettext ? (char_u *)_(name) : name);
  	return TRUE;
      }
      if ((flags & DI_FLAGS_RO_SBX) && sandbox)
      {
! 	semsg(_(e_readonlysbx), use_gettext ? (char_u *)_(name) : name);
  	return TRUE;
      }
      return FALSE;
***************
*** 7966,7972 ****
  {
      if (flags & DI_FLAGS_FIX)
      {
! 	EMSG2(_("E795: Cannot delete variable %s"),
  				      use_gettext ? (char_u *)_(name) : name);
  	return TRUE;
      }
--- 7966,7972 ----
  {
      if (flags & DI_FLAGS_FIX)
      {
! 	semsg(_("E795: Cannot delete variable %s"),
  				      use_gettext ? (char_u *)_(name) : name);
  	return TRUE;
      }
***************
*** 7987,7993 ****
  	    && !ASCII_ISUPPER((name[0] != NUL && name[1] == ':')
  						     ? name[2] : name[0]))
      {
! 	EMSG2(_("E704: Funcref variable name must start with a capital: %s"),
  									name);
  	return TRUE;
      }
--- 7987,7993 ----
  	    && !ASCII_ISUPPER((name[0] != NUL && name[1] == ':')
  						     ? name[2] : name[0]))
      {
! 	semsg(_("E704: Funcref variable name must start with a capital: %s"),
  									name);
  	return TRUE;
      }
***************
*** 7996,8002 ****
       * below. */
      if (new_var && function_exists(name, FALSE))
      {
! 	EMSG2(_("E705: Variable name conflicts with existing function: %s"),
  								    name);
  	return TRUE;
      }
--- 7996,8002 ----
       * below. */
      if (new_var && function_exists(name, FALSE))
      {
! 	semsg(_("E705: Variable name conflicts with existing function: %s"),
  								    name);
  	return TRUE;
      }
***************
*** 8016,8022 ****
  	if (!eval_isnamec1(*p) && (p == varname || !VIM_ISDIGIT(*p))
  						   && *p != AUTOLOAD_CHAR)
  	{
! 	    EMSG2(_(e_illvar), varname);
  	    return FALSE;
  	}
      return TRUE;
--- 8016,8022 ----
  	if (!eval_isnamec1(*p) && (p == varname || !VIM_ISDIGIT(*p))
  						   && *p != AUTOLOAD_CHAR)
  	{
! 	    semsg(_(e_illvar), varname);
  	    return FALSE;
  	}
      return TRUE;
***************
*** 8032,8038 ****
  {
      if (lock & VAR_LOCKED)
      {
! 	EMSG2(_("E741: Value is locked: %s"),
  				name == NULL ? (char_u *)_("Unknown")
  					     : use_gettext ? (char_u *)_(name)
  					     : name);
--- 8032,8038 ----
  {
      if (lock & VAR_LOCKED)
      {
! 	semsg(_("E741: Value is locked: %s"),
  				name == NULL ? (char_u *)_("Unknown")
  					     : use_gettext ? (char_u *)_(name)
  					     : name);
***************
*** 8040,8046 ****
      }
      if (lock & VAR_FIXED)
      {
! 	EMSG2(_("E742: Cannot change value of %s"),
  				name == NULL ? (char_u *)_("Unknown")
  					     : use_gettext ? (char_u *)_(name)
  					     : name);
--- 8040,8046 ----
      }
      if (lock & VAR_FIXED)
      {
! 	semsg(_("E742: Cannot change value of %s"),
  				name == NULL ? (char_u *)_("Unknown")
  					     : use_gettext ? (char_u *)_(name)
  					     : name);
***************
*** 8158,8164 ****
  
      if (recurse >= DICT_MAXNEST)
      {
! 	EMSG(_("E698: variable nested too deep for making a copy"));
  	return FAIL;
      }
      ++recurse;
--- 8158,8164 ----
  
      if (recurse >= DICT_MAXNEST)
      {
! 	emsg(_("E698: variable nested too deep for making a copy"));
  	return FAIL;
      }
      ++recurse;
***************
*** 8358,8364 ****
  	     */
  	    if (!aborting() && did_emsg == did_emsg_before
  					  && called_emsg == called_emsg_before)
! 		EMSG2(_(e_invexpr2), p);
  	    need_clr_eos = FALSE;
  	    break;
  	}
--- 8358,8364 ----
  	     */
  	    if (!aborting() && did_emsg == did_emsg_before
  					  && called_emsg == called_emsg_before)
! 		semsg(_(e_invexpr2), p);
  	    need_clr_eos = FALSE;
  	    break;
  	}
***************
*** 8472,8478 ****
  	     * exception.
  	     */
  	    if (!aborting() && did_emsg == save_did_emsg)
! 		EMSG2(_(e_invexpr2), p);
  	    ret = FAIL;
  	    break;
  	}
--- 8472,8478 ----
  	     * exception.
  	     */
  	    if (!aborting() && did_emsg == save_did_emsg)
! 		semsg(_(e_invexpr2), p);
  	    ret = FAIL;
  	    break;
  	}
***************
*** 8521,8527 ****
  	{
  	    /* We don't want to abort following commands, restore did_emsg. */
  	    save_did_emsg = did_emsg;
! 	    EMSG((char_u *)ga.ga_data);
  	    if (!force_abort)
  		did_emsg = save_did_emsg;
  	}
--- 8521,8527 ----
  	{
  	    /* We don't want to abort following commands, restore did_emsg. */
  	    save_did_emsg = did_emsg;
! 	    emsg(ga.ga_data);
  	    if (!force_abort)
  		did_emsg = save_did_emsg;
  	}
***************
*** 9286,9292 ****
      char_u	*text = tv_get_string_buf_chk(&argvars[1], buf2);
  
      if (pat == NULL || text == NULL)
! 	EMSG(_(e_invarg));
      else if (pattern_match(pat, text, FALSE) != (atype == ASSERT_MATCH))
      {
  	prepare_assert_error(&ga);
--- 9286,9292 ----
      char_u	*text = tv_get_string_buf_chk(&argvars[1], buf2);
  
      if (pat == NULL || text == NULL)
! 	emsg(_(e_invarg));
      else if (pattern_match(pat, text, FALSE) != (atype == ASSERT_MATCH))
      {
  	prepare_assert_error(&ga);
***************
*** 9602,9610 ****
  		|| (type != TYPE_EQUAL && type != TYPE_NEQUAL))
  	{
  	    if (typ1->v_type != typ2->v_type)
! 		EMSG(_("E977: Can only compare Blob with Blob"));
  	    else
! 		EMSG(_(e_invalblob));
  	    clear_tv(typ1);
  	    return FAIL;
  	}
--- 9602,9610 ----
  		|| (type != TYPE_EQUAL && type != TYPE_NEQUAL))
  	{
  	    if (typ1->v_type != typ2->v_type)
! 		emsg(_("E977: Can only compare Blob with Blob"));
  	    else
! 		emsg(_(e_invalblob));
  	    clear_tv(typ1);
  	    return FAIL;
  	}
***************
*** 9629,9637 ****
  		|| (type != TYPE_EQUAL && type != TYPE_NEQUAL))
  	{
  	    if (typ1->v_type != typ2->v_type)
! 		EMSG(_("E691: Can only compare List with List"));
  	    else
! 		EMSG(_("E692: Invalid operation for List"));
  	    clear_tv(typ1);
  	    return FAIL;
  	}
--- 9629,9637 ----
  		|| (type != TYPE_EQUAL && type != TYPE_NEQUAL))
  	{
  	    if (typ1->v_type != typ2->v_type)
! 		emsg(_("E691: Can only compare List with List"));
  	    else
! 		emsg(_("E692: Invalid operation for List"));
  	    clear_tv(typ1);
  	    return FAIL;
  	}
***************
*** 9658,9666 ****
  		|| (type != TYPE_EQUAL && type != TYPE_NEQUAL))
  	{
  	    if (typ1->v_type != typ2->v_type)
! 		EMSG(_("E735: Can only compare Dictionary with Dictionary"));
  	    else
! 		EMSG(_("E736: Invalid operation for Dictionary"));
  	    clear_tv(typ1);
  	    return FAIL;
  	}
--- 9658,9666 ----
  		|| (type != TYPE_EQUAL && type != TYPE_NEQUAL))
  	{
  	    if (typ1->v_type != typ2->v_type)
! 		emsg(_("E735: Can only compare Dictionary with Dictionary"));
  	    else
! 		emsg(_("E736: Invalid operation for Dictionary"));
  	    clear_tv(typ1);
  	    return FAIL;
  	}
***************
*** 9679,9685 ****
      {
  	if (type != TYPE_EQUAL && type != TYPE_NEQUAL)
  	{
! 	    EMSG(_("E694: Invalid operation for Funcrefs"));
  	    clear_tv(typ1);
  	    return FAIL;
  	}
--- 9679,9685 ----
      {
  	if (type != TYPE_EQUAL && type != TYPE_NEQUAL)
  	{
! 	    emsg(_("E694: Invalid operation for Funcrefs"));
  	    clear_tv(typ1);
  	    return FAIL;
  	}
***************
*** 10672,10678 ****
      }
      else
      {
! 	EMSG2(_(e_listdictarg), ermsg);
  	return;
      }
  
--- 10672,10678 ----
      }
      else
      {
! 	semsg(_(e_listdictarg), ermsg);
  	return;
      }
  
***************
*** 10740,10746 ****
  		    break;
  		if (tv.v_type != VAR_NUMBER)
  		{
! 		    EMSG(_(e_invalblob));
  		    return;
  		}
  		tv.v_type = VAR_NUMBER;
--- 10740,10746 ----
  		    break;
  		if (tv.v_type != VAR_NUMBER)
  		{
! 		    emsg(_(e_invalblob));
  		    return;
  		}
  		tv.v_type = VAR_NUMBER;
*** ../vim-8.1.0742/src/evalfunc.c	2019-01-13 19:10:28.963419901 +0100
--- src/evalfunc.c	2019-01-13 21:39:30.890113621 +0100
***************
*** 1188,1194 ****
  	*f = (float_T)argvars[0].vval.v_number;
  	return OK;
      }
!     EMSG(_("E808: Number or Float required"));
      return FAIL;
  }
  
--- 1188,1194 ----
  	*f = (float_T)argvars[0].vval.v_number;
  	return OK;
      }
!     emsg(_("E808: Number or Float required"));
      return FAIL;
  }
  
***************
*** 1269,1275 ****
  	}
      }
      else
! 	EMSG(_(e_listreq));
  }
  
  /*
--- 1269,1275 ----
  	}
      }
      else
! 	emsg(_(e_listreq));
  }
  
  /*
***************
*** 1954,1960 ****
      buf = tv_get_buf(arg, FALSE);
      --emsg_off;
      if (buf == NULL)
! 	EMSG2(_("E158: Invalid buffer name: %s"), tv_get_string(arg));
      return buf;
  }
  #endif
--- 1954,1960 ----
      buf = tv_get_buf(arg, FALSE);
      --emsg_off;
      if (buf == NULL)
! 	semsg(_("E158: Invalid buffer name: %s"), tv_get_string(arg));
      return buf;
  }
  #endif
***************
*** 2130,2136 ****
  
      if (argvars[1].v_type != VAR_LIST)
      {
! 	EMSG(_(e_listreq));
  	return;
      }
      if (argvars[1].vval.v_list == NULL)
--- 2130,2136 ----
  
      if (argvars[1].v_type != VAR_LIST)
      {
! 	emsg(_(e_listreq));
  	return;
      }
      if (argvars[1].vval.v_list == NULL)
***************
*** 2152,2158 ****
      {
  	if (argvars[2].v_type != VAR_DICT)
  	{
! 	    EMSG(_(e_dictreq));
  	    return;
  	}
  	selfdict = argvars[2].vval.v_dict;
--- 2152,2158 ----
      {
  	if (argvars[2].v_type != VAR_DICT)
  	{
! 	    emsg(_(e_dictreq));
  	    return;
  	}
  	selfdict = argvars[2].vval.v_dict;
***************
*** 2563,2569 ****
  
      if ((State & INSERT) == 0)
      {
! 	EMSG(_("E785: complete() can only be used in Insert mode"));
  	return;
      }
  
--- 2563,2569 ----
  
      if ((State & INSERT) == 0)
      {
! 	emsg(_("E785: complete() can only be used in Insert mode"));
  	return;
      }
  
***************
*** 2574,2580 ****
  
      if (argvars[1].v_type != VAR_LIST || argvars[1].vval.v_list == NULL)
      {
! 	EMSG(_(e_invarg));
  	return;
      }
  
--- 2574,2580 ----
  
      if (argvars[1].v_type != VAR_LIST || argvars[1].vval.v_list == NULL)
      {
! 	emsg(_(e_invarg));
  	return;
      }
  
***************
*** 2770,2776 ****
  		    {
  			li = list_find(l, idx);
  			if (li == NULL)
! 			    EMSGN(_(e_listidx), idx);
  		    }
  		}
  		if (error)
--- 2770,2776 ----
  		    {
  			li = list_find(l, idx);
  			if (li == NULL)
! 			    semsg(_(e_listidx), idx);
  		    }
  		}
  		if (error)
***************
*** 2793,2799 ****
  	    if (argvars[2].v_type != VAR_UNKNOWN)
  	    {
  		if (argvars[3].v_type != VAR_UNKNOWN)
! 		    EMSG(_(e_invarg));
  	    }
  
  	    todo = error ? 0 : (int)d->dv_hashtab.ht_used;
--- 2793,2799 ----
  	    if (argvars[2].v_type != VAR_UNKNOWN)
  	    {
  		if (argvars[3].v_type != VAR_UNKNOWN)
! 		    emsg(_(e_invarg));
  	    }
  
  	    todo = error ? 0 : (int)d->dv_hashtab.ht_used;
***************
*** 2809,2815 ****
  	}
      }
      else
! 	EMSG2(_(e_listdictarg), "count()");
      rettv->vval.v_number = n;
  }
  
--- 2809,2815 ----
  	}
      }
      else
! 	semsg(_(e_listdictarg), "count()");
      rettv->vval.v_number = n;
  }
  
***************
*** 2864,2870 ****
  
  	if (list2fpos(argvars, &pos, NULL, &curswant) == FAIL)
  	{
! 	    EMSG(_(e_invarg));
  	    return;
  	}
  	line = pos.lnum;
--- 2864,2870 ----
  
  	if (list2fpos(argvars, &pos, NULL, &curswant) == FAIL)
  	{
! 	    emsg(_(e_invarg));
  	    return;
  	}
  	line = pos.lnum;
***************
*** 2925,2931 ****
      rettv->vval.v_number = FAIL;
      pid = (int)tv_get_number(&argvars[0]);
      if (pid == 0)
! 	EMSG(_(e_invarg));
      else
      {
  	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);
--- 2925,2931 ----
      rettv->vval.v_number = FAIL;
      pid = (int)tv_get_number(&argvars[0]);
      if (pid == 0)
! 	emsg(_(e_invarg));
      else
      {
  	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);
***************
*** 2952,2958 ****
      if (argvars[1].v_type != VAR_UNKNOWN)
  	noref = (int)tv_get_number_chk(&argvars[1], NULL);
      if (noref < 0 || noref > 1)
! 	EMSG(_(e_invarg));
      else
      {
  	copyID = get_copyID();
--- 2952,2958 ----
      if (argvars[1].v_type != VAR_UNKNOWN)
  	noref = (int)tv_get_number_chk(&argvars[1], NULL);
      if (noref < 0 || noref > 1)
! 	emsg(_(e_invarg));
      else
      {
  	copyID = get_copyID();
***************
*** 2977,2983 ****
      name = tv_get_string(&argvars[0]);
      if (name == NULL || *name == NUL)
      {
! 	EMSG(_(e_invarg));
  	return;
      }
  
--- 2977,2983 ----
      name = tv_get_string(&argvars[0]);
      if (name == NULL || *name == NUL)
      {
! 	emsg(_(e_invarg));
  	return;
      }
  
***************
*** 2996,3002 ****
  	/* delete a directory recursively */
  	rettv->vval.v_number = delete_recursive(name);
      else
! 	EMSG2(_(e_invexpr2), flags);
  }
  
  /*
--- 2996,3002 ----
  	/* delete a directory recursively */
  	rettv->vval.v_number = delete_recursive(name);
      else
! 	semsg(_(e_invexpr2), flags);
  }
  
  /*
***************
*** 3255,3267 ****
      if (s == NULL || eval1(&s, rettv, TRUE) == FAIL)
      {
  	if (p != NULL && !aborting())
! 	    EMSG2(_(e_invexpr2), p);
  	need_clr_eos = FALSE;
  	rettv->v_type = VAR_NUMBER;
  	rettv->vval.v_number = 0;
      }
      else if (*s != NUL)
! 	EMSG(_(e_trailing));
  }
  
  /*
--- 3255,3267 ----
      if (s == NULL || eval1(&s, rettv, TRUE) == FAIL)
      {
  	if (p != NULL && !aborting())
! 	    semsg(_(e_invexpr2), p);
  	need_clr_eos = FALSE;
  	rettv->v_type = VAR_NUMBER;
  	rettv->vval.v_number = 0;
      }
      else if (*s != NUL)
! 	emsg(_(e_trailing));
  }
  
  /*
***************
*** 3528,3534 ****
  {
      char_u	*s;
      int		len;
!     char_u	*errormsg;
      int		options = WILD_SILENT|WILD_USE_NL|WILD_LIST_NOTFOUND;
      expand_T	xpc;
      int		error = FALSE;
--- 3528,3534 ----
  {
      char_u	*s;
      int		len;
!     char	*errormsg;
      int		options = WILD_SILENT|WILD_USE_NL|WILD_LIST_NOTFOUND;
      expand_T	xpc;
      int		error = FALSE;
***************
*** 3624,3630 ****
  		    item = list_find(l1, before);
  		    if (item == NULL)
  		    {
! 			EMSGN(_(e_listidx), before);
  			return;
  		    }
  		}
--- 3624,3630 ----
  		    item = list_find(l1, before);
  		    if (item == NULL)
  		    {
! 			semsg(_(e_listidx), before);
  			return;
  		    }
  		}
***************
*** 3660,3666 ****
  			break;
  		if (i == 3)
  		{
! 		    EMSG2(_(e_invarg2), action);
  		    return;
  		}
  	    }
--- 3660,3666 ----
  			break;
  		if (i == 3)
  		{
! 		    semsg(_(e_invarg2), action);
  		    return;
  		}
  	    }
***************
*** 3673,3679 ****
  	}
      }
      else
! 	EMSG2(_(e_listdictarg), "extend()");
  }
  
  /*
--- 3673,3679 ----
  	}
      }
      else
! 	semsg(_(e_listdictarg), "extend()");
  }
  
  /*
***************
*** 4197,4208 ****
  
      if (s == NULL || *s == NUL || (use_string && VIM_ISDIGIT(*s))
  					 || (is_funcref && trans_name == NULL))
! 	EMSG2(_(e_invarg2), use_string ? tv_get_string(&argvars[0]) : s);
      /* Don't check an autoload name for existence here. */
      else if (trans_name != NULL && (is_funcref
  				? find_func(trans_name) == NULL
  				: !translated_function_exists(trans_name)))
! 	EMSG2(_("E700: Unknown function: %s"), s);
      else
      {
  	int	dict_idx = 0;
--- 4197,4208 ----
  
      if (s == NULL || *s == NUL || (use_string && VIM_ISDIGIT(*s))
  					 || (is_funcref && trans_name == NULL))
! 	semsg(_(e_invarg2), use_string ? tv_get_string(&argvars[0]) : s);
      /* Don't check an autoload name for existence here. */
      else if (trans_name != NULL && (is_funcref
  				? find_func(trans_name) == NULL
  				: !translated_function_exists(trans_name)))
! 	semsg(_("E700: Unknown function: %s"), s);
      else
      {
  	int	dict_idx = 0;
***************
*** 4247,4253 ****
  	    {
  		if (argvars[dict_idx].v_type != VAR_DICT)
  		{
! 		    EMSG(_("E922: expected a dict"));
  		    vim_free(name);
  		    goto theend;
  		}
--- 4247,4253 ----
  	    {
  		if (argvars[dict_idx].v_type != VAR_DICT)
  		{
! 		    emsg(_("E922: expected a dict"));
  		    vim_free(name);
  		    goto theend;
  		}
***************
*** 4258,4264 ****
  	    {
  		if (argvars[arg_idx].v_type != VAR_LIST)
  		{
! 		    EMSG(_("E923: Second argument of function() must be a list or a dict"));
  		    vim_free(name);
  		    goto theend;
  		}
--- 4258,4264 ----
  	    {
  		if (argvars[arg_idx].v_type != VAR_LIST)
  		{
! 		    emsg(_("E923: Second argument of function() must be a list or a dict"));
  		    vim_free(name);
  		    goto theend;
  		}
***************
*** 4409,4415 ****
  	{
  	    rettv->v_type = VAR_NUMBER;
  	    if (idx >= blob_len(argvars[0].vval.v_blob))
! 		EMSGN(_(e_blobidx), idx);
  	    else
  		rettv->vval.v_number = blob_get(argvars[0].vval.v_blob, idx);
  	}
--- 4409,4415 ----
  	{
  	    rettv->v_type = VAR_NUMBER;
  	    if (idx >= blob_len(argvars[0].vval.v_blob))
! 		semsg(_(e_blobidx), idx);
  	    else
  		rettv->vval.v_number = blob_get(argvars[0].vval.v_blob, idx);
  	}
***************
*** 4480,4491 ****
  		}
  	    }
  	    else
! 		EMSG2(_(e_invarg2), what);
  	    return;
  	}
      }
      else
! 	EMSG2(_(e_listdictarg), "get()");
  
      if (tv == NULL)
      {
--- 4480,4491 ----
  		}
  	    }
  	    else
! 		semsg(_(e_invarg2), what);
  	    return;
  	}
      }
      else
! 	semsg(_(e_listdictarg), "get()");
  
      if (tv == NULL)
      {
***************
*** 5029,5037 ****
      if (xpc.xp_context == EXPAND_NOTHING)
      {
  	if (argvars[1].v_type == VAR_STRING)
! 	    EMSG2(_(e_invarg2), argvars[1].vval.v_string);
  	else
! 	    EMSG(_(e_invarg));
  	return;
      }
  
--- 5029,5037 ----
      if (xpc.xp_context == EXPAND_NOTHING)
      {
  	if (argvars[1].v_type == VAR_STRING)
! 	    semsg(_(e_invarg2), argvars[1].vval.v_string);
  	else
! 	    emsg(_(e_invarg));
  	return;
      }
  
***************
*** 5363,5369 ****
  			qf_get_properties(wp, d, rettv->vval.v_dict);
  		}
  		else
! 		    EMSG(_(e_dictreq));
  	    }
      }
  }
--- 5363,5369 ----
  			qf_get_properties(wp, d, rettv->vval.v_dict);
  		}
  		else
! 		    emsg(_(e_dictreq));
  	    }
      }
  }
***************
*** 6765,6771 ****
  {
      if (argvars[0].v_type != VAR_DICT)
      {
! 	EMSG(_(e_dictreq));
  	return;
      }
      if (argvars[0].vval.v_dict == NULL)
--- 6765,6771 ----
  {
      if (argvars[0].v_type != VAR_DICT)
      {
! 	emsg(_(e_dictreq));
  	return;
      }
      if (argvars[0].vval.v_dict == NULL)
***************
*** 7055,7061 ****
      }
      else if (argvars[0].v_type != VAR_LIST)
      {
! 	EMSG(_(e_listreq));
  	return;
      }
  
--- 7055,7061 ----
      }
      else if (argvars[0].v_type != VAR_LIST)
      {
! 	emsg(_(e_listreq));
  	return;
      }
  
***************
*** 7155,7161 ****
  #endif
      if (argvars[0].v_type != VAR_LIST || argvars[0].vval.v_list == NULL)
      {
! 	EMSG2(_(e_listarg), "inputlist()");
  	return;
      }
  
--- 7155,7161 ----
  #endif
      if (argvars[0].v_type != VAR_LIST || argvars[0].vval.v_list == NULL)
      {
! 	semsg(_(e_listarg), "inputlist()");
  	return;
      }
  
***************
*** 7256,7262 ****
  		return;		// type error; errmsg already given
  	    if (before < 0 || before > len)
  	    {
! 		EMSG2(_(e_invarg2), tv_get_string(&argvars[2]));
  		return;
  	    }
  	}
--- 7256,7262 ----
  		return;		// type error; errmsg already given
  	    if (before < 0 || before > len)
  	    {
! 		semsg(_(e_invarg2), tv_get_string(&argvars[2]));
  		return;
  	    }
  	}
***************
*** 7265,7271 ****
  	    return;
  	if (val < 0 || val > 255)
  	{
! 	    EMSG2(_(e_invarg2), tv_get_string(&argvars[1]));
  	    return;
  	}
  
--- 7265,7271 ----
  	    return;
  	if (val < 0 || val > 255)
  	{
! 	    semsg(_(e_invarg2), tv_get_string(&argvars[1]));
  	    return;
  	}
  
***************
*** 7279,7285 ****
  	copy_tv(&argvars[0], rettv);
      }
      else if (argvars[0].v_type != VAR_LIST)
! 	EMSG2(_(e_listarg), "insert()");
      else if ((l = argvars[0].vval.v_list) != NULL && !tv_check_lock(l->lv_lock,
  				      (char_u *)N_("insert() argument"), TRUE))
      {
--- 7279,7285 ----
  	copy_tv(&argvars[0], rettv);
      }
      else if (argvars[0].v_type != VAR_LIST)
! 	semsg(_(e_listarg), "insert()");
      else if ((l = argvars[0].vval.v_list) != NULL && !tv_check_lock(l->lv_lock,
  				      (char_u *)N_("insert() argument"), TRUE))
      {
***************
*** 7295,7301 ****
  	    item = list_find(l, before);
  	    if (item == NULL)
  	    {
! 		EMSGN(_(e_listidx), before);
  		l = NULL;
  	    }
  	}
--- 7295,7301 ----
  	    item = list_find(l, before);
  	    if (item == NULL)
  	    {
! 		semsg(_(e_listidx), before);
  		l = NULL;
  	    }
  	}
***************
*** 7357,7363 ****
      if (end != NULL && lv.ll_name != NULL)
      {
  	if (*end != NUL)
! 	    EMSG(_(e_trailing));
  	else
  	{
  	    if (lv.ll_tv == NULL)
--- 7357,7363 ----
      if (end != NULL && lv.ll_name != NULL)
      {
  	if (*end != NUL)
! 	    emsg(_(e_trailing));
  	else
  	{
  	    if (lv.ll_tv == NULL)
***************
*** 7375,7383 ****
  		}
  	    }
  	    else if (lv.ll_range)
! 		EMSG(_("E786: Range not allowed"));
  	    else if (lv.ll_newkey != NULL)
! 		EMSG2(_(e_dictkey), lv.ll_newkey);
  	    else if (lv.ll_list != NULL)
  		/* List item. */
  		rettv->vval.v_number = tv_islocked(&lv.ll_li->li_tv);
--- 7375,7383 ----
  		}
  	    }
  	    else if (lv.ll_range)
! 		emsg(_("E786: Range not allowed"));
  	    else if (lv.ll_newkey != NULL)
! 		semsg(_(e_dictkey), lv.ll_newkey);
  	    else if (lv.ll_list != NULL)
  		/* List item. */
  		rettv->vval.v_number = tv_islocked(&lv.ll_li->li_tv);
***************
*** 7423,7435 ****
  
      if (tv->v_type != VAR_JOB)
      {
! 	EMSG2(_(e_invarg2), tv_get_string(tv));
  	return NULL;
      }
      job = tv->vval.v_job;
  
      if (job == NULL)
! 	EMSG(_("E916: not a valid job"));
      return job;
  }
  
--- 7423,7435 ----
  
      if (tv->v_type != VAR_JOB)
      {
! 	semsg(_(e_invarg2), tv_get_string(tv));
  	return NULL;
      }
      job = tv->vval.v_job;
  
      if (job == NULL)
! 	emsg(_("E916: not a valid job"));
      return job;
  }
  
***************
*** 7535,7541 ****
  
      if (argvars[0].v_type != VAR_LIST)
      {
! 	EMSG(_(e_listreq));
  	return;
      }
      if (argvars[0].vval.v_list == NULL)
--- 7535,7541 ----
  
      if (argvars[0].v_type != VAR_LIST)
      {
! 	emsg(_(e_listreq));
  	return;
      }
      if (argvars[0].vval.v_list == NULL)
***************
*** 7570,7576 ****
      reader.js_fill = NULL;
      reader.js_used = 0;
      if (json_decode_all(&reader, rettv, JSON_JS) != OK)
! 	EMSG(_(e_invarg));
  }
  
  /*
--- 7570,7576 ----
      reader.js_fill = NULL;
      reader.js_used = 0;
      if (json_decode_all(&reader, rettv, JSON_JS) != OK)
! 	emsg(_(e_invarg));
  }
  
  /*
***************
*** 7661,7667 ****
  	case VAR_PARTIAL:
  	case VAR_JOB:
  	case VAR_CHANNEL:
! 	    EMSG(_("E701: Invalid type for len()"));
  	    break;
      }
  }
--- 7661,7667 ----
  	case VAR_PARTIAL:
  	case VAR_JOB:
  	case VAR_CHANNEL:
! 	    emsg(_("E701: Invalid type for len()"));
  	    break;
      }
  }
***************
*** 8199,8205 ****
  
      if (tv->v_type != VAR_DICT)
      {
! 	EMSG(_(e_dictreq));
  	return FAIL;
      }
  
--- 8199,8205 ----
  
      if (tv->v_type != VAR_DICT)
      {
! 	emsg(_(e_dictreq));
  	return FAIL;
      }
  
***************
*** 8212,8218 ****
  	*win = find_win_by_nr_or_id(&di->di_tv);
  	if (*win == NULL)
  	{
! 	    EMSG(_("E957: Invalid window number"));
  	    return FAIL;
  	}
      }
--- 8212,8218 ----
  	*win = find_win_by_nr_or_id(&di->di_tv);
  	if (*win == NULL)
  	{
! 	    emsg(_("E957: Invalid window number"));
  	    return FAIL;
  	}
      }
***************
*** 8256,8262 ****
  	return;
      if (id >= 1 && id <= 3)
      {
! 	EMSGN(_("E798: ID is reserved for \":match\": %ld"), id);
  	return;
      }
  
--- 8256,8262 ----
  	return;
      if (id >= 1 && id <= 3)
      {
! 	semsg(_("E798: ID is reserved for \":match\": %ld"), id);
  	return;
      }
  
***************
*** 8289,8295 ****
  
      if (argvars[1].v_type != VAR_LIST)
      {
! 	EMSG2(_(e_listarg), "matchaddpos()");
  	return;
      }
      l = argvars[1].vval.v_list;
--- 8289,8295 ----
  
      if (argvars[1].v_type != VAR_LIST)
      {
! 	semsg(_(e_listarg), "matchaddpos()");
  	return;
      }
      l = argvars[1].vval.v_list;
***************
*** 8314,8320 ****
      /* id == 3 is ok because matchaddpos() is supposed to substitute :3match */
      if (id == 1 || id == 2)
      {
! 	EMSGN(_("E798: ID is reserved for \":match\": %ld"), id);
  	return;
      }
  
--- 8314,8320 ----
      /* id == 3 is ok because matchaddpos() is supposed to substitute :3match */
      if (id == 1 || id == 2)
      {
! 	semsg(_("E798: ID is reserved for \":match\": %ld"), id);
  	return;
      }
  
***************
*** 8461,8467 ****
  	}
      }
      else
! 	EMSG2(_(e_listdictarg), domax ? "max()" : "min()");
      rettv->vval.v_number = error ? 0 : n;
  }
  
--- 8461,8467 ----
  	}
      }
      else
! 	semsg(_(e_listdictarg), domax ? "max()" : "min()");
      rettv->vval.v_number = error ? 0 : n;
  }
  
***************
*** 9027,9035 ****
      if (error)
  	return;		/* type error; errmsg already given */
      if (stride == 0)
! 	EMSG(_("E726: Stride is zero"));
      else if (stride > 0 ? end + 1 < start : end - 1 > start)
! 	EMSG(_("E727: Start past end"));
      else
      {
  	if (rettv_list_alloc(rettv) == OK)
--- 9027,9035 ----
      if (error)
  	return;		/* type error; errmsg already given */
      if (stride == 0)
! 	emsg(_("E726: Stride is zero"));
      else if (stride > 0 ? end + 1 < start : end - 1 > start)
! 	emsg(_("E727: Start past end"));
      else
      {
  	if (rettv_list_alloc(rettv) == OK)
***************
*** 9089,9095 ****
      fname = tv_get_string(&argvars[0]);
      if (*fname == NUL || (fd = mch_fopen((char *)fname, READBIN)) == NULL)
      {
! 	EMSG2(_(e_notopen), *fname == NUL ? (char_u *)_("<empty>") : fname);
  	return;
      }
  
--- 9089,9095 ----
      fname = tv_get_string(&argvars[0]);
      if (*fname == NUL || (fd = mch_fopen((char *)fname, READBIN)) == NULL)
      {
! 	semsg(_(e_notopen), *fname == NUL ? (char_u *)_("<empty>") : fname);
  	return;
      }
  
***************
*** 9097,9103 ****
      {
  	if (read_blob(fd, rettv->vval.v_blob) == FAIL)
  	{
! 	    EMSG("cannot read file");
  	    blob_free(rettv->vval.v_blob);
  	}
  	fclose(fd);
--- 9097,9103 ----
      {
  	if (read_blob(fd, rettv->vval.v_blob) == FAIL)
  	{
! 	    emsg("cannot read file");
  	    blob_free(rettv->vval.v_blob);
  	}
  	fclose(fd);
***************
*** 9437,9443 ****
      make_connection();
      if (X_DISPLAY == NULL)
      {
! 	EMSG(_("E240: No connection to the X server"));
  	return FAIL;
      }
      return OK;
--- 9437,9443 ----
      make_connection();
      if (X_DISPLAY == NULL)
      {
! 	emsg(_("E240: No connection to the X server"));
  	return FAIL;
      }
      return OK;
***************
*** 9483,9493 ****
      {
  	if (r != NULL)
  	{
! 	    EMSG(r);		/* sending worked but evaluation failed */
  	    vim_free(r);
  	}
  	else
! 	    EMSG2(_("E241: Unable to send to %s"), server_name);
  	return;
      }
  
--- 9483,9493 ----
      {
  	if (r != NULL)
  	{
! 	    emsg((char *)r);	// sending worked but evaluation failed
  	    vim_free(r);
  	}
  	else
! 	    semsg(_("E241: Unable to send to %s"), server_name);
  	return;
      }
  
***************
*** 9637,9643 ****
  		|| serverReadReply(X_DISPLAY, serverStrToWin(serverid),
  						       &r, FALSE, timeout) < 0)
  # endif
! 	    EMSG(_("E277: Unable to read a server reply"));
      }
  #endif
      rettv->v_type = VAR_STRING;
--- 9637,9643 ----
  		|| serverReadReply(X_DISPLAY, serverStrToWin(serverid),
  						       &r, FALSE, timeout) < 0)
  # endif
! 	    emsg(_("E277: Unable to read a server reply"));
      }
  #endif
      rettv->v_type = VAR_STRING;
***************
*** 9669,9675 ****
      if (server == NULL)
  	return;		/* type error; errmsg already given */
      if (serverName != NULL)
! 	EMSG(_("E941: already started a server"));
      else
      {
  # ifdef FEAT_X11
--- 9669,9675 ----
      if (server == NULL)
  	return;		/* type error; errmsg already given */
      if (serverName != NULL)
! 	emsg(_("E941: already started a server"));
      else
      {
  # ifdef FEAT_X11
***************
*** 9680,9686 ****
  # endif
      }
  #else
!     EMSG(_("E942: +clientserver feature not available"));
  #endif
  }
  
--- 9680,9686 ----
  # endif
      }
  #else
!     emsg(_("E942: +clientserver feature not available"));
  #endif
  }
  
***************
*** 9704,9710 ****
      if (argvars[0].v_type == VAR_DICT)
      {
  	if (argvars[2].v_type != VAR_UNKNOWN)
! 	    EMSG2(_(e_toomanyarg), "remove()");
  	else if ((d = argvars[0].vval.v_dict) != NULL
  		&& !tv_check_lock(d->dv_lock, arg_errmsg, TRUE))
  	{
--- 9704,9710 ----
      if (argvars[0].v_type == VAR_DICT)
      {
  	if (argvars[2].v_type != VAR_UNKNOWN)
! 	    semsg(_(e_toomanyarg), "remove()");
  	else if ((d = argvars[0].vval.v_dict) != NULL
  		&& !tv_check_lock(d->dv_lock, arg_errmsg, TRUE))
  	{
***************
*** 9713,9719 ****
  	    {
  		di = dict_find(d, key, -1);
  		if (di == NULL)
! 		    EMSG2(_(e_dictkey), key);
  		else if (!var_check_fixed(di->di_flags, arg_errmsg, TRUE)
  			    && !var_check_ro(di->di_flags, arg_errmsg, TRUE))
  		{
--- 9713,9719 ----
  	    {
  		di = dict_find(d, key, -1);
  		if (di == NULL)
! 		    semsg(_(e_dictkey), key);
  		else if (!var_check_fixed(di->di_flags, arg_errmsg, TRUE)
  			    && !var_check_ro(di->di_flags, arg_errmsg, TRUE))
  		{
***************
*** 9738,9744 ****
  		idx = len + idx;
  	    if (idx < 0 || idx >= len)
  	    {
! 		EMSGN(_(e_blobidx), idx);
  		return;
  	    }
  	    if (argvars[2].v_type == VAR_UNKNOWN)
--- 9738,9744 ----
  		idx = len + idx;
  	    if (idx < 0 || idx >= len)
  	    {
! 		semsg(_(e_blobidx), idx);
  		return;
  	    }
  	    if (argvars[2].v_type == VAR_UNKNOWN)
***************
*** 9762,9768 ****
  		    end = len + end;
  		if (end >= len || idx > end)
  		{
! 		    EMSGN(_(e_blobidx), end);
  		    return;
  		}
  		blob = blob_alloc();
--- 9762,9768 ----
  		    end = len + end;
  		if (end >= len || idx > end)
  		{
! 		    semsg(_(e_blobidx), end);
  		    return;
  		}
  		blob = blob_alloc();
***************
*** 9787,9793 ****
  	}
      }
      else if (argvars[0].v_type != VAR_LIST)
! 	EMSG2(_(e_listdictarg), "remove()");
      else if ((l = argvars[0].vval.v_list) != NULL
  			       && !tv_check_lock(l->lv_lock, arg_errmsg, TRUE))
      {
--- 9787,9793 ----
  	}
      }
      else if (argvars[0].v_type != VAR_LIST)
! 	semsg(_(e_listdictarg), "remove()");
      else if ((l = argvars[0].vval.v_list) != NULL
  			       && !tv_check_lock(l->lv_lock, arg_errmsg, TRUE))
      {
***************
*** 9795,9801 ****
  	if (error)
  	    ;		// type error: do nothing, errmsg already given
  	else if ((item = list_find(l, idx)) == NULL)
! 	    EMSGN(_(e_listidx), idx);
  	else
  	{
  	    if (argvars[2].v_type == VAR_UNKNOWN)
--- 9795,9801 ----
  	if (error)
  	    ;		// type error: do nothing, errmsg already given
  	else if ((item = list_find(l, idx)) == NULL)
! 	    semsg(_(e_listidx), idx);
  	else
  	{
  	    if (argvars[2].v_type == VAR_UNKNOWN)
***************
*** 9812,9818 ****
  		if (error)
  		    ;		// type error: do nothing
  		else if ((item2 = list_find(l, end)) == NULL)
! 		    EMSGN(_(e_listidx), end);
  		else
  		{
  		    int	    cnt = 0;
--- 9812,9818 ----
  		if (error)
  		    ;		// type error: do nothing
  		else if ((item2 = list_find(l, end)) == NULL)
! 		    semsg(_(e_listidx), end);
  		else
  		{
  		    int	    cnt = 0;
***************
*** 9824,9830 ****
  			    break;
  		    }
  		    if (li == NULL)  /* didn't find "item2" after "item" */
! 			EMSG(_(e_invrange));
  		    else
  		    {
  			vimlist_remove(l, item, item2);
--- 9824,9830 ----
  			    break;
  		    }
  		    if (li == NULL)  /* didn't find "item2" after "item" */
! 			emsg(_(e_invrange));
  		    else
  		    {
  			vimlist_remove(l, item, item2);
***************
*** 9976,9982 ****
  		{
  		    vim_free(p);
  		    vim_free(remain);
! 		    EMSG(_("E655: Too many symbolic links (cycle?)"));
  		    rettv->vval.v_string = NULL;
  		    goto fail;
  		}
--- 9976,9982 ----
  		{
  		    vim_free(p);
  		    vim_free(remain);
! 		    emsg(_("E655: Too many symbolic links (cycle?)"));
  		    rettv->vval.v_string = NULL;
  		    goto fail;
  		}
***************
*** 10134,10140 ****
      }
  
      if (argvars[0].v_type != VAR_LIST)
! 	EMSG2(_(e_listarg), "reverse()");
      else if ((l = argvars[0].vval.v_list) != NULL
  	    && !tv_check_lock(l->lv_lock,
  				    (char_u *)N_("reverse() argument"), TRUE))
--- 10134,10140 ----
      }
  
      if (argvars[0].v_type != VAR_LIST)
! 	semsg(_(e_listarg), "reverse()");
      else if ((l = argvars[0].vval.v_list) != NULL
  	    && !tv_check_lock(l->lv_lock,
  				    (char_u *)N_("reverse() argument"), TRUE))
***************
*** 10202,10208 ****
  			     }
  			  if (mask == 0)
  			  {
! 			      EMSG2(_(e_invarg2), flags);
  			      dir = 0;
  			  }
  			  else
--- 10202,10208 ----
  			     }
  			  if (mask == 0)
  			  {
! 			      semsg(_(e_invarg2), flags);
  			      dir = 0;
  			  }
  			  else
***************
*** 10279,10285 ****
      if (((flags & (SP_REPEAT | SP_RETCOUNT)) != 0)
  	    || ((flags & SP_NOMOVE) && (flags & SP_SETPCMARK)))
      {
! 	EMSG2(_(e_invarg2), tv_get_string(&argvars[1]));
  	goto theend;
      }
  
--- 10279,10285 ----
      if (((flags & (SP_REPEAT | SP_RETCOUNT)) != 0)
  	    || ((flags & SP_NOMOVE) && (flags & SP_SETPCMARK)))
      {
! 	semsg(_(e_invarg2), tv_get_string(&argvars[1]));
  	goto theend;
      }
  
***************
*** 10485,10491 ****
      if ((flags & (SP_END | SP_SUBPAT)) != 0
  	    || ((flags & SP_NOMOVE) && (flags & SP_SETPCMARK)))
      {
! 	EMSG2(_(e_invarg2), tv_get_string(&argvars[3]));
  	goto theend;
      }
  
--- 10485,10491 ----
      if ((flags & (SP_END | SP_SUBPAT)) != 0
  	    || ((flags & SP_NOMOVE) && (flags & SP_SETPCMARK)))
      {
! 	semsg(_(e_invarg2), tv_get_string(&argvars[3]));
  	goto theend;
      }
  
***************
*** 10504,10510 ****
  	    && skip->v_type != VAR_STRING)
  	{
  	    /* Type error */
! 	    EMSG2(_(e_invarg2), tv_get_string(&argvars[4]));
  	    goto theend;
  	}
  	if (argvars[5].v_type != VAR_UNKNOWN)
--- 10504,10510 ----
  	    && skip->v_type != VAR_STRING)
  	{
  	    /* Type error */
! 	    semsg(_(e_invarg2), tv_get_string(&argvars[4]));
  	    goto theend;
  	}
  	if (argvars[5].v_type != VAR_UNKNOWN)
***************
*** 10512,10518 ****
  	    lnum_stop = (long)tv_get_number_chk(&argvars[5], NULL);
  	    if (lnum_stop < 0)
  	    {
! 		EMSG2(_(e_invarg2), tv_get_string(&argvars[5]));
  		goto theend;
  	    }
  #ifdef FEAT_RELTIME
--- 10512,10518 ----
  	    lnum_stop = (long)tv_get_number_chk(&argvars[5], NULL);
  	    if (lnum_stop < 0)
  	    {
! 		semsg(_(e_invarg2), tv_get_string(&argvars[5]));
  		goto theend;
  	    }
  #ifdef FEAT_RELTIME
***************
*** 10521,10527 ****
  		time_limit = (long)tv_get_number_chk(&argvars[6], NULL);
  		if (time_limit < 0)
  		{
! 		    EMSG2(_(e_invarg2), tv_get_string(&argvars[6]));
  		    goto theend;
  		}
  	    }
--- 10521,10527 ----
  		time_limit = (long)tv_get_number_chk(&argvars[6], NULL);
  		if (time_limit < 0)
  		{
! 		    semsg(_(e_invarg2), tv_get_string(&argvars[6]));
  		    goto theend;
  		}
  	    }
***************
*** 10786,10792 ****
  
      if (serverSendReply(server, reply) < 0)
      {
! 	EMSG(_("E258: Unable to send to client"));
  	return;
      }
      rettv->vval.v_number = 0;
--- 10786,10792 ----
  
      if (serverSendReply(server, reply) < 0)
      {
! 	emsg(_("E258: Unable to send to client"));
  	return;
      }
      rettv->vval.v_number = 0;
***************
*** 10898,10904 ****
  
      if (argvars[0].v_type != VAR_DICT)
      {
! 	EMSG(_(e_dictreq));
  	return;
      }
  
--- 10898,10904 ----
  
      if (argvars[0].v_type != VAR_DICT)
      {
! 	emsg(_(e_dictreq));
  	return;
      }
  
***************
*** 10966,10972 ****
  	return;
      if (STRLEN(mode_str) != 9)
      {
! 	EMSG2(_(e_invarg2), mode_str);
  	return;
      }
  
--- 10966,10972 ----
  	return;
      if (STRLEN(mode_str) != 9)
      {
! 	semsg(_(e_invarg2), mode_str);
  	return;
      }
  
***************
*** 11013,11021 ****
  
  #ifdef FEAT_QUICKFIX
      if (list_arg->v_type != VAR_LIST)
! 	EMSG(_(e_listreq));
      else if (recursive != 0)
! 	EMSG(_(e_au_recursive));
      else
      {
  	list_T  *l = list_arg->vval.v_list;
--- 11013,11021 ----
  
  #ifdef FEAT_QUICKFIX
      if (list_arg->v_type != VAR_LIST)
! 	emsg(_(e_listreq));
      else if (recursive != 0)
! 	emsg(_(e_au_recursive));
      else
      {
  	list_T  *l = list_arg->vval.v_list;
***************
*** 11031,11042 ****
  		    act[1] == NUL)
  		action = *act;
  	    else
! 		EMSG2(_(e_invact), act);
  	}
  	else if (action_arg->v_type == VAR_UNKNOWN)
  	    action = ' ';
  	else
! 	    EMSG(_(e_stringreq));
  
  	if (action_arg->v_type != VAR_UNKNOWN
  		&& what_arg->v_type != VAR_UNKNOWN)
--- 11031,11042 ----
  		    act[1] == NUL)
  		action = *act;
  	    else
! 		semsg(_(e_invact), act);
  	}
  	else if (action_arg->v_type == VAR_UNKNOWN)
  	    action = ' ';
  	else
! 	    emsg(_(e_stringreq));
  
  	if (action_arg->v_type != VAR_UNKNOWN
  		&& what_arg->v_type != VAR_UNKNOWN)
***************
*** 11045,11051 ****
  		d = what_arg->vval.v_dict;
  	    else
  	    {
! 		EMSG(_(e_dictreq));
  		valid_dict = FALSE;
  	    }
  	}
--- 11045,11051 ----
  		d = what_arg->vval.v_dict;
  	    else
  	    {
! 		emsg(_(e_dictreq));
  		valid_dict = FALSE;
  	    }
  	}
***************
*** 11090,11096 ****
      rettv->vval.v_number = -1;
      if (argvars[0].v_type != VAR_LIST)
      {
! 	EMSG(_(e_listreq));
  	return;
      }
      if ((l = argvars[0].vval.v_list) != NULL)
--- 11090,11096 ----
      rettv->vval.v_number = -1;
      if (argvars[0].v_type != VAR_LIST)
      {
! 	emsg(_(e_listreq));
  	return;
      }
      if ((l = argvars[0].vval.v_list) != NULL)
***************
*** 11104,11110 ****
  	    if (li->li_tv.v_type != VAR_DICT
  		    || (d = li->li_tv.vval.v_dict) == NULL)
  	    {
! 		EMSG(_(e_invarg));
  		return;
  	    }
  	    if (!(dict_find(d, (char_u *)"group", -1) != NULL
--- 11104,11110 ----
  	    if (li->li_tv.v_type != VAR_DICT
  		    || (d = li->li_tv.vval.v_dict) == NULL)
  	    {
! 		emsg(_(e_invarg));
  		return;
  	    }
  	    if (!(dict_find(d, (char_u *)"group", -1) != NULL
***************
*** 11113,11119 ****
  			&& dict_find(d, (char_u *)"priority", -1) != NULL
  			&& dict_find(d, (char_u *)"id", -1) != NULL))
  	    {
! 		EMSG(_(e_invarg));
  		return;
  	    }
  	    li = li->li_next;
--- 11113,11119 ----
  			&& dict_find(d, (char_u *)"priority", -1) != NULL
  			&& dict_find(d, (char_u *)"id", -1) != NULL))
  	    {
! 		emsg(_(e_invarg));
  		return;
  	    }
  	    li = li->li_next;
***************
*** 11224,11230 ****
  		    rettv->vval.v_number = 0;
  	    }
  	    else
! 		EMSG(_(e_invarg));
  	}
      }
  }
--- 11224,11230 ----
  		    rettv->vval.v_number = 0;
  	    }
  	    else
! 		emsg(_(e_invarg));
  	}
      }
  }
***************
*** 11424,11430 ****
      // second argument: dict with items to set in the tag stack
      if (argvars[1].v_type != VAR_DICT)
      {
! 	EMSG(_(e_dictreq));
  	return;
      }
      d = argvars[1].vval.v_dict;
--- 11424,11430 ----
      // second argument: dict with items to set in the tag stack
      if (argvars[1].v_type != VAR_DICT)
      {
! 	emsg(_(e_dictreq));
  	return;
      }
      d = argvars[1].vval.v_dict;
***************
*** 11445,11457 ****
  	    action = *actstr;
  	else
  	{
! 	    EMSG2(_(e_invact2), actstr);
  	    return;
  	}
      }
      else
      {
! 	EMSG(_(e_stringreq));
  	return;
      }
  
--- 11445,11457 ----
  	    action = *actstr;
  	else
  	{
! 	    semsg(_(e_invact2), actstr);
  	    return;
  	}
      }
      else
      {
! 	emsg(_(e_stringreq));
  	return;
      }
  
***************
*** 11545,11551 ****
      {
  	if (argvars[1].v_type != VAR_DICT)
  	{
! 	    EMSG(_(e_dictreq));
  	    return;
  	}
  
--- 11545,11551 ----
      {
  	if (argvars[1].v_type != VAR_DICT)
  	{
! 	    emsg(_(e_dictreq));
  	    return;
  	}
  
***************
*** 11616,11622 ****
  	    if (argvars[1].v_type != VAR_DICT ||
  				((dict = argvars[1].vval.v_dict) == NULL))
  	    {
! 		EMSG(_(e_dictreq));
  		return;
  	    }
  	    if ((di = dict_find(dict, (char_u *)"lnum", -1)) != NULL)
--- 11616,11622 ----
  	    if (argvars[1].v_type != VAR_DICT ||
  				((dict = argvars[1].vval.v_dict) == NULL))
  	    {
! 		emsg(_(e_dictreq));
  		return;
  	    }
  	    if ((di = dict_find(dict, (char_u *)"lnum", -1)) != NULL)
***************
*** 11667,11673 ****
  	return;
      if (sign_id <= 0)
      {
! 	EMSG(_(e_invarg));
  	return;
      }
  
--- 11667,11673 ----
  	return;
      if (sign_id <= 0)
      {
! 	emsg(_(e_invarg));
  	return;
      }
  
***************
*** 11719,11725 ****
  	return;
      if (sign_id < 0)
      {
! 	EMSG(_(e_invarg));
  	return;
      }
  
--- 11719,11725 ----
  	return;
      if (sign_id < 0)
      {
! 	emsg(_(e_invarg));
  	return;
      }
  
***************
*** 11751,11757 ****
  	if (argvars[4].v_type != VAR_DICT ||
  				((dict = argvars[4].vval.v_dict) == NULL))
  	{
! 	    EMSG(_(e_dictreq));
  	    goto cleanup;
  	}
  
--- 11751,11757 ----
  	if (argvars[4].v_type != VAR_DICT ||
  				((dict = argvars[4].vval.v_dict) == NULL))
  	{
! 	    emsg(_(e_dictreq));
  	    goto cleanup;
  	}
  
***************
*** 11823,11829 ****
  
      if (argvars[0].v_type != VAR_STRING)
      {
! 	EMSG(_(e_invarg));
  	return;
      }
  
--- 11823,11829 ----
  
      if (argvars[0].v_type != VAR_STRING)
      {
! 	emsg(_(e_invarg));
  	return;
      }
  
***************
*** 11841,11847 ****
      {
  	if (argvars[1].v_type != VAR_DICT)
  	{
! 	    EMSG(_(e_dictreq));
  	    goto cleanup;
  	}
  	dict = argvars[1].vval.v_dict;
--- 11841,11847 ----
      {
  	if (argvars[1].v_type != VAR_DICT)
  	{
! 	    emsg(_(e_dictreq));
  	    goto cleanup;
  	}
  	dict = argvars[1].vval.v_dict;
***************
*** 12120,12126 ****
      sortinfo = &info;
  
      if (argvars[0].v_type != VAR_LIST)
! 	EMSG2(_(e_listarg), sort ? "sort()" : "uniq()");
      else
      {
  	l = argvars[0].vval.v_list;
--- 12120,12126 ----
      sortinfo = &info;
  
      if (argvars[0].v_type != VAR_LIST)
! 	semsg(_(e_listarg), sort ? "sort()" : "uniq()");
      else
      {
  	l = argvars[0].vval.v_list;
***************
*** 12163,12169 ****
  		    info.item_compare_func = tv_get_string(&argvars[1]);
  		else if (i != 0)
  		{
! 		    EMSG(_(e_invarg));
  		    goto theend;
  		}
  		if (info.item_compare_func != NULL)
--- 12163,12169 ----
  		    info.item_compare_func = tv_get_string(&argvars[1]);
  		else if (i != 0)
  		{
! 		    emsg(_(e_invarg));
  		    goto theend;
  		}
  		if (info.item_compare_func != NULL)
***************
*** 12203,12209 ****
  		/* optional third argument: {dict} */
  		if (argvars[2].v_type != VAR_DICT)
  		{
! 		    EMSG(_(e_dictreq));
  		    goto theend;
  		}
  		info.item_compare_selfdict = argvars[2].vval.v_dict;
--- 12203,12209 ----
  		/* optional third argument: {dict} */
  		if (argvars[2].v_type != VAR_DICT)
  		{
! 		    emsg(_(e_dictreq));
  		    goto theend;
  		}
  		info.item_compare_selfdict = argvars[2].vval.v_dict;
***************
*** 12233,12239 ****
  					 || info.item_compare_partial != NULL)
  		    && item_compare2((void *)&ptrs[0], (void *)&ptrs[1])
  							 == ITEM_COMPARE_FAIL)
! 		EMSG(_("E702: Sort compare function failed"));
  	    else
  	    {
  		/* Sort the array with item pointers. */
--- 12233,12239 ----
  					 || info.item_compare_partial != NULL)
  		    && item_compare2((void *)&ptrs[0], (void *)&ptrs[1])
  							 == ITEM_COMPARE_FAIL)
! 		emsg(_("E702: Sort compare function failed"));
  	    else
  	    {
  		/* Sort the array with item pointers. */
***************
*** 12271,12277 ****
  		    ptrs[i++].item = li;
  		if (info.item_compare_func_err)
  		{
! 		    EMSG(_("E882: Uniq compare function failed"));
  		    break;
  		}
  	    }
--- 12271,12277 ----
  		    ptrs[i++].item = li;
  		if (info.item_compare_func_err)
  		{
! 		    emsg(_("E882: Uniq compare function failed"));
  		    break;
  		}
  	    }
***************
*** 12580,12586 ****
  	base = (int)tv_get_number(&argvars[1]);
  	if (base != 2 && base != 8 && base != 10 && base != 16)
  	{
! 	    EMSG(_(e_invarg));
  	    return;
  	}
      }
--- 12580,12586 ----
  	base = (int)tv_get_number(&argvars[1]);
  	if (base != 2 && base != 8 && base != 10 && base != 16)
  	{
! 	    emsg(_(e_invarg));
  	    return;
  	}
      }
***************
*** 12782,12788 ****
      if (argvars[1].v_type != VAR_UNKNOWN)
  	skipcc = (int)tv_get_number_chk(&argvars[1], NULL);
      if (skipcc < 0 || skipcc > 1)
! 	EMSG(_(e_invarg));
      else
      {
  #ifdef FEAT_MBYTE
--- 12782,12788 ----
      if (argvars[1].v_type != VAR_UNKNOWN)
  	skipcc = (int)tv_get_number_chk(&argvars[1], NULL);
      if (skipcc < 0 || skipcc > 1)
! 	emsg(_(e_invarg));
      else
      {
  #ifdef FEAT_MBYTE
***************
*** 13022,13028 ****
  	return;
      if (no < 0 || no >= NSUBEXP)
      {
! 	EMSGN(_("E935: invalid submatch number: %d"), no);
  	return;
      }
      if (argvars[1].v_type != VAR_UNKNOWN)
--- 13022,13028 ----
  	return;
      if (no < 0 || no >= NSUBEXP)
      {
! 	semsg(_("E935: invalid submatch number: %d"), no);
  	return;
      }
      if (argvars[1].v_type != VAR_UNKNOWN)
***************
*** 13357,13370 ****
  	 */
  	if ((infile = vim_tempname('i', TRUE)) == NULL)
  	{
! 	    EMSG(_(e_notmp));
  	    goto errret;
  	}
  
  	fd = mch_fopen((char *)infile, WRITEBIN);
  	if (fd == NULL)
  	{
! 	    EMSG2(_(e_notopen), infile);
  	    goto errret;
  	}
  	if (argvars[1].v_type == VAR_NUMBER)
--- 13357,13370 ----
  	 */
  	if ((infile = vim_tempname('i', TRUE)) == NULL)
  	{
! 	    emsg(_(e_notmp));
  	    goto errret;
  	}
  
  	fd = mch_fopen((char *)infile, WRITEBIN);
  	if (fd == NULL)
  	{
! 	    semsg(_(e_notopen), infile);
  	    goto errret;
  	}
  	if (argvars[1].v_type == VAR_NUMBER)
***************
*** 13375,13381 ****
  	    buf = buflist_findnr(argvars[1].vval.v_number);
  	    if (buf == NULL)
  	    {
! 		EMSGN(_(e_nobufnr), argvars[1].vval.v_number);
  		fclose(fd);
  		goto errret;
  	    }
--- 13375,13381 ----
  	    buf = buflist_findnr(argvars[1].vval.v_number);
  	    if (buf == NULL)
  	    {
! 		semsg(_(e_nobufnr), argvars[1].vval.v_number);
  		fclose(fd);
  		goto errret;
  	    }
***************
*** 13419,13425 ****
  	    err = TRUE;
  	if (err)
  	{
! 	    EMSG(_("E677: Error writing temp file"));
  	    goto errret;
  	}
      }
--- 13419,13425 ----
  	    err = TRUE;
  	if (err)
  	{
! 	    emsg(_("E677: Error writing temp file"));
  	    goto errret;
  	}
      }
***************
*** 13587,13593 ****
  	    if (STRCMP(arg, "$") == 0)
  		nr = tabpage_index(NULL) - 1;
  	    else
! 		EMSG2(_(e_invexpr2), arg);
  	}
      }
      else
--- 13587,13593 ----
  	    if (STRCMP(arg, "$") == 0)
  		nr = tabpage_index(NULL) - 1;
  	    else
! 		semsg(_(e_invexpr2), arg);
  	}
      }
      else
***************
*** 13623,13629 ****
  	}
  	else
  	{
! 	    EMSG2(_(e_invexpr2), arg);
  	    nr = 0;
  	}
      }
--- 13623,13629 ----
  	}
  	else
  	{
! 	    semsg(_(e_invexpr2), arg);
  	    nr = 0;
  	}
      }
***************
*** 13781,13792 ****
  	    || argvars[1].v_type != VAR_NUMBER
  	    || argvars[1].vval.v_number < 0
  	    || argvars[2].v_type != VAR_NUMBER)
! 	EMSG(_(e_invarg));
      else
      {
  	alloc_fail_id = argvars[0].vval.v_number;
  	if (alloc_fail_id >= aid_last)
! 	    EMSG(_(e_invarg));
  	alloc_fail_countdown = argvars[1].vval.v_number;
  	alloc_fail_repeat = argvars[2].vval.v_number;
  	did_outofmem_msg = FALSE;
--- 13781,13792 ----
  	    || argvars[1].v_type != VAR_NUMBER
  	    || argvars[1].vval.v_number < 0
  	    || argvars[2].v_type != VAR_NUMBER)
! 	emsg(_(e_invarg));
      else
      {
  	alloc_fail_id = argvars[0].vval.v_number;
  	if (alloc_fail_id >= aid_last)
! 	    emsg(_(e_invarg));
  	alloc_fail_countdown = argvars[1].vval.v_number;
  	alloc_fail_repeat = argvars[2].vval.v_number;
  	did_outofmem_msg = FALSE;
***************
*** 13830,13841 ****
      char_u *name = (char_u *)"";
  
      if (argvars[0].v_type != VAR_STRING)
! 	EMSG(_(e_invarg));
      else
      {
  	name = tv_get_string(&argvars[0]);
  	if (reset_option_was_set(name) == FAIL)
! 	    EMSG2(_(e_invarg2), name);
      }
  }
  
--- 13830,13841 ----
      char_u *name = (char_u *)"";
  
      if (argvars[0].v_type != VAR_STRING)
! 	emsg(_(e_invarg));
      else
      {
  	name = tv_get_string(&argvars[0]);
  	if (reset_option_was_set(name) == FAIL)
! 	    semsg(_(e_invarg2), name);
      }
  }
  
***************
*** 13851,13857 ****
  
      if (argvars[0].v_type != VAR_STRING
  	    || (argvars[1].v_type) != VAR_NUMBER)
! 	EMSG(_(e_invarg));
      else
      {
  	name = tv_get_string(&argvars[0]);
--- 13851,13857 ----
  
      if (argvars[0].v_type != VAR_STRING
  	    || (argvars[1].v_type) != VAR_NUMBER)
! 	emsg(_(e_invarg));
      else
      {
  	name = tv_get_string(&argvars[0]);
***************
*** 13892,13898 ****
  	    }
  	}
  	else
! 	    EMSG2(_(e_invarg2), name);
      }
  }
  
--- 13892,13898 ----
  	    }
  	}
  	else
! 	    semsg(_(e_invarg2), name);
      }
  }
  
***************
*** 13980,13986 ****
  	    || (argvars[1].v_type) != VAR_NUMBER
  	    || (argvars[2].v_type) != VAR_NUMBER)
      {
! 	EMSG(_(e_invarg));
  	return;
      }
      which = tv_get_string(&argvars[0]);
--- 13980,13986 ----
  	    || (argvars[1].v_type) != VAR_NUMBER
  	    || (argvars[2].v_type) != VAR_NUMBER)
      {
! 	emsg(_(e_invarg));
  	return;
      }
      which = tv_get_string(&argvars[0]);
***************
*** 13995,14001 ****
  	sb = &gui.bottom_sbar;
      if (sb == NULL)
      {
! 	EMSG2(_(e_invarg2), which);
  	return;
      }
      gui_drag_scrollbar(sb, value, dragging);
--- 13995,14001 ----
  	sb = &gui.bottom_sbar;
      if (sb == NULL)
      {
! 	semsg(_(e_invarg2), which);
  	return;
      }
      gui_drag_scrollbar(sb, value, dragging);
***************
*** 14035,14041 ****
      }
      if (arg->v_type == VAR_NUMBER && arg->vval.v_number == 0)
  	return (char_u *)"";
!     EMSG(_("E921: Invalid callback argument"));
      return NULL;
  }
  
--- 14035,14041 ----
      }
      if (arg->v_type == VAR_NUMBER && arg->vval.v_number == 0)
  	return (char_u *)"";
!     emsg(_("E921: Invalid callback argument"));
      return NULL;
  }
  
***************
*** 14069,14075 ****
      if (argvars[0].v_type != VAR_UNKNOWN)
      {
  	if (argvars[0].v_type != VAR_NUMBER)
! 	    EMSG(_(e_number_exp));
  	else
  	{
  	    timer = find_timer((int)tv_get_number(&argvars[0]));
--- 14069,14075 ----
      if (argvars[0].v_type != VAR_UNKNOWN)
      {
  	if (argvars[0].v_type != VAR_NUMBER)
! 	    emsg(_(e_number_exp));
  	else
  	{
  	    timer = find_timer((int)tv_get_number(&argvars[0]));
***************
*** 14091,14097 ****
      int		paused = (int)tv_get_number(&argvars[1]);
  
      if (argvars[0].v_type != VAR_NUMBER)
! 	EMSG(_(e_number_exp));
      else
      {
  	timer = find_timer((int)tv_get_number(&argvars[0]));
--- 14091,14097 ----
      int		paused = (int)tv_get_number(&argvars[1]);
  
      if (argvars[0].v_type != VAR_NUMBER)
! 	emsg(_(e_number_exp));
      else
      {
  	timer = find_timer((int)tv_get_number(&argvars[0]));
***************
*** 14121,14127 ****
  	if (argvars[2].v_type != VAR_DICT
  				   || (dict = argvars[2].vval.v_dict) == NULL)
  	{
! 	    EMSG2(_(e_invarg2), tv_get_string(&argvars[2]));
  	    return;
  	}
  	if (dict_find(dict, (char_u *)"repeat", -1) != NULL)
--- 14121,14127 ----
  	if (argvars[2].v_type != VAR_DICT
  				   || (dict = argvars[2].vval.v_dict) == NULL)
  	{
! 	    semsg(_(e_invarg2), tv_get_string(&argvars[2]));
  	    return;
  	}
  	if (dict_find(dict, (char_u *)"repeat", -1) != NULL)
***************
*** 14157,14163 ****
  
      if (argvars[0].v_type != VAR_NUMBER)
      {
! 	EMSG(_(e_number_exp));
  	return;
      }
      timer = find_timer((int)tv_get_number(&argvars[0]));
--- 14157,14163 ----
  
      if (argvars[0].v_type != VAR_NUMBER)
      {
! 	emsg(_(e_number_exp));
  	return;
      }
      timer = find_timer((int)tv_get_number(&argvars[0]));
***************
*** 14238,14244 ****
  #ifdef FEAT_MBYTE
  error:
  #endif
! 	    EMSG2(_(e_invarg2), fromstr);
  	    ga_clear(&ga);
  	    return;
  	}
--- 14238,14244 ----
  #ifdef FEAT_MBYTE
  error:
  #endif
! 	    semsg(_(e_invarg2), fromstr);
  	    ga_clear(&ga);
  	    return;
  	}
***************
*** 14673,14679 ****
  
      if (argvars[0].v_type != VAR_DICT
  	    || (dict = argvars[0].vval.v_dict) == NULL)
! 	EMSG(_(e_invarg));
      else
      {
  	if (dict_find(dict, (char_u *)"lnum", -1) != NULL)
--- 14673,14679 ----
  
      if (argvars[0].v_type != VAR_DICT
  	    || (dict = argvars[0].vval.v_dict) == NULL)
! 	emsg(_(e_invarg));
      else
      {
  	if (dict_find(dict, (char_u *)"lnum", -1) != NULL)
***************
*** 14809,14815 ****
      }
      else
      {
! 	EMSG2(_(e_invarg2), "writefile()");
  	return;
      }
  
--- 14809,14815 ----
      }
      else
      {
! 	semsg(_(e_invarg2), "writefile()");
  	return;
      }
  
***************
*** 14840,14846 ****
      if (*fname == NUL || (fd = mch_fopen((char *)fname,
  				      append ? APPENDBIN : WRITEBIN)) == NULL)
      {
! 	EMSG2(_(e_notcreate), *fname == NUL ? (char_u *)_("<empty>") : fname);
  	ret = -1;
      }
      else if (blob)
--- 14840,14846 ----
      if (*fname == NUL || (fd = mch_fopen((char *)fname,
  				      append ? APPENDBIN : WRITEBIN)) == NULL)
      {
! 	semsg(_(e_notcreate), *fname == NUL ? (char_u *)_("<empty>") : fname);
  	ret = -1;
      }
      else if (blob)
*** ../vim-8.1.0742/src/ex_cmds.c	2019-01-04 23:09:45.249360567 +0100
--- src/ex_cmds.c	2019-01-13 20:01:49.527319274 +0100
***************
*** 467,473 ****
  	    s = skip_regexp(p + 1, *p, TRUE, NULL);
  	    if (*s != *p)
  	    {
! 		EMSG(_(e_invalpat));
  		goto sortend;
  	    }
  	    *s = NUL;
--- 467,473 ----
  	    s = skip_regexp(p + 1, *p, TRUE, NULL);
  	    if (*s != *p)
  	    {
! 		emsg(_(e_invalpat));
  		goto sortend;
  	    }
  	    *s = NUL;
***************
*** 476,482 ****
  	    {
  		if (last_search_pat() == NULL)
  		{
! 		    EMSG(_(e_noprevre));
  		    goto sortend;
  		}
  		regmatch.regprog = vim_regcomp(last_search_pat(), RE_MAGIC);
--- 476,482 ----
  	    {
  		if (last_search_pat() == NULL)
  		{
! 		    emsg(_(e_noprevre));
  		    goto sortend;
  		}
  		regmatch.regprog = vim_regcomp(last_search_pat(), RE_MAGIC);
***************
*** 490,496 ****
  	}
  	else
  	{
! 	    EMSG2(_(e_invarg2), p);
  	    goto sortend;
  	}
      }
--- 490,496 ----
  	}
  	else
  	{
! 	    semsg(_(e_invarg2), p);
  	    goto sortend;
  	}
      }
***************
*** 498,504 ****
      /* Can only have one of 'n', 'b', 'o' and 'x'. */
      if (format_found > 1)
      {
! 	EMSG(_(e_invarg));
  	goto sortend;
      }
  
--- 498,504 ----
      /* Can only have one of 'n', 'b', 'o' and 'x'. */
      if (format_found > 1)
      {
! 	emsg(_(e_invarg));
  	goto sortend;
      }
  
***************
*** 668,674 ****
      vim_free(sortbuf2);
      vim_regfree(regmatch.regprog);
      if (got_int)
! 	EMSG(_(e_interr));
  }
  
  /*
--- 668,674 ----
      vim_free(sortbuf2);
      vim_regfree(regmatch.regprog);
      if (got_int)
! 	emsg(_(e_interr));
  }
  
  /*
***************
*** 725,731 ****
      new_ts = getdigits(&(eap->arg));
      if (new_ts < 0)
      {
! 	EMSG(_(e_positive));
  	return;
      }
      if (new_ts == 0)
--- 725,731 ----
      new_ts = getdigits(&(eap->arg));
      if (new_ts < 0)
      {
! 	emsg(_(e_positive));
  	return;
      }
      if (new_ts == 0)
***************
*** 835,841 ****
  	line_breakcheck();
      }
      if (got_int)
! 	EMSG(_(e_interr));
  
  #ifdef FEAT_VARTABS
      // If a single value was given then it can be considered equal to
--- 835,841 ----
  	line_breakcheck();
      }
      if (got_int)
! 	emsg(_(e_interr));
  
  #ifdef FEAT_VARTABS
      // If a single value was given then it can be considered equal to
***************
*** 909,915 ****
  
      if (dest >= line1 && dest < line2)
      {
! 	EMSG(_("E134: Cannot move a range of lines into itself"));
  	return FAIL;
      }
  
--- 909,915 ----
  
      if (dest >= line1 && dest < line2)
      {
! 	emsg(_("E134: Cannot move a range of lines into itself"));
  	return FAIL;
      }
  
***************
*** 1002,1008 ****
  	ml_delete(line1 + extra, TRUE);
  
      if (!global_busy && num_lines > p_report)
! 	smsg((char_u *)NGETTEXT("%ld line moved", "%ld lines moved", num_lines),
  			(long)num_lines);
  
      /*
--- 1002,1008 ----
  	ml_delete(line1 + extra, TRUE);
  
      if (!global_busy && num_lines > p_report)
! 	smsg(NGETTEXT("%ld line moved", "%ld lines moved", num_lines),
  			(long)num_lines);
  
      /*
***************
*** 1147,1153 ****
  	{
  	    if (prevcmd == NULL)
  	    {
! 		EMSG(_(e_noprev));
  		vim_free(newcmd);
  		return;
  	    }
--- 1147,1153 ----
  	{
  	    if (prevcmd == NULL)
  	    {
! 		emsg(_(e_noprev));
  		vim_free(newcmd);
  		return;
  	    }
***************
*** 1334,1340 ****
  	if ((do_in && (itmp = vim_tempname('i', FALSE)) == NULL)
  		|| (do_out && (otmp = vim_tempname('o', FALSE)) == NULL))
  	{
! 	    EMSG(_(e_notmp));
  	    goto filterend;
  	}
  
--- 1334,1340 ----
  	if ((do_in && (itmp = vim_tempname('i', FALSE)) == NULL)
  		|| (do_out && (otmp = vim_tempname('o', FALSE)) == NULL))
  	{
! 	    emsg(_(e_notmp));
  	    goto filterend;
  	}
  
***************
*** 1351,1357 ****
  #if defined(FEAT_EVAL)
  	if (!aborting())
  #endif
! 	    (void)EMSG2(_(e_notcreate), itmp);	/* will call wait_return */
  	goto filterend;
      }
      if (curbuf != old_curbuf)
--- 1351,1357 ----
  #if defined(FEAT_EVAL)
  	if (!aborting())
  #endif
! 	    (void)semsg(_(e_notcreate), itmp);	/* will call wait_return */
  	goto filterend;
      }
      if (curbuf != old_curbuf)
***************
*** 1426,1432 ****
  #endif
  		{
  		    msg_putchar('\n');
! 		    EMSG2(_(e_notread), otmp);
  		}
  		goto error;
  	    }
--- 1426,1432 ----
  #endif
  		{
  		    msg_putchar('\n');
! 		    semsg(_(e_notread), otmp);
  		}
  		goto error;
  	    }
***************
*** 1514,1520 ****
      if (curbuf != old_curbuf)
      {
  	--no_wait_return;
! 	EMSG(_("E135: *Filter* Autocommands must not change current buffer"));
      }
      if (itmp != NULL)
  	mch_remove(itmp);
--- 1514,1520 ----
      if (curbuf != old_curbuf)
      {
  	--no_wait_return;
! 	emsg(_("E135: *Filter* Autocommands must not change current buffer"));
      }
      if (itmp != NULL)
  	mch_remove(itmp);
***************
*** 1871,1880 ****
      STRNCAT(IObuff, line, IOSIZE - STRLEN(IObuff) - 1);
      if (IObuff[STRLEN(IObuff) - 1] == '\n')
  	IObuff[STRLEN(IObuff) - 1] = NUL;
!     emsg(IObuff);
      if (++viminfo_errcnt >= 10)
      {
! 	EMSG(_("E136: viminfo: Too many errors, skipping rest of file"));
  	return TRUE;
      }
      return FALSE;
--- 1871,1880 ----
      STRNCAT(IObuff, line, IOSIZE - STRLEN(IObuff) - 1);
      if (IObuff[STRLEN(IObuff) - 1] == '\n')
  	IObuff[STRLEN(IObuff) - 1] = NUL;
!     emsg((char *)IObuff);
      if (++viminfo_errcnt >= 10)
      {
! 	emsg(_("E136: viminfo: Too many errors, skipping rest of file"));
  	return TRUE;
      }
      return FALSE;
***************
*** 1903,1909 ****
      if (p_verbose > 0)
      {
  	verbose_enter();
! 	smsg((char_u *)_("Reading viminfo file \"%s\"%s%s%s"),
  		fname,
  		(flags & VIF_WANT_INFO) ? _(" info") : "",
  		(flags & VIF_WANT_MARKS) ? _(" marks") : "",
--- 1903,1909 ----
      if (p_verbose > 0)
      {
  	verbose_enter();
! 	smsg(_("Reading viminfo file \"%s\"%s%s%s"),
  		fname,
  		(flags & VIF_WANT_INFO) ? _(" info") : "",
  		(flags & VIF_WANT_MARKS) ? _(" marks") : "",
***************
*** 2003,2009 ****
  	    int	tt = msg_didany;
  
  	    /* avoid a wait_return for this message, it's annoying */
! 	    EMSG2(_("E137: Viminfo file is not writable: %s"), fname);
  	    msg_didany = tt;
  	    fclose(fp_in);
  	    goto end;
--- 2003,2009 ----
  	    int	tt = msg_didany;
  
  	    /* avoid a wait_return for this message, it's annoying */
! 	    semsg(_("E137: Viminfo file is not writable: %s"), fname);
  	    msg_didany = tt;
  	    fclose(fp_in);
  	    goto end;
***************
*** 2126,2132 ****
  		{
  		    /* They all exist?  Must be something wrong! Don't write
  		     * the viminfo file then. */
! 		    EMSG2(_("E929: Too many viminfo temp files, like %s!"),
  								     tempname);
  		    break;
  		}
--- 2126,2132 ----
  		{
  		    /* They all exist?  Must be something wrong! Don't write
  		     * the viminfo file then. */
! 		    semsg(_("E929: Too many viminfo temp files, like %s!"),
  								     tempname);
  		    break;
  		}
***************
*** 2172,2178 ****
       */
      if (fp_out == NULL)
      {
! 	EMSG2(_("E138: Can't write viminfo file %s!"),
  		       (fp_in == NULL || tempname == NULL) ? fname : tempname);
  	if (fp_in != NULL)
  	    fclose(fp_in);
--- 2172,2178 ----
       */
      if (fp_out == NULL)
      {
! 	semsg(_("E138: Can't write viminfo file %s!"),
  		       (fp_in == NULL || tempname == NULL) ? fname : tempname);
  	if (fp_in != NULL)
  	    fclose(fp_in);
***************
*** 2182,2188 ****
      if (p_verbose > 0)
      {
  	verbose_enter();
! 	smsg((char_u *)_("Writing viminfo file \"%s\""), fname);
  	verbose_leave();
      }
  
--- 2182,2188 ----
      if (p_verbose > 0)
      {
  	verbose_enter();
! 	smsg(_("Writing viminfo file \"%s\""), fname);
  	verbose_leave();
      }
  
***************
*** 2203,2209 ****
  	    if (vim_rename(tempname, fname) == -1)
  	    {
  		++viminfo_errcnt;
! 		EMSG2(_("E886: Can't rename viminfo file to %s!"), fname);
  	    }
  # ifdef WIN3264
  	    /* If the viminfo file was hidden then also hide the new file. */
--- 2203,2209 ----
  	    if (vim_rename(tempname, fname) == -1)
  	    {
  		++viminfo_errcnt;
! 		semsg(_("E886: Can't rename viminfo file to %s!"), fname);
  	    }
  # ifdef WIN3264
  	    /* If the viminfo file was hidden then also hide the new file. */
***************
*** 3127,3133 ****
  		|| eap->line2 > 0
  		|| eap->addr_count > 1))
      {
! 	EMSG(_(e_invarg));
  	return;
      }
  
--- 3127,3133 ----
  		|| eap->line2 > 0
  		|| eap->addr_count > 1))
      {
! 	emsg(_(e_invarg));
  	return;
      }
  
***************
*** 3205,3211 ****
      {
  	if (eap->cmdidx == CMD_saveas)
  	{
! 	    EMSG(_(e_argreq));
  	    goto theend;
  	}
  	other = FALSE;
--- 3205,3211 ----
      {
  	if (eap->cmdidx == CMD_saveas)
  	{
! 	    emsg(_(e_argreq));
  	    goto theend;
  	}
  	other = FALSE;
***************
*** 3237,3243 ****
  	{
  	    /* Overwriting a file that is loaded in another buffer is not a
  	     * good idea. */
! 	    EMSG(_(e_bufloaded));
  	    goto theend;
  	}
      }
--- 3237,3243 ----
  	{
  	    /* Overwriting a file that is loaded in another buffer is not a
  	     * good idea. */
! 	    emsg(_(e_bufloaded));
  	    goto theend;
  	}
      }
***************
*** 3278,3284 ****
  	    else
  #endif
  	    {
! 		EMSG(_("E140: Use ! to write partial buffer"));
  		goto theend;
  	    }
  	}
--- 3278,3284 ----
  	    else
  #endif
  	    {
! 		emsg(_("E140: Use ! to write partial buffer"));
  		goto theend;
  	    }
  	}
***************
*** 3417,3423 ****
  	    /* with UNIX it is possible to open a directory */
  	    if (mch_isdir(ffname))
  	    {
! 		EMSG2(_(e_isadir2), ffname);
  		return FAIL;
  	    }
  #endif
--- 3417,3423 ----
  	    /* with UNIX it is possible to open a directory */
  	    if (mch_isdir(ffname))
  	    {
! 		semsg(_(e_isadir2), ffname);
  		return FAIL;
  	    }
  #endif
***************
*** 3434,3440 ****
  	    else
  #endif
  	    {
! 		EMSG(_(e_exists));
  		return FAIL;
  	    }
  	}
--- 3434,3440 ----
  	    else
  #endif
  	    {
! 		emsg(_(e_exists));
  		return FAIL;
  	    }
  	}
***************
*** 3491,3497 ****
  		else
  #endif
  		{
! 		    EMSG2(_("E768: Swap file exists: %s (:silent! overrides)"),
  								    swapname);
  		    vim_free(swapname);
  		    return FAIL;
--- 3491,3497 ----
  		else
  #endif
  		{
! 		    semsg(_("E768: Swap file exists: %s (:silent! overrides)"),
  								    swapname);
  		    vim_free(swapname);
  		    return FAIL;
***************
*** 3565,3571 ****
  #endif
  	    if (buf->b_ffname == NULL)
  	    {
! 		EMSGN(_("E141: No file name for buffer %ld"), (long)buf->b_fnum);
  		++error;
  	    }
  	    else if (check_readonly(&eap->forceit, buf)
--- 3565,3571 ----
  #endif
  	    if (buf->b_ffname == NULL)
  	    {
! 		semsg(_("E141: No file name for buffer %ld"), (long)buf->b_fnum);
  		++error;
  	    }
  	    else if (check_readonly(&eap->forceit, buf)
***************
*** 3605,3611 ****
  {
      if (p_write)
  	return FALSE;
!     EMSG(_("E142: File not written: Writing is disabled by 'write' option"));
      return TRUE;
  }
  
--- 3605,3611 ----
  {
      if (p_write)
  	return FALSE;
!     emsg(_("E142: File not written: Writing is disabled by 'write' option"));
      return TRUE;
  }
  
***************
*** 3651,3659 ****
  	else
  #endif
  	if (buf->b_p_ro)
! 	    EMSG(_(e_readonly));
  	else
! 	    EMSG2(_("E505: \"%s\" is read-only (add ! to override)"),
  		    buf->b_fname);
  	return TRUE;
      }
--- 3651,3659 ----
  	else
  #endif
  	if (buf->b_p_ro)
! 	    emsg(_(e_readonly));
  	else
! 	    semsg(_("E505: \"%s\" is read-only (add ! to override)"),
  		    buf->b_fname);
  	return TRUE;
      }
***************
*** 4488,4494 ****
      static void
  delbuf_msg(char_u *name)
  {
!     EMSG2(_("E143: Autocommands unexpectedly deleted new buffer %s"),
  	    name == NULL ? (char_u *)"" : name);
      vim_free(name);
      au_new_curbuf.br_buf = NULL;
--- 4488,4494 ----
      static void
  delbuf_msg(char_u *name)
  {
!     semsg(_("E143: Autocommands unexpectedly deleted new buffer %s"),
  	    name == NULL ? (char_u *)"" : name);
      vim_free(name);
      au_new_curbuf.br_buf = NULL;
***************
*** 4707,4713 ****
      {
  	if (!VIM_ISDIGIT(*x))
  	{
! 	    EMSG(_("E144: non-numeric argument to :z"));
  	    return;
  	}
  	else
--- 4707,4713 ----
      {
  	if (!VIM_ISDIGIT(*x))
  	{
! 	    emsg(_("E144: non-numeric argument to :z"));
  	    return;
  	}
  	else
***************
*** 4817,4823 ****
  {
      if (restricted)
      {
! 	EMSG(_("E145: Shell commands not allowed in rvim"));
  	return TRUE;
      }
      return FALSE;
--- 4817,4823 ----
  {
      if (restricted)
      {
! 	emsg(_("E145: Shell commands not allowed in rvim"));
  	return TRUE;
      }
      return FALSE;
***************
*** 4834,4840 ****
      if (secure)
      {
  	secure = 2;
! 	EMSG(_(e_curdir));
  	return TRUE;
      }
  #ifdef HAVE_SANDBOX
--- 4834,4840 ----
      if (secure)
      {
  	secure = 2;
! 	emsg(_(e_curdir));
  	return TRUE;
      }
  #ifdef HAVE_SANDBOX
***************
*** 4844,4850 ****
       */
      if (sandbox != 0)
      {
! 	EMSG(_(e_sandbox));
  	return TRUE;
      }
  #endif
--- 4844,4850 ----
       */
      if (sandbox != 0)
      {
! 	emsg(_(e_sandbox));
  	return TRUE;
      }
  #endif
***************
*** 4933,4939 ****
  				/* don't accept alphanumeric for separator */
  	if (isalpha(*cmd))
  	{
! 	    EMSG(_("E146: Regular expressions can't be delimited by letters"));
  	    return;
  	}
  	/*
--- 4933,4939 ----
  				/* don't accept alphanumeric for separator */
  	if (isalpha(*cmd))
  	{
! 	    emsg(_("E146: Regular expressions can't be delimited by letters"));
  	    return;
  	}
  	/*
***************
*** 4946,4952 ****
  	    ++cmd;
  	    if (vim_strchr((char_u *)"/?&", *cmd) == NULL)
  	    {
! 		EMSG(_(e_backslash));
  		return;
  	    }
  	    if (*cmd != '&')
--- 4946,4952 ----
  	    ++cmd;
  	    if (vim_strchr((char_u *)"/?&", *cmd) == NULL)
  	    {
! 		emsg(_(e_backslash));
  		return;
  	    }
  	    if (*cmd != '&')
***************
*** 4994,5000 ****
  	    {
  		if (old_sub == NULL)	/* there is no previous command */
  		{
! 		    EMSG(_(e_nopresub));
  		    return;
  		}
  		sub = old_sub;
--- 4994,5000 ----
  	    {
  		if (old_sub == NULL)	/* there is no previous command */
  		{
! 		    emsg(_(e_nopresub));
  		    return;
  		}
  		sub = old_sub;
***************
*** 5010,5016 ****
      {
  	if (old_sub == NULL)	/* there is no previous command */
  	{
! 	    EMSG(_(e_nopresub));
  	    return;
  	}
  	pat = NULL;		/* search_regcomp() will use previous pattern */
--- 5010,5016 ----
      {
  	if (old_sub == NULL)	/* there is no previous command */
  	{
! 	    emsg(_(e_nopresub));
  	    return;
  	}
  	pat = NULL;		/* search_regcomp() will use previous pattern */
***************
*** 5137,5143 ****
  	i = getdigits(&cmd);
  	if (i <= 0 && !eap->skip && subflags.do_error)
  	{
! 	    EMSG(_(e_zerocount));
  	    return;
  	}
  	eap->line1 = eap->line2;
--- 5137,5143 ----
  	i = getdigits(&cmd);
  	if (i <= 0 && !eap->skip && subflags.do_error)
  	{
! 	    emsg(_(e_zerocount));
  	    return;
  	}
  	eap->line1 = eap->line2;
***************
*** 5155,5161 ****
  	eap->nextcmd = check_nextcmd(cmd);
  	if (eap->nextcmd == NULL)
  	{
! 	    EMSG(_(e_trailing));
  	    return;
  	}
      }
--- 5155,5161 ----
  	eap->nextcmd = check_nextcmd(cmd);
  	if (eap->nextcmd == NULL)
  	{
! 	    emsg(_(e_trailing));
  	    return;
  	}
      }
***************
*** 5166,5179 ****
      if (!subflags.do_count && !curbuf->b_p_ma)
      {
  	/* Substitution is not allowed in non-'modifiable' buffer */
! 	EMSG(_(e_modifiable));
  	return;
      }
  
      if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)
      {
  	if (subflags.do_error)
! 	    EMSG(_(e_invcmd));
  	return;
      }
  
--- 5166,5179 ----
      if (!subflags.do_count && !curbuf->b_p_ma)
      {
  	/* Substitution is not allowed in non-'modifiable' buffer */
! 	emsg(_(e_modifiable));
  	return;
      }
  
      if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)
      {
  	if (subflags.do_error)
! 	    emsg(_(e_invcmd));
  	return;
      }
  
***************
*** 5496,5502 ****
  			    /* write message same highlighting as for
  			     * wait_return */
  			    smsg_attr(HL_ATTR(HLF_R),
! 				    (char_u *)_("replace with %s (y/n/a/q/l/^E/^Y)?"), sub);
  			    msg_no_more = FALSE;
  			    msg_scroll = i;
  			    showruler(TRUE);
--- 5496,5502 ----
  			    /* write message same highlighting as for
  			     * wait_return */
  			    smsg_attr(HL_ATTR(HLF_R),
! 				_("replace with %s (y/n/a/q/l/^E/^Y)?"), sub);
  			    msg_no_more = FALSE;
  			    msg_scroll = i;
  			    showruler(TRUE);
***************
*** 5949,5959 ****
      else if (!global_busy)
      {
  	if (got_int)		/* interrupted */
! 	    EMSG(_(e_interr));
  	else if (got_match)	/* did find something but nothing substituted */
  	    MSG("");
  	else if (subflags.do_error)	/* nothing found */
! 	    EMSG2(_(e_patnotf2), get_search_pat());
      }
  
  #ifdef FEAT_FOLDING
--- 5949,5959 ----
      else if (!global_busy)
      {
  	if (got_int)		/* interrupted */
! 	    emsg(_(e_interr));
  	else if (got_match)	/* did find something but nothing substituted */
  	    MSG("");
  	else if (subflags.do_error)	/* nothing found */
! 	    semsg(_(e_patnotf2), get_search_pat());
      }
  
  #ifdef FEAT_FOLDING
***************
*** 6018,6024 ****
      }
      if (got_int)
      {
! 	EMSG(_(e_interr));
  	return TRUE;
      }
      return FALSE;
--- 6018,6024 ----
      }
      if (got_int)
      {
! 	emsg(_(e_interr));
  	return TRUE;
      }
      return FALSE;
***************
*** 6071,6077 ****
  				  || eap->line2 != curbuf->b_ml.ml_line_count))
      {
  	/* will increment global_busy to break out of the loop */
! 	EMSG(_("E147: Cannot do :global recursive with a range"));
  	return;
      }
  
--- 6071,6077 ----
  				  || eap->line2 != curbuf->b_ml.ml_line_count))
      {
  	/* will increment global_busy to break out of the loop */
! 	emsg(_("E147: Cannot do :global recursive with a range"));
  	return;
      }
  
***************
*** 6092,6098 ****
  	++cmd;
  	if (vim_strchr((char_u *)"/?&", *cmd) == NULL)
  	{
! 	    EMSG(_(e_backslash));
  	    return;
  	}
  	if (*cmd == '&')
--- 6092,6098 ----
  	++cmd;
  	if (vim_strchr((char_u *)"/?&", *cmd) == NULL)
  	{
! 	    emsg(_(e_backslash));
  	    return;
  	}
  	if (*cmd == '&')
***************
*** 6104,6110 ****
      }
      else if (*cmd == NUL)
      {
! 	EMSG(_("E148: Regular expression missing from global"));
  	return;
      }
      else
--- 6104,6110 ----
      }
      else if (*cmd == NUL)
      {
! 	emsg(_("E148: Regular expression missing from global"));
  	return;
      }
      else
***************
*** 6125,6131 ****
  
      if (search_regcomp(pat, RE_BOTH, which_pat, SEARCH_HIS, &regmatch) == FAIL)
      {
! 	EMSG(_(e_invcmd));
  	return;
      }
  
--- 6125,6131 ----
  
      if (search_regcomp(pat, RE_BOTH, which_pat, SEARCH_HIS, &regmatch) == FAIL)
      {
! 	emsg(_(e_invcmd));
  	return;
      }
  
***************
*** 6163,6171 ****
  	else if (ndone == 0)
  	{
  	    if (type == 'v')
! 		smsg((char_u *)_("Pattern found in every line: %s"), pat);
  	    else
! 		smsg((char_u *)_("Pattern not found: %s"), pat);
  	}
  	else
  	{
--- 6163,6171 ----
  	else if (ndone == 0)
  	{
  	    if (type == 'v')
! 		smsg(_("Pattern found in every line: %s"), pat);
  	    else
! 		smsg(_("Pattern not found: %s"), pat);
  	}
  	else
  	{
***************
*** 6366,6372 ****
  
  	if (eap->forceit && *arg == NUL && !curbuf->b_help)
  	{
! 	    EMSG(_("E478: Don't panic!"));
  	    return;
  	}
  
--- 6366,6372 ----
  
  	if (eap->forceit && *arg == NUL && !curbuf->b_help)
  	{
! 	    emsg(_("E478: Don't panic!"));
  	    return;
  	}
  
***************
*** 6412,6421 ****
      {
  #ifdef FEAT_MULTI_LANG
  	if (lang != NULL)
! 	    EMSG3(_("E661: Sorry, no '%s' help for %s"), lang, arg);
  	else
  #endif
! 	    EMSG2(_("E149: Sorry, no help for %s"), arg);
  	if (n != FAIL)
  	    FreeWild(num_matches, matches);
  	return;
--- 6412,6421 ----
      {
  #ifdef FEAT_MULTI_LANG
  	if (lang != NULL)
! 	    semsg(_("E661: Sorry, no '%s' help for %s"), lang, arg);
  	else
  #endif
! 	    semsg(_("E149: Sorry, no help for %s"), arg);
  	if (n != FAIL)
  	    FreeWild(num_matches, matches);
  	return;
***************
*** 6451,6457 ****
  	     */
  	    if ((helpfd = mch_fopen((char *)p_hf, READBIN)) == NULL)
  	    {
! 		smsg((char_u *)_("Sorry, help file \"%s\" not found"), p_hf);
  		goto erret;
  	    }
  	    fclose(helpfd);
--- 6451,6457 ----
  	     */
  	    if ((helpfd = mch_fopen((char *)p_hf, READBIN)) == NULL)
  	    {
! 		smsg(_("Sorry, help file \"%s\" not found"), p_hf);
  		goto erret;
  	    }
  	    fclose(helpfd);
***************
*** 7230,7236 ****
  	    || filecount == 0)
      {
  	if (!got_int)
! 	    EMSG2(_("E151: No match: %s"), NameBuff);
  	return;
      }
  
--- 7230,7236 ----
  	    || filecount == 0)
      {
  	if (!got_int)
! 	    semsg(_("E151: No match: %s"), NameBuff);
  	return;
      }
  
***************
*** 7244,7250 ****
      fd_tags = mch_fopen((char *)NameBuff, "w");
      if (fd_tags == NULL)
      {
! 	EMSG2(_("E152: Cannot open %s for writing"), NameBuff);
  	FreeWild(filecount, files);
  	return;
      }
--- 7244,7250 ----
      fd_tags = mch_fopen((char *)NameBuff, "w");
      if (fd_tags == NULL)
      {
! 	semsg(_("E152: Cannot open %s for writing"), NameBuff);
  	FreeWild(filecount, files);
  	return;
      }
***************
*** 7281,7287 ****
  	fd = mch_fopen((char *)files[fi], "r");
  	if (fd == NULL)
  	{
! 	    EMSG2(_("E153: Unable to open %s for reading"), files[fi]);
  	    continue;
  	}
  	fname = files[fi] + dirlen + 1;
--- 7281,7287 ----
  	fd = mch_fopen((char *)files[fi], "r");
  	if (fd == NULL)
  	{
! 	    semsg(_("E153: Unable to open %s for reading"), files[fi]);
  	    continue;
  	}
  	fname = files[fi] + dirlen + 1;
***************
*** 7317,7323 ****
  		    utf8 = this_utf8;
  		else if (utf8 != this_utf8)
  		{
! 		    EMSG2(_("E670: Mix of help file encodings within a language: %s"), files[fi]);
  		    mix = !got_int;
  		    got_int = TRUE;
  		}
--- 7317,7323 ----
  		    utf8 = this_utf8;
  		else if (utf8 != this_utf8)
  		{
! 		    semsg(_("E670: Mix of help file encodings within a language: %s"), files[fi]);
  		    mix = !got_int;
  		    got_int = TRUE;
  		}
***************
*** 7401,7407 ****
  		    vim_snprintf((char *)NameBuff, MAXPATHL,
  			    _("E154: Duplicate tag \"%s\" in file %s/%s"),
  				     ((char_u **)ga.ga_data)[i], dir, p2 + 1);
! 		    EMSG(NameBuff);
  		    *p2 = '\t';
  		    break;
  		}
--- 7401,7407 ----
  		    vim_snprintf((char *)NameBuff, MAXPATHL,
  			    _("E154: Duplicate tag \"%s\" in file %s/%s"),
  				     ((char_u **)ga.ga_data)[i], dir, p2 + 1);
! 		    emsg((char *)NameBuff);
  		    *p2 = '\t';
  		    break;
  		}
***************
*** 7473,7479 ****
  						    EW_FILE|EW_SILENT) == FAIL
  	    || filecount == 0)
      {
! 	EMSG2(_("E151: No match: %s"), NameBuff);
  	return;
      }
  
--- 7473,7479 ----
  						    EW_FILE|EW_SILENT) == FAIL
  	    || filecount == 0)
      {
! 	semsg(_("E151: No match: %s"), NameBuff);
  	return;
      }
  
***************
*** 7586,7592 ****
  	dirname = ExpandOne(&xpc, eap->arg, NULL,
  			    WILD_LIST_NOTFOUND|WILD_SILENT, WILD_EXPAND_FREE);
  	if (dirname == NULL || !mch_isdir(dirname))
! 	    EMSG2(_("E150: Not a directory: %s"), eap->arg);
  	else
  	    do_helptags(dirname, add_help_tags);
  	vim_free(dirname);
--- 7586,7592 ----
  	dirname = ExpandOne(&xpc, eap->arg, NULL,
  			    WILD_LIST_NOTFOUND|WILD_SILENT, WILD_EXPAND_FREE);
  	if (dirname == NULL || !mch_isdir(dirname))
! 	    semsg(_("E150: Not a directory: %s"), eap->arg);
  	else
  	    do_helptags(dirname, add_help_tags);
  	vim_free(dirname);
*** ../vim-8.1.0742/src/ex_cmds.h	2019-01-08 22:02:36.044297306 +0100
--- src/ex_cmds.h	2019-01-13 20:24:01.272847911 +0100
***************
*** 1799,1805 ****
  #ifdef FEAT_USR_CMDS
      int		useridx;	/* user command index */
  #endif
!     char_u	*errmsg;	/* returned error message */
      char_u	*(*getline)(int, void *, int);
      void	*cookie;	/* argument for getline() */
  #ifdef FEAT_EVAL
--- 1799,1805 ----
  #ifdef FEAT_USR_CMDS
      int		useridx;	/* user command index */
  #endif
!     char	*errmsg;	/* returned error message */
      char_u	*(*getline)(int, void *, int);
      void	*cookie;	/* argument for getline() */
  #ifdef FEAT_EVAL
*** ../vim-8.1.0742/src/ex_cmds2.c	2019-01-12 15:15:34.089783011 +0100
--- src/ex_cmds2.c	2019-01-13 19:48:43.978119627 +0100
***************
*** 146,167 ****
  	MSG(_("Entering Debug mode.  Type \"cont\" to continue."));
      if (debug_oldval != NULL)
      {
! 	smsg((char_u *)_("Oldval = \"%s\""), debug_oldval);
  	vim_free(debug_oldval);
  	debug_oldval = NULL;
      }
      if (debug_newval != NULL)
      {
! 	smsg((char_u *)_("Newval = \"%s\""), debug_newval);
  	vim_free(debug_newval);
  	debug_newval = NULL;
      }
      if (sourcing_name != NULL)
  	msg(sourcing_name);
      if (sourcing_lnum != 0)
! 	smsg((char_u *)_("line %ld: %s"), (long)sourcing_lnum, cmd);
      else
! 	smsg((char_u *)_("cmd: %s"), cmd);
      /*
       * Repeat getting a command and executing it.
       */
--- 146,167 ----
  	MSG(_("Entering Debug mode.  Type \"cont\" to continue."));
      if (debug_oldval != NULL)
      {
! 	smsg(_("Oldval = \"%s\""), debug_oldval);
  	vim_free(debug_oldval);
  	debug_oldval = NULL;
      }
      if (debug_newval != NULL)
      {
! 	smsg(_("Newval = \"%s\""), debug_newval);
  	vim_free(debug_newval);
  	debug_newval = NULL;
      }
      if (sourcing_name != NULL)
  	msg(sourcing_name);
      if (sourcing_lnum != 0)
! 	smsg(_("line %ld: %s"), (long)sourcing_lnum, cmd);
      else
! 	smsg(_("cmd: %s"), cmd);
      /*
       * Repeat getting a command and executing it.
       */
***************
*** 399,405 ****
  	if (debug_backtrace_level > max)
  	{
  	    debug_backtrace_level = max;
! 	    smsg((char_u *)_("frame at highest level: %d"), max);
  	}
      }
  }
--- 399,405 ----
  	if (debug_backtrace_level > max)
  	{
  	    debug_backtrace_level = max;
! 	    smsg(_("frame at highest level: %d"), max);
  	}
      }
  }
***************
*** 421,429 ****
  	    if (next != NULL)
  		*next = NUL;
  	    if (i == max - debug_backtrace_level)
! 		smsg((char_u *)"->%d %s", max - i, cur);
  	    else
! 		smsg((char_u *)"  %d %s", max - i, cur);
  	    ++i;
  	    if (next == NULL)
  		break;
--- 421,429 ----
  	    if (next != NULL)
  		*next = NUL;
  	    if (i == max - debug_backtrace_level)
! 		smsg("->%d %s", max - i, cur);
  	    else
! 		smsg("  %d %s", max - i, cur);
  	    ++i;
  	    if (next == NULL)
  		break;
***************
*** 432,440 ****
  	}
      }
      if (sourcing_lnum != 0)
!        smsg((char_u *)_("line %ld: %s"), (long)sourcing_lnum, cmd);
      else
!        smsg((char_u *)_("cmd: %s"), cmd);
  }
  
  /*
--- 432,440 ----
  	}
      }
      if (sourcing_lnum != 0)
!        smsg(_("line %ld: %s"), (long)sourcing_lnum, cmd);
      else
!        smsg(_("cmd: %s"), cmd);
  }
  
  /*
***************
*** 487,493 ****
  		p = (char_u *)"<SNR>";
  	    else
  		p = (char_u *)"";
! 	    smsg((char_u *)_("Breakpoint in \"%s%s\" line %ld"),
  		    p,
  		    debug_breakpoint_name + (*p == NUL ? 0 : 3),
  		    (long)debug_breakpoint_lnum);
--- 487,493 ----
  		p = (char_u *)"<SNR>";
  	    else
  		p = (char_u *)"";
! 	    smsg(_("Breakpoint in \"%s%s\" line %ld"),
  		    p,
  		    debug_breakpoint_name + (*p == NUL ? 0 : 3),
  		    (long)debug_breakpoint_lnum);
***************
*** 607,613 ****
      {
  	if (curbuf->b_ffname == NULL)
  	{
! 	    EMSG(_(e_noname));
  	    return FAIL;
  	}
  	bp->dbg_type = DBG_FILE;
--- 607,613 ----
      {
  	if (curbuf->b_ffname == NULL)
  	{
! 	    emsg(_(e_noname));
  	    return FAIL;
  	}
  	bp->dbg_type = DBG_FILE;
***************
*** 621,627 ****
  	bp->dbg_type = DBG_EXPR;
      else
      {
! 	EMSG2(_(e_invarg2), p);
  	return FAIL;
      }
      p = skipwhite(p + 4);
--- 621,627 ----
  	bp->dbg_type = DBG_EXPR;
      else
      {
! 	semsg(_(e_invarg2), p);
  	return FAIL;
      }
      p = skipwhite(p + 4);
***************
*** 646,652 ****
  	    || (here && *p != NUL)
  	    || (bp->dbg_type == DBG_FUNC && strstr((char *)p, "()") != NULL))
      {
! 	EMSG2(_(e_invarg2), arg);
  	return FAIL;
      }
  
--- 646,652 ----
  	    || (here && *p != NUL)
  	    || (bp->dbg_type == DBG_FUNC && strstr((char *)p, "()") != NULL))
      {
! 	semsg(_(e_invarg2), arg);
  	return FAIL;
      }
  
***************
*** 817,823 ****
      }
  
      if (todel < 0)
! 	EMSG2(_("E161: Breakpoint not found: %s"), eap->arg);
      else
      {
  	while (gap->ga_len > 0)
--- 817,823 ----
      }
  
      if (todel < 0)
! 	semsg(_("E161: Breakpoint not found: %s"), eap->arg);
      else
      {
  	while (gap->ga_len > 0)
***************
*** 865,877 ****
  	    if (bp->dbg_type == DBG_FILE)
  		home_replace(NULL, bp->dbg_name, NameBuff, MAXPATHL, TRUE);
  	    if (bp->dbg_type != DBG_EXPR)
! 		smsg((char_u *)_("%3d  %s %s  line %ld"),
  		    bp->dbg_nr,
  		    bp->dbg_type == DBG_FUNC ? "func" : "file",
  		    bp->dbg_type == DBG_FUNC ? bp->dbg_name : NameBuff,
  		    (long)bp->dbg_lnum);
  	    else
! 		smsg((char_u *)_("%3d  expr %s"),
  		    bp->dbg_nr, bp->dbg_name);
  	}
  }
--- 865,877 ----
  	    if (bp->dbg_type == DBG_FILE)
  		home_replace(NULL, bp->dbg_name, NameBuff, MAXPATHL, TRUE);
  	    if (bp->dbg_type != DBG_EXPR)
! 		smsg(_("%3d  %s %s  line %ld"),
  		    bp->dbg_nr,
  		    bp->dbg_type == DBG_FUNC ? "func" : "file",
  		    bp->dbg_type == DBG_FUNC ? bp->dbg_name : NameBuff,
  		    (long)bp->dbg_lnum);
  	    else
! 		smsg(_("%3d  expr %s"),
  		    bp->dbg_nr, bp->dbg_name);
  	}
  }
***************
*** 1726,1732 ****
  	set_vim_var_nr(VV_PROFILING, 1L);
      }
      else if (do_profiling == PROF_NONE)
! 	EMSG(_("E750: First use \":profile start {fname}\""));
      else if (STRCMP(eap->arg, "pause") == 0)
      {
  	if (do_profiling == PROF_YES)
--- 1726,1732 ----
  	set_vim_var_nr(VV_PROFILING, 1L);
      }
      else if (do_profiling == PROF_NONE)
! 	emsg(_("E750: First use \":profile start {fname}\""));
      else if (STRCMP(eap->arg, "pause") == 0)
      {
  	if (do_profiling == PROF_YES)
***************
*** 1828,1834 ****
      {
  	fd = mch_fopen((char *)profile_fname, "w");
  	if (fd == NULL)
! 	    EMSG2(_(e_notopen), profile_fname);
  	else
  	{
  	    script_dump_profile(fd);
--- 1828,1834 ----
      {
  	fd = mch_fopen((char *)profile_fname, "w");
  	if (fd == NULL)
! 	    semsg(_(e_notopen), profile_fname);
  	else
  	{
  	    script_dump_profile(fd);
***************
*** 2357,2367 ****
  	if (
  #ifdef FEAT_TERMINAL
  		term_job_running(buf->b_term)
! 		    ? EMSG2(_("E947: Job still running in buffer \"%s\""),
  								  buf->b_fname)
  		    :
  #endif
! 		EMSG2(_("E162: No write since last change for buffer \"%s\""),
  		    buf_spname(buf) != NULL ? buf_spname(buf) : buf->b_fname))
  	{
  	    save = no_wait_return;
--- 2357,2367 ----
  	if (
  #ifdef FEAT_TERMINAL
  		term_job_running(buf->b_term)
! 		    ? semsg(_("E947: Job still running in buffer \"%s\""),
  								  buf->b_fname)
  		    :
  #endif
! 		semsg(_("E162: No write since last change for buffer \"%s\""),
  		    buf_spname(buf) != NULL ? buf_spname(buf) : buf->b_fname))
  	{
  	    save = no_wait_return;
***************
*** 2407,2413 ****
  {
      if (curbuf->b_ffname == NULL)
      {
! 	EMSG(_(e_noname));
  	return FAIL;
      }
      return OK;
--- 2407,2413 ----
  {
      if (curbuf->b_ffname == NULL)
      {
! 	emsg(_(e_noname));
  	return FAIL;
      }
      return OK;
***************
*** 2629,2635 ****
  	    vim_regfree(regmatch.regprog);
  	    vim_free(p);
  	    if (!didone)
! 		EMSG2(_(e_nomatch2), ((char_u **)new_ga.ga_data)[i]);
  	}
  	ga_clear(&new_ga);
      }
--- 2629,2635 ----
  	    vim_regfree(regmatch.regprog);
  	    vim_free(p);
  	    if (!didone)
! 		semsg(_(e_nomatch2), ((char_u **)new_ga.ga_data)[i]);
  	}
  	ga_clear(&new_ga);
      }
***************
*** 2640,2646 ****
  	ga_clear(&new_ga);
  	if (i == FAIL || exp_count == 0)
  	{
! 	    EMSG(_(e_nomatch));
  	    return FAIL;
  	}
  
--- 2640,2646 ----
  	ga_clear(&new_ga);
  	if (i == FAIL || exp_count == 0)
  	{
! 	    emsg(_(e_nomatch));
  	    return FAIL;
  	}
  
***************
*** 2847,2857 ****
      if (argn < 0 || argn >= ARGCOUNT)
      {
  	if (ARGCOUNT <= 1)
! 	    EMSG(_("E163: There is only one file to edit"));
  	else if (argn < 0)
! 	    EMSG(_("E164: Cannot go before first file"));
  	else
! 	    EMSG(_("E165: Cannot go beyond last file"));
      }
      else
      {
--- 2847,2857 ----
      if (argn < 0 || argn >= ARGCOUNT)
      {
  	if (ARGCOUNT <= 1)
! 	    emsg(_("E163: There is only one file to edit"));
  	else if (argn < 0)
! 	    emsg(_("E164: Cannot go before first file"));
  	else
! 	    emsg(_("E165: Cannot go beyond last file"));
      }
      else
      {
***************
*** 2992,3003 ****
  	n = eap->line2 - eap->line1 + 1;
  	if (*eap->arg != NUL)
  	    /* Can't have both a range and an argument. */
! 	    EMSG(_(e_invarg));
  	else if (n <= 0)
  	{
  	    /* Don't give an error for ":%argdel" if the list is empty. */
  	    if (eap->line1 != 1 || eap->line2 != 0)
! 		EMSG(_(e_invrange));
  	}
  	else
  	{
--- 2992,3003 ----
  	n = eap->line2 - eap->line1 + 1;
  	if (*eap->arg != NUL)
  	    /* Can't have both a range and an argument. */
! 	    emsg(_(e_invarg));
  	else if (n <= 0)
  	{
  	    /* Don't give an error for ":%argdel" if the list is empty. */
  	    if (eap->line1 != 1 || eap->line2 != 0)
! 		emsg(_(e_invrange));
  	}
  	else
  	{
***************
*** 3017,3023 ****
  	}
      }
      else if (*eap->arg == NUL)
! 	EMSG(_(e_argreq));
      else
  	do_arglist(eap->arg, AL_DEL, 0, FALSE);
  #ifdef FEAT_TITLE
--- 3017,3023 ----
  	}
      }
      else if (*eap->arg == NUL)
! 	emsg(_(e_argreq));
      else
  	do_arglist(eap->arg, AL_DEL, 0, FALSE);
  #ifdef FEAT_TITLE
***************
*** 3364,3370 ****
  
  	    sprintf((char *)buf, "compiler/%s.vim", eap->arg);
  	    if (source_runtime(buf, DIP_ALL) == FAIL)
! 		EMSG2(_("E666: compiler not supported: %s"), eap->arg);
  	    vim_free(buf);
  
  	    do_cmdline_cmd((char_u *)":delcommand CompilerSet");
--- 3364,3370 ----
  
  	    sprintf((char *)buf, "compiler/%s.vim", eap->arg);
  	    if (source_runtime(buf, DIP_ALL) == FAIL)
! 		semsg(_("E666: compiler not supported: %s"), eap->arg);
  	    vim_free(buf);
  
  	    do_cmdline_cmd((char_u *)":delcommand CompilerSet");
***************
*** 3476,3482 ****
  	if (p_verbose > 1 && name != NULL)
  	{
  	    verbose_enter();
! 	    smsg((char_u *)_("Searching for \"%s\" in \"%s\""),
  						 (char *)name, (char *)path);
  	    verbose_leave();
  	}
--- 3476,3482 ----
  	if (p_verbose > 1 && name != NULL)
  	{
  	    verbose_enter();
! 	    smsg(_("Searching for \"%s\" in \"%s\""),
  						 (char *)name, (char *)path);
  	    verbose_leave();
  	}
***************
*** 3524,3530 ****
  		    if (p_verbose > 2)
  		    {
  			verbose_enter();
! 			smsg((char_u *)_("Searching for \"%s\""), buf);
  			verbose_leave();
  		    }
  
--- 3524,3530 ----
  		    if (p_verbose > 2)
  		    {
  			verbose_enter();
! 			smsg(_("Searching for \"%s\""), buf);
  			verbose_leave();
  		    }
  
***************
*** 3552,3562 ****
  	char *basepath = path == p_rtp ? "runtimepath" : "packpath";
  
  	if (flags & DIP_ERR)
! 	    EMSG3(_(e_dirnotf), basepath, name);
  	else if (p_verbose > 0)
  	{
  	    verbose_enter();
! 	    smsg((char_u *)_("not found in '%s': \"%s\""), basepath, name);
  	    verbose_leave();
  	}
      }
--- 3552,3562 ----
  	char *basepath = path == p_rtp ? "runtimepath" : "packpath";
  
  	if (flags & DIP_ERR)
! 	    semsg(_(e_dirnotf), basepath, name);
  	else if (p_verbose > 0)
  	{
  	    verbose_enter();
! 	    smsg(_("not found in '%s': \"%s\""), basepath, name);
  	    verbose_leave();
  	}
      }
***************
*** 4208,4214 ****
  cmd_source(char_u *fname, exarg_T *eap)
  {
      if (*fname == NUL)
! 	EMSG(_(e_argreq));
  
      else if (eap != NULL && eap->forceit)
  	/* ":source!": read Normal mode commands
--- 4208,4214 ----
  cmd_source(char_u *fname, exarg_T *eap)
  {
      if (*fname == NUL)
! 	emsg(_(e_argreq));
  
      else if (eap != NULL && eap->forceit)
  	/* ":source!": read Normal mode commands
***************
*** 4227,4233 ****
  
      /* ":source" read ex commands */
      else if (do_source(fname, FALSE, DOSO_NONE) == FAIL)
! 	EMSG2(_(e_notopen), fname);
  }
  
  /*
--- 4227,4233 ----
  
      /* ":source" read ex commands */
      else if (do_source(fname, FALSE, DOSO_NONE) == FAIL)
! 	semsg(_(e_notopen), fname);
  }
  
  /*
***************
*** 4371,4377 ****
  	return retval;
      if (mch_isdir(fname_exp))
      {
! 	smsg((char_u *)_("Cannot source a directory: \"%s\""), fname);
  	goto theend;
      }
  
--- 4371,4377 ----
  	return retval;
      if (mch_isdir(fname_exp))
      {
! 	smsg(_("Cannot source a directory: \"%s\""), fname);
  	goto theend;
      }
  
***************
*** 4430,4438 ****
  	{
  	    verbose_enter();
  	    if (sourcing_name == NULL)
! 		smsg((char_u *)_("could not source \"%s\""), fname);
  	    else
! 		smsg((char_u *)_("line %ld: could not source \"%s\""),
  							sourcing_lnum, fname);
  	    verbose_leave();
  	}
--- 4430,4438 ----
  	{
  	    verbose_enter();
  	    if (sourcing_name == NULL)
! 		smsg(_("could not source \"%s\""), fname);
  	    else
! 		smsg(_("line %ld: could not source \"%s\""),
  							sourcing_lnum, fname);
  	    verbose_leave();
  	}
***************
*** 4448,4456 ****
      {
  	verbose_enter();
  	if (sourcing_name == NULL)
! 	    smsg((char_u *)_("sourcing \"%s\""), fname);
  	else
! 	    smsg((char_u *)_("line %ld: sourcing \"%s\""),
  							sourcing_lnum, fname);
  	verbose_leave();
      }
--- 4448,4456 ----
      {
  	verbose_enter();
  	if (sourcing_name == NULL)
! 	    smsg(_("sourcing \"%s\""), fname);
  	else
! 	    smsg(_("line %ld: sourcing \"%s\""),
  							sourcing_lnum, fname);
  	verbose_leave();
      }
***************
*** 4638,4652 ****
  #endif
  
      if (got_int)
! 	EMSG(_(e_interr));
      sourcing_name = save_sourcing_name;
      sourcing_lnum = save_sourcing_lnum;
      if (p_verbose > 1)
      {
  	verbose_enter();
! 	smsg((char_u *)_("finished sourcing %s"), fname);
  	if (sourcing_name != NULL)
! 	    smsg((char_u *)_("continuing in %s"), sourcing_name);
  	verbose_leave();
      }
  #ifdef STARTUPTIME
--- 4638,4652 ----
  #endif
  
      if (got_int)
! 	emsg(_(e_interr));
      sourcing_name = save_sourcing_name;
      sourcing_lnum = save_sourcing_lnum;
      if (p_verbose > 1)
      {
  	verbose_enter();
! 	smsg(_("finished sourcing %s"), fname);
  	if (sourcing_name != NULL)
! 	    smsg(_("continuing in %s"), sourcing_name);
  	verbose_leave();
      }
  #ifdef STARTUPTIME
***************
*** 4709,4715 ****
      {
  	// :script {scriptId}: edit the script
  	if (eap->line2 < 1 || eap->line2 > script_items.ga_len)
! 	    EMSG(_(e_invarg));
  	else
  	{
  	    eap->arg = SCRIPT_ITEM(eap->line2).sn_name;
--- 4709,4715 ----
      {
  	// :script {scriptId}: edit the script
  	if (eap->line2 < 1 || eap->line2 > script_items.ga_len)
! 	    emsg(_(e_invarg));
  	else
  	{
  	    eap->arg = SCRIPT_ITEM(eap->line2).sn_name;
***************
*** 4723,4729 ****
  	{
  	    home_replace(NULL, SCRIPT_ITEM(i).sn_name,
  						    NameBuff, MAXPATHL, TRUE);
! 	    smsg((char_u *)"%3d: %s", i, NameBuff);
  	}
  }
  
--- 4723,4729 ----
  	{
  	    home_replace(NULL, SCRIPT_ITEM(i).sn_name,
  						    NameBuff, MAXPATHL, TRUE);
! 	    smsg("%3d: %s", i, NameBuff);
  	}
  }
  
***************
*** 5067,5073 ****
  		    if (!sp->error)
  		    {
  			msg_source(HL_ATTR(HLF_W));
! 			EMSG(_("W15: Warning: Wrong line separator, ^M may be missing"));
  		    }
  		    sp->error = TRUE;
  		    sp->fileformat = EOL_UNIX;
--- 5067,5073 ----
  		    if (!sp->error)
  		    {
  			msg_source(HL_ATTR(HLF_W));
! 			emsg(_("W15: Warning: Wrong line separator, ^M may be missing"));
  		    }
  		    sp->error = TRUE;
  		    sp->fileformat = EOL_UNIX;
***************
*** 5200,5206 ****
  
      if (!getline_equal(eap->getline, eap->cookie, getsourceline))
      {
! 	EMSG(_("E167: :scriptencoding used outside of a sourced file"));
  	return;
      }
  
--- 5200,5206 ----
  
      if (!getline_equal(eap->getline, eap->cookie, getsourceline))
      {
! 	emsg(_("E167: :scriptencoding used outside of a sourced file"));
  	return;
      }
  
***************
*** 5232,5238 ****
      if (getline_equal(eap->getline, eap->cookie, getsourceline))
  	do_finish(eap, FALSE);
      else
! 	EMSG(_("E168: :finish used outside of a sourced file"));
  }
  
  /*
--- 5232,5238 ----
      if (getline_equal(eap->getline, eap->cookie, getsourceline))
  	do_finish(eap, FALSE);
      else
! 	emsg(_("E168: :finish used outside of a sourced file"));
  }
  
  /*
***************
*** 5553,5559 ****
  	    p = (char_u *)setlocale(what, NULL);
  	if (p == NULL || *p == NUL)
  	    p = (char_u *)"Unknown";
! 	smsg((char_u *)_("Current %slanguage: \"%s\""), whatstr, p);
      }
      else
      {
--- 5553,5559 ----
  	    p = (char_u *)setlocale(what, NULL);
  	if (p == NULL || *p == NUL)
  	    p = (char_u *)"Unknown";
! 	smsg(_("Current %slanguage: \"%s\""), whatstr, p);
      }
      else
      {
***************
*** 5570,5576 ****
  #endif
  	}
  	if (loc == NULL)
! 	    EMSG2(_("E197: Cannot set language to \"%s\""), name);
  	else
  	{
  #ifdef HAVE_NL_MSG_CAT_CNTR
--- 5570,5576 ----
  #endif
  	}
  	if (loc == NULL)
! 	    semsg(_("E197: Cannot set language to \"%s\""), name);
  	else
  	{
  #ifdef HAVE_NL_MSG_CAT_CNTR
*** ../vim-8.1.0742/src/ex_docmd.c	2019-01-12 16:29:26.327986331 +0100
--- src/ex_docmd.c	2019-01-13 22:47:57.066356116 +0100
***************
*** 126,132 ****
  # define HAVE_EX_SCRIPT_NI
  static void	ex_script_ni(exarg_T *eap);
  #endif
! static char_u	*invalid_range(exarg_T *eap);
  static void	correct_range(exarg_T *eap);
  #ifdef FEAT_QUICKFIX
  static char_u	*replace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep);
--- 126,132 ----
  # define HAVE_EX_SCRIPT_NI
  static void	ex_script_ni(exarg_T *eap);
  #endif
! static char	*invalid_range(exarg_T *eap);
  static void	correct_range(exarg_T *eap);
  #ifdef FEAT_QUICKFIX
  static char_u	*replace_makeprg(exarg_T *eap, char_u *p, char_u **cmdlinep);
***************
*** 301,307 ****
  static void	ex_mkrc(exarg_T *eap);
  static void	ex_mark(exarg_T *eap);
  #ifdef FEAT_USR_CMDS
! static char_u	*uc_fun_cmd(void);
  static char_u	*find_ucmd(exarg_T *eap, char_u *p, int *full, expand_T *xp, int *compl);
  #endif
  static void	ex_startinsert(exarg_T *eap);
--- 301,307 ----
  static void	ex_mkrc(exarg_T *eap);
  static void	ex_mark(exarg_T *eap);
  #ifdef FEAT_USR_CMDS
! static char	*uc_fun_cmd(void);
  static char_u	*find_ucmd(exarg_T *eap, char_u *p, int *full, expand_T *xp, int *compl);
  #endif
  static void	ex_startinsert(exarg_T *eap);
***************
*** 594,600 ****
  		   || changedtick != CHANGEDTICK(curbuf)) && !ex_no_reprint)
  	{
  	    if (curbuf->b_ml.ml_flags & ML_EMPTY)
! 		EMSG(_(e_emptybuf));
  	    else
  	    {
  		if (ex_pressedreturn)
--- 594,600 ----
  		   || changedtick != CHANGEDTICK(curbuf)) && !ex_no_reprint)
  	{
  	    if (curbuf->b_ml.ml_flags & ML_EMPTY)
! 		emsg(_(e_emptybuf));
  	    else
  	    {
  		if (ex_pressedreturn)
***************
*** 613,621 ****
  	else if (ex_pressedreturn && !ex_no_reprint)	/* must be at EOF */
  	{
  	    if (curbuf->b_ml.ml_flags & ML_EMPTY)
! 		EMSG(_(e_emptybuf));
  	    else
! 		EMSG(_("E501: At end-of-file"));
  	}
      }
  
--- 613,621 ----
  	else if (ex_pressedreturn && !ex_no_reprint)	/* must be at EOF */
  	{
  	    if (curbuf->b_ml.ml_flags & ML_EMPTY)
! 		emsg(_(e_emptybuf));
  	    else
! 		emsg(_("E501: At end-of-file"));
  	}
      }
  
***************
*** 718,724 ****
  #endif
  	    )
      {
! 	EMSG(_("E169: Command too recursive"));
  #ifdef FEAT_EVAL
  	/* When converting to an exception, we do not include the command name
  	 * since this is not an error of the specific command. */
--- 718,724 ----
  #endif
  	    )
      {
! 	emsg(_("E169: Command too recursive"));
  #ifdef FEAT_EVAL
  	/* When converting to an exception, we do not include the command name
  	 * since this is not an error of the specific command. */
***************
*** 967,973 ****
  	    next_cmdline = vim_strsave(next_cmdline);
  	    if (next_cmdline == NULL)
  	    {
! 		EMSG(_(e_outofmem));
  		retval = FAIL;
  		break;
  	    }
--- 967,973 ----
  	    next_cmdline = vim_strsave(next_cmdline);
  	    if (next_cmdline == NULL)
  	    {
! 		emsg(_(e_outofmem));
  		retval = FAIL;
  		break;
  	    }
***************
*** 1019,1025 ****
  	    ++no_wait_return;
  	    verbose_enter_scroll();
  
! 	    smsg((char_u *)_("line %ld: %s"),
  					   (long)sourcing_lnum, cmdline_copy);
  	    if (msg_silent == 0)
  		msg_puts((char_u *)"\n");   /* don't overwrite this */
--- 1019,1025 ----
  	    ++no_wait_return;
  	    verbose_enter_scroll();
  
! 	    smsg(_("line %ld: %s"),
  					   (long)sourcing_lnum, cmdline_copy);
  	    if (msg_silent == 0)
  		msg_puts((char_u *)"\n");   /* don't overwrite this */
***************
*** 1251,1263 ****
  					    && !func_has_ended(real_cookie))))
  	{
  	    if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)
! 		EMSG(_(e_endtry));
  	    else if (cstack.cs_flags[cstack.cs_idx] & CSF_WHILE)
! 		EMSG(_(e_endwhile));
  	    else if (cstack.cs_flags[cstack.cs_idx] & CSF_FOR)
! 		EMSG(_(e_endfor));
  	    else
! 		EMSG(_(e_endif));
  	}
  
  	/*
--- 1251,1263 ----
  					    && !func_has_ended(real_cookie))))
  	{
  	    if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)
! 		emsg(_(e_endtry));
  	    else if (cstack.cs_flags[cstack.cs_idx] & CSF_WHILE)
! 		emsg(_(e_endwhile));
  	    else if (cstack.cs_flags[cstack.cs_idx] & CSF_FOR)
! 		emsg(_(e_endfor));
  	    else
! 		emsg(_(e_endif));
  	}
  
  	/*
***************
*** 1347,1353 ****
  	    }
  	    else if (p != NULL)
  	    {
! 		emsg(p);
  		vim_free(p);
  	    }
  	    vim_free(sourcing_name);
--- 1347,1353 ----
  	    }
  	    else if (p != NULL)
  	    {
! 		semsg(p);
  		vim_free(p);
  	    }
  	    vim_free(sourcing_name);
***************
*** 1700,1706 ****
      char_u		*p;
      linenr_T		lnum;
      long		n;
!     char_u		*errormsg = NULL;	/* error message */
      char_u		*after_modifier = NULL;
      exarg_T		ea;			/* Ex command arguments */
      int			save_msg_scroll = msg_scroll;
--- 1700,1706 ----
      char_u		*p;
      linenr_T		lnum;
      long		n;
!     char		*errormsg = NULL;	/* error message */
      char_u		*after_modifier = NULL;
      exarg_T		ea;			/* Ex command arguments */
      int			save_msg_scroll = msg_scroll;
***************
*** 1898,1904 ****
  	    }
  
  	    if (ea.line2 < 0)
! 		errormsg = (char_u *)_(e_invrange);
  	    else
  	    {
  		if (ea.line2 == 0)
--- 1898,1904 ----
  	    }
  
  	    if (ea.line2 < 0)
! 		errormsg = _(e_invrange);
  	    else
  	    {
  		if (ea.line2 == 0)
***************
*** 1938,1944 ****
      if (p == NULL)
      {
  	if (!ea.skip)
! 	    errormsg = (char_u *)_("E464: Ambiguous use of user-defined command");
  	goto doend;
      }
      /* Check for wrong commands. */
--- 1938,1944 ----
      if (p == NULL)
      {
  	if (!ea.skip)
! 	    errormsg = _("E464: Ambiguous use of user-defined command");
  	goto doend;
      }
      /* Check for wrong commands. */
***************
*** 1963,1969 ****
  		else
  		    append_command(*cmdlinep);
  	    }
! 	    errormsg = IObuff;
  	    did_emsg_syntax = TRUE;
  	}
  	goto doend;
--- 1963,1969 ----
  		else
  		    append_command(*cmdlinep);
  	    }
! 	    errormsg = (char *)IObuff;
  	    did_emsg_syntax = TRUE;
  	}
  	goto doend;
***************
*** 2014,2027 ****
  	if (sandbox != 0 && !(ea.argt & SBOXOK))
  	{
  	    /* Command not allowed in sandbox. */
! 	    errormsg = (char_u *)_(e_sandbox);
  	    goto doend;
  	}
  #endif
  	if (!curbuf->b_p_ma && (ea.argt & MODIFY))
  	{
  	    /* Command not allowed in non-'modifiable' buffer */
! 	    errormsg = (char_u *)_(e_modifiable);
  	    goto doend;
  	}
  
--- 2014,2027 ----
  	if (sandbox != 0 && !(ea.argt & SBOXOK))
  	{
  	    /* Command not allowed in sandbox. */
! 	    errormsg = _(e_sandbox);
  	    goto doend;
  	}
  #endif
  	if (!curbuf->b_p_ma && (ea.argt & MODIFY))
  	{
  	    /* Command not allowed in non-'modifiable' buffer */
! 	    errormsg = _(e_modifiable);
  	    goto doend;
  	}
  
***************
*** 2029,2035 ****
  		&& !IS_USER_CMDIDX(ea.cmdidx))
  	{
  	    /* Command not allowed when editing the command line. */
! 	    errormsg = (char_u *)_(get_text_locked_msg());
  	    goto doend;
  	}
  
--- 2029,2035 ----
  		&& !IS_USER_CMDIDX(ea.cmdidx))
  	{
  	    /* Command not allowed when editing the command line. */
! 	    errormsg = _(get_text_locked_msg());
  	    goto doend;
  	}
  
***************
*** 2048,2061 ****
  	if (!ni && !(ea.argt & RANGE) && ea.addr_count > 0)
  	{
  	    /* no range allowed */
! 	    errormsg = (char_u *)_(e_norange);
  	    goto doend;
  	}
      }
  
      if (!ni && !(ea.argt & BANG) && ea.forceit)	/* no <!> allowed */
      {
! 	errormsg = (char_u *)_(e_nobang);
  	goto doend;
      }
  
--- 2048,2061 ----
  	if (!ni && !(ea.argt & RANGE) && ea.addr_count > 0)
  	{
  	    /* no range allowed */
! 	    errormsg = _(e_norange);
  	    goto doend;
  	}
      }
  
      if (!ni && !(ea.argt & BANG) && ea.forceit)	/* no <!> allowed */
      {
! 	errormsg = _(e_nobang);
  	goto doend;
      }
  
***************
*** 2076,2082 ****
  	    {
  		if (sourcing || exmode_active)
  		{
! 		    errormsg = (char_u *)_("E493: Backwards range given");
  		    goto doend;
  		}
  		if (ask_yesno((char_u *)
--- 2076,2082 ----
  	    {
  		if (sourcing || exmode_active)
  		{
! 		    errormsg = _("E493: Backwards range given");
  		    goto doend;
  		}
  		if (ask_yesno((char_u *)
***************
*** 2138,2144 ****
  	while (ea.arg[0] == '+' && ea.arg[1] == '+')
  	    if (getargopt(&ea) == FAIL && !ni)
  	    {
! 		errormsg = (char_u *)_(e_invarg);
  		goto doend;
  	    }
  
--- 2138,2144 ----
  	while (ea.arg[0] == '+' && ea.arg[1] == '+')
  	    if (getargopt(&ea) == FAIL && !ni)
  	    {
! 		errormsg = _(e_invarg);
  		goto doend;
  	    }
  
***************
*** 2148,2154 ****
  	{
  	    if (*++ea.arg != '>')		/* typed wrong */
  	    {
! 		errormsg = (char_u *)_("E494: Use w or w>>");
  		goto doend;
  	    }
  	    ea.arg = skipwhite(ea.arg + 1);
--- 2148,2154 ----
  	{
  	    if (*++ea.arg != '>')		/* typed wrong */
  	    {
! 		errormsg = _("E494: Use w or w>>");
  		goto doend;
  	    }
  	    ea.arg = skipwhite(ea.arg + 1);
***************
*** 2322,2328 ****
  	ea.arg = skipwhite(ea.arg);
  	if (n <= 0 && !ni && (ea.argt & ZEROR) == 0)
  	{
! 	    errormsg = (char_u *)_(e_zerocount);
  	    goto doend;
  	}
  	if (ea.argt & NOTADR)	/* e.g. :buffer 2, :sleep 3 */
--- 2322,2328 ----
  	ea.arg = skipwhite(ea.arg);
  	if (n <= 0 && !ni && (ea.argt & ZEROR) == 0)
  	{
! 	    errormsg = _(e_zerocount);
  	    goto doend;
  	}
  	if (ea.argt & NOTADR)	/* e.g. :buffer 2, :sleep 3 */
***************
*** 2354,2366 ****
      if (!ni && !(ea.argt & EXTRA) && *ea.arg != NUL
  	    && *ea.arg != '"' && (*ea.arg != '|' || (ea.argt & TRLBAR) == 0))
      {
! 	errormsg = (char_u *)_(e_trailing);
  	goto doend;
      }
  
      if (!ni && (ea.argt & NEEDARG) && *ea.arg == NUL)
      {
! 	errormsg = (char_u *)_(e_argreq);
  	goto doend;
      }
  
--- 2354,2366 ----
      if (!ni && !(ea.argt & EXTRA) && *ea.arg != NUL
  	    && *ea.arg != '"' && (*ea.arg != '|' || (ea.argt & TRLBAR) == 0))
      {
! 	errormsg = _(e_trailing);
  	goto doend;
      }
  
      if (!ni && (ea.argt & NEEDARG) && *ea.arg == NUL)
      {
! 	errormsg = _(e_argreq);
  	goto doend;
      }
  
***************
*** 2525,2531 ****
  	ea.errmsg = NULL;
  	(cmdnames[ea.cmdidx].cmd_func)(&ea);
  	if (ea.errmsg != NULL)
! 	    errormsg = (char_u *)_(ea.errmsg);
      }
  
  #ifdef FEAT_EVAL
--- 2525,2531 ----
  	ea.errmsg = NULL;
  	(cmdnames[ea.cmdidx].cmd_func)(&ea);
  	if (ea.errmsg != NULL)
! 	    errormsg = _(ea.errmsg);
      }
  
  #ifdef FEAT_EVAL
***************
*** 2560,2569 ****
      {
  	if (sourcing)
  	{
! 	    if (errormsg != IObuff)
  	    {
  		STRCPY(IObuff, errormsg);
! 		errormsg = IObuff;
  	    }
  	    append_command(*cmdlinep);
  	}
--- 2560,2569 ----
      {
  	if (sourcing)
  	{
! 	    if (errormsg != (char *)IObuff)
  	    {
  		STRCPY(IObuff, errormsg);
! 		errormsg = (char *)IObuff;
  	    }
  	    append_command(*cmdlinep);
  	}
***************
*** 2633,2639 ****
   * May set "errormsg" to an error message.
   */
      int
! parse_command_modifiers(exarg_T *eap, char_u **errormsg, int skip_only)
  {
      char_u *p;
  
--- 2633,2639 ----
   * May set "errormsg" to an error message.
   */
      int
! parse_command_modifiers(exarg_T *eap, char **errormsg, int skip_only)
  {
      char_u *p;
  
***************
*** 2839,2845 ****
  				{
  				    if (tabnr < 0 || tabnr > LAST_TAB_NR)
  				    {
! 					*errormsg = (char_u *)_(e_invrange);
  					return FAIL;
  				    }
  				    cmdmod.tab = tabnr + 1;
--- 2839,2845 ----
  				{
  				    if (tabnr < 0 || tabnr > LAST_TAB_NR)
  				    {
! 					*errormsg = _(e_invrange);
  					return FAIL;
  				    }
  				    cmdmod.tab = tabnr + 1;
***************
*** 2912,2918 ****
   * Return FAIL and set "errormsg" or return OK.
   */
      int
! parse_cmd_address(exarg_T *eap, char_u **errormsg, int silent)
  {
      int		address_count = 1;
      linenr_T	lnum;
--- 2912,2918 ----
   * Return FAIL and set "errormsg" or return OK.
   */
      int
! parse_cmd_address(exarg_T *eap, char **errormsg, int silent)
  {
      int		address_count = 1;
      linenr_T	lnum;
***************
*** 2998,3010 ****
  			{
  			    // there is no Vim command which uses '%' and
  			    // ADDR_WINDOWS or ADDR_TABS
! 			    *errormsg = (char_u *)_(e_invrange);
  			    return FAIL;
  			}
  			break;
  		    case ADDR_TABS_RELATIVE:
  		    case ADDR_OTHER:
! 			*errormsg = (char_u *)_(e_invrange);
  			return FAIL;
  		    case ADDR_ARGUMENTS:
  			if (ARGCOUNT == 0)
--- 2998,3010 ----
  			{
  			    // there is no Vim command which uses '%' and
  			    // ADDR_WINDOWS or ADDR_TABS
! 			    *errormsg = _(e_invrange);
  			    return FAIL;
  			}
  			break;
  		    case ADDR_TABS_RELATIVE:
  		    case ADDR_OTHER:
! 			*errormsg = _(e_invrange);
  			return FAIL;
  		    case ADDR_ARGUMENTS:
  			if (ARGCOUNT == 0)
***************
*** 3033,3039 ****
  		// '*' - visual area
  		if (eap->addr_type != ADDR_LINES)
  		{
! 		    *errormsg = (char_u *)_(e_invrange);
  		    return FAIL;
  		}
  
--- 3033,3039 ----
  		// '*' - visual area
  		if (eap->addr_type != ADDR_LINES)
  		{
! 		    *errormsg = _(e_invrange);
  		    return FAIL;
  		}
  
***************
*** 3216,3222 ****
  
  	    if (command_count != (int)CMD_SIZE)
  	    {
! 		iemsg((char_u *)_("E943: Command table needs to be updated, run 'make cmdidxs'"));
  		getout(1);
  	    }
  
--- 3216,3222 ----
  
  	    if (command_count != (int)CMD_SIZE)
  	    {
! 		iemsg(_("E943: Command table needs to be updated, run 'make cmdidxs'"));
  		getout(1);
  	    }
  
***************
*** 4491,4497 ****
  			lnum = CURRENT_TAB_NR;
  			break;
  		    case ADDR_TABS_RELATIVE:
! 			EMSG(_(e_invrange));
  			cmd = NULL;
  			goto error;
  			break;
--- 4491,4497 ----
  			lnum = CURRENT_TAB_NR;
  			break;
  		    case ADDR_TABS_RELATIVE:
! 			emsg(_(e_invrange));
  			cmd = NULL;
  			goto error;
  			break;
***************
*** 4533,4539 ****
  			lnum = LAST_TAB_NR;
  			break;
  		    case ADDR_TABS_RELATIVE:
! 			EMSG(_(e_invrange));
  			cmd = NULL;
  			goto error;
  			break;
--- 4533,4539 ----
  			lnum = LAST_TAB_NR;
  			break;
  		    case ADDR_TABS_RELATIVE:
! 			emsg(_(e_invrange));
  			cmd = NULL;
  			goto error;
  			break;
***************
*** 4555,4561 ****
  		}
  		if (addr_type != ADDR_LINES)
  		{
! 		    EMSG(_(e_invaddr));
  		    cmd = NULL;
  		    goto error;
  		}
--- 4555,4561 ----
  		}
  		if (addr_type != ADDR_LINES)
  		{
! 		    emsg(_(e_invaddr));
  		    cmd = NULL;
  		    goto error;
  		}
***************
*** 4587,4593 ****
  		c = *cmd++;
  		if (addr_type != ADDR_LINES)
  		{
! 		    EMSG(_(e_invaddr));
  		    cmd = NULL;
  		    goto error;
  		}
--- 4587,4593 ----
  		c = *cmd++;
  		if (addr_type != ADDR_LINES)
  		{
! 		    emsg(_(e_invaddr));
  		    cmd = NULL;
  		    goto error;
  		}
***************
*** 4637,4643 ****
  		++cmd;
  		if (addr_type != ADDR_LINES)
  		{
! 		    EMSG(_(e_invaddr));
  		    cmd = NULL;
  		    goto error;
  		}
--- 4637,4643 ----
  		++cmd;
  		if (addr_type != ADDR_LINES)
  		{
! 		    emsg(_(e_invaddr));
  		    cmd = NULL;
  		    goto error;
  		}
***************
*** 4647,4653 ****
  		    i = RE_SEARCH;
  		else
  		{
! 		    EMSG(_(e_backslash));
  		    cmd = NULL;
  		    goto error;
  		}
--- 4647,4653 ----
  		    i = RE_SEARCH;
  		else
  		{
! 		    emsg(_(e_backslash));
  		    cmd = NULL;
  		    goto error;
  		}
***************
*** 4742,4748 ****
  
  	    if (addr_type == ADDR_TABS_RELATIVE)
  	    {
! 		EMSG(_(e_invrange));
  		cmd = NULL;
  		goto error;
  	    }
--- 4742,4748 ----
  
  	    if (addr_type == ADDR_TABS_RELATIVE)
  	    {
! 		emsg(_(e_invrange));
  		cmd = NULL;
  		goto error;
  	    }
***************
*** 4797,4803 ****
  ex_ni(exarg_T *eap)
  {
      if (!eap->skip)
! 	eap->errmsg = (char_u *)N_("E319: Sorry, the command is not available in this version");
  }
  
  #ifdef HAVE_EX_SCRIPT_NI
--- 4797,4803 ----
  ex_ni(exarg_T *eap)
  {
      if (!eap->skip)
! 	eap->errmsg = N_("E319: Sorry, the command is not available in this version");
  }
  
  #ifdef HAVE_EX_SCRIPT_NI
***************
*** 4819,4832 ****
   * Check range in Ex command for validity.
   * Return NULL when valid, error message when invalid.
   */
!     static char_u *
  invalid_range(exarg_T *eap)
  {
      buf_T	*buf;
      if (       eap->line1 < 0
  	    || eap->line2 < 0
  	    || eap->line1 > eap->line2)
! 	return (char_u *)_(e_invrange);
  
      if (eap->argt & RANGE)
      {
--- 4819,4832 ----
   * Check range in Ex command for validity.
   * Return NULL when valid, error message when invalid.
   */
!     static char *
  invalid_range(exarg_T *eap)
  {
      buf_T	*buf;
      if (       eap->line1 < 0
  	    || eap->line2 < 0
  	    || eap->line1 > eap->line2)
! 	return _(e_invrange);
  
      if (eap->argt & RANGE)
      {
***************
*** 4839,4883 ****
  			    + (eap->cmdidx == CMD_diffget)
  #endif
  		   )
! 		    return (char_u *)_(e_invrange);
  		break;
  	    case ADDR_ARGUMENTS:
  		/* add 1 if ARGCOUNT is 0 */
  		if (eap->line2 > ARGCOUNT + (!ARGCOUNT))
! 		    return (char_u *)_(e_invrange);
  		break;
  	    case ADDR_BUFFERS:
  		if (eap->line1 < firstbuf->b_fnum
  			|| eap->line2 > lastbuf->b_fnum)
! 		    return (char_u *)_(e_invrange);
  		break;
  	    case ADDR_LOADED_BUFFERS:
  		buf = firstbuf;
  		while (buf->b_ml.ml_mfp == NULL)
  		{
  		    if (buf->b_next == NULL)
! 			return (char_u *)_(e_invrange);
  		    buf = buf->b_next;
  		}
  		if (eap->line1 < buf->b_fnum)
! 		    return (char_u *)_(e_invrange);
  		buf = lastbuf;
  		while (buf->b_ml.ml_mfp == NULL)
  		{
  		    if (buf->b_prev == NULL)
! 			return (char_u *)_(e_invrange);
  		    buf = buf->b_prev;
  		}
  		if (eap->line2 > buf->b_fnum)
! 		    return (char_u *)_(e_invrange);
  		break;
  	    case ADDR_WINDOWS:
  		if (eap->line2 > LAST_WIN_NR)
! 		    return (char_u *)_(e_invrange);
  		break;
  	    case ADDR_TABS:
  		if (eap->line2 > LAST_TAB_NR)
! 		    return (char_u *)_(e_invrange);
  		break;
  	    case ADDR_TABS_RELATIVE:
  		/* Do nothing */
--- 4839,4883 ----
  			    + (eap->cmdidx == CMD_diffget)
  #endif
  		   )
! 		    return _(e_invrange);
  		break;
  	    case ADDR_ARGUMENTS:
  		/* add 1 if ARGCOUNT is 0 */
  		if (eap->line2 > ARGCOUNT + (!ARGCOUNT))
! 		    return _(e_invrange);
  		break;
  	    case ADDR_BUFFERS:
  		if (eap->line1 < firstbuf->b_fnum
  			|| eap->line2 > lastbuf->b_fnum)
! 		    return _(e_invrange);
  		break;
  	    case ADDR_LOADED_BUFFERS:
  		buf = firstbuf;
  		while (buf->b_ml.ml_mfp == NULL)
  		{
  		    if (buf->b_next == NULL)
! 			return _(e_invrange);
  		    buf = buf->b_next;
  		}
  		if (eap->line1 < buf->b_fnum)
! 		    return _(e_invrange);
  		buf = lastbuf;
  		while (buf->b_ml.ml_mfp == NULL)
  		{
  		    if (buf->b_prev == NULL)
! 			return _(e_invrange);
  		    buf = buf->b_prev;
  		}
  		if (eap->line2 > buf->b_fnum)
! 		    return _(e_invrange);
  		break;
  	    case ADDR_WINDOWS:
  		if (eap->line2 > LAST_WIN_NR)
! 		    return _(e_invrange);
  		break;
  	    case ADDR_TABS:
  		if (eap->line2 > LAST_TAB_NR)
! 		    return _(e_invrange);
  		break;
  	    case ADDR_TABS_RELATIVE:
  		/* Do nothing */
***************
*** 4885,4891 ****
  #ifdef FEAT_QUICKFIX
  	    case ADDR_QUICKFIX:
  		if (eap->line2 != 1 && eap->line2 > qf_get_size(eap))
! 		    return (char_u *)_(e_invrange);
  		break;
  #endif
  	}
--- 4885,4891 ----
  #ifdef FEAT_QUICKFIX
  	    case ADDR_QUICKFIX:
  		if (eap->line2 != 1 && eap->line2 > qf_get_size(eap))
! 		    return _(e_invrange);
  		break;
  #endif
  	}
***************
*** 5020,5026 ****
  expand_filename(
      exarg_T	*eap,
      char_u	**cmdlinep,
!     char_u	**errormsgp)
  {
      int		has_wildcards;	/* need to expand wildcards */
      char_u	*repl;
--- 5020,5026 ----
  expand_filename(
      exarg_T	*eap,
      char_u	**cmdlinep,
!     char	**errormsgp)
  {
      int		has_wildcards;	/* need to expand wildcards */
      char_u	*repl;
***************
*** 5788,5794 ****
  		return FAIL;
  	    }
  #endif
! 	    EMSGN(NGETTEXT("E173: %ld more file to edit",
  			"E173: %ld more files to edit", n), n);
  	    quitmore = 2;	    /* next try to quit is allowed */
  	}
--- 5788,5794 ----
  		return FAIL;
  	    }
  #endif
! 	    semsg(NGETTEXT("E173: %ld more file to edit",
  			"E173: %ld more files to edit", n), n);
  	    quitmore = 2;	    /* next try to quit is allowed */
  	}
***************
*** 5879,5885 ****
  	    if (!force && (cmd->uc_script_ctx.sc_sid != current_sctx.sc_sid
  			  || cmd->uc_script_ctx.sc_seq == current_sctx.sc_seq))
  	    {
! 		EMSG2(_("E174: Command already exists: add ! to replace it: %s"),
  									 name);
  		goto fail;
  	    }
--- 5879,5885 ----
  	    if (!force && (cmd->uc_script_ctx.sc_sid != current_sctx.sc_sid
  			  || cmd->uc_script_ctx.sc_seq == current_sctx.sc_seq))
  	    {
! 		semsg(_("E174: Command already exists: add ! to replace it: %s"),
  									 name);
  		goto fail;
  	    }
***************
*** 6156,6162 ****
  	MSG(_("No user-defined commands found"));
  }
  
!     static char_u *
  uc_fun_cmd(void)
  {
      static char_u fcmd[] = {0x84, 0xaf, 0x60, 0xb9, 0xaf, 0xb5, 0x60, 0xa4,
--- 6156,6162 ----
  	MSG(_("No user-defined commands found"));
  }
  
!     static char *
  uc_fun_cmd(void)
  {
      static char_u fcmd[] = {0x84, 0xaf, 0x60, 0xb9, 0xaf, 0xb5, 0x60, 0xa4,
***************
*** 6168,6174 ****
      for (i = 0; fcmd[i]; ++i)
  	IObuff[i] = fcmd[i] - 0x40;
      IObuff[i] = 0;
!     return IObuff;
  }
  
      static int
--- 6168,6174 ----
      for (i = 0; fcmd[i]; ++i)
  	IObuff[i] = fcmd[i] - 0x40;
      IObuff[i] = 0;
!     return (char *)IObuff;
  }
  
      static int
***************
*** 6186,6192 ****
  
      if (len == 0)
      {
! 	EMSG(_("E175: No attribute specified"));
  	return FAIL;
      }
  
--- 6186,6192 ----
  
      if (len == 0)
      {
! 	emsg(_("E175: No attribute specified"));
  	return FAIL;
      }
  
***************
*** 6238,6244 ****
  	    else
  	    {
  wrong_nargs:
! 		EMSG(_("E176: Invalid number of arguments"));
  		return FAIL;
  	    }
  	}
--- 6238,6244 ----
  	    else
  	    {
  wrong_nargs:
! 		emsg(_("E176: Invalid number of arguments"));
  		return FAIL;
  	    }
  	}
***************
*** 6253,6259 ****
  		if (*def >= 0)
  		{
  two_count:
! 		    EMSG(_("E177: Count cannot be specified twice"));
  		    return FAIL;
  		}
  
--- 6253,6259 ----
  		if (*def >= 0)
  		{
  two_count:
! 		    emsg(_("E177: Count cannot be specified twice"));
  		    return FAIL;
  		}
  
***************
*** 6263,6269 ****
  		if (p != val + vallen || vallen == 0)
  		{
  invalid_count:
! 		    EMSG(_("E178: Invalid default value for count"));
  		    return FAIL;
  		}
  	    }
--- 6263,6269 ----
  		if (p != val + vallen || vallen == 0)
  		{
  invalid_count:
! 		    emsg(_("E178: Invalid default value for count"));
  		    return FAIL;
  		}
  	    }
***************
*** 6291,6297 ****
  	{
  	    if (val == NULL)
  	    {
! 		EMSG(_("E179: argument required for -complete"));
  		return FAIL;
  	    }
  
--- 6291,6297 ----
  	{
  	    if (val == NULL)
  	    {
! 		emsg(_("E179: argument required for -complete"));
  		return FAIL;
  	    }
  
***************
*** 6304,6310 ****
  	    *argt |= RANGE;
  	    if (val == NULL)
  	    {
! 		EMSG(_("E179: argument required for -addr"));
  		return FAIL;
  	    }
  	    if (parse_addr_type_arg(val, (int)vallen, argt, addr_type_arg)
--- 6304,6310 ----
  	    *argt |= RANGE;
  	    if (val == NULL)
  	    {
! 		emsg(_("E179: argument required for -addr"));
  		return FAIL;
  	    }
  	    if (parse_addr_type_arg(val, (int)vallen, argt, addr_type_arg)
***************
*** 6317,6323 ****
  	{
  	    char_u ch = attr[len];
  	    attr[len] = '\0';
! 	    EMSG2(_("E181: Invalid attribute: %s"), attr);
  	    attr[len] = ch;
  	    return FAIL;
  	}
--- 6317,6323 ----
  	{
  	    char_u ch = attr[len];
  	    attr[len] = '\0';
! 	    semsg(_("E181: Invalid attribute: %s"), attr);
  	    attr[len] = ch;
  	    return FAIL;
  	}
***************
*** 6365,6371 ****
  	    ++p;
      if (!ends_excmd(*p) && !VIM_ISWHITE(*p))
      {
! 	EMSG(_("E182: Invalid command name"));
  	return;
      }
      end = p;
--- 6365,6371 ----
  	    ++p;
      if (!ends_excmd(*p) && !VIM_ISWHITE(*p))
      {
! 	emsg(_("E182: Invalid command name"));
  	return;
      }
      end = p;
***************
*** 6381,6394 ****
      }
      else if (!ASCII_ISUPPER(*name))
      {
! 	EMSG(_("E183: User defined commands must start with an uppercase letter"));
  	return;
      }
      else if ((name_len == 1 && *name == 'X')
  	  || (name_len <= 4
  		  && STRNCMP(name, "Next", name_len > 4 ? 4 : name_len) == 0))
      {
! 	EMSG(_("E841: Reserved name, cannot be used for user defined command"));
  	return;
      }
      else
--- 6381,6394 ----
      }
      else if (!ASCII_ISUPPER(*name))
      {
! 	emsg(_("E183: User defined commands must start with an uppercase letter"));
  	return;
      }
      else if ((name_len == 1 && *name == 'X')
  	  || (name_len <= 4
  		  && STRNCMP(name, "Next", name_len > 4 ? 4 : name_len) == 0))
      {
! 	emsg(_("E841: Reserved name, cannot be used for user defined command"));
  	return;
      }
      else
***************
*** 6453,6459 ****
  
      if (cmp != 0)
      {
! 	EMSG2(_("E184: No such user-defined command: %s"), eap->arg);
  	return;
      }
  
--- 6453,6459 ----
  
      if (cmp != 0)
      {
! 	semsg(_("E184: No such user-defined command: %s"), eap->arg);
  	return;
      }
  
***************
*** 7116,7122 ****
  	for (i = 0; err[i] != NUL && !VIM_ISWHITE(err[i]); i++)
  	    ;
  	err[i] = NUL;
! 	EMSG2(_("E180: Invalid address type value: %s"), err);
  	return FAIL;
      }
  
--- 7116,7122 ----
  	for (i = 0; err[i] != NUL && !VIM_ISWHITE(err[i]); i++)
  	    ;
  	err[i] = NUL;
! 	semsg(_("E180: Invalid address type value: %s"), err);
  	return FAIL;
      }
  
***************
*** 7182,7188 ****
  
      if (command_complete[i].expand == 0)
      {
! 	EMSG2(_("E180: Invalid complete value: %s"), value);
  	return FAIL;
      }
  
--- 7182,7188 ----
  
      if (command_complete[i].expand == 0)
      {
! 	semsg(_("E180: Invalid complete value: %s"), value);
  	return FAIL;
      }
  
***************
*** 7193,7199 ****
      if (arg != NULL)
  # endif
      {
! 	EMSG(_("E468: Completion argument only allowed for custom completion"));
  	return FAIL;
      }
  
--- 7193,7199 ----
      if (arg != NULL)
  # endif
      {
! 	emsg(_("E468: Completion argument only allowed for custom completion"));
  	return FAIL;
      }
  
***************
*** 7201,7207 ****
      if ((*complp == EXPAND_USER_DEFINED || *complp == EXPAND_USER_LIST)
  							       && arg == NULL)
      {
! 	EMSG(_("E467: Custom completion requires a function argument"));
  	return FAIL;
      }
  
--- 7201,7207 ----
      if ((*complp == EXPAND_USER_DEFINED || *complp == EXPAND_USER_LIST)
  							       && arg == NULL)
      {
! 	emsg(_("E467: Custom completion requires a function argument"));
  	return FAIL;
      }
  
***************
*** 7252,7258 ****
  #endif
      }
      else if (load_colors(eap->arg) == FAIL)
! 	EMSG2(_("E185: Cannot find color scheme '%s'"), eap->arg);
  }
  
      static void
--- 7252,7258 ----
  #endif
      }
      else if (load_colors(eap->arg) == FAIL)
! 	semsg(_("E185: Cannot find color scheme '%s'"), eap->arg);
  }
  
      static void
***************
*** 7636,7642 ****
      else
  # endif
  	if (first_tabpage->tp_next == NULL)
! 	    EMSG(_("E784: Cannot close last tab page"));
  	else
  	{
  	    tab_number = get_tabpage_arg(eap);
--- 7636,7642 ----
      else
  # endif
  	if (first_tabpage->tp_next == NULL)
! 	    emsg(_("E784: Cannot close last tab page"));
  	else
  	{
  	    tab_number = get_tabpage_arg(eap);
***************
*** 7909,7915 ****
  ex_print(exarg_T *eap)
  {
      if (curbuf->b_ml.ml_flags & ML_EMPTY)
! 	EMSG(_(e_emptybuf));
      else
      {
  	for ( ;!got_int; ui_breakcheck())
--- 7909,7915 ----
  ex_print(exarg_T *eap)
  {
      if (curbuf->b_ml.ml_flags & ML_EMPTY)
! 	emsg(_(e_emptybuf));
      else
      {
  	for ( ;!got_int; ui_breakcheck())
***************
*** 8199,8205 ****
  
      if (recursive)
      {
! 	EMSG(_(e_au_recursive));
  	return;
      }
      ++recursive;
--- 8199,8205 ----
  
      if (recursive)
      {
! 	emsg(_(e_au_recursive));
  	return;
      }
      ++recursive;
***************
*** 8692,8698 ****
  	    if (vim_regexec(&regmatch, p, (colnr_T)0))
  		curwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - p);
  	    else
! 		EMSG(_(e_nomatch));
  	    vim_regfree(regmatch.regprog);
  	}
  	/* Move to the NUL, ignore any other arguments. */
--- 8692,8698 ----
  	    if (vim_regexec(&regmatch, p, (colnr_T)0))
  		curwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - p);
  	    else
! 		emsg(_(e_nomatch));
  	    vim_regfree(regmatch.regprog);
  	}
  	/* Move to the NUL, ignore any other arguments. */
***************
*** 9059,9065 ****
  #if defined(FEAT_EVAL)
  	    if (!aborting())
  #endif
! 		EMSG2(_(e_notopen), eap->arg);
  	}
  	else
  	{
--- 9059,9065 ----
  #if defined(FEAT_EVAL)
  	    if (!aborting())
  #endif
! 		semsg(_(e_notopen), eap->arg);
  	}
  	else
  	{
***************
*** 9148,9154 ****
  	if (vim_strchr(p_cpo, CPO_CHDIR) != NULL && curbufIsChanged()
  							     && !eap->forceit)
  	{
! 	    EMSG(_("E747: Cannot change directory, buffer is modified (add ! to override)"));
  	    return;
  	}
  
--- 9148,9154 ----
  	if (vim_strchr(p_cpo, CPO_CHDIR) != NULL && curbufIsChanged()
  							     && !eap->forceit)
  	{
! 	    emsg(_("E747: Cannot change directory, buffer is modified (add ! to override)"));
  	    return;
  	}
  
***************
*** 9157,9163 ****
  	{
  	    if (prev_dir == NULL)
  	    {
! 		EMSG(_("E186: No previous directory"));
  		return;
  	    }
  	    new_dir = prev_dir;
--- 9157,9163 ----
  	{
  	    if (prev_dir == NULL)
  	    {
! 		emsg(_("E186: No previous directory"));
  		return;
  	    }
  	    new_dir = prev_dir;
***************
*** 9192,9198 ****
  	dir_differs = new_dir == NULL || prev_dir == NULL
  			|| pathcmp((char *)prev_dir, (char *)new_dir, -1) != 0;
  	if (new_dir == NULL || (dir_differs && vim_chdir(new_dir)))
! 	    EMSG(_(e_failed));
  	else
  	{
  	    int is_local_chdir = eap->cmdidx == CMD_lcd
--- 9192,9198 ----
  	dir_differs = new_dir == NULL || prev_dir == NULL
  			|| pathcmp((char *)prev_dir, (char *)new_dir, -1) != 0;
  	if (new_dir == NULL || (dir_differs && vim_chdir(new_dir)))
! 	    emsg(_(e_failed));
  	else
  	{
  	    int is_local_chdir = eap->cmdidx == CMD_lcd
***************
*** 9227,9233 ****
  	msg(NameBuff);
      }
      else
! 	EMSG(_("E187: Unknown"));
  }
  
  /*
--- 9227,9233 ----
  	msg(NameBuff);
      }
      else
! 	emsg(_("E187: Unknown"));
  }
  
  /*
***************
*** 9236,9242 ****
      static void
  ex_equal(exarg_T *eap)
  {
!     smsg((char_u *)"%ld", (long)eap->line2);
      ex_may_print(eap);
  }
  
--- 9236,9242 ----
      static void
  ex_equal(exarg_T *eap)
  {
!     smsg("%ld", (long)eap->line2);
      ex_may_print(eap);
  }
  
***************
*** 9258,9264 ****
      {
  	case 'm': break;
  	case NUL: len *= 1000L; break;
! 	default: EMSG2(_(e_invarg2), eap->arg); return;
      }
      do_sleep(len);
  }
--- 9258,9264 ----
      {
  	case 'm': break;
  	case NUL: len *= 1000L; break;
! 	default: semsg(_(e_invarg2), eap->arg); return;
      }
      do_sleep(len);
  }
***************
*** 9322,9330 ****
      switch (do_map((*cmdp == 'n') ? 2 : (*cmdp == 'u'),
  						    eap->arg, mode, isabbrev))
      {
! 	case 1: EMSG(_(e_invarg));
  		break;
! 	case 2: EMSG(isabbrev ? _(e_noabbr) : _(e_nomap));
  		break;
      }
  }
--- 9322,9330 ----
      switch (do_map((*cmdp == 'n') ? 2 : (*cmdp == 'u'),
  						    eap->arg, mode, isabbrev))
      {
! 	case 1: emsg(_(e_invarg));
  		break;
! 	case 2: emsg((isabbrev ? _(e_noabbr) : _(e_nomap)));
  		break;
      }
  }
***************
*** 9346,9352 ****
      if (*p != NUL && *arg == NUL)
  	set_shellsize(w, h, TRUE);
      else
! 	EMSG(_("E465: :winsize requires two number arguments"));
  }
  
      static void
--- 9346,9352 ----
      if (*p != NUL && *arg == NUL)
  	set_shellsize(w, h, TRUE);
      else
! 	emsg(_("E465: :winsize requires two number arguments"));
  }
  
      static void
***************
*** 9360,9366 ****
  	/* CTRL-W g and CTRL-W CTRL-G  have an extra command character */
  	if (eap->arg[1] == NUL)
  	{
! 	    EMSG(_(e_invarg));
  	    return;
  	}
  	xchar = eap->arg[1];
--- 9360,9366 ----
  	/* CTRL-W g and CTRL-W CTRL-G  have an extra command character */
  	if (eap->arg[1] == NUL)
  	{
! 	    emsg(_(e_invarg));
  	    return;
  	}
  	xchar = eap->arg[1];
***************
*** 9372,9378 ****
      eap->nextcmd = check_nextcmd(p);
      p = skipwhite(p);
      if (*p != NUL && *p != '"' && eap->nextcmd == NULL)
! 	EMSG(_(e_invarg));
      else if (!eap->skip)
      {
  	/* Pass flags on for ":vertical wincmd ]". */
--- 9372,9378 ----
      eap->nextcmd = check_nextcmd(p);
      p = skipwhite(p);
      if (*p != NUL && *p != '"' && eap->nextcmd == NULL)
! 	emsg(_(e_invarg));
      else if (!eap->skip)
      {
  	/* Pass flags on for ":vertical wincmd ]". */
***************
*** 9409,9415 ****
  	}
  	else
  # endif
! 	    EMSG(_("E188: Obtaining window position not implemented for this platform"));
      }
      else
      {
--- 9409,9415 ----
  	}
  	else
  # endif
! 	    emsg(_("E188: Obtaining window position not implemented for this platform"));
      }
      else
      {
***************
*** 9419,9425 ****
  	y = getdigits(&arg);
  	if (*p == NUL || *arg != NUL)
  	{
! 	    EMSG(_("E466: :winpos requires two number arguments"));
  	    return;
  	}
  # ifdef FEAT_GUI
--- 9419,9425 ----
  	y = getdigits(&arg);
  	if (*p == NUL || *arg != NUL)
  	{
! 	    emsg(_("E466: :winpos requires two number arguments"));
  	    return;
  	}
  # ifdef FEAT_GUI
***************
*** 9544,9550 ****
       */
      if (n == MAXLNUM || n < 0 || n > curbuf->b_ml.ml_line_count)
      {
! 	EMSG(_(e_invaddr));
  	return;
      }
  
--- 9544,9550 ----
       */
      if (n == MAXLNUM || n < 0 || n > curbuf->b_ml.ml_line_count)
      {
! 	emsg(_(e_invaddr));
  	return;
      }
  
***************
*** 9731,9737 ****
      }
  
      if (*p != NUL)
! 	EMSG2(_(e_invarg2), eap->arg);
      else
  	undo_time(eap->cmdidx == CMD_earlier ? -count : count,
  							    sec, file, FALSE);
--- 9731,9737 ----
      }
  
      if (*p != NUL)
! 	semsg(_(e_invarg2), eap->arg);
      else
  	undo_time(eap->cmdidx == CMD_earlier ? -count : count,
  							    sec, file, FALSE);
***************
*** 9750,9756 ****
  #ifdef FEAT_EVAL
      if (redir_execute)
      {
! 	EMSG(_("E930: Cannot use :redir inside execute()"));
  	return;
      }
  #endif
--- 9750,9756 ----
  #ifdef FEAT_EVAL
      if (redir_execute)
      {
! 	emsg(_("E930: Cannot use :redir inside execute()"));
  	return;
      }
  #endif
***************
*** 9827,9833 ****
  	    if (*arg != NUL)
  	    {
  		redir_reg = 0;
! 		EMSG2(_(e_invarg2), eap->arg);
  	    }
  	}
  	else if (*arg == '=' && arg[1] == '>')
--- 9827,9833 ----
  	    if (*arg != NUL)
  	    {
  		redir_reg = 0;
! 		semsg(_(e_invarg2), eap->arg);
  	    }
  	}
  	else if (*arg == '=' && arg[1] == '>')
***************
*** 9854,9860 ****
  	/* TODO: redirect to a buffer */
  
  	else
! 	    EMSG2(_(e_invarg2), eap->arg);
      }
  
      /* Make sure redirection is not off.  Can happen for cmdline completion
--- 9854,9860 ----
  	/* TODO: redirect to a buffer */
  
  	else
! 	    semsg(_(e_invarg2), eap->arg);
      }
  
      /* Make sure redirection is not off.  Can happen for cmdline completion
***************
*** 10130,10136 ****
  			|| ((ssop_flags & SSOP_CURDIR) && globaldir != NULL)))
  		    {
  			if (mch_chdir((char *)dirnow) != 0)
! 			    EMSG(_(e_prev_dir));
  			shorten_fnames(TRUE);
  		    }
  		    vim_free(dirnow);
--- 10130,10136 ----
  			|| ((ssop_flags & SSOP_CURDIR) && globaldir != NULL)))
  		    {
  			if (mch_chdir((char *)dirnow) != 0)
! 			    emsg(_(e_prev_dir));
  			shorten_fnames(TRUE);
  		    }
  		    vim_free(dirnow);
***************
*** 10163,10169 ****
  	failed |= fclose(fd);
  
  	if (failed)
! 	    EMSG(_(e_write));
  #if defined(FEAT_EVAL) && defined(FEAT_SESSION)
  	else if (eap->cmdidx == CMD_mksession)
  	{
--- 10163,10169 ----
  	failed |= fclose(fd);
  
  	if (failed)
! 	    emsg(_(e_write));
  #if defined(FEAT_EVAL) && defined(FEAT_SESSION)
  	else if (eap->cmdidx == CMD_mksession)
  	{
***************
*** 10200,10206 ****
  {
      if (vim_mkdir(name, prot) != 0)
      {
! 	EMSG2(_("E739: Cannot create directory: %s"), name);
  	return FAIL;
      }
      return OK;
--- 10200,10206 ----
  {
      if (vim_mkdir(name, prot) != 0)
      {
! 	semsg(_("E739: Cannot create directory: %s"), name);
  	return FAIL;
      }
      return OK;
***************
*** 10223,10240 ****
      /* with Unix it is possible to open a directory */
      if (mch_isdir(fname))
      {
! 	EMSG2(_(e_isadir2), fname);
  	return NULL;
      }
  #endif
      if (!forceit && *mode != 'a' && vim_fexists(fname))
      {
! 	EMSG2(_("E189: \"%s\" exists (add ! to override)"), fname);
  	return NULL;
      }
  
      if ((fd = mch_fopen((char *)fname, mode)) == NULL)
! 	EMSG2(_("E190: Cannot open \"%s\" for writing"), fname);
  
      return fd;
  }
--- 10223,10240 ----
      /* with Unix it is possible to open a directory */
      if (mch_isdir(fname))
      {
! 	semsg(_(e_isadir2), fname);
  	return NULL;
      }
  #endif
      if (!forceit && *mode != 'a' && vim_fexists(fname))
      {
! 	semsg(_("E189: \"%s\" exists (add ! to override)"), fname);
  	return NULL;
      }
  
      if ((fd = mch_fopen((char *)fname, mode)) == NULL)
! 	semsg(_("E190: Cannot open \"%s\" for writing"), fname);
  
      return fd;
  }
***************
*** 10248,10263 ****
      pos_T	pos;
  
      if (*eap->arg == NUL)		/* No argument? */
! 	EMSG(_(e_argreq));
      else if (eap->arg[1] != NUL)	/* more than one character? */
! 	EMSG(_(e_trailing));
      else
      {
  	pos = curwin->w_cursor;		/* save curwin->w_cursor */
  	curwin->w_cursor.lnum = eap->line2;
  	beginline(BL_WHITE | BL_FIX);
  	if (setmark(*eap->arg) == FAIL)	/* set mark */
! 	    EMSG(_("E191: Argument must be a letter or forward/backward quote"));
  	curwin->w_cursor = pos;		/* restore curwin->w_cursor */
      }
  }
--- 10248,10263 ----
      pos_T	pos;
  
      if (*eap->arg == NUL)		/* No argument? */
! 	emsg(_(e_argreq));
      else if (eap->arg[1] != NUL)	/* more than one character? */
! 	emsg(_(e_trailing));
      else
      {
  	pos = curwin->w_cursor;		/* save curwin->w_cursor */
  	curwin->w_cursor.lnum = eap->line2;
  	beginline(BL_WHITE | BL_FIX);
  	if (setmark(*eap->arg) == FAIL)	/* set mark */
! 	    emsg(_("E191: Argument must be a letter or forward/backward quote"));
  	curwin->w_cursor = pos;		/* restore curwin->w_cursor */
      }
  }
***************
*** 10339,10350 ****
  
      if (ex_normal_lock > 0)
      {
! 	EMSG(_(e_secure));
  	return;
      }
      if (ex_normal_busy >= p_mmd)
      {
! 	EMSG(_("E192: Recursive use of :normal too deep"));
  	return;
      }
  
--- 10339,10350 ----
  
      if (ex_normal_lock > 0)
      {
! 	emsg(_(e_secure));
  	return;
      }
      if (ex_normal_busy >= p_mmd)
      {
! 	emsg(_("E192: Recursive use of :normal too deep"));
  	return;
      }
  
***************
*** 10817,10823 ****
      char_u	*srcstart,	/* beginning of valid memory for src */
      int		*usedlen,	/* characters after src that are used */
      linenr_T	*lnump,		/* line number for :e command, or NULL */
!     char_u	**errormsg,	/* pointer to error message */
      int		*escaped)	/* return value has escaped white space (can
  				 * be NULL) */
  {
--- 10817,10823 ----
      char_u	*srcstart,	/* beginning of valid memory for src */
      int		*usedlen,	/* characters after src that are used */
      linenr_T	*lnump,		/* line number for :e command, or NULL */
!     char	**errormsg,	/* pointer to error message */
      int		*escaped)	/* return value has escaped white space (can
  				 * be NULL) */
  {
***************
*** 10872,10878 ****
  	      : FIND_STRING);
  	if (resultlen == 0)
  	{
! 	    *errormsg = (char_u *)"";
  	    return NULL;
  	}
      }
--- 10872,10878 ----
  	      : FIND_STRING);
  	if (resultlen == 0)
  	{
! 	    *errormsg = "";
  	    return NULL;
  	}
      }
***************
*** 10938,10944 ****
  								     (long)i);
  		    if (result == NULL)
  		    {
! 			*errormsg = (char_u *)"";
  			return NULL;
  		    }
  #else
--- 10938,10944 ----
  								     (long)i);
  		    if (result == NULL)
  		    {
! 			*errormsg = "";
  			return NULL;
  		    }
  #else
***************
*** 10953,10959 ****
  		    buf = buflist_findnr(i);
  		    if (buf == NULL)
  		    {
! 			*errormsg = (char_u *)_("E194: No alternate file name to substitute for '#'");
  			return NULL;
  		    }
  		    if (lnump != NULL)
--- 10953,10959 ----
  		    buf = buflist_findnr(i);
  		    if (buf == NULL)
  		    {
! 			*errormsg = _("E194: No alternate file name to substitute for '#'");
  			return NULL;
  		    }
  		    if (lnump != NULL)
***************
*** 10978,10984 ****
  		result = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L, NULL);
  		if (result == NULL)
  		{
! 		    *errormsg = (char_u *)"";
  		    return NULL;
  		}
  		resultbuf = result;	    /* remember allocated string */
--- 10978,10984 ----
  		result = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L, NULL);
  		if (result == NULL)
  		{
! 		    *errormsg = "";
  		    return NULL;
  		}
  		resultbuf = result;	    /* remember allocated string */
***************
*** 10998,11004 ****
  		}
  		if (result == NULL)
  		{
! 		    *errormsg = (char_u *)_("E495: no autocommand file name to substitute for \"<afile>\"");
  		    return NULL;
  		}
  		result = shorten_fname1(result);
--- 10998,11004 ----
  		}
  		if (result == NULL)
  		{
! 		    *errormsg = _("E495: no autocommand file name to substitute for \"<afile>\"");
  		    return NULL;
  		}
  		result = shorten_fname1(result);
***************
*** 11007,11013 ****
  	case SPEC_ABUF:		/* buffer number for autocommand */
  		if (autocmd_bufnr <= 0)
  		{
! 		    *errormsg = (char_u *)_("E496: no autocommand buffer number to substitute for \"<abuf>\"");
  		    return NULL;
  		}
  		sprintf((char *)strbuf, "%d", autocmd_bufnr);
--- 11007,11013 ----
  	case SPEC_ABUF:		/* buffer number for autocommand */
  		if (autocmd_bufnr <= 0)
  		{
! 		    *errormsg = _("E496: no autocommand buffer number to substitute for \"<abuf>\"");
  		    return NULL;
  		}
  		sprintf((char *)strbuf, "%d", autocmd_bufnr);
***************
*** 11018,11024 ****
  		result = autocmd_match;
  		if (result == NULL)
  		{
! 		    *errormsg = (char_u *)_("E497: no autocommand match name to substitute for \"<amatch>\"");
  		    return NULL;
  		}
  		break;
--- 11018,11024 ----
  		result = autocmd_match;
  		if (result == NULL)
  		{
! 		    *errormsg = _("E497: no autocommand match name to substitute for \"<amatch>\"");
  		    return NULL;
  		}
  		break;
***************
*** 11027,11033 ****
  		result = sourcing_name;
  		if (result == NULL)
  		{
! 		    *errormsg = (char_u *)_("E498: no :source file name to substitute for \"<sfile>\"");
  		    return NULL;
  		}
  		break;
--- 11027,11033 ----
  		result = sourcing_name;
  		if (result == NULL)
  		{
! 		    *errormsg = _("E498: no :source file name to substitute for \"<sfile>\"");
  		    return NULL;
  		}
  		break;
***************
*** 11035,11041 ****
  	case SPEC_SLNUM:	/* line in file for ":so" command */
  		if (sourcing_name == NULL || sourcing_lnum == 0)
  		{
! 		    *errormsg = (char_u *)_("E842: no line number to use for \"<slnum>\"");
  		    return NULL;
  		}
  		sprintf((char *)strbuf, "%ld", (long)sourcing_lnum);
--- 11035,11041 ----
  	case SPEC_SLNUM:	/* line in file for ":so" command */
  		if (sourcing_name == NULL || sourcing_lnum == 0)
  		{
! 		    *errormsg = _("E842: no line number to use for \"<slnum>\"");
  		    return NULL;
  		}
  		sprintf((char *)strbuf, "%ld", (long)sourcing_lnum);
***************
*** 11046,11052 ****
  	case SPEC_SFLNUM:	/* line in script file */
  		if (current_sctx.sc_lnum + sourcing_lnum == 0)
  		{
! 		    *errormsg = (char_u *)_("E961: no line number to use for \"<sflnum>\"");
  		    return NULL;
  		}
  		sprintf((char *)strbuf, "%ld",
--- 11046,11052 ----
  	case SPEC_SFLNUM:	/* line in script file */
  		if (current_sctx.sc_lnum + sourcing_lnum == 0)
  		{
! 		    *errormsg = _("E961: no line number to use for \"<sflnum>\"");
  		    return NULL;
  		}
  		sprintf((char *)strbuf, "%ld",
***************
*** 11082,11088 ****
  								  &resultlen);
  	    if (result == NULL)
  	    {
! 		*errormsg = (char_u *)"";
  		return NULL;
  	    }
  	}
--- 11082,11088 ----
  								  &resultlen);
  	    if (result == NULL)
  	    {
! 		*errormsg = "";
  		return NULL;
  	    }
  	}
***************
*** 11093,11101 ****
      {
  	if (valid != VALID_HEAD + VALID_PATH)
  	    /* xgettext:no-c-format */
! 	    *errormsg = (char_u *)_("E499: Empty file name for '%' or '#', only works with \":p:h\"");
  	else
! 	    *errormsg = (char_u *)_("E500: Evaluates to an empty string");
  	result = NULL;
      }
      else
--- 11093,11101 ----
      {
  	if (valid != VALID_HEAD + VALID_PATH)
  	    /* xgettext:no-c-format */
! 	    *errormsg = _("E499: Empty file name for '%' or '#', only works with \":p:h\"");
  	else
! 	    *errormsg = _("E500: Evaluates to an empty string");
  	result = NULL;
      }
      else
***************
*** 11182,11188 ****
      char_u *
  expand_sfile(char_u *arg)
  {
!     char_u	*errormsg;
      int		len;
      char_u	*result;
      char_u	*newres;
--- 11182,11188 ----
      char_u *
  expand_sfile(char_u *arg)
  {
!     char	*errormsg;
      int		len;
      char_u	*result;
      char_u	*newres;
***************
*** 12139,12145 ****
  
      if (curbuf->b_ffname == NULL)
      {
! 	EMSG(_(e_noname));
  	return NULL;
      }
      sname = home_replace_save(NULL, curbuf->b_ffname);
--- 12139,12145 ----
  
      if (curbuf->b_ffname == NULL)
      {
! 	emsg(_(e_noname));
  	return NULL;
      }
      sname = home_replace_save(NULL, curbuf->b_ffname);
***************
*** 12242,12248 ****
      {
  	if (read_viminfo(eap->arg, VIF_WANT_INFO | VIF_WANT_MARKS
  				  | (eap->forceit ? VIF_FORCEIT : 0)) == FAIL)
! 	    EMSG(_("E195: Cannot open viminfo file for reading"));
      }
      else
  	write_viminfo(eap->arg, eap->forceit);
--- 12242,12248 ----
      {
  	if (read_viminfo(eap->arg, VIF_WANT_INFO | VIF_WANT_MARKS
  				  | (eap->forceit ? VIF_FORCEIT : 0)) == FAIL)
! 	    emsg(_("E195: Cannot open viminfo file for reading"));
      }
      else
  	write_viminfo(eap->arg, eap->forceit);
***************
*** 12286,12292 ****
  	set_option_value((char_u *)"keymodel", 0L, (char_u *)"", 0);
      }
      else
! 	EMSG2(_(e_invarg2), eap->arg);
  }
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
--- 12286,12292 ----
  	set_option_value((char_u *)"keymodel", 0L, (char_u *)"", 0);
      }
      else
! 	semsg(_(e_invarg2), eap->arg);
  }
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
***************
*** 12348,12354 ****
      if (*eap->arg == NUL)
      {
  	/* Print current status. */
! 	smsg((char_u *)"filetype detection:%s  plugin:%s  indent:%s",
  		filetype_detect ? "ON" : "OFF",
  		filetype_plugin ? (filetype_detect ? "ON" : "(on)") : "OFF",
  		filetype_indent ? (filetype_detect ? "ON" : "(on)") : "OFF");
--- 12348,12354 ----
      if (*eap->arg == NUL)
      {
  	/* Print current status. */
! 	smsg("filetype detection:%s  plugin:%s  indent:%s",
  		filetype_detect ? "ON" : "OFF",
  		filetype_plugin ? (filetype_detect ? "ON" : "(on)") : "OFF",
  		filetype_indent ? (filetype_detect ? "ON" : "(on)") : "OFF");
***************
*** 12417,12423 ****
  	}
      }
      else
! 	EMSG2(_(e_invarg2), arg);
  }
  
  /*
--- 12417,12423 ----
  	}
      }
      else
! 	semsg(_(e_invarg2), arg);
  }
  
  /*
***************
*** 12448,12454 ****
      else
  	listdigraphs(eap->forceit);
  #else
!     EMSG(_("E196: No digraphs in this version"));
  #endif
  }
  
--- 12448,12454 ----
      else
  	listdigraphs(eap->forceit);
  #else
!     emsg(_("E196: No digraphs in this version"));
  #endif
  }
  
***************
*** 12507,12513 ****
  	id = eap->line2;
      else
      {
! 	EMSG(e_invcmd);
  	return;
      }
  
--- 12507,12513 ----
  	id = eap->line2;
      else
      {
! 	emsg(_(e_invcmd));
  	return;
      }
  
***************
*** 12530,12536 ****
  	{
  	    /* There must be two arguments. */
  	    vim_free(g);
! 	    EMSG2(_(e_invarg2), eap->arg);
  	    return;
  	}
  	end = skip_regexp(p + 1, *p, TRUE, NULL);
--- 12530,12536 ----
  	{
  	    /* There must be two arguments. */
  	    vim_free(g);
! 	    semsg(_(e_invarg2), eap->arg);
  	    return;
  	}
  	end = skip_regexp(p + 1, *p, TRUE, NULL);
***************
*** 12545,12551 ****
  	    if (*end != *p)
  	    {
  		vim_free(g);
! 		EMSG2(_(e_invarg2), p);
  		return;
  	    }
  
--- 12545,12551 ----
  	    if (*end != *p)
  	    {
  		vim_free(g);
! 		semsg(_(e_invarg2), p);
  		return;
  	    }
  
*** ../vim-8.1.0742/src/ex_eval.c	2018-09-30 21:43:17.187693348 +0200
--- src/ex_eval.c	2019-01-13 22:58:42.321795761 +0100
***************
*** 16,22 ****
  #if defined(FEAT_EVAL) || defined(PROTO)
  
  static int	throw_exception(void *, except_type_T, char_u *);
! static char_u	*get_end_emsg(struct condstack *cstack);
  
  /*
   * Exception handling terms:
--- 16,22 ----
  #if defined(FEAT_EVAL) || defined(PROTO)
  
  static int	throw_exception(void *, except_type_T, char_u *);
! static char	*get_end_emsg(struct condstack *cstack);
  
  /*
   * Exception handling terms:
***************
*** 255,270 ****
  	    if (elem == NULL)
  	    {
  		suppress_errthrow = TRUE;
! 		EMSG(_(e_outofmem));
  	    }
  	    else
  	    {
! 		elem->msg = vim_strsave(mesg);
  		if (elem->msg == NULL)
  		{
  		    vim_free(elem);
  		    suppress_errthrow = TRUE;
! 		    EMSG(_(e_outofmem));
  		}
  		else
  		{
--- 255,270 ----
  	    if (elem == NULL)
  	    {
  		suppress_errthrow = TRUE;
! 		emsg(_(e_outofmem));
  	    }
  	    else
  	    {
! 		elem->msg = (char *)vim_strsave(mesg);
  		if (elem->msg == NULL)
  		{
  		    vim_free(elem);
  		    suppress_errthrow = TRUE;
! 		    emsg(_(e_outofmem));
  		}
  		else
  		{
***************
*** 273,279 ****
  		    *plist = elem;
  		    if (plist == msg_list || severe)
  		    {
! 			char_u	    *tmsg;
  
  			/* Skip the extra "Vim " prefix for message "E458". */
  			tmsg = elem->msg;
--- 273,279 ----
  		    *plist = elem;
  		    if (plist == msg_list || severe)
  		    {
! 			char	    *tmsg;
  
  			/* Skip the extra "Vim " prefix for message "E458". */
  			tmsg = elem->msg;
***************
*** 413,428 ****
  /*
   * Get an exception message that is to be stored in current_exception->value.
   */
!     char_u *
  get_exception_string(
      void	*value,
      except_type_T type,
      char_u	*cmdname,
      int		*should_free)
  {
!     char_u	*ret, *mesg;
      int		cmdlen;
!     char_u	*p, *val;
  
      if (type == ET_ERROR)
      {
--- 413,429 ----
  /*
   * Get an exception message that is to be stored in current_exception->value.
   */
!     char *
  get_exception_string(
      void	*value,
      except_type_T type,
      char_u	*cmdname,
      int		*should_free)
  {
!     char	*ret;
!     char	*mesg;
      int		cmdlen;
!     char	*p, *val;
  
      if (type == ET_ERROR)
      {
***************
*** 431,437 ****
  	if (cmdname != NULL && *cmdname != NUL)
  	{
  	    cmdlen = (int)STRLEN(cmdname);
! 	    ret = vim_strnsave((char_u *)"Vim(",
  					   4 + cmdlen + 2 + (int)STRLEN(mesg));
  	    if (ret == NULL)
  		return ret;
--- 432,438 ----
  	if (cmdname != NULL && *cmdname != NUL)
  	{
  	    cmdlen = (int)STRLEN(cmdname);
! 	    ret = (char *)vim_strnsave((char_u *)"Vim(",
  					   4 + cmdlen + 2 + (int)STRLEN(mesg));
  	    if (ret == NULL)
  		return ret;
***************
*** 441,447 ****
  	}
  	else
  	{
! 	    ret = vim_strnsave((char_u *)"Vim:", 4 + (int)STRLEN(mesg));
  	    if (ret == NULL)
  		return ret;
  	    val = ret + 4;
--- 442,448 ----
  	}
  	else
  	{
! 	    ret = (char *)vim_strnsave((char_u *)"Vim:", 4 + (int)STRLEN(mesg));
  	    if (ret == NULL)
  		return ret;
  	    val = ret + 4;
***************
*** 483,489 ****
      else
      {
  	*should_free = FALSE;
! 	ret = (char_u *)value;
      }
  
      return ret;
--- 484,490 ----
      else
      {
  	*should_free = FALSE;
! 	ret = value;
      }
  
      return ret;
***************
*** 513,519 ****
  		&& (((char_u *)value)[3] == NUL || ((char_u *)value)[3] == ':'
  		    || ((char_u *)value)[3] == '('))
  	{
! 	    EMSG(_("E608: Cannot :throw exceptions with 'Vim' prefix"));
  	    goto fail;
  	}
      }
--- 514,520 ----
  		&& (((char_u *)value)[3] == NUL || ((char_u *)value)[3] == ':'
  		    || ((char_u *)value)[3] == '('))
  	{
! 	    emsg(_("E608: Cannot :throw exceptions with 'Vim' prefix"));
  	    goto fail;
  	}
      }
***************
*** 554,560 ****
  	if (debug_break_level > 0 || *p_vfile == NUL)
  	    msg_scroll = TRUE;	    /* always scroll up, don't overwrite */
  
! 	smsg((char_u *)_("Exception thrown: %s"), excp->value);
  	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  
  	if (debug_break_level > 0 || *p_vfile == NUL)
--- 555,561 ----
  	if (debug_break_level > 0 || *p_vfile == NUL)
  	    msg_scroll = TRUE;	    /* always scroll up, don't overwrite */
  
! 	smsg(_("Exception thrown: %s"), excp->value);
  	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  
  	if (debug_break_level > 0 || *p_vfile == NUL)
***************
*** 572,578 ****
  nomem:
      vim_free(excp);
      suppress_errthrow = TRUE;
!     EMSG(_(e_outofmem));
  fail:
      current_exception = NULL;
      return FAIL;
--- 573,579 ----
  nomem:
      vim_free(excp);
      suppress_errthrow = TRUE;
!     emsg(_(e_outofmem));
  fail:
      current_exception = NULL;
      return FAIL;
***************
*** 606,613 ****
  	if (debug_break_level > 0 || *p_vfile == NUL)
  	    msg_scroll = TRUE;	    /* always scroll up, don't overwrite */
  	smsg(was_finished
! 		    ? (char_u *)_("Exception finished: %s")
! 		    : (char_u *)_("Exception discarded: %s"),
  		excp->value);
  	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  	if (debug_break_level > 0 || *p_vfile == NUL)
--- 607,614 ----
  	if (debug_break_level > 0 || *p_vfile == NUL)
  	    msg_scroll = TRUE;	    /* always scroll up, don't overwrite */
  	smsg(was_finished
! 		    ? _("Exception finished: %s")
! 		    : _("Exception discarded: %s"),
  		excp->value);
  	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  	if (debug_break_level > 0 || *p_vfile == NUL)
***************
*** 651,657 ****
  {
      excp->caught = caught_stack;
      caught_stack = excp;
!     set_vim_var_string(VV_EXCEPTION, excp->value, -1);
      if (*excp->throw_name != NUL)
      {
  	if (excp->throw_lnum != 0)
--- 652,658 ----
  {
      excp->caught = caught_stack;
      caught_stack = excp;
!     set_vim_var_string(VV_EXCEPTION, (char_u *)excp->value, -1);
      if (*excp->throw_name != NUL)
      {
  	if (excp->throw_lnum != 0)
***************
*** 677,683 ****
  	if (debug_break_level > 0 || *p_vfile == NUL)
  	    msg_scroll = TRUE;	    /* always scroll up, don't overwrite */
  
! 	smsg((char_u *)_("Exception caught: %s"), excp->value);
  	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  
  	if (debug_break_level > 0 || *p_vfile == NUL)
--- 678,684 ----
  	if (debug_break_level > 0 || *p_vfile == NUL)
  	    msg_scroll = TRUE;	    /* always scroll up, don't overwrite */
  
! 	smsg(_("Exception caught: %s"), excp->value);
  	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  
  	if (debug_break_level > 0 || *p_vfile == NUL)
***************
*** 701,707 ****
      caught_stack = caught_stack->caught;
      if (caught_stack != NULL)
      {
! 	set_vim_var_string(VV_EXCEPTION, caught_stack->value, -1);
  	if (*caught_stack->throw_name != NUL)
  	{
  	    if (caught_stack->throw_lnum != 0)
--- 702,708 ----
      caught_stack = caught_stack->caught;
      if (caught_stack != NULL)
      {
! 	set_vim_var_string(VV_EXCEPTION, (char_u *)caught_stack->value, -1);
  	if (*caught_stack->throw_name != NUL)
  	{
  	    if (caught_stack->throw_lnum != 0)
***************
*** 745,751 ****
      static void
  report_pending(int action, int pending, void *value)
  {
!     char_u	*mesg;
      char	*s;
      int		save_msg_silent;
  
--- 746,752 ----
      static void
  report_pending(int action, int pending, void *value)
  {
!     char	*mesg;
      char	*s;
      int		save_msg_silent;
  
***************
*** 753,766 ****
      switch (action)
      {
  	case RP_MAKE:
! 	    mesg = (char_u *)_("%s made pending");
  	    break;
  	case RP_RESUME:
! 	    mesg = (char_u *)_("%s resumed");
  	    break;
  	/* case RP_DISCARD: */
  	default:
! 	    mesg = (char_u *)_("%s discarded");
  	    break;
      }
  
--- 754,767 ----
      switch (action)
      {
  	case RP_MAKE:
! 	    mesg = _("%s made pending");
  	    break;
  	case RP_RESUME:
! 	    mesg = _("%s resumed");
  	    break;
  	/* case RP_DISCARD: */
  	default:
! 	    mesg = _("%s discarded");
  	    break;
      }
  
***************
*** 786,794 ****
  	default:
  	    if (pending & CSTP_THROW)
  	    {
! 		vim_snprintf((char *)IObuff, IOSIZE,
! 						(char *)mesg, _("Exception"));
! 		mesg = vim_strnsave(IObuff, (int)STRLEN(IObuff) + 4);
  		STRCAT(mesg, ": %s");
  		s = (char *)((except_T *)value)->value;
  	    }
--- 787,794 ----
  	default:
  	    if (pending & CSTP_THROW)
  	    {
! 		vim_snprintf((char *)IObuff, IOSIZE, mesg, _("Exception"));
! 		mesg = (char *)vim_strnsave(IObuff, (int)STRLEN(IObuff) + 4);
  		STRCAT(mesg, ": %s");
  		s = (char *)((except_T *)value)->value;
  	    }
***************
*** 805,811 ****
  	msg_silent = FALSE;	/* display messages */
      ++no_wait_return;
      msg_scroll = TRUE;		/* always scroll up, don't overwrite */
!     smsg(mesg, (char_u *)s);
      msg_puts((char_u *)"\n");   /* don't overwrite this either */
      cmdline_row = msg_row;
      --no_wait_return;
--- 805,811 ----
  	msg_silent = FALSE;	/* display messages */
      ++no_wait_return;
      msg_scroll = TRUE;		/* always scroll up, don't overwrite */
!     smsg(mesg, s);
      msg_puts((char_u *)"\n");   /* don't overwrite this either */
      cmdline_row = msg_row;
      --no_wait_return;
***************
*** 882,888 ****
      struct condstack	*cstack = eap->cstack;
  
      if (cstack->cs_idx == CSTACK_LEN - 1)
! 	eap->errmsg = (char_u *)N_("E579: :if nesting too deep");
      else
      {
  	++cstack->cs_idx;
--- 882,888 ----
      struct condstack	*cstack = eap->cstack;
  
      if (cstack->cs_idx == CSTACK_LEN - 1)
! 	eap->errmsg = N_("E579: :if nesting too deep");
      else
      {
  	++cstack->cs_idx;
***************
*** 918,924 ****
      if (eap->cstack->cs_idx < 0
  	    || (eap->cstack->cs_flags[eap->cstack->cs_idx]
  					   & (CSF_WHILE | CSF_FOR | CSF_TRY)))
! 	eap->errmsg = (char_u *)N_("E580: :endif without :if");
      else
      {
  	/*
--- 918,924 ----
      if (eap->cstack->cs_idx < 0
  	    || (eap->cstack->cs_flags[eap->cstack->cs_idx]
  					   & (CSF_WHILE | CSF_FOR | CSF_TRY)))
! 	eap->errmsg = N_("E580: :endif without :if");
      else
      {
  	/*
***************
*** 962,981 ****
      {
  	if (eap->cmdidx == CMD_else)
  	{
! 	    eap->errmsg = (char_u *)N_("E581: :else without :if");
  	    return;
  	}
! 	eap->errmsg = (char_u *)N_("E582: :elseif without :if");
  	skip = TRUE;
      }
      else if (cstack->cs_flags[cstack->cs_idx] & CSF_ELSE)
      {
  	if (eap->cmdidx == CMD_else)
  	{
! 	    eap->errmsg = (char_u *)N_("E583: multiple :else");
  	    return;
  	}
! 	eap->errmsg = (char_u *)N_("E584: :elseif after :else");
  	skip = TRUE;
      }
  
--- 962,981 ----
      {
  	if (eap->cmdidx == CMD_else)
  	{
! 	    eap->errmsg = N_("E581: :else without :if");
  	    return;
  	}
! 	eap->errmsg = N_("E582: :elseif without :if");
  	skip = TRUE;
      }
      else if (cstack->cs_flags[cstack->cs_idx] & CSF_ELSE)
      {
  	if (eap->cmdidx == CMD_else)
  	{
! 	    eap->errmsg = N_("E583: multiple :else");
  	    return;
  	}
! 	eap->errmsg = N_("E584: :elseif after :else");
  	skip = TRUE;
      }
  
***************
*** 1041,1047 ****
      struct condstack	*cstack = eap->cstack;
  
      if (cstack->cs_idx == CSTACK_LEN - 1)
! 	eap->errmsg = (char_u *)N_("E585: :while/:for nesting too deep");
      else
      {
  	/*
--- 1041,1047 ----
      struct condstack	*cstack = eap->cstack;
  
      if (cstack->cs_idx == CSTACK_LEN - 1)
! 	eap->errmsg = N_("E585: :while/:for nesting too deep");
      else
      {
  	/*
***************
*** 1138,1144 ****
      struct condstack	*cstack = eap->cstack;
  
      if (cstack->cs_looplevel <= 0 || cstack->cs_idx < 0)
! 	eap->errmsg = (char_u *)N_("E586: :continue without :while or :for");
      else
      {
  	/* Try to find the matching ":while".  This might stop at a try
--- 1138,1144 ----
      struct condstack	*cstack = eap->cstack;
  
      if (cstack->cs_looplevel <= 0 || cstack->cs_idx < 0)
! 	eap->errmsg = N_("E586: :continue without :while or :for");
      else
      {
  	/* Try to find the matching ":while".  This might stop at a try
***************
*** 1176,1182 ****
      struct condstack	*cstack = eap->cstack;
  
      if (cstack->cs_looplevel <= 0 || cstack->cs_idx < 0)
! 	eap->errmsg = (char_u *)N_("E587: :break without :while or :for");
      else
      {
  	/* Inactivate conditionals until the matching ":while" or a try
--- 1176,1182 ----
      struct condstack	*cstack = eap->cstack;
  
      if (cstack->cs_looplevel <= 0 || cstack->cs_idx < 0)
! 	eap->errmsg = N_("E587: :break without :while or :for");
      else
      {
  	/* Inactivate conditionals until the matching ":while" or a try
***************
*** 1200,1206 ****
  {
      struct condstack	*cstack = eap->cstack;
      int			idx;
!     char_u		*err;
      int			csf;
      int			fl;
  
--- 1200,1206 ----
  {
      struct condstack	*cstack = eap->cstack;
      int			idx;
!     char		*err;
      int			csf;
      int			fl;
  
***************
*** 1225,1233 ****
  	    /* If we are in a ":while" or ":for" but used the wrong endloop
  	     * command, do not rewind to the next enclosing ":for"/":while". */
  	    if (fl & CSF_WHILE)
! 		eap->errmsg = (char_u *)_("E732: Using :endfor with :while");
  	    else if (fl & CSF_FOR)
! 		eap->errmsg = (char_u *)_("E733: Using :endwhile with :for");
  	}
  	if (!(fl & (CSF_WHILE | CSF_FOR)))
  	{
--- 1225,1233 ----
  	    /* If we are in a ":while" or ":for" but used the wrong endloop
  	     * command, do not rewind to the next enclosing ":for"/":while". */
  	    if (fl & CSF_WHILE)
! 		eap->errmsg = _("E732: Using :endfor with :while");
  	    else if (fl & CSF_FOR)
! 		eap->errmsg = _("E733: Using :endwhile with :for");
  	}
  	if (!(fl & (CSF_WHILE | CSF_FOR)))
  	{
***************
*** 1291,1297 ****
  	value = eval_to_string_skip(arg, &eap->nextcmd, eap->skip);
      else
      {
! 	EMSG(_(e_argreq));
  	value = NULL;
      }
  
--- 1291,1297 ----
  	value = eval_to_string_skip(arg, &eap->nextcmd, eap->skip);
      else
      {
! 	emsg(_(e_argreq));
  	value = NULL;
      }
  
***************
*** 1399,1405 ****
      struct condstack	*cstack = eap->cstack;
  
      if (cstack->cs_idx == CSTACK_LEN - 1)
! 	eap->errmsg = (char_u *)N_("E601: :try nesting too deep");
      else
      {
  	++cstack->cs_idx;
--- 1399,1405 ----
      struct condstack	*cstack = eap->cstack;
  
      if (cstack->cs_idx == CSTACK_LEN - 1)
! 	eap->errmsg = N_("E601: :try nesting too deep");
      else
      {
  	++cstack->cs_idx;
***************
*** 1443,1449 ****
  
  		elem = (eslist_T *)alloc((unsigned)sizeof(struct eslist_elem));
  		if (elem == NULL)
! 		    EMSG(_(e_outofmem));
  		else
  		{
  		    elem->saved_emsg_silent = emsg_silent;
--- 1443,1449 ----
  
  		elem = (eslist_T *)alloc((unsigned)sizeof(struct eslist_elem));
  		if (elem == NULL)
! 		    emsg(_(e_outofmem));
  		else
  		{
  		    elem->saved_emsg_silent = emsg_silent;
***************
*** 1478,1484 ****
  
      if (cstack->cs_trylevel <= 0 || cstack->cs_idx < 0)
      {
! 	eap->errmsg = (char_u *)N_("E603: :catch without :try");
  	give_up = TRUE;
      }
      else
--- 1478,1484 ----
  
      if (cstack->cs_trylevel <= 0 || cstack->cs_idx < 0)
      {
! 	eap->errmsg = N_("E603: :catch without :try");
  	give_up = TRUE;
      }
      else
***************
*** 1497,1503 ****
  	{
  	    /* Give up for a ":catch" after ":finally" and ignore it.
  	     * Just parse. */
! 	    eap->errmsg = (char_u *)N_("E604: :catch after :finally");
  	    give_up = TRUE;
  	}
  	else
--- 1497,1503 ----
  	{
  	    /* Give up for a ":catch" after ":finally" and ignore it.
  	     * Just parse. */
! 	    eap->errmsg = N_("E604: :catch after :finally");
  	    give_up = TRUE;
  	}
  	else
***************
*** 1537,1543 ****
  	{
  	    if (end != NULL && *end != NUL && !ends_excmd(*skipwhite(end + 1)))
  	    {
! 		EMSG(_(e_trailing));
  		return;
  	    }
  
--- 1537,1543 ----
  	{
  	    if (end != NULL && *end != NUL && !ends_excmd(*skipwhite(end + 1)))
  	    {
! 		emsg(_(e_trailing));
  		return;
  	    }
  
***************
*** 1569,1575 ****
  		    *end = save_char;
  		p_cpo = save_cpo;
  		if (regmatch.regprog == NULL)
! 		    EMSG2(_(e_invarg2), pat);
  		else
  		{
  		    /*
--- 1569,1575 ----
  		    *end = save_char;
  		p_cpo = save_cpo;
  		if (regmatch.regprog == NULL)
! 		    semsg(_(e_invarg2), pat);
  		else
  		{
  		    /*
***************
*** 1579,1586 ****
  		     */
  		    prev_got_int = got_int;
  		    got_int = FALSE;
! 		    caught = vim_regexec_nl(&regmatch, current_exception->value,
! 			    (colnr_T)0);
  		    got_int |= prev_got_int;
  		    vim_regfree(regmatch.regprog);
  		}
--- 1579,1586 ----
  		     */
  		    prev_got_int = got_int;
  		    got_int = FALSE;
! 		    caught = vim_regexec_nl(&regmatch,
! 			       (char_u *)current_exception->value, (colnr_T)0);
  		    got_int |= prev_got_int;
  		    vim_regfree(regmatch.regprog);
  		}
***************
*** 1634,1640 ****
      struct condstack	*cstack = eap->cstack;
  
      if (cstack->cs_trylevel <= 0 || cstack->cs_idx < 0)
! 	eap->errmsg = (char_u *)N_("E606: :finally without :try");
      else
      {
  	if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))
--- 1634,1640 ----
      struct condstack	*cstack = eap->cstack;
  
      if (cstack->cs_trylevel <= 0 || cstack->cs_idx < 0)
! 	eap->errmsg = N_("E606: :finally without :try");
      else
      {
  	if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))
***************
*** 1654,1660 ****
  	if (cstack->cs_flags[idx] & CSF_FINALLY)
  	{
  	    /* Give up for a multiple ":finally" and ignore it. */
! 	    eap->errmsg = (char_u *)N_("E607: multiple :finally");
  	    return;
  	}
  	rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,
--- 1654,1660 ----
  	if (cstack->cs_flags[idx] & CSF_FINALLY)
  	{
  	    /* Give up for a multiple ":finally" and ignore it. */
! 	    eap->errmsg = N_("E607: multiple :finally");
  	    return;
  	}
  	rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,
***************
*** 1763,1769 ****
      struct condstack	*cstack = eap->cstack;
  
      if (cstack->cs_trylevel <= 0 || cstack->cs_idx < 0)
! 	eap->errmsg = (char_u *)N_("E602: :endtry without :try");
      else
      {
  	/*
--- 1763,1769 ----
      struct condstack	*cstack = eap->cstack;
  
      if (cstack->cs_trylevel <= 0 || cstack->cs_idx < 0)
! 	eap->errmsg = N_("E602: :endtry without :try");
      else
      {
  	/*
***************
*** 2223,2229 ****
  /*
   * Return an appropriate error message for a missing endwhile/endfor/endif.
   */
!    static char_u *
  get_end_emsg(struct condstack *cstack)
  {
      if (cstack->cs_flags[cstack->cs_idx] & CSF_WHILE)
--- 2223,2229 ----
  /*
   * Return an appropriate error message for a missing endwhile/endfor/endif.
   */
!    static char *
  get_end_emsg(struct condstack *cstack)
  {
      if (cstack->cs_flags[cstack->cs_idx] & CSF_WHILE)
***************
*** 2264,2270 ****
      void
  ex_endfunction(exarg_T *eap UNUSED)
  {
!     EMSG(_("E193: :endfunction not inside a function"));
  }
  
  /*
--- 2264,2270 ----
      void
  ex_endfunction(exarg_T *eap UNUSED)
  {
!     emsg(_("E193: :endfunction not inside a function"));
  }
  
  /*
*** ../vim-8.1.0742/src/ex_getln.c	2018-12-23 19:10:05.010359907 +0100
--- src/ex_getln.c	2019-01-13 22:59:08.661612380 +0100
***************
*** 275,281 ****
      int		delim_optional = FALSE;
      int		delim;
      char_u	*end;
!     char_u	*dummy;
      exarg_T	ea;
      pos_T	save_cursor;
      int		use_last_pat;
--- 275,281 ----
      int		delim_optional = FALSE;
      int		delim;
      char_u	*end;
!     char	*dummy;
      exarg_T	ea;
      pos_T	save_cursor;
      int		use_last_pat;
***************
*** 2601,2610 ****
      void
  text_locked_msg(void)
  {
!     EMSG(_(get_text_locked_msg()));
  }
  
!     char_u *
  get_text_locked_msg(void)
  {
  #ifdef FEAT_CMDWIN
--- 2601,2610 ----
      void
  text_locked_msg(void)
  {
!     emsg(_(get_text_locked_msg()));
  }
  
!     char *
  get_text_locked_msg(void)
  {
  #ifdef FEAT_CMDWIN
***************
*** 2623,2629 ****
  {
      if (curbuf_lock > 0)
      {
! 	EMSG(_("E788: Not allowed to edit another buffer now"));
  	return TRUE;
      }
      return allbuf_locked();
--- 2623,2629 ----
  {
      if (curbuf_lock > 0)
      {
! 	emsg(_("E788: Not allowed to edit another buffer now"));
  	return TRUE;
      }
      return allbuf_locked();
***************
*** 2638,2644 ****
  {
      if (allbuf_lock > 0)
      {
! 	EMSG(_("E811: Not allowed to change buffer information now"));
  	return TRUE;
      }
      return FALSE;
--- 2638,2644 ----
  {
      if (allbuf_lock > 0)
      {
! 	emsg(_("E811: Not allowed to change buffer information now"));
  	return TRUE;
      }
      return FALSE;
***************
*** 4174,4186 ****
  	     * causing the pattern to be added, which has illegal characters.
  	     */
  	    if (!(options & WILD_SILENT) && (options & WILD_LIST_NOTFOUND))
! 		EMSG2(_(e_nomatch2), str);
  #endif
  	}
  	else if (xp->xp_numfiles == 0)
  	{
  	    if (!(options & WILD_SILENT))
! 		EMSG2(_(e_nomatch2), str);
  	}
  	else
  	{
--- 4174,4186 ----
  	     * causing the pattern to be added, which has illegal characters.
  	     */
  	    if (!(options & WILD_SILENT) && (options & WILD_LIST_NOTFOUND))
! 		semsg(_(e_nomatch2), str);
  #endif
  	}
  	else if (xp->xp_numfiles == 0)
  	{
  	    if (!(options & WILD_SILENT))
! 		semsg(_(e_nomatch2), str);
  	}
  	else
  	{
***************
*** 4219,4225 ****
  		     * (and possibly have to hit return to continue!).
  		     */
  		    if (!(options & WILD_SILENT))
! 			EMSG(_(e_toomany));
  		    else if (!(options & WILD_NO_BEEP))
  			beep_flush();
  		}
--- 4219,4225 ----
  		     * (and possibly have to hit return to continue!).
  		     */
  		    if (!(options & WILD_SILENT))
! 			emsg(_(e_toomany));
  		    else if (!(options & WILD_NO_BEEP))
  			beep_flush();
  		}
***************
*** 6658,6664 ****
  	    else
  	    {
  		*end = i;
! 		EMSG(_(e_trailing));
  		return;
  	    }
  	}
--- 6658,6664 ----
  	    else
  	    {
  		*end = i;
! 		emsg(_(e_trailing));
  		return;
  	    }
  	}
***************
*** 6670,6676 ****
  	end = arg;
      if (!get_list_range(&end, &hisidx1, &hisidx2) || *end != NUL)
      {
! 	EMSG(_(e_trailing));
  	return;
      }
  
--- 6670,6676 ----
  	end = arg;
      if (!get_list_range(&end, &hisidx1, &hisidx2) || *end != NUL)
      {
! 	emsg(_(e_trailing));
  	return;
      }
  
***************
*** 7201,7207 ****
  {
      if (ccline.cmdpos + offset >= ccline.cmdlen || ccline.cmdpos + offset < 0)
      {
! 	EMSG(_("E198: cmd_pchar beyond the command length"));
  	return;
      }
      ccline.cmdbuff[ccline.cmdpos + offset] = (char_u)c;
--- 7201,7207 ----
  {
      if (ccline.cmdpos + offset >= ccline.cmdlen || ccline.cmdpos + offset < 0)
      {
! 	emsg(_("E198: cmd_pchar beyond the command length"));
  	return;
      }
      ccline.cmdbuff[ccline.cmdpos + offset] = (char_u)c;
***************
*** 7213,7219 ****
  {
      if (ccline.cmdpos + offset >= ccline.cmdlen || ccline.cmdpos + offset < 0)
      {
! 	/*  EMSG(_("cmd_gchar beyond the command length")); */
  	return NUL;
      }
      return (int)ccline.cmdbuff[ccline.cmdpos + offset];
--- 7213,7219 ----
  {
      if (ccline.cmdpos + offset >= ccline.cmdlen || ccline.cmdpos + offset < 0)
      {
! 	// emsg(_("cmd_gchar beyond the command length"));
  	return NUL;
      }
      return (int)ccline.cmdbuff[ccline.cmdpos + offset];
***************
*** 7392,7398 ****
      if (!win_valid(old_curwin) || !bufref_valid(&old_curbuf))
      {
  	cmdwin_result = Ctrl_C;
! 	EMSG(_("E199: Active window or buffer deleted"));
      }
      else
      {
--- 7392,7398 ----
      if (!win_valid(old_curwin) || !bufref_valid(&old_curbuf))
      {
  	cmdwin_result = Ctrl_C;
! 	emsg(_("E199: Active window or buffer deleted"));
      }
      else
      {
*** ../vim-8.1.0742/src/farsi.h	2016-08-29 22:42:20.000000000 +0200
--- src/farsi.h	2019-01-13 20:00:13.856099533 +0100
***************
*** 203,209 ****
  #endif
  		     ;
  
! EXTERN char_u farsi_text_3[]
  #ifdef DO_INIT
  		= { DAL, WAW, _SHIN, _YE, _MIM, _NOON, ' ', YE_, _NOON,
  		    ALEF_,_BE, _YE, _TE, _SHIN, _PE, ' ', 'R','E','P','L',
--- 203,209 ----
  #endif
  		     ;
  
! EXTERN char farsi_text_3[]
  #ifdef DO_INIT
  		= { DAL, WAW, _SHIN, _YE, _MIM, _NOON, ' ', YE_, _NOON,
  		    ALEF_,_BE, _YE, _TE, _SHIN, _PE, ' ', 'R','E','P','L',
*** ../vim-8.1.0742/src/fileio.c	2019-01-12 13:25:42.633479785 +0100
--- src/fileio.c	2019-01-13 23:00:47.592924735 +0100
***************
*** 595,601 ****
  				|| (using_b_fname
  					 && (old_b_fname != curbuf->b_fname)))
  			{
! 			    EMSG(_(e_auchangedbuf));
  			    return FAIL;
  			}
  		    }
--- 595,601 ----
  				|| (using_b_fname
  					 && (old_b_fname != curbuf->b_fname)))
  			{
! 			    emsg(_(e_auchangedbuf));
  			    return FAIL;
  			}
  		    }
***************
*** 676,682 ****
  		|| (using_b_ffname && (old_b_ffname != curbuf->b_ffname))
  		|| (using_b_fname && (old_b_fname != curbuf->b_fname))))
  	{
! 	    EMSG(_(e_auchangedbuf));
  	    if (!read_buffer)
  		close(fd);
  	    return FAIL;
--- 676,682 ----
  		|| (using_b_ffname && (old_b_ffname != curbuf->b_ffname))
  		|| (using_b_fname && (old_b_fname != curbuf->b_fname))))
  	{
! 	    emsg(_(e_auchangedbuf));
  	    if (!read_buffer)
  		close(fd);
  	    return FAIL;
***************
*** 798,806 ****
  	    --no_wait_return;
  	    msg_scroll = msg_save;
  	    if (fd < 0)
! 		EMSG(_("E200: *ReadPre autocommands made the file unreadable"));
  	    else
! 		EMSG(_("E201: *ReadPre autocommands must not change current buffer"));
  	    curbuf->b_p_ro = TRUE;	/* must use "w!" now */
  	    return FAIL;
  	}
--- 798,806 ----
  	    --no_wait_return;
  	    msg_scroll = msg_save;
  	    if (fd < 0)
! 		emsg(_("E200: *ReadPre autocommands made the file unreadable"));
  	    else
! 		emsg(_("E201: *ReadPre autocommands must not change current buffer"));
  	    curbuf->b_p_ro = TRUE;	/* must use "w!" now */
  	    return FAIL;
  	}
***************
*** 1128,1134 ****
  		    if (fd < 0)
  		    {
  			/* Re-opening the original file failed! */
! 			EMSG(_("E202: Conversion made file unreadable!"));
  			error = TRUE;
  			goto failed;
  		    }
--- 1128,1134 ----
  		    if (fd < 0)
  		    {
  			/* Re-opening the original file failed! */
! 			emsg(_("E202: Conversion made file unreadable!"));
  			error = TRUE;
  			goto failed;
  		    }
***************
*** 2993,2999 ****
  		 * option and don't free it.  bf needs hash of the key saved.
  		 * Don't ask for the key again when first time Enter was hit.
  		 * Happens when retrying to detect encoding. */
! 		smsg((char_u *)_(need_key_msg), fname);
  		msg_scroll = TRUE;
  		crypt_check_method(method);
  		cryptkey = crypt_get_key(newfile, FALSE);
--- 2993,2999 ----
  		 * option and don't free it.  bf needs hash of the key saved.
  		 * Don't ask for the key again when first time Enter was hit.
  		 * Happens when retrying to detect encoding. */
! 		smsg(_(need_key_msg), fname);
  		msg_scroll = TRUE;
  		crypt_check_method(method);
  		cryptkey = crypt_get_key(newfile, FALSE);
***************
*** 3197,3203 ****
      {
  	/* This can happen during startup when there is a stray "w" in the
  	 * vimrc file. */
! 	EMSG(_(e_emptybuf));
  	return FAIL;
      }
  
--- 3197,3203 ----
      {
  	/* This can happen during startup when there is a stray "w" in the
  	 * vimrc file. */
! 	emsg(_(e_emptybuf));
  	return FAIL;
      }
  
***************
*** 3211,3217 ****
      /* Avoid a crash for a long name. */
      if (STRLEN(fname) >= MAXPATHL)
      {
! 	EMSG(_(e_longname));
  	return FAIL;
      }
  
--- 3211,3217 ----
      /* Avoid a crash for a long name. */
      if (STRLEN(fname) >= MAXPATHL)
      {
! 	emsg(_(e_longname));
  	return FAIL;
      }
  
***************
*** 3399,3405 ****
  	    --no_wait_return;
  	    msg_scroll = msg_save;
  	    if (nofile_err)
! 		EMSG(_("E676: No matching autocommands for acwrite buffer"));
  
  	    if (nofile_err
  #ifdef FEAT_EVAL
--- 3399,3405 ----
  	    --no_wait_return;
  	    msg_scroll = msg_save;
  	    if (nofile_err)
! 		emsg(_("E676: No matching autocommands for acwrite buffer"));
  
  	    if (nofile_err
  #ifdef FEAT_EVAL
***************
*** 3434,3440 ****
  #ifdef FEAT_EVAL
  	    if (!aborting())
  #endif
! 		EMSG(_("E203: Autocommands deleted or unloaded buffer to be written"));
  	    return FAIL;
  	}
  
--- 3434,3440 ----
  #ifdef FEAT_EVAL
  	    if (!aborting())
  #endif
! 		emsg(_("E203: Autocommands deleted or unloaded buffer to be written"));
  	    return FAIL;
  	}
  
***************
*** 3457,3463 ****
  		{
  		    --no_wait_return;
  		    msg_scroll = msg_save;
! 		    EMSG(_("E204: Autocommand changed number of lines in unexpected way"));
  		    return FAIL;
  		}
  	    }
--- 3457,3463 ----
  		{
  		    --no_wait_return;
  		    msg_scroll = msg_save;
! 		    emsg(_("E204: Autocommand changed number of lines in unexpected way"));
  		    return FAIL;
  		}
  	    }
***************
*** 5055,5061 ****
  	     * the current backup file becomes the original file
  	     */
  	    if (org == NULL)
! 		EMSG(_("E205: Patchmode: can't save original file"));
  	    else if (mch_stat(org, &st) < 0)
  	    {
  		vim_rename(backup, (char_u *)org);
--- 5055,5061 ----
  	     * the current backup file becomes the original file
  	     */
  	    if (org == NULL)
! 		emsg(_("E205: Patchmode: can't save original file"));
  	    else if (mch_stat(org, &st) < 0)
  	    {
  		vim_rename(backup, (char_u *)org);
***************
*** 5077,5083 ****
  		    || (empty_fd = mch_open(org,
  				      O_CREAT | O_EXTRA | O_EXCL | O_NOFOLLOW,
  					perm < 0 ? 0666 : (perm & 0777))) < 0)
! 	      EMSG(_("E206: patchmode: can't touch empty original file"));
  	    else
  	      close(empty_fd);
  	}
--- 5077,5083 ----
  		    || (empty_fd = mch_open(org,
  				      O_CREAT | O_EXTRA | O_EXCL | O_NOFOLLOW,
  					perm < 0 ? 0666 : (perm & 0777))) < 0)
! 	      emsg(_("E206: patchmode: can't touch empty original file"));
  	    else
  	      close(empty_fd);
  	}
***************
*** 5092,5098 ****
       * Remove the backup unless 'backup' option is set
       */
      if (!p_bk && backup != NULL && mch_remove(backup) != 0)
! 	EMSG(_("E207: Can't delete backup file"));
  
  #ifdef FEAT_SUN_WORKSHOP
      if (usingSunWorkShop)
--- 5092,5098 ----
       * Remove the backup unless 'backup' option is set
       */
      if (!p_bk && backup != NULL && mch_remove(backup) != 0)
! 	emsg(_("E207: Can't delete backup file"));
  
  #ifdef FEAT_SUN_WORKSHOP
      if (usingSunWorkShop)
***************
*** 5151,5157 ****
  	    mch_memmove(IObuff, errnum, (size_t)numlen);
  	}
  	STRCAT(IObuff, errmsg);
! 	emsg(IObuff);
  	if (errmsg_allocated)
  	    vim_free(errmsg);
  
--- 5151,5157 ----
  	    mch_memmove(IObuff, errnum, (size_t)numlen);
  	}
  	STRCAT(IObuff, errmsg);
! 	emsg((char *)IObuff);
  	if (errmsg_allocated)
  	    vim_free(errmsg);
  
***************
*** 5251,5257 ****
      if (curbuf != buf)
      {
  	/* We are in another buffer now, don't do the renaming. */
! 	EMSG(_(e_auchangedbuf));
  	return FAIL;
      }
  
--- 5251,5257 ----
      if (curbuf != buf)
      {
  	/* We are in another buffer now, don't do the renaming. */
! 	emsg(_(e_auchangedbuf));
  	return FAIL;
      }
  
***************
*** 6732,6738 ****
  #endif
      if (errmsg != NULL)
      {
! 	EMSG2(errmsg, to);
  	return -1;
      }
      mch_remove(from);
--- 6732,6738 ----
  #endif
      if (errmsg != NULL)
      {
! 	semsg(errmsg, to);
  	return -1;
      }
      mch_remove(from);
***************
*** 6872,6878 ****
      int		stat_res;
      int		retval = 0;
      char_u	*path;
!     char_u	*tbuf;
      char	*mesg = NULL;
      char	*mesg2 = "";
      int		helpmesg = FALSE;
--- 6872,6878 ----
      int		stat_res;
      int		retval = 0;
      char_u	*path;
!     char	*tbuf;
      char	*mesg = NULL;
      char	*mesg2 = "";
      int		helpmesg = FALSE;
***************
*** 6983,6989 ****
  	    if (n)
  	    {
  		if (!bufref_valid(&bufref))
! 		    EMSG(_("E246: FileChangedShell autocommand deleted buffer"));
  #ifdef FEAT_EVAL
  		s = get_vim_var_str(VV_FCS_CHOICE);
  		if (STRCMP(s, "reload") == 0 && *reason != 'd')
--- 6983,6989 ----
  	    if (n)
  	    {
  		if (!bufref_valid(&bufref))
! 		    emsg(_("E246: FileChangedShell autocommand deleted buffer"));
  #ifdef FEAT_EVAL
  		s = get_vim_var_str(VV_FCS_CHOICE);
  		if (STRCMP(s, "reload") == 0 && *reason != 'd')
***************
*** 7052,7064 ****
  	{
  	    if (!helpmesg)
  		mesg2 = "";
! 	    tbuf = alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
  							+ STRLEN(mesg2) + 2));
! 	    sprintf((char *)tbuf, mesg, path);
  #ifdef FEAT_EVAL
  	    /* Set warningmsg here, before the unimportant and output-specific
  	     * mesg2 has been appended. */
! 	    set_vim_var_string(VV_WARNINGMSG, tbuf, -1);
  #endif
  #if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)
  	    if (can_reload)
--- 7052,7064 ----
  	{
  	    if (!helpmesg)
  		mesg2 = "";
! 	    tbuf = (char *)alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
  							+ STRLEN(mesg2) + 2));
! 	    sprintf(tbuf, mesg, path);
  #ifdef FEAT_EVAL
  	    /* Set warningmsg here, before the unimportant and output-specific
  	     * mesg2 has been appended. */
! 	    set_vim_var_string(VV_WARNINGMSG, (char_u *)tbuf, -1);
  #endif
  #if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)
  	    if (can_reload)
***************
*** 7068,7074 ****
  		    STRCAT(tbuf, "\n");
  		    STRCAT(tbuf, mesg2);
  		}
! 		if (do_dialog(VIM_WARNING, (char_u *)_("Warning"), tbuf,
  			  (char_u *)_("&OK\n&Load File"), 1, NULL, TRUE) == 2)
  		    reload = TRUE;
  	    }
--- 7068,7075 ----
  		    STRCAT(tbuf, "\n");
  		    STRCAT(tbuf, mesg2);
  		}
! 		if (do_dialog(VIM_WARNING, (char_u *)_("Warning"),
! 			    (char_u *)tbuf,
  			  (char_u *)_("&OK\n&Load File"), 1, NULL, TRUE) == 2)
  		    reload = TRUE;
  	    }
***************
*** 7081,7087 ****
  		    STRCAT(tbuf, "; ");
  		    STRCAT(tbuf, mesg2);
  		}
! 		EMSG(tbuf);
  		retval = 2;
  	    }
  	    else
--- 7082,7088 ----
  		    STRCAT(tbuf, "; ");
  		    STRCAT(tbuf, mesg2);
  		}
! 		emsg(tbuf);
  		retval = 2;
  	    }
  	    else
***************
*** 7089,7095 ****
  		if (!autocmd_busy)
  		{
  		    msg_start();
! 		    msg_puts_attr(tbuf, HL_ATTR(HLF_E) + MSG_HIST);
  		    if (*mesg2 != NUL)
  			msg_puts_attr((char_u *)mesg2,
  						   HL_ATTR(HLF_W) + MSG_HIST);
--- 7090,7096 ----
  		if (!autocmd_busy)
  		{
  		    msg_start();
! 		    msg_puts_attr((char_u *)tbuf, HL_ATTR(HLF_E) + MSG_HIST);
  		    if (*mesg2 != NUL)
  			msg_puts_attr((char_u *)mesg2,
  						   HL_ATTR(HLF_W) + MSG_HIST);
***************
*** 7213,7219 ****
  	    if (savebuf == NULL || saved == FAIL || buf != curbuf
  				      || move_lines(buf, savebuf) == FAIL)
  	    {
! 		EMSG2(_("E462: Could not prepare for reloading \"%s\""),
  							    buf->b_fname);
  		saved = FAIL;
  	    }
--- 7214,7220 ----
  	    if (savebuf == NULL || saved == FAIL || buf != curbuf
  				      || move_lines(buf, savebuf) == FAIL)
  	    {
! 		semsg(_("E462: Could not prepare for reloading \"%s\""),
  							    buf->b_fname);
  		saved = FAIL;
  	    }
***************
*** 7230,7236 ****
  #if defined(FEAT_EVAL)
  		if (!aborting())
  #endif
! 		    EMSG2(_("E321: Could not reload \"%s\""), buf->b_fname);
  		if (savebuf != NULL && bufref_valid(&bufref) && buf == curbuf)
  		{
  		    /* Put the text back from the save buffer.  First
--- 7231,7237 ----
  #if defined(FEAT_EVAL)
  		if (!aborting())
  #endif
! 		    semsg(_("E321: Could not reload \"%s\""), buf->b_fname);
  		if (savebuf != NULL && bufref_valid(&bufref) && buf == curbuf)
  		{
  		    /* Put the text back from the save buffer.  First
***************
*** 8076,8083 ****
  		if (p_verbose >= 6)
  		{
  		    verbose_enter();
! 		    smsg((char_u *)
! 			    _("auto-removing autocommand: %s <buffer=%d>"),
  					   event_nr2name(event), buf->b_fnum);
  		    verbose_leave();
  		}
--- 8077,8083 ----
  		if (p_verbose >= 6)
  		{
  		    verbose_enter();
! 		    smsg(_("auto-removing autocommand: %s <buffer=%d>"),
  					   event_nr2name(event), buf->b_fnum);
  		    verbose_leave();
  		}
***************
*** 8121,8129 ****
  
      i = au_find_group(name);
      if (i == AUGROUP_ERROR)	/* the group doesn't exist */
! 	EMSG2(_("E367: No such group: \"%s\""), name);
      else if (i == current_augroup)
! 	EMSG(_("E936: Cannot delete the current group"));
      else
      {
  	event_T	event;
--- 8121,8129 ----
  
      i = au_find_group(name);
      if (i == AUGROUP_ERROR)	/* the group doesn't exist */
! 	semsg(_("E367: No such group: \"%s\""), name);
      else if (i == current_augroup)
! 	emsg(_("E936: Cannot delete the current group"));
      else
      {
  	event_T	event;
***************
*** 8188,8194 ****
      if (del_group)
      {
  	if (*arg == NUL)
! 	    EMSG(_(e_argreq));
  	else
  	    au_del_group(arg);
      }
--- 8188,8194 ----
      if (del_group)
      {
  	if (*arg == NUL)
! 	    emsg(_(e_argreq));
  	else
  	    au_del_group(arg);
      }
***************
*** 8295,8301 ****
      {
  	if (arg[1] && !VIM_ISWHITE(arg[1]))
  	{
! 	    EMSG2(_("E215: Illegal character after *: %s"), arg);
  	    return NULL;
  	}
  	pat = arg + 1;
--- 8295,8301 ----
      {
  	if (arg[1] && !VIM_ISWHITE(arg[1]))
  	{
! 	    semsg(_("E215: Illegal character after *: %s"), arg);
  	    return NULL;
  	}
  	pat = arg + 1;
***************
*** 8307,8315 ****
  	    if ((int)event_name2nr(pat, &p) >= (int)NUM_EVENTS)
  	    {
  		if (have_group)
! 		    EMSG2(_("E216: No such event: %s"), pat);
  		else
! 		    EMSG2(_("E216: No such group or event: %s"), pat);
  		return NULL;
  	    }
  	}
--- 8307,8315 ----
  	    if ((int)event_name2nr(pat, &p) >= (int)NUM_EVENTS)
  	    {
  		if (have_group)
! 		    semsg(_("E216: No such event: %s"), pat);
  		else
! 		    semsg(_("E216: No such group or event: %s"), pat);
  		return NULL;
  	    }
  	}
***************
*** 8773,8779 ****
  		if (is_buflocal && (buflocal_nr == 0
  				      || buflist_findnr(buflocal_nr) == NULL))
  		{
! 		    EMSGN(_("E680: <buffer=%d>: invalid buffer number "),
  								 buflocal_nr);
  		    return FAIL;
  		}
--- 8773,8779 ----
  		if (is_buflocal && (buflocal_nr == 0
  				      || buflist_findnr(buflocal_nr) == NULL))
  		{
! 		    semsg(_("E680: <buffer=%d>: invalid buffer number "),
  								 buflocal_nr);
  		    return FAIL;
  		}
***************
*** 8876,8882 ****
  
      if (*arg == '*')
      {
! 	EMSG(_("E217: Can't execute autocommands for ALL events"));
  	return FAIL;
      }
  
--- 8876,8882 ----
  
      if (*arg == '*')
      {
! 	emsg(_("E217: Can't execute autocommands for ALL events"));
  	return FAIL;
      }
  
***************
*** 9461,9467 ****
       */
      if (nesting == 10)
      {
! 	EMSG(_("E218: autocommand nesting too deep"));
  	goto BYPASS_AU;
      }
  
--- 9461,9467 ----
       */
      if (nesting == 10)
      {
! 	emsg(_("E218: autocommand nesting too deep"));
  	goto BYPASS_AU;
      }
  
***************
*** 9869,9875 ****
  		    if (p_verbose >= 8)
  		    {
  			verbose_enter();
! 			smsg((char_u *)_("Executing %s"), sourcing_name);
  			verbose_leave();
  		    }
  		}
--- 9869,9875 ----
  		    if (p_verbose >= 8)
  		    {
  			verbose_enter();
! 			smsg(_("Executing %s"), sourcing_name);
  			verbose_leave();
  		    }
  		}
***************
*** 9935,9941 ****
      if (p_verbose >= 9)
      {
  	verbose_enter_scroll();
! 	smsg((char_u *)_("autocommand %s"), ac->cmd);
  	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  	verbose_leave_scroll();
      }
--- 9935,9941 ----
      if (p_verbose >= 9)
      {
  	verbose_enter_scroll();
! 	smsg(_("autocommand %s"), ac->cmd);
  	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  	verbose_leave_scroll();
      }
***************
*** 10483,10491 ****
      if (nested != 0)
      {
  	if (nested < 0)
! 	    EMSG(_("E219: Missing {."));
  	else
! 	    EMSG(_("E220: Missing }."));
  	VIM_CLEAR(reg_pat);
      }
      return reg_pat;
--- 10483,10491 ----
      if (nested != 0)
      {
  	if (nested < 0)
! 	    emsg(_("E219: Missing {."));
  	else
! 	    emsg(_("E220: Missing }."));
  	VIM_CLEAR(reg_pat);
      }
      return reg_pat;
*** ../vim-8.1.0742/src/fold.c	2018-11-14 21:45:28.996589969 +0100
--- src/fold.c	2019-01-13 19:49:46.021533677 +0100
***************
*** 410,416 ****
  	    (void)hasFolding(lnum, NULL, &lnum_next);
      }
      if (done == DONE_NOTHING)
! 	EMSG(_(e_nofold));
      /* Force a redraw to remove the Visual highlighting. */
      if (had_visual)
  	redraw_curbuf_later(INVERTED);
--- 410,416 ----
  	    (void)hasFolding(lnum, NULL, &lnum_next);
      }
      if (done == DONE_NOTHING)
! 	emsg(_(e_nofold));
      /* Force a redraw to remove the Visual highlighting. */
      if (had_visual)
  	redraw_curbuf_later(INVERTED);
***************
*** 561,569 ****
      if (foldmethodIsManual(curwin) || foldmethodIsMarker(curwin))
  	return TRUE;
      if (create)
! 	EMSG(_("E350: Cannot create fold with current 'foldmethod'"));
      else
! 	EMSG(_("E351: Cannot delete fold with current 'foldmethod'"));
      return FALSE;
  }
  
--- 561,569 ----
      if (foldmethodIsManual(curwin) || foldmethodIsMarker(curwin))
  	return TRUE;
      if (create)
! 	emsg(_("E350: Cannot create fold with current 'foldmethod'"));
      else
! 	emsg(_("E351: Cannot delete fold with current 'foldmethod'"));
      return FALSE;
  }
  
***************
*** 775,781 ****
      }
      if (!did_one)
      {
! 	EMSG(_(e_nofold));
  	/* Force a redraw to remove the Visual highlighting. */
  	if (had_visual)
  	    redraw_curbuf_later(INVERTED);
--- 775,781 ----
      }
      if (!did_one)
      {
! 	emsg(_(e_nofold));
  	/* Force a redraw to remove the Visual highlighting. */
  	if (had_visual)
  	    redraw_curbuf_later(INVERTED);
***************
*** 1211,1217 ****
  	{
  	    /* Only give an error message when no fold could be opened. */
  	    if (n == 0 && !(done & DONE_FOLD))
! 		EMSG(_(e_nofold));
  	    break;
  	}
      }
--- 1211,1217 ----
  	{
  	    /* Only give an error message when no fold could be opened. */
  	    if (n == 0 && !(done & DONE_FOLD))
! 		emsg(_(e_nofold));
  	    break;
  	}
      }
***************
*** 1363,1369 ****
  	done |= DONE_FOLD;
      }
      else if (donep == NULL && wp == curwin)
! 	EMSG(_(e_nofold));
  
      if (donep != NULL)
  	*donep |= done;
--- 1363,1369 ----
  	done |= DONE_FOLD;
      }
      else if (donep == NULL && wp == curwin)
! 	emsg(_(e_nofold));
  
      if (donep != NULL)
  	*donep |= done;
***************
*** 1735,1741 ****
  {
      if (!curbuf->b_p_ma)
      {
! 	EMSG(_(e_modifiable));
  	return;
      }
      parseMarker(curwin);
--- 1735,1741 ----
  {
      if (!curbuf->b_p_ma)
      {
! 	emsg(_(e_modifiable));
  	return;
      }
      parseMarker(curwin);
*** ../vim-8.1.0742/src/getchar.c	2018-10-07 23:16:33.134616234 +0200
--- src/getchar.c	2019-01-13 19:49:56.993431369 +0100
***************
*** 237,243 ****
      }
      else if (buf->bh_curr == NULL)	/* buffer has already been read */
      {
! 	IEMSG(_("E222: Add to read buffer"));
  	return;
      }
      else if (buf->bh_index != 0)
--- 237,243 ----
      }
      else if (buf->bh_curr == NULL)	/* buffer has already been read */
      {
! 	iemsg(_("E222: Add to read buffer"));
  	return;
      }
      else if (buf->bh_index != 0)
***************
*** 998,1004 ****
  	newlen = typebuf.tb_len + addlen + newoff + 4 * (MAXMAPLEN + 4);
  	if (newlen < 0)		    /* string is getting too long */
  	{
! 	    EMSG(_(e_toocompl));    /* also calls flush_buffers */
  	    setcursor();
  	    return FAIL;
  	}
--- 998,1004 ----
  	newlen = typebuf.tb_len + addlen + newoff + 4 * (MAXMAPLEN + 4);
  	if (newlen < 0)		    /* string is getting too long */
  	{
! 	    emsg(_(e_toocompl));    /* also calls flush_buffers */
  	    setcursor();
  	    return FAIL;
  	}
***************
*** 1431,1437 ****
  {
      if (curscript + 1 == NSCRIPT)
      {
! 	EMSG(_(e_nesting));
  	return;
      }
  #ifdef FEAT_EVAL
--- 1431,1437 ----
  {
      if (curscript + 1 == NSCRIPT)
      {
! 	emsg(_(e_nesting));
  	return;
      }
  #ifdef FEAT_EVAL
***************
*** 1446,1452 ****
      expand_env(name, NameBuff, MAXPATHL);
      if ((scriptin[curscript] = mch_fopen((char *)NameBuff, READBIN)) == NULL)
      {
! 	EMSG2(_(e_notopen), name);
  	if (curscript)
  	    --curscript;
  	return;
--- 1446,1452 ----
      expand_env(name, NameBuff, MAXPATHL);
      if ((scriptin[curscript] = mch_fopen((char *)NameBuff, READBIN)) == NULL)
      {
! 	semsg(_(e_notopen), name);
  	if (curscript)
  	    --curscript;
  	return;
***************
*** 2508,2514 ****
  			 */
  			if (++mapdepth >= p_mmd)
  			{
! 			    EMSG(_("E223: recursive mapping"));
  			    if (State & CMDLINE)
  				redrawcmdline();
  			    else
--- 2508,2514 ----
  			 */
  			if (++mapdepth >= p_mmd)
  			{
! 			    emsg(_("E223: recursive mapping"));
  			    if (State & CMDLINE)
  				redrawcmdline();
  			    else
***************
*** 3508,3517 ****
  			&& STRNCMP(mp->m_keys, keys, (size_t)len) == 0)
  		{
  		    if (abbrev)
! 			EMSG2(_("E224: global abbreviation already exists for %s"),
  				mp->m_keys);
  		    else
! 			EMSG2(_("E225: global mapping already exists for %s"),
  				mp->m_keys);
  		    retval = 5;
  		    goto theend;
--- 3508,3517 ----
  			&& STRNCMP(mp->m_keys, keys, (size_t)len) == 0)
  		{
  		    if (abbrev)
! 			semsg(_("E224: global abbreviation already exists for %s"),
  				mp->m_keys);
  		    else
! 			semsg(_("E225: global mapping already exists for %s"),
  				mp->m_keys);
  		    retval = 5;
  		    goto theend;
***************
*** 3643,3652 ****
  			else if (unique)
  			{
  			    if (abbrev)
! 				EMSG2(_("E226: abbreviation already exists for %s"),
  									   p);
  			    else
! 				EMSG2(_("E227: mapping already exists for %s"), p);
  			    retval = 5;
  			    goto theend;
  			}
--- 3643,3652 ----
  			else if (unique)
  			{
  			    if (abbrev)
! 				semsg(_("E226: abbreviation already exists for %s"),
  									   p);
  			    else
! 				semsg(_("E227: mapping already exists for %s"), p);
  			    retval = 5;
  			    goto theend;
  			}
***************
*** 3892,3898 ****
      local = (STRCMP(arg, "<buffer>") == 0);
      if (!local && *arg != NUL)
      {
! 	EMSG(_(e_invarg));
  	return;
      }
  #endif
--- 3892,3898 ----
      local = (STRCMP(arg, "<buffer>") == 0);
      if (!local && *arg != NUL)
      {
! 	emsg(_(e_invarg));
  	return;
      }
  #endif
***************
*** 4920,4926 ****
  			c1 = 't';
  			break;
  		    default:
! 			IEMSG(_("E228: makemap: Illegal mode"));
  			return FAIL;
  		}
  		do	/* do this twice if c2 is set, 3 times with c3 */
--- 4920,4926 ----
  			c1 = 't';
  			break;
  		    default:
! 			iemsg(_("E228: makemap: Illegal mode"));
  			return FAIL;
  		}
  		do	/* do this twice if c2 is set, 3 times with c3 */
*** ../vim-8.1.0742/src/globals.h	2019-01-12 22:47:01.264088074 +0100
--- src/globals.h	2019-01-13 20:05:39.345471559 +0100
***************
*** 1391,1444 ****
   * The error messages that can be shared are included here.
   * Excluded are errors that are only used once and debugging messages.
   */
! EXTERN char_u e_abort[]		INIT(= N_("E470: Command aborted"));
! EXTERN char_u e_argreq[]	INIT(= N_("E471: Argument required"));
! EXTERN char_u e_backslash[]	INIT(= N_("E10: \\ should be followed by /, ? or &"));
  #ifdef FEAT_CMDWIN
! EXTERN char_u e_cmdwin[]	INIT(= N_("E11: Invalid in command-line window; <CR> executes, CTRL-C quits"));
  #endif
! EXTERN char_u e_curdir[]	INIT(= N_("E12: Command not allowed from exrc/vimrc in current dir or tag search"));
  #ifdef FEAT_EVAL
! EXTERN char_u e_endif[]		INIT(= N_("E171: Missing :endif"));
! EXTERN char_u e_endtry[]	INIT(= N_("E600: Missing :endtry"));
! EXTERN char_u e_endwhile[]	INIT(= N_("E170: Missing :endwhile"));
! EXTERN char_u e_endfor[]	INIT(= N_("E170: Missing :endfor"));
! EXTERN char_u e_while[]		INIT(= N_("E588: :endwhile without :while"));
! EXTERN char_u e_for[]		INIT(= N_("E588: :endfor without :for"));
  #endif
! EXTERN char_u e_exists[]	INIT(= N_("E13: File exists (add ! to override)"));
! EXTERN char_u e_failed[]	INIT(= N_("E472: Command failed"));
  #if defined(FEAT_GUI) && defined(FEAT_XFONTSET)
! EXTERN char_u e_fontset[]	INIT(= N_("E234: Unknown fontset: %s"));
  #endif
  #if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_MAC) \
  	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MSWIN)
! EXTERN char_u e_font[]		INIT(= N_("E235: Unknown font: %s"));
  #endif
  #if defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)
! EXTERN char_u e_fontwidth[]	INIT(= N_("E236: Font \"%s\" is not fixed-width"));
  #endif
! EXTERN char_u e_internal[]	INIT(= N_("E473: Internal error"));
! EXTERN char_u e_intern2[]	INIT(= N_("E685: Internal error: %s"));
! EXTERN char_u e_interr[]	INIT(= N_("Interrupted"));
! EXTERN char_u e_invaddr[]	INIT(= N_("E14: Invalid address"));
! EXTERN char_u e_invarg[]	INIT(= N_("E474: Invalid argument"));
! EXTERN char_u e_invarg2[]	INIT(= N_("E475: Invalid argument: %s"));
! EXTERN char_u e_invargval[]	INIT(= N_("E475: Invalid value for argument %s"));
! EXTERN char_u e_invargNval[]	INIT(= N_("E475: Invalid value for argument %s: %s"));
  #ifdef FEAT_EVAL
! EXTERN char_u e_invexpr2[]	INIT(= N_("E15: Invalid expression: %s"));
  #endif
! EXTERN char_u e_invrange[]	INIT(= N_("E16: Invalid range"));
! EXTERN char_u e_invcmd[]	INIT(= N_("E476: Invalid command"));
  #if defined(UNIX) || defined(FEAT_SYN_HL) || defined(FEAT_SPELL)
! EXTERN char_u e_isadir2[]	INIT(= N_("E17: \"%s\" is a directory"));
  #endif
  #ifdef FEAT_LIBCALL
! EXTERN char_u e_libcall[]	INIT(= N_("E364: Library call failed for \"%s()\""));
  #endif
  #ifdef HAVE_FSYNC
! EXTERN char_u e_fsync[]		INIT(= N_("E667: Fsync failed"));
  #endif
  #if defined(DYNAMIC_PERL) \
  	|| defined(DYNAMIC_PYTHON) || defined(DYNAMIC_PYTHON3) \
--- 1391,1444 ----
   * The error messages that can be shared are included here.
   * Excluded are errors that are only used once and debugging messages.
   */
! EXTERN char e_abort[]		INIT(= N_("E470: Command aborted"));
! EXTERN char e_argreq[]	INIT(= N_("E471: Argument required"));
! EXTERN char e_backslash[]	INIT(= N_("E10: \\ should be followed by /, ? or &"));
  #ifdef FEAT_CMDWIN
! EXTERN char e_cmdwin[]	INIT(= N_("E11: Invalid in command-line window; <CR> executes, CTRL-C quits"));
  #endif
! EXTERN char e_curdir[]	INIT(= N_("E12: Command not allowed from exrc/vimrc in current dir or tag search"));
  #ifdef FEAT_EVAL
! EXTERN char e_endif[]		INIT(= N_("E171: Missing :endif"));
! EXTERN char e_endtry[]	INIT(= N_("E600: Missing :endtry"));
! EXTERN char e_endwhile[]	INIT(= N_("E170: Missing :endwhile"));
! EXTERN char e_endfor[]	INIT(= N_("E170: Missing :endfor"));
! EXTERN char e_while[]		INIT(= N_("E588: :endwhile without :while"));
! EXTERN char e_for[]		INIT(= N_("E588: :endfor without :for"));
  #endif
! EXTERN char e_exists[]	INIT(= N_("E13: File exists (add ! to override)"));
! EXTERN char e_failed[]	INIT(= N_("E472: Command failed"));
  #if defined(FEAT_GUI) && defined(FEAT_XFONTSET)
! EXTERN char e_fontset[]	INIT(= N_("E234: Unknown fontset: %s"));
  #endif
  #if defined(FEAT_GUI_X11) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_MAC) \
  	|| defined(FEAT_GUI_PHOTON) || defined(FEAT_GUI_MSWIN)
! EXTERN char e_font[]		INIT(= N_("E235: Unknown font: %s"));
  #endif
  #if defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)
! EXTERN char e_fontwidth[]	INIT(= N_("E236: Font \"%s\" is not fixed-width"));
  #endif
! EXTERN char e_internal[]	INIT(= N_("E473: Internal error"));
! EXTERN char e_intern2[]	INIT(= N_("E685: Internal error: %s"));
! EXTERN char e_interr[]	INIT(= N_("Interrupted"));
! EXTERN char e_invaddr[]	INIT(= N_("E14: Invalid address"));
! EXTERN char e_invarg[]	INIT(= N_("E474: Invalid argument"));
! EXTERN char e_invarg2[]	INIT(= N_("E475: Invalid argument: %s"));
! EXTERN char e_invargval[]	INIT(= N_("E475: Invalid value for argument %s"));
! EXTERN char e_invargNval[]	INIT(= N_("E475: Invalid value for argument %s: %s"));
  #ifdef FEAT_EVAL
! EXTERN char e_invexpr2[]	INIT(= N_("E15: Invalid expression: %s"));
  #endif
! EXTERN char e_invrange[]	INIT(= N_("E16: Invalid range"));
! EXTERN char e_invcmd[]	INIT(= N_("E476: Invalid command"));
  #if defined(UNIX) || defined(FEAT_SYN_HL) || defined(FEAT_SPELL)
! EXTERN char e_isadir2[]	INIT(= N_("E17: \"%s\" is a directory"));
  #endif
  #ifdef FEAT_LIBCALL
! EXTERN char e_libcall[]	INIT(= N_("E364: Library call failed for \"%s()\""));
  #endif
  #ifdef HAVE_FSYNC
! EXTERN char e_fsync[]		INIT(= N_("E667: Fsync failed"));
  #endif
  #if defined(DYNAMIC_PERL) \
  	|| defined(DYNAMIC_PYTHON) || defined(DYNAMIC_PYTHON3) \
***************
*** 1448,1592 ****
  	|| defined(DYNAMIC_GETTEXT) \
  	|| defined(DYNAMIC_MZSCHEME) \
  	|| defined(DYNAMIC_LUA)
! EXTERN char_u e_loadlib[]	INIT(= N_("E370: Could not load library %s"));
! EXTERN char_u e_loadfunc[]	INIT(= N_("E448: Could not load library function %s"));
  #endif
! EXTERN char_u e_markinval[]	INIT(= N_("E19: Mark has invalid line number"));
! EXTERN char_u e_marknotset[]	INIT(= N_("E20: Mark not set"));
! EXTERN char_u e_modifiable[]	INIT(= N_("E21: Cannot make changes, 'modifiable' is off"));
! EXTERN char_u e_nesting[]	INIT(= N_("E22: Scripts nested too deep"));
! EXTERN char_u e_noalt[]		INIT(= N_("E23: No alternate file"));
! EXTERN char_u e_noabbr[]	INIT(= N_("E24: No such abbreviation"));
! EXTERN char_u e_nobang[]	INIT(= N_("E477: No ! allowed"));
  #ifndef FEAT_GUI
! EXTERN char_u e_nogvim[]	INIT(= N_("E25: GUI cannot be used: Not enabled at compile time"));
  #endif
  #ifndef FEAT_RIGHTLEFT
! EXTERN char_u e_nohebrew[]	INIT(= N_("E26: Hebrew cannot be used: Not enabled at compile time\n"));
  #endif
  #ifndef FEAT_FKMAP
! EXTERN char_u e_nofarsi[]	INIT(= N_("E27: Farsi cannot be used: Not enabled at compile time\n"));
  #endif
  #ifndef FEAT_ARABIC
! EXTERN char_u e_noarabic[]	INIT(= N_("E800: Arabic cannot be used: Not enabled at compile time\n"));
  #endif
  #if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_SYN_HL)
! EXTERN char_u e_nogroup[]	INIT(= N_("E28: No such highlight group name: %s"));
  #endif
! EXTERN char_u e_noinstext[]	INIT(= N_("E29: No inserted text yet"));
! EXTERN char_u e_nolastcmd[]	INIT(= N_("E30: No previous command line"));
! EXTERN char_u e_nomap[]		INIT(= N_("E31: No such mapping"));
! EXTERN char_u e_nomatch[]	INIT(= N_("E479: No match"));
! EXTERN char_u e_nomatch2[]	INIT(= N_("E480: No match: %s"));
! EXTERN char_u e_noname[]	INIT(= N_("E32: No file name"));
! EXTERN char_u e_nopresub[]	INIT(= N_("E33: No previous substitute regular expression"));
! EXTERN char_u e_noprev[]	INIT(= N_("E34: No previous command"));
! EXTERN char_u e_noprevre[]	INIT(= N_("E35: No previous regular expression"));
! EXTERN char_u e_norange[]	INIT(= N_("E481: No range allowed"));
! EXTERN char_u e_noroom[]	INIT(= N_("E36: Not enough room"));
  #ifdef FEAT_CLIENTSERVER
! EXTERN char_u e_noserver[]	INIT(= N_("E247: no registered server named \"%s\""));
  #endif
! EXTERN char_u e_notcreate[]	INIT(= N_("E482: Can't create file %s"));
! EXTERN char_u e_notmp[]		INIT(= N_("E483: Can't get temp file name"));
! EXTERN char_u e_notopen[]	INIT(= N_("E484: Can't open file %s"));
! EXTERN char_u e_notread[]	INIT(= N_("E485: Can't read file %s"));
! EXTERN char_u e_null[]		INIT(= N_("E38: Null argument"));
  #if defined(FEAT_DIGRAPHS) || defined(FEAT_TIMERS)
! EXTERN char_u e_number_exp[]	INIT(= N_("E39: Number expected"));
  #endif
  #ifdef FEAT_QUICKFIX
! EXTERN char_u e_openerrf[]	INIT(= N_("E40: Can't open errorfile %s"));
  #endif
  #if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)
! EXTERN char_u e_opendisp[]	INIT(= N_("E233: cannot open display"));
  #endif
! EXTERN char_u e_outofmem[]	INIT(= N_("E41: Out of memory!"));
  #ifdef FEAT_INS_EXPAND
! EXTERN char_u e_patnotf[]	INIT(= N_("Pattern not found"));
  #endif
! EXTERN char_u e_patnotf2[]	INIT(= N_("E486: Pattern not found: %s"));
! EXTERN char_u e_positive[]	INIT(= N_("E487: Argument must be positive"));
  #if defined(UNIX) || defined(FEAT_SESSION)
! EXTERN char_u e_prev_dir[]	INIT(= N_("E459: Cannot go back to previous directory"));
  #endif
  
  #ifdef FEAT_QUICKFIX
! EXTERN char_u e_quickfix[]	INIT(= N_("E42: No Errors"));
! EXTERN char_u e_loclist[]	INIT(= N_("E776: No location list"));
  #endif
! EXTERN char_u e_re_damg[]	INIT(= N_("E43: Damaged match string"));
! EXTERN char_u e_re_corr[]	INIT(= N_("E44: Corrupted regexp program"));
! EXTERN char_u e_readonly[]	INIT(= N_("E45: 'readonly' option is set (add ! to override)"));
  #ifdef FEAT_EVAL
! EXTERN char_u e_readonlyvar[]	INIT(= N_("E46: Cannot change read-only variable \"%s\""));
! EXTERN char_u e_readonlysbx[]	INIT(= N_("E794: Cannot set variable in the sandbox: \"%s\""));
! EXTERN char_u e_emptykey[]	INIT(= N_("E713: Cannot use empty key for Dictionary"));
! EXTERN char_u e_dictreq[]	INIT(= N_("E715: Dictionary required"));
! EXTERN char_u e_listidx[]	INIT(= N_("E684: list index out of range: %ld"));
! EXTERN char_u e_blobidx[]	INIT(= N_("E979: Blob index out of range: %ld"));
! EXTERN char_u e_invalblob[]	INIT(= N_("E978: Invalid operation for Blob"));
! EXTERN char_u e_toomanyarg[]	INIT(= N_("E118: Too many arguments for function: %s"));
! EXTERN char_u e_dictkey[]	INIT(= N_("E716: Key not present in Dictionary: %s"));
! EXTERN char_u e_listreq[]	INIT(= N_("E714: List required"));
! EXTERN char_u e_listdictarg[]	INIT(= N_("E712: Argument of %s must be a List or Dictionary"));
  #endif
  #ifdef FEAT_QUICKFIX
! EXTERN char_u e_readerrf[]	INIT(= N_("E47: Error while reading errorfile"));
  #endif
  #ifdef HAVE_SANDBOX
! EXTERN char_u e_sandbox[]	INIT(= N_("E48: Not allowed in sandbox"));
  #endif
! EXTERN char_u e_secure[]	INIT(= N_("E523: Not allowed here"));
  #if defined(AMIGA) || defined(MACOS_X) || defined(MSWIN)  \
  	|| defined(UNIX) || defined(VMS)
! EXTERN char_u e_screenmode[]	INIT(= N_("E359: Screen mode setting not supported"));
  #endif
! EXTERN char_u e_scroll[]	INIT(= N_("E49: Invalid scroll size"));
! EXTERN char_u e_shellempty[]	INIT(= N_("E91: 'shell' option is empty"));
  #if defined(FEAT_SIGN_ICONS) && !defined(FEAT_GUI_GTK)
! EXTERN char_u e_signdata[]	INIT(= N_("E255: Couldn't read in sign data!"));
  #endif
! EXTERN char_u e_swapclose[]	INIT(= N_("E72: Close error on swap file"));
! EXTERN char_u e_tagstack[]	INIT(= N_("E73: tag stack empty"));
! EXTERN char_u e_toocompl[]	INIT(= N_("E74: Command too complex"));
! EXTERN char_u e_longname[]	INIT(= N_("E75: Name too long"));
! EXTERN char_u e_toomsbra[]	INIT(= N_("E76: Too many ["));
! EXTERN char_u e_toomany[]	INIT(= N_("E77: Too many file names"));
! EXTERN char_u e_trailing[]	INIT(= N_("E488: Trailing characters"));
! EXTERN char_u e_umark[]		INIT(= N_("E78: Unknown mark"));
! EXTERN char_u e_wildexpand[]	INIT(= N_("E79: Cannot expand wildcards"));
! EXTERN char_u e_winheight[]	INIT(= N_("E591: 'winheight' cannot be smaller than 'winminheight'"));
! EXTERN char_u e_winwidth[]	INIT(= N_("E592: 'winwidth' cannot be smaller than 'winminwidth'"));
! EXTERN char_u e_write[]		INIT(= N_("E80: Error while writing"));
! EXTERN char_u e_zerocount[]	INIT(= N_("E939: Positive count required"));
  #ifdef FEAT_EVAL
! EXTERN char_u e_usingsid[]	INIT(= N_("E81: Using <SID> not in a script context"));
  #endif
  #ifdef FEAT_CLIENTSERVER
! EXTERN char_u e_invexprmsg[]	INIT(= N_("E449: Invalid expression received"));
  #endif
  #ifdef FEAT_NETBEANS_INTG
! EXTERN char_u e_guarded[]	INIT(= N_("E463: Region is guarded, cannot modify"));
! EXTERN char_u e_nbreadonly[]	INIT(= N_("E744: NetBeans does not allow changes in read-only files"));
  #endif
! EXTERN char_u e_maxmempat[]	INIT(= N_("E363: pattern uses more memory than 'maxmempattern'"));
! EXTERN char_u e_emptybuf[]	INIT(= N_("E749: empty buffer"));
! EXTERN char_u e_nobufnr[]	INIT(= N_("E86: Buffer %ld does not exist"));
  
! EXTERN char_u e_invalpat[]	INIT(= N_("E682: Invalid search pattern or delimiter"));
! EXTERN char_u e_bufloaded[]	INIT(= N_("E139: File is loaded in another buffer"));
  #if defined(FEAT_SYN_HL) || \
  	(defined(FEAT_INS_EXPAND) && defined(FEAT_COMPL_FUNC))
! EXTERN char_u e_notset[]	INIT(= N_("E764: Option '%s' is not set"));
  #endif
  #ifndef FEAT_CLIPBOARD
! EXTERN char_u e_invalidreg[]    INIT(= N_("E850: Invalid register name"));
  #endif
! EXTERN char_u e_dirnotf[]	INIT(= N_("E919: Directory not found in '%s': \"%s\""));
! EXTERN char_u e_au_recursive[]	INIT(= N_("E952: Autocommand caused recursive behavior"));
  #ifdef FEAT_MENU
! EXTERN char_u e_menuothermode[] INIT(= N_("E328: Menu only exists in another mode"));
  #endif
  
  #ifdef FEAT_GUI_MAC
--- 1448,1592 ----
  	|| defined(DYNAMIC_GETTEXT) \
  	|| defined(DYNAMIC_MZSCHEME) \
  	|| defined(DYNAMIC_LUA)
! EXTERN char e_loadlib[]	INIT(= N_("E370: Could not load library %s"));
! EXTERN char e_loadfunc[]	INIT(= N_("E448: Could not load library function %s"));
  #endif
! EXTERN char e_markinval[]	INIT(= N_("E19: Mark has invalid line number"));
! EXTERN char e_marknotset[]	INIT(= N_("E20: Mark not set"));
! EXTERN char e_modifiable[]	INIT(= N_("E21: Cannot make changes, 'modifiable' is off"));
! EXTERN char e_nesting[]	INIT(= N_("E22: Scripts nested too deep"));
! EXTERN char e_noalt[]		INIT(= N_("E23: No alternate file"));
! EXTERN char e_noabbr[]	INIT(= N_("E24: No such abbreviation"));
! EXTERN char e_nobang[]	INIT(= N_("E477: No ! allowed"));
  #ifndef FEAT_GUI
! EXTERN char e_nogvim[]	INIT(= N_("E25: GUI cannot be used: Not enabled at compile time"));
  #endif
  #ifndef FEAT_RIGHTLEFT
! EXTERN char e_nohebrew[]	INIT(= N_("E26: Hebrew cannot be used: Not enabled at compile time\n"));
  #endif
  #ifndef FEAT_FKMAP
! EXTERN char e_nofarsi[]	INIT(= N_("E27: Farsi cannot be used: Not enabled at compile time\n"));
  #endif
  #ifndef FEAT_ARABIC
! EXTERN char e_noarabic[]	INIT(= N_("E800: Arabic cannot be used: Not enabled at compile time\n"));
  #endif
  #if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_SYN_HL)
! EXTERN char e_nogroup[]	INIT(= N_("E28: No such highlight group name: %s"));
  #endif
! EXTERN char e_noinstext[]	INIT(= N_("E29: No inserted text yet"));
! EXTERN char e_nolastcmd[]	INIT(= N_("E30: No previous command line"));
! EXTERN char e_nomap[]		INIT(= N_("E31: No such mapping"));
! EXTERN char e_nomatch[]	INIT(= N_("E479: No match"));
! EXTERN char e_nomatch2[]	INIT(= N_("E480: No match: %s"));
! EXTERN char e_noname[]	INIT(= N_("E32: No file name"));
! EXTERN char e_nopresub[]	INIT(= N_("E33: No previous substitute regular expression"));
! EXTERN char e_noprev[]	INIT(= N_("E34: No previous command"));
! EXTERN char e_noprevre[]	INIT(= N_("E35: No previous regular expression"));
! EXTERN char e_norange[]	INIT(= N_("E481: No range allowed"));
! EXTERN char e_noroom[]	INIT(= N_("E36: Not enough room"));
  #ifdef FEAT_CLIENTSERVER
! EXTERN char e_noserver[]	INIT(= N_("E247: no registered server named \"%s\""));
  #endif
! EXTERN char e_notcreate[]	INIT(= N_("E482: Can't create file %s"));
! EXTERN char e_notmp[]		INIT(= N_("E483: Can't get temp file name"));
! EXTERN char e_notopen[]	INIT(= N_("E484: Can't open file %s"));
! EXTERN char e_notread[]	INIT(= N_("E485: Can't read file %s"));
! EXTERN char e_null[]		INIT(= N_("E38: Null argument"));
  #if defined(FEAT_DIGRAPHS) || defined(FEAT_TIMERS)
! EXTERN char e_number_exp[]	INIT(= N_("E39: Number expected"));
  #endif
  #ifdef FEAT_QUICKFIX
! EXTERN char e_openerrf[]	INIT(= N_("E40: Can't open errorfile %s"));
  #endif
  #if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)
! EXTERN char e_opendisp[]	INIT(= N_("E233: cannot open display"));
  #endif
! EXTERN char e_outofmem[]	INIT(= N_("E41: Out of memory!"));
  #ifdef FEAT_INS_EXPAND
! EXTERN char e_patnotf[]	INIT(= N_("Pattern not found"));
  #endif
! EXTERN char e_patnotf2[]	INIT(= N_("E486: Pattern not found: %s"));
! EXTERN char e_positive[]	INIT(= N_("E487: Argument must be positive"));
  #if defined(UNIX) || defined(FEAT_SESSION)
! EXTERN char e_prev_dir[]	INIT(= N_("E459: Cannot go back to previous directory"));
  #endif
  
  #ifdef FEAT_QUICKFIX
! EXTERN char e_quickfix[]	INIT(= N_("E42: No Errors"));
! EXTERN char e_loclist[]	INIT(= N_("E776: No location list"));
  #endif
! EXTERN char e_re_damg[]	INIT(= N_("E43: Damaged match string"));
! EXTERN char e_re_corr[]	INIT(= N_("E44: Corrupted regexp program"));
! EXTERN char e_readonly[]	INIT(= N_("E45: 'readonly' option is set (add ! to override)"));
  #ifdef FEAT_EVAL
! EXTERN char e_readonlyvar[]	INIT(= N_("E46: Cannot change read-only variable \"%s\""));
! EXTERN char e_readonlysbx[]	INIT(= N_("E794: Cannot set variable in the sandbox: \"%s\""));
! EXTERN char e_emptykey[]	INIT(= N_("E713: Cannot use empty key for Dictionary"));
! EXTERN char e_dictreq[]	INIT(= N_("E715: Dictionary required"));
! EXTERN char e_listidx[]	INIT(= N_("E684: list index out of range: %ld"));
! EXTERN char e_blobidx[]	INIT(= N_("E979: Blob index out of range: %ld"));
! EXTERN char e_invalblob[]	INIT(= N_("E978: Invalid operation for Blob"));
! EXTERN char e_toomanyarg[]	INIT(= N_("E118: Too many arguments for function: %s"));
! EXTERN char e_dictkey[]	INIT(= N_("E716: Key not present in Dictionary: %s"));
! EXTERN char e_listreq[]	INIT(= N_("E714: List required"));
! EXTERN char e_listdictarg[]	INIT(= N_("E712: Argument of %s must be a List or Dictionary"));
  #endif
  #ifdef FEAT_QUICKFIX
! EXTERN char e_readerrf[]	INIT(= N_("E47: Error while reading errorfile"));
  #endif
  #ifdef HAVE_SANDBOX
! EXTERN char e_sandbox[]	INIT(= N_("E48: Not allowed in sandbox"));
  #endif
! EXTERN char e_secure[]	INIT(= N_("E523: Not allowed here"));
  #if defined(AMIGA) || defined(MACOS_X) || defined(MSWIN)  \
  	|| defined(UNIX) || defined(VMS)
! EXTERN char e_screenmode[]	INIT(= N_("E359: Screen mode setting not supported"));
  #endif
! EXTERN char e_scroll[]	INIT(= N_("E49: Invalid scroll size"));
! EXTERN char e_shellempty[]	INIT(= N_("E91: 'shell' option is empty"));
  #if defined(FEAT_SIGN_ICONS) && !defined(FEAT_GUI_GTK)
! EXTERN char e_signdata[]	INIT(= N_("E255: Couldn't read in sign data!"));
  #endif
! EXTERN char e_swapclose[]	INIT(= N_("E72: Close error on swap file"));
! EXTERN char e_tagstack[]	INIT(= N_("E73: tag stack empty"));
! EXTERN char e_toocompl[]	INIT(= N_("E74: Command too complex"));
! EXTERN char e_longname[]	INIT(= N_("E75: Name too long"));
! EXTERN char e_toomsbra[]	INIT(= N_("E76: Too many ["));
! EXTERN char e_toomany[]	INIT(= N_("E77: Too many file names"));
! EXTERN char e_trailing[]	INIT(= N_("E488: Trailing characters"));
! EXTERN char e_umark[]		INIT(= N_("E78: Unknown mark"));
! EXTERN char e_wildexpand[]	INIT(= N_("E79: Cannot expand wildcards"));
! EXTERN char e_winheight[]	INIT(= N_("E591: 'winheight' cannot be smaller than 'winminheight'"));
! EXTERN char e_winwidth[]	INIT(= N_("E592: 'winwidth' cannot be smaller than 'winminwidth'"));
! EXTERN char e_write[]		INIT(= N_("E80: Error while writing"));
! EXTERN char e_zerocount[]	INIT(= N_("E939: Positive count required"));
  #ifdef FEAT_EVAL
! EXTERN char e_usingsid[]	INIT(= N_("E81: Using <SID> not in a script context"));
  #endif
  #ifdef FEAT_CLIENTSERVER
! EXTERN char e_invexprmsg[]	INIT(= N_("E449: Invalid expression received"));
  #endif
  #ifdef FEAT_NETBEANS_INTG
! EXTERN char e_guarded[]	INIT(= N_("E463: Region is guarded, cannot modify"));
! EXTERN char e_nbreadonly[]	INIT(= N_("E744: NetBeans does not allow changes in read-only files"));
  #endif
! EXTERN char e_maxmempat[]	INIT(= N_("E363: pattern uses more memory than 'maxmempattern'"));
! EXTERN char e_emptybuf[]	INIT(= N_("E749: empty buffer"));
! EXTERN char e_nobufnr[]	INIT(= N_("E86: Buffer %ld does not exist"));
  
! EXTERN char e_invalpat[]	INIT(= N_("E682: Invalid search pattern or delimiter"));
! EXTERN char e_bufloaded[]	INIT(= N_("E139: File is loaded in another buffer"));
  #if defined(FEAT_SYN_HL) || \
  	(defined(FEAT_INS_EXPAND) && defined(FEAT_COMPL_FUNC))
! EXTERN char e_notset[]	INIT(= N_("E764: Option '%s' is not set"));
  #endif
  #ifndef FEAT_CLIPBOARD
! EXTERN char e_invalidreg[]    INIT(= N_("E850: Invalid register name"));
  #endif
! EXTERN char e_dirnotf[]	INIT(= N_("E919: Directory not found in '%s': \"%s\""));
! EXTERN char e_au_recursive[]	INIT(= N_("E952: Autocommand caused recursive behavior"));
  #ifdef FEAT_MENU
! EXTERN char e_menuothermode[] INIT(= N_("E328: Menu only exists in another mode"));
  #endif
  
  #ifdef FEAT_GUI_MAC
*** ../vim-8.1.0742/src/gui.c	2019-01-11 20:34:18.296314730 +0100
--- src/gui.c	2019-01-13 19:50:04.537361241 +0100
***************
*** 215,221 ****
      pid = fork();
      if (pid < 0)	    /* Fork error */
      {
! 	EMSG(_("E851: Failed to create a new process for the GUI"));
  	return;
      }
      else if (pid > 0)	    /* Parent */
--- 215,221 ----
      pid = fork();
      if (pid < 0)	    /* Fork error */
      {
! 	emsg(_("E851: Failed to create a new process for the GUI"));
  	return;
      }
      else if (pid > 0)	    /* Parent */
***************
*** 239,245 ****
  # else
  		waitpid(pid, &exit_status, 0);
  # endif
! 		EMSG(_("E852: The child process failed to start the GUI"));
  		return;
  	    }
  	    else if (status == GUI_CHILD_IO_ERROR)
--- 239,245 ----
  # else
  		waitpid(pid, &exit_status, 0);
  # endif
! 		emsg(_("E852: The child process failed to start the GUI"));
  		return;
  	    }
  	    else if (status == GUI_CHILD_IO_ERROR)
***************
*** 362,368 ****
      if (result != MAYBE)
      {
  	if (result == FAIL)
! 	    EMSG(_("E229: Cannot start the GUI"));
  	return result;
      }
  
--- 362,368 ----
      if (result != MAYBE)
      {
  	if (result == FAIL)
! 	    emsg(_("E229: Cannot start the GUI"));
  	return result;
      }
  
***************
*** 515,521 ****
  	    if (STRCMP(use_gvimrc, "NONE") != 0
  		    && STRCMP(use_gvimrc, "NORC") != 0
  		    && do_source(use_gvimrc, FALSE, DOSO_NONE) != OK)
! 		EMSG2(_("E230: Cannot read from \"%s\""), use_gvimrc);
  	}
  	else
  	{
--- 515,521 ----
  	    if (STRCMP(use_gvimrc, "NONE") != 0
  		    && STRCMP(use_gvimrc, "NORC") != 0
  		    && do_source(use_gvimrc, FALSE, DOSO_NONE) != OK)
! 		semsg(_("E230: Cannot read from \"%s\""), use_gvimrc);
  	}
  	else
  	{
***************
*** 649,660 ****
  	    gui_init_font(*p_guifont == NUL ? hl_get_font_name()
  						  : p_guifont, FALSE) == FAIL)
      {
! 	EMSG(_("E665: Cannot start GUI, no valid font found"));
  	goto error2;
      }
  #ifdef FEAT_MBYTE
      if (gui_get_wide_font() == FAIL)
! 	EMSG(_("E231: 'guifontwide' invalid"));
  #endif
  
      gui.num_cols = Columns;
--- 649,660 ----
  	    gui_init_font(*p_guifont == NUL ? hl_get_font_name()
  						  : p_guifont, FALSE) == FAIL)
      {
! 	emsg(_("E665: Cannot start GUI, no valid font found"));
  	goto error2;
      }
  #ifdef FEAT_MBYTE
      if (gui_get_wide_font() == FAIL)
! 	emsg(_("E231: 'guifontwide' invalid"));
  #endif
  
      gui.num_cols = Columns;
***************
*** 769,775 ****
  
  #if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
  	if (!im_xim_isvalid_imactivate())
! 	    EMSG(_("E599: Value of 'imactivatekey' is invalid"));
  #endif
  	/* When 'cmdheight' was set during startup it may not have taken
  	 * effect yet. */
--- 769,775 ----
  
  #if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)
  	if (!im_xim_isvalid_imactivate())
! 	    emsg(_("E599: Value of 'imactivatekey' is invalid"));
  #endif
  	/* When 'cmdheight' was set during startup it may not have taken
  	 * effect yet. */
***************
*** 4785,4791 ****
  	    && gui.in_use
  #endif
  	    )
! 	EMSG2(_("E254: Cannot allocate color %s"), name);
      return t;
  }
  
--- 4785,4791 ----
  	    && gui.in_use
  #endif
  	    )
! 	semsg(_("E254: Cannot allocate color %s"), name);
      return t;
  }
  
*** ../vim-8.1.0742/src/gui_at_fs.c	2018-09-30 21:43:17.191693320 +0200
--- src/gui_at_fs.c	2019-01-13 19:50:14.181271847 +0100
***************
*** 1063,1069 ****
  #endif
  	if (!SFfont)
  	{
! 	    EMSG2(_("E616: vim_SelFile: can't get font %s"), SF_DEFAULT_FONT);
  	    SFstatus = SEL_FILE_CANCEL;
  	    return;
  	}
--- 1063,1069 ----
  #endif
  	if (!SFfont)
  	{
! 	    semsg(_("E616: vim_SelFile: can't get font %s"), SF_DEFAULT_FONT);
  	    SFstatus = SEL_FILE_CANCEL;
  	    return;
  	}
***************
*** 2629,2635 ****
      XtRemoveTimeOut(SFdirModTimerId);
      if (SFchdir(SFstartDir))
      {
! 	EMSG(_("E614: vim_SelFile: can't return to current directory"));
  	SFstatus = SEL_FILE_CANCEL;
      }
  }
--- 2629,2635 ----
      XtRemoveTimeOut(SFdirModTimerId);
      if (SFchdir(SFstartDir))
      {
! 	emsg(_("E614: vim_SelFile: can't return to current directory"));
  	SFstatus = SEL_FILE_CANCEL;
      }
  }
***************
*** 2658,2664 ****
  
      if (mch_dirname((char_u *)SFstartDir, MAXPATHL) == FAIL)
      {
! 	EMSG(_("E615: vim_SelFile: can't get current directory"));
  	return NULL;
      }
  
--- 2658,2664 ----
  
      if (mch_dirname((char_u *)SFstartDir, MAXPATHL) == FAIL)
      {
! 	emsg(_("E615: vim_SelFile: can't get current directory"));
  	return NULL;
      }
  
*** ../vim-8.1.0742/src/gui_at_sb.c	2018-04-10 18:37:19.000000000 +0200
--- src/gui_at_sb.c	2019-01-13 19:50:42.105014555 +0100
***************
*** 485,491 ****
  
  	if (XGetGeometry (XtDisplay(w), sbw->scrollbar.thumb, &root, &x, &y,
  		&width, &height, &bw, &depth) == 0)
! 	    EMSG(_("Scrollbar Widget: Could not get geometry of thumb pixmap."));
      }
  
      gcValues.foreground = sbw->scrollbar.foreground;
--- 485,491 ----
  
  	if (XGetGeometry (XtDisplay(w), sbw->scrollbar.thumb, &root, &x, &y,
  		&width, &height, &bw, &depth) == 0)
! 	    emsg(_("Scrollbar Widget: Could not get geometry of thumb pixmap."));
      }
  
      gcValues.foreground = sbw->scrollbar.foreground;
*** ../vim-8.1.0742/src/gui_beval.c	2019-01-10 22:56:25.521250993 +0100
--- src/gui_beval.c	2019-01-13 19:33:46.394150608 +0100
***************
*** 103,109 ****
  
      if (mesg != NULL && mesgCB != NULL)
      {
! 	IEMSG(_("E232: Cannot create BalloonEval with both message and callback"));
  	return NULL;
      }
  
--- 103,109 ----
  
      if (mesg != NULL && mesgCB != NULL)
      {
! 	iemsg(_("E232: Cannot create BalloonEval with both message and callback"));
  	return NULL;
      }
  
*** ../vim-8.1.0742/src/gui_gtk_x11.c	2018-12-11 20:39:15.442937076 +0100
--- src/gui_gtk_x11.c	2019-01-13 19:50:51.804925705 +0100
***************
*** 1664,1670 ****
      {
  	gui.dying = TRUE;
  	if (give_message)
! 	    EMSG(_((char *)e_opendisp));
  	return FAIL;
      }
      return OK;
--- 1664,1670 ----
      {
  	gui.dying = TRUE;
  	if (give_message)
! 	    emsg(_((char *)e_opendisp));
  	return FAIL;
      }
      return OK;
***************
*** 1710,1716 ****
      if (!gtk_init_check(&gui_argc, &gui_argv))
      {
  	gui.dying = TRUE;
! 	EMSG(_((char *)e_opendisp));
  	return FAIL;
      }
  
--- 1710,1716 ----
      if (!gtk_init_check(&gui_argc, &gui_argv))
      {
  	gui.dying = TRUE;
! 	emsg(_((char *)e_opendisp));
  	return FAIL;
      }
  
***************
*** 5247,5253 ****
      if (font == NULL)
      {
  	if (report_error)
! 	    EMSG2(_((char *)e_font), name);
  	return NULL;
      }
  
--- 5247,5253 ----
      if (font == NULL)
      {
  	if (report_error)
! 	    semsg(_((char *)e_font), name);
  	return NULL;
      }
  
***************
*** 7138,7144 ****
  	{
  	    /* The error message is already translated and will be more
  	     * descriptive than anything we could possibly do ourselves. */
! 	    EMSG2("E255: %s", message);
  
  	    if (input_conv.vc_type != CONV_NONE)
  		vim_free(message);
--- 7138,7144 ----
  	{
  	    /* The error message is already translated and will be more
  	     * descriptive than anything we could possibly do ourselves. */
! 	    semsg("E255: %s", message);
  
  	    if (input_conv.vc_type != CONV_NONE)
  		vim_free(message);
*** ../vim-8.1.0742/src/gui_mac.c	2018-12-11 20:39:15.442937076 +0100
--- src/gui_mac.c	2019-01-13 19:27:43.420614022 +0100
***************
*** 3556,3562 ****
      if (font == NOFONT)
      {
  	if (giveErrorIfMissing)
! 	    EMSG2(_(e_font), name);
  	return NOFONT;
      }
      /*
--- 3556,3562 ----
      if (font == NOFONT)
      {
  	if (giveErrorIfMissing)
! 	    semsg(_(e_font), name);
  	return NOFONT;
      }
      /*
*** ../vim-8.1.0742/src/gui_photon.c	2018-09-30 21:43:17.191693320 +0200
--- src/gui_photon.c	2019-01-13 19:27:43.420614022 +0100
***************
*** 2937,2943 ****
      }
  
      if (report_error)
! 	EMSG2(e_font, vim_font_name);
  
      return FAIL;
  }
--- 2937,2943 ----
      }
  
      if (report_error)
! 	semsg(e_font, vim_font_name);
  
      return FAIL;
  }
*** ../vim-8.1.0742/src/gui_w32.c	2018-12-28 19:13:28.591806287 +0100
--- src/gui_w32.c	2019-01-13 19:50:58.588863721 +0100
***************
*** 1582,1588 ****
      if (get_logfont(&lf, name, NULL, giveErrorIfMissing) == OK)
  	font = get_font_handle(&lf);
      if (font == NOFONT && giveErrorIfMissing)
! 	EMSG2(_(e_font), name);
      return font;
  }
  
--- 1582,1588 ----
      if (get_logfont(&lf, name, NULL, giveErrorIfMissing) == OK)
  	font = get_font_handle(&lf);
      if (font == NOFONT && giveErrorIfMissing)
! 	semsg(_(e_font), name);
      return font;
  }
  
***************
*** 5235,5241 ****
      EnumWindows(FindWindowTitle, (LPARAM)title);
      if (vim_parent_hwnd == NULL)
      {
! 	EMSG2(_("E671: Cannot find window title \"%s\""), title);
  	mch_exit(2);
      }
  }
--- 5235,5241 ----
      EnumWindows(FindWindowTitle, (LPARAM)title);
      if (vim_parent_hwnd == NULL)
      {
! 	semsg(_("E671: Cannot find window title \"%s\""), title);
  	mch_exit(2);
      }
  }
***************
*** 5246,5252 ****
  {
      char buf[IOSIZE];
  
!     /* Can't use EMSG() here, we have not finished initialisation yet. */
      vim_snprintf(buf, IOSIZE,
  	    _("E243: Argument not supported: \"-%s\"; Use the OLE version."),
  	    arg);
--- 5246,5252 ----
  {
      char buf[IOSIZE];
  
!     /* Can't use emsg() here, we have not finished initialisation yet. */
      vim_snprintf(buf, IOSIZE,
  	    _("E243: Argument not supported: \"-%s\"; Use the OLE version."),
  	    arg);
***************
*** 5468,5474 ****
  #endif
  	if (s_hwnd == NULL)
  	{
! 	    EMSG(_("E672: Unable to open window inside MDI application"));
  	    mch_exit(2);
  	}
      }
--- 5468,5474 ----
  #endif
  	if (s_hwnd == NULL)
  	{
! 	    emsg(_("E672: Unable to open window inside MDI application"));
  	    mch_exit(2);
  	}
      }
***************
*** 8671,8677 ****
      {
  	if (sign.hImage)
  	    close_signicon_image(&sign);
! 	EMSG(_(e_signdata));
      }
      return (void *)psign;
  
--- 8671,8677 ----
      {
  	if (sign.hImage)
  	    close_signicon_image(&sign);
! 	emsg(_(e_signdata));
      }
      return (void *)psign;
  
***************
*** 9025,9031 ****
  
      if (mesg != NULL && mesgCB != NULL)
      {
! 	IEMSG(_("E232: Cannot create BalloonEval with both message and callback"));
  	return NULL;
      }
  
--- 9025,9031 ----
  
      if (mesg != NULL && mesgCB != NULL)
      {
! 	iemsg(_("E232: Cannot create BalloonEval with both message and callback"));
  	return NULL;
      }
  
*** ../vim-8.1.0742/src/gui_x11.c	2018-09-30 21:43:17.191693320 +0200
--- src/gui_x11.c	2019-01-13 19:51:08.964769156 +0100
***************
*** 1295,1301 ****
      if (app_context == NULL || gui.dpy == NULL)
      {
  	gui.dying = TRUE;
! 	EMSG(_(e_opendisp));
  	return FAIL;
      }
      return OK;
--- 1295,1301 ----
      if (app_context == NULL || gui.dpy == NULL)
      {
  	gui.dying = TRUE;
! 	emsg(_(e_opendisp));
  	return FAIL;
      }
      return OK;
***************
*** 1541,1547 ****
      }
  
      if (gui.color_approx)
! 	EMSG(_("Vim E458: Cannot allocate colormap entry, some colors may be incorrect"));
  
  #ifdef FEAT_SUN_WORKSHOP
      if (usingSunWorkShop)
--- 1541,1547 ----
      }
  
      if (gui.color_approx)
! 	emsg(_("Vim E458: Cannot allocate colormap entry, some colors may be incorrect"));
  
  #ifdef FEAT_SUN_WORKSHOP
      if (usingSunWorkShop)
***************
*** 1970,1976 ****
      if (font == NULL)
      {
  	if (giveErrorIfMissing)
! 	    EMSG2(_(e_font), name);
  	return NOFONT;
      }
  
--- 1970,1976 ----
      if (font == NULL)
      {
  	if (giveErrorIfMissing)
! 	    semsg(_(e_font), name);
  	return NOFONT;
      }
  
***************
*** 1994,2000 ****
  
      if (font->max_bounds.width != font->min_bounds.width)
      {
! 	EMSG2(_(e_fontwidth), name);
  	XFreeFont(gui.dpy, font);
  	return NOFONT;
      }
--- 1994,2000 ----
  
      if (font->max_bounds.width != font->min_bounds.width)
      {
! 	semsg(_(e_fontwidth), name);
  	XFreeFont(gui.dpy, font);
  	return NOFONT;
      }
***************
*** 2145,2153 ****
  
  	if (giveErrorIfMissing)
  	{
! 	    EMSG2(_("E250: Fonts for the following charsets are missing in fontset %s:"), name);
  	    for (i = 0; i < num_missing; i++)
! 		EMSG2("%s", missing[i]);
  	}
  	XFreeStringList(missing);
      }
--- 2145,2153 ----
  
  	if (giveErrorIfMissing)
  	{
! 	    semsg(_("E250: Fonts for the following charsets are missing in fontset %s:"), name);
  	    for (i = 0; i < num_missing; i++)
! 		semsg("%s", missing[i]);
  	}
  	XFreeStringList(missing);
      }
***************
*** 2155,2161 ****
      if (fontset == NULL)
      {
  	if (giveErrorIfMissing)
! 	    EMSG2(_(e_fontset), name);
  	return NOFONTSET;
      }
  
--- 2155,2161 ----
      if (fontset == NULL)
      {
  	if (giveErrorIfMissing)
! 	    semsg(_(e_fontset), name);
  	return NOFONTSET;
      }
  
***************
*** 2187,2194 ****
      {
  	if (xfs[i]->max_bounds.width != xfs[i]->min_bounds.width)
  	{
! 	    EMSG2(_("E252: Fontset name: %s"), base_name);
! 	    EMSG2(_("Font '%s' is not fixed-width"), font_name[i]);
  	    return FAIL;
  	}
      }
--- 2187,2194 ----
      {
  	if (xfs[i]->max_bounds.width != xfs[i]->min_bounds.width)
  	{
! 	    semsg(_("E252: Fontset name: %s"), base_name);
! 	    semsg(_("Font '%s' is not fixed-width"), font_name[i]);
  	    return FAIL;
  	}
      }
***************
*** 2207,2218 ****
  	if (	   xfs[i]->max_bounds.width != 2 * min_width
  		&& xfs[i]->max_bounds.width != min_width)
  	{
! 	    EMSG2(_("E253: Fontset name: %s"), base_name);
! 	    EMSG2(_("Font0: %s"), font_name[min_font_idx]);
! 	    EMSG2(_("Font1: %s"), font_name[i]);
! 	    EMSGN(_("Font%ld width is not twice that of font0"), i);
! 	    EMSGN(_("Font0 width: %ld"), xfs[min_font_idx]->max_bounds.width);
! 	    EMSGN(_("Font1 width: %ld"), xfs[i]->max_bounds.width);
  	    return FAIL;
  	}
      }
--- 2207,2218 ----
  	if (	   xfs[i]->max_bounds.width != 2 * min_width
  		&& xfs[i]->max_bounds.width != min_width)
  	{
! 	    semsg(_("E253: Fontset name: %s"), base_name);
! 	    semsg(_("Font0: %s"), font_name[min_font_idx]);
! 	    semsg(_("Font1: %s"), font_name[i]);
! 	    semsg(_("Font%ld width is not twice that of font0"), i);
! 	    semsg(_("Font0 width: %ld"), xfs[min_font_idx]->max_bounds.width);
! 	    semsg(_("Font1 width: %ld"), xfs[i]->max_bounds.width);
  	    return FAIL;
  	}
      }
***************
*** 3326,3332 ****
  		gui.sign_width = sign->width + 8; */
  	}
  	else
! 	    EMSG(_(e_signdata));
      }
  
      return (void *)sign;
--- 3326,3332 ----
  		gui.sign_width = sign->width + 8; */
  	}
  	else
! 	    emsg(_(e_signdata));
      }
  
      return (void *)sign;
*** ../vim-8.1.0742/src/hangulin.c	2018-09-30 21:43:17.191693320 +0200
--- src/hangulin.c	2019-01-13 19:34:02.178043188 +0100
***************
*** 588,594 ****
  	    return AUTOMATA_CORRECT_NEW;
  
  	default:
! 	    IEMSG(_("E256: Hangul automata ERROR"));
  	    break;
      }
      return AUTOMATA_ERROR; /* RrEeAaLlLlYy EeRrRrOoRr */
--- 588,594 ----
  	    return AUTOMATA_CORRECT_NEW;
  
  	default:
! 	    iemsg(_("E256: Hangul automata ERROR"));
  	    break;
      }
      return AUTOMATA_ERROR; /* RrEeAaLlLlYy EeRrRrOoRr */
*** ../vim-8.1.0742/src/hardcopy.c	2018-09-30 21:43:17.191693320 +0200
--- src/hardcopy.c	2019-01-13 20:19:02.819164649 +0100
***************
*** 135,141 ****
      int		ff;		    /* seen form feed character */
  } prt_pos_T;
  
! static char_u *parse_list_options(char_u *option_str, option_table_T *table, int table_size);
  
  static colnr_T hardcopy_line(prt_settings_T *psettings, int page_line, prt_pos_T *ppos);
  
--- 135,141 ----
      int		ff;		    /* seen form feed character */
  } prt_pos_T;
  
! static char *parse_list_options(char_u *option_str, option_table_T *table, int table_size);
  
  static colnr_T hardcopy_line(prt_settings_T *psettings, int page_line, prt_pos_T *ppos);
  
***************
*** 143,149 ****
   * Parse 'printoptions' and set the flags in "printer_opts".
   * Returns an error message or NULL;
   */
!     char_u *
  parse_printoptions(void)
  {
      return parse_list_options(p_popt, printer_opts, OPT_PRINT_NUM_OPTIONS);
--- 143,149 ----
   * Parse 'printoptions' and set the flags in "printer_opts".
   * Returns an error message or NULL;
   */
!     char *
  parse_printoptions(void)
  {
      return parse_list_options(p_popt, printer_opts, OPT_PRINT_NUM_OPTIONS);
***************
*** 154,160 ****
   * Parse 'printmbfont' and set the flags in "mbfont_opts".
   * Returns an error message or NULL;
   */
!     char_u *
  parse_printmbfont(void)
  {
      return parse_list_options(p_pmfn, mbfont_opts, OPT_MBFONT_NUM_OPTIONS);
--- 154,160 ----
   * Parse 'printmbfont' and set the flags in "mbfont_opts".
   * Returns an error message or NULL;
   */
!     char *
  parse_printmbfont(void)
  {
      return parse_list_options(p_pmfn, mbfont_opts, OPT_MBFONT_NUM_OPTIONS);
***************
*** 170,183 ****
   * Returns an error message for an illegal option, NULL otherwise.
   * Only used for the printer at the moment...
   */
!     static char_u *
  parse_list_options(
      char_u		*option_str,
      option_table_T	*table,
      int			table_size)
  {
      option_table_T *old_opts;
!     char_u	*ret = NULL;
      char_u	*stringp;
      char_u	*colonp;
      char_u	*commap;
--- 170,183 ----
   * Returns an error message for an illegal option, NULL otherwise.
   * Only used for the printer at the moment...
   */
!     static char *
  parse_list_options(
      char_u		*option_str,
      option_table_T	*table,
      int			table_size)
  {
      option_table_T *old_opts;
!     char	*ret = NULL;
      char_u	*stringp;
      char_u	*colonp;
      char_u	*commap;
***************
*** 205,211 ****
  	colonp = vim_strchr(stringp, ':');
  	if (colonp == NULL)
  	{
! 	    ret = (char_u *)N_("E550: Missing colon");
  	    break;
  	}
  	commap = vim_strchr(stringp, ',');
--- 205,211 ----
  	colonp = vim_strchr(stringp, ':');
  	if (colonp == NULL)
  	{
! 	    ret = N_("E550: Missing colon");
  	    break;
  	}
  	commap = vim_strchr(stringp, ',');
***************
*** 220,226 ****
  
  	if (idx == table_size)
  	{
! 	    ret = (char_u *)N_("E551: Illegal component");
  	    break;
  	}
  	p = colonp + 1;
--- 220,226 ----
  
  	if (idx == table_size)
  	{
! 	    ret = N_("E551: Illegal component");
  	    break;
  	}
  	p = colonp + 1;
***************
*** 230,236 ****
  	{
  	    if (!VIM_ISDIGIT(*p))
  	    {
! 		ret = (char_u *)N_("E552: digit expected");
  		break;
  	    }
  
--- 230,236 ----
  	{
  	    if (!VIM_ISDIGIT(*p))
  	    {
! 		ret = N_("E552: digit expected");
  		break;
  	    }
  
***************
*** 576,588 ****
  # ifdef FEAT_POSTSCRIPT
      if (*eap->arg == '>')
      {
! 	char_u	*errormsg = NULL;
  
  	/* Expand things like "%.ps". */
  	if (expand_filename(eap, eap->cmdlinep, &errormsg) == FAIL)
  	{
  	    if (errormsg != NULL)
! 		EMSG(errormsg);
  	    return;
  	}
  	settings.outfile = skipwhite(eap->arg + 1);
--- 576,588 ----
  # ifdef FEAT_POSTSCRIPT
      if (*eap->arg == '>')
      {
! 	char	*errormsg = NULL;
  
  	/* Expand things like "%.ps". */
  	if (expand_filename(eap, eap->cmdlinep, &errormsg) == FAIL)
  	{
  	    if (errormsg != NULL)
! 		emsg(errormsg);
  	    return;
  	}
  	settings.outfile = skipwhite(eap->arg + 1);
***************
*** 1431,1437 ****
  	    && fwrite(buffer, sizeof(char_u), bytes, prt_ps_fd)
  							     != (size_t)bytes)
      {
! 	EMSG(_("E455: Error writing to PostScript output file"));
  	prt_file_error = TRUE;
      }
  }
--- 1431,1437 ----
  	    && fwrite(buffer, sizeof(char_u), bytes, prt_ps_fd)
  							     != (size_t)bytes)
      {
! 	emsg(_("E455: Error writing to PostScript output file"));
  	prt_file_error = TRUE;
      }
  }
***************
*** 1873,1879 ****
      fd_resource = mch_fopen((char *)resource->filename, READBIN);
      if (fd_resource == NULL)
      {
! 	EMSG2(_("E624: Can't open file \"%s\""), resource->filename);
  	return FALSE;
      }
      vim_memset(prt_resfile.buffer, NUL, PRT_FILE_BUFFER_LEN);
--- 1873,1879 ----
      fd_resource = mch_fopen((char *)resource->filename, READBIN);
      if (fd_resource == NULL)
      {
! 	semsg(_("E624: Can't open file \"%s\""), resource->filename);
  	return FALSE;
      }
      vim_memset(prt_resfile.buffer, NUL, PRT_FILE_BUFFER_LEN);
***************
*** 1883,1889 ****
  					    PRT_FILE_BUFFER_LEN, fd_resource);
      if (ferror(fd_resource))
      {
! 	EMSG2(_("E457: Can't read PostScript resource file \"%s\""),
  		resource->filename);
  	fclose(fd_resource);
  	return FALSE;
--- 1883,1889 ----
  					    PRT_FILE_BUFFER_LEN, fd_resource);
      if (ferror(fd_resource))
      {
! 	semsg(_("E457: Can't read PostScript resource file \"%s\""),
  		resource->filename);
  	fclose(fd_resource);
  	return FALSE;
***************
*** 1900,1906 ****
      if (prt_resfile_strncmp(offset, PRT_RESOURCE_HEADER,
  				       (int)STRLEN(PRT_RESOURCE_HEADER)) != 0)
      {
! 	EMSG2(_("E618: file \"%s\" is not a PostScript resource file"),
  		resource->filename);
  	return FALSE;
      }
--- 1900,1906 ----
      if (prt_resfile_strncmp(offset, PRT_RESOURCE_HEADER,
  				       (int)STRLEN(PRT_RESOURCE_HEADER)) != 0)
      {
! 	semsg(_("E618: file \"%s\" is not a PostScript resource file"),
  		resource->filename);
  	return FALSE;
      }
***************
*** 1917,1923 ****
      if (prt_resfile_strncmp(offset, PRT_RESOURCE_RESOURCE,
  				     (int)STRLEN(PRT_RESOURCE_RESOURCE)) != 0)
      {
! 	EMSG2(_("E619: file \"%s\" is not a supported PostScript resource file"),
  		resource->filename);
  	return FALSE;
      }
--- 1917,1923 ----
      if (prt_resfile_strncmp(offset, PRT_RESOURCE_RESOURCE,
  				     (int)STRLEN(PRT_RESOURCE_RESOURCE)) != 0)
      {
! 	semsg(_("E619: file \"%s\" is not a supported PostScript resource file"),
  		resource->filename);
  	return FALSE;
      }
***************
*** 1935,1941 ****
  	resource->type = PRT_RESOURCE_TYPE_CMAP;
      else
      {
! 	EMSG2(_("E619: file \"%s\" is not a supported PostScript resource file"),
  		resource->filename);
  	return FALSE;
      }
--- 1935,1941 ----
  	resource->type = PRT_RESOURCE_TYPE_CMAP;
      else
      {
! 	semsg(_("E619: file \"%s\" is not a supported PostScript resource file"),
  		resource->filename);
  	return FALSE;
      }
***************
*** 1977,1983 ****
  
      if (!seen_title || !seen_version)
      {
! 	EMSG2(_("E619: file \"%s\" is not a supported PostScript resource file"),
  		resource->filename);
  	return FALSE;
      }
--- 1977,1983 ----
  
      if (!seen_title || !seen_version)
      {
! 	semsg(_("E619: file \"%s\" is not a supported PostScript resource file"),
  		resource->filename);
  	return FALSE;
      }
***************
*** 1991,1997 ****
      /* Version number m.n should match, the revision number does not matter */
      if (STRNCMP(resource->version, version, STRLEN(version)))
      {
! 	EMSG2(_("E621: \"%s\" resource file has wrong version"),
  		resource->name);
  	return FALSE;
      }
--- 1991,1997 ----
      /* Version number m.n should match, the revision number does not matter */
      if (STRNCMP(resource->version, version, STRLEN(version)))
      {
! 	semsg(_("E621: \"%s\" resource file has wrong version"),
  		resource->name);
  	return FALSE;
      }
***************
*** 2465,2471 ****
  	    /* Check encoding and character set are compatible */
  	    if ((p_mbenc->needs_charset & p_mbchar->has_charset) == 0)
  	    {
! 		EMSG(_("E673: Incompatible multi-byte encoding and character set."));
  		return FALSE;
  	    }
  
--- 2465,2471 ----
  	    /* Check encoding and character set are compatible */
  	    if ((p_mbenc->needs_charset & p_mbchar->has_charset) == 0)
  	    {
! 		emsg(_("E673: Incompatible multi-byte encoding and character set."));
  		return FALSE;
  	    }
  
***************
*** 2482,2488 ****
  	    /* Add custom CMap character set name */
  	    if (*p_pmcs == NUL)
  	    {
! 		EMSG(_("E674: printmbcharset cannot be empty with multi-byte encoding."));
  		return FALSE;
  	    }
  	    vim_strncpy((char_u *)prt_cmap, p_pmcs, sizeof(prt_cmap) - 3);
--- 2482,2488 ----
  	    /* Add custom CMap character set name */
  	    if (*p_pmcs == NUL)
  	    {
! 		emsg(_("E674: printmbcharset cannot be empty with multi-byte encoding."));
  		return FALSE;
  	    }
  	    vim_strncpy((char_u *)prt_cmap, p_pmcs, sizeof(prt_cmap) - 3);
***************
*** 2500,2506 ****
  
  	if (!mbfont_opts[OPT_MBFONT_REGULAR].present)
  	{
! 	    EMSG(_("E675: No default font specified for multi-byte printing."));
  	    return FALSE;
  	}
  
--- 2500,2506 ----
  
  	if (!mbfont_opts[OPT_MBFONT_REGULAR].present)
  	{
! 	    emsg(_("E675: No default font specified for multi-byte printing."));
  	    return FALSE;
  	}
  
***************
*** 2677,2683 ****
  	prt_ps_file_name = vim_tempname('p', TRUE);
  	if (prt_ps_file_name == NULL)
  	{
! 	    EMSG(_(e_notmp));
  	    return FAIL;
  	}
  	prt_ps_fd = mch_fopen((char *)prt_ps_file_name, WRITEBIN);
--- 2677,2683 ----
  	prt_ps_file_name = vim_tempname('p', TRUE);
  	if (prt_ps_file_name == NULL)
  	{
! 	    emsg(_(e_notmp));
  	    return FAIL;
  	}
  	prt_ps_fd = mch_fopen((char *)prt_ps_file_name, WRITEBIN);
***************
*** 2693,2699 ****
      }
      if (prt_ps_fd == NULL)
      {
! 	EMSG(_("E324: Can't open PostScript output file"));
  	mch_print_cleanup();
  	return FAIL;
      }
--- 2693,2699 ----
      }
      if (prt_ps_fd == NULL)
      {
! 	emsg(_("E324: Can't open PostScript output file"));
  	mch_print_cleanup();
  	return FAIL;
      }
***************
*** 2729,2735 ****
      fd_resource = mch_fopen((char *)resource->filename, READBIN);
      if (fd_resource == NULL)
      {
! 	EMSG2(_("E456: Can't open file \"%s\""), resource->filename);
  	return FALSE;
      }
      prt_dsc_resources("BeginResource", prt_resource_types[resource->type],
--- 2729,2735 ----
      fd_resource = mch_fopen((char *)resource->filename, READBIN);
      if (fd_resource == NULL)
      {
! 	semsg(_("E456: Can't open file \"%s\""), resource->filename);
  	return FALSE;
      }
      prt_dsc_resources("BeginResource", prt_resource_types[resource->type],
***************
*** 2743,2749 ****
  			   sizeof(resource_buffer), fd_resource);
  	if (ferror(fd_resource))
  	{
! 	    EMSG2(_("E457: Can't read PostScript resource file \"%s\""),
  							    resource->filename);
  	    fclose(fd_resource);
  	    return FALSE;
--- 2743,2749 ----
  			   sizeof(resource_buffer), fd_resource);
  	if (ferror(fd_resource))
  	{
! 	    semsg(_("E457: Can't read PostScript resource file \"%s\""),
  							    resource->filename);
  	    fclose(fd_resource);
  	    return FALSE;
***************
*** 2880,2886 ****
      /* Search for external resources VIM supplies */
      if (!prt_find_resource("prolog", res_prolog))
      {
! 	EMSG(_("E456: Can't find PostScript resource file \"prolog.ps\""));
  	goto theend;
      }
      if (!prt_open_resource(res_prolog))
--- 2880,2886 ----
      /* Search for external resources VIM supplies */
      if (!prt_find_resource("prolog", res_prolog))
      {
! 	emsg(_("E456: Can't find PostScript resource file \"prolog.ps\""));
  	goto theend;
      }
      if (!prt_open_resource(res_prolog))
***************
*** 2893,2899 ****
  	/* Look for required version of multi-byte printing procset */
  	if (!prt_find_resource("cidfont", res_cidfont))
  	{
! 	    EMSG(_("E456: Can't find PostScript resource file \"cidfont.ps\""));
  	    goto theend;
  	}
  	if (!prt_open_resource(res_cidfont))
--- 2893,2899 ----
  	/* Look for required version of multi-byte printing procset */
  	if (!prt_find_resource("cidfont", res_cidfont))
  	{
! 	    emsg(_("E456: Can't find PostScript resource file \"cidfont.ps\""));
  	    goto theend;
  	}
  	if (!prt_open_resource(res_cidfont))
***************
*** 2931,2937 ****
  		p_encoding = (char_u *)"latin1";
  		if (!prt_find_resource((char *)p_encoding, res_encoding))
  		{
! 		    EMSG2(_("E456: Can't find PostScript resource file \"%s.ps\""),
  			    p_encoding);
  		    goto theend;
  		}
--- 2931,2937 ----
  		p_encoding = (char_u *)"latin1";
  		if (!prt_find_resource((char *)p_encoding, res_encoding))
  		{
! 		    semsg(_("E456: Can't find PostScript resource file \"%s.ps\""),
  			    p_encoding);
  		    goto theend;
  		}
***************
*** 2953,2959 ****
  	    /* Include ASCII range encoding vector */
  	    if (!prt_find_resource(prt_ascii_encoding, res_encoding))
  	    {
! 		EMSG2(_("E456: Can't find PostScript resource file \"%s.ps\""),
  							  prt_ascii_encoding);
  		goto theend;
  	    }
--- 2953,2959 ----
  	    /* Include ASCII range encoding vector */
  	    if (!prt_find_resource(prt_ascii_encoding, res_encoding))
  	    {
! 		semsg(_("E456: Can't find PostScript resource file \"%s.ps\""),
  							  prt_ascii_encoding);
  		goto theend;
  	    }
***************
*** 2969,2975 ****
  	/* Set up encoding conversion if required */
  	if (FAIL == convert_setup(&prt_conv, p_enc, p_encoding))
  	{
! 	    EMSG2(_("E620: Unable to convert to print encoding \"%s\""),
  		    p_encoding);
  	    goto theend;
  	}
--- 2969,2975 ----
  	/* Set up encoding conversion if required */
  	if (FAIL == convert_setup(&prt_conv, p_enc, p_encoding))
  	{
! 	    semsg(_("E620: Unable to convert to print encoding \"%s\""),
  		    p_encoding);
  	    goto theend;
  	}
***************
*** 2982,2988 ****
  	/* Find user supplied CMap */
  	if (!prt_find_resource(prt_cmap, res_cmap))
  	{
! 	    EMSG2(_("E456: Can't find PostScript resource file \"%s.ps\""),
  								    prt_cmap);
  	    goto theend;
  	}
--- 2982,2988 ----
  	/* Find user supplied CMap */
  	if (!prt_find_resource(prt_cmap, res_cmap))
  	{
! 	    semsg(_("E456: Can't find PostScript resource file \"%s.ps\""),
  								    prt_cmap);
  	    goto theend;
  	}
***************
*** 3236,3242 ****
  
  	/* Not printing to a file: use 'printexpr' to print the file. */
  	if (eval_printexpr(prt_ps_file_name, psettings->arguments) == FAIL)
! 	    EMSG(_("E365: Failed to print PostScript file"));
  	else
  	    prt_message((char_u *)_("Print job sent."));
      }
--- 3236,3242 ----
  
  	/* Not printing to a file: use 'printexpr' to print the file. */
  	if (eval_printexpr(prt_ps_file_name, psettings->arguments) == FAIL)
! 	    emsg(_("E365: Failed to print PostScript file"));
  	else
  	    prt_message((char_u *)_("Print job sent."));
      }
*** ../vim-8.1.0742/src/hashtab.c	2017-01-15 17:16:08.000000000 +0100
--- src/hashtab.c	2019-01-13 19:51:33.364547920 +0100
***************
*** 334,342 ****
  
  #ifdef HT_DEBUG
      if (ht->ht_used > ht->ht_filled)
! 	EMSG("hash_may_resize(): more used than filled");
      if (ht->ht_filled >= ht->ht_mask + 1)
! 	EMSG("hash_may_resize(): table completely filled");
  #endif
  
      if (minitems == 0)
--- 334,342 ----
  
  #ifdef HT_DEBUG
      if (ht->ht_used > ht->ht_filled)
! 	emsg("hash_may_resize(): more used than filled");
      if (ht->ht_filled >= ht->ht_mask + 1)
! 	emsg("hash_may_resize(): table completely filled");
  #endif
  
      if (minitems == 0)
*** ../vim-8.1.0742/src/if_cscope.c	2018-09-30 21:43:17.195693290 +0200
--- src/if_cscope.c	2019-01-13 19:51:40.908479830 +0100
***************
*** 76,82 ****
      static void
  cs_usage_msg(csid_e x)
  {
!     (void)EMSG2(_("E560: Usage: cs[cope] %s"), cs_cmds[(int)x].usage);
  }
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
--- 76,82 ----
      static void
  cs_usage_msg(csid_e x)
  {
!     (void)semsg(_("E560: Usage: cs[cope] %s"), cs_cmds[(int)x].usage);
  }
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
***************
*** 254,260 ****
  
      if (*eap->arg == NUL)
      {
! 	(void)EMSG(_("E562: Usage: cstag <ident>"));
  	return;
      }
  
--- 254,260 ----
  
      if (*eap->arg == NUL)
      {
! 	(void)emsg(_("E562: Usage: cstag <ident>"));
  	return;
      }
  
***************
*** 312,318 ****
  
      if (!ret)
      {
! 	(void)EMSG(_("E257: cstag: tag not found"));
  #if defined(FEAT_QUICKFIX)
  	g_do_tagpreview = 0;
  #endif
--- 312,318 ----
  
      if (!ret)
      {
! 	(void)emsg(_("E257: cstag: tag not found"));
  #if defined(FEAT_QUICKFIX)
  	g_do_tagpreview = 0;
  #endif
***************
*** 471,481 ****
      if (buf != NULL)
      {
  	(void)sprintf(buf, stat_emsg, fname, errno);
! 	(void)EMSG(buf);
  	vim_free(buf);
      }
      else
! 	(void)EMSG(_("E563: stat error"));
  }
  
  
--- 471,481 ----
      if (buf != NULL)
      {
  	(void)sprintf(buf, stat_emsg, fname, errno);
! 	(void)emsg(buf);
  	vim_free(buf);
      }
      else
! 	(void)emsg(_("E563: stat error"));
  }
  
  
***************
*** 579,585 ****
      else
      {
  	if (p_csverbose)
! 	    (void)EMSG2(
  		_("E564: %s is not a directory or a valid cscope database"),
  		fname);
  	goto add_err;
--- 579,585 ----
      else
      {
  	if (p_csverbose)
! 	    (void)semsg(
  		_("E564: %s is not a directory or a valid cscope database"),
  		fname);
  	goto add_err;
***************
*** 598,604 ****
  	{
  	    msg_clr_eos();
  	    (void)smsg_attr(HL_ATTR(HLF_R),
! 			    (char_u *)_("Added cscope database %s"),
  			    csinfo[i].fname);
  	}
      }
--- 598,604 ----
  	{
  	    msg_clr_eos();
  	    (void)smsg_attr(HL_ATTR(HLF_R),
! 			    _("Added cscope database %s"),
  			    csinfo[i].fname);
  	}
      }
***************
*** 651,657 ****
  cs_reading_emsg(
      int idx)	/* connection index */
  {
!     EMSGN(_("E262: error reading cscope connection %ld"), idx);
  }
  
  #define	CSREAD_BUFSIZE	2048
--- 651,657 ----
  cs_reading_emsg(
      int idx)	/* connection index */
  {
!     semsg(_("E262: error reading cscope connection %ld"), idx);
  }
  
  #define	CSREAD_BUFSIZE	2048
***************
*** 757,763 ****
  	search = 9;
  	break;
      default :
! 	(void)EMSG(_("E561: unknown cscope search type"));
  	cs_usage_msg(Find);
  	return NULL;
      }
--- 757,763 ----
  	search = 9;
  	break;
      default :
! 	(void)emsg(_("E561: unknown cscope search type"));
  	cs_usage_msg(Find);
  	return NULL;
      }
***************
*** 814,820 ****
      to_cs[0] = to_cs[1] = from_cs[0] = from_cs[1] = -1;
      if (pipe(to_cs) < 0 || pipe(from_cs) < 0)
      {
! 	(void)EMSG(_("E566: Could not create cscope pipes"));
  err_closing:
  	if (to_cs[0] != -1)
  	    (void)close(to_cs[0]);
--- 814,820 ----
      to_cs[0] = to_cs[1] = from_cs[0] = from_cs[1] = -1;
      if (pipe(to_cs) < 0 || pipe(from_cs) < 0)
      {
! 	(void)emsg(_("E566: Could not create cscope pipes"));
  err_closing:
  	if (to_cs[0] != -1)
  	    (void)close(to_cs[0]);
***************
*** 830,836 ****
      switch (csinfo[i].pid = fork())
      {
      case -1:
! 	(void)EMSG(_("E622: Could not fork for cscope"));
  	goto err_closing;
      case 0:				/* child: run cscope. */
  	if (dup2(to_cs[0], STDIN_FILENO) == -1)
--- 830,836 ----
      switch (csinfo[i].pid = fork())
      {
      case -1:
! 	(void)emsg(_("E622: Could not fork for cscope"));
  	goto err_closing;
      case 0:				/* child: run cscope. */
  	if (dup2(to_cs[0], STDIN_FILENO) == -1)
***************
*** 853,859 ****
  	if (!(pipe_stdin = CreatePipe(&stdin_rd, &stdin_wr, &sa, 0))
  		|| !(pipe_stdout = CreatePipe(&stdout_rd, &stdout_wr, &sa, 0)))
  	{
! 	    (void)EMSG(_("E566: Could not create cscope pipes"));
  err_closing:
  	    if (pipe_stdin)
  	    {
--- 853,859 ----
  	if (!(pipe_stdin = CreatePipe(&stdin_rd, &stdin_wr, &sa, 0))
  		|| !(pipe_stdout = CreatePipe(&stdout_rd, &stdout_wr, &sa, 0)))
  	{
! 	    (void)emsg(_("E566: Could not create cscope pipes"));
  err_closing:
  	    if (pipe_stdin)
  	    {
***************
*** 987,993 ****
      if (!created)
      {
  	PERROR(_("cs_create_connection exec failed"));
! 	(void)EMSG(_("E623: Could not spawn cscope process"));
  	goto err_closing;
      }
      /* else */
--- 987,993 ----
      if (!created)
      {
  	PERROR(_("cs_create_connection exec failed"));
! 	(void)emsg(_("E623: Could not spawn cscope process"));
  	goto err_closing;
      }
      /* else */
***************
*** 1029,1035 ****
  
      if (cs_check_for_connections() == FALSE)
      {
! 	(void)EMSG(_("E567: no cscope connections"));
  	return FALSE;
      }
  
--- 1029,1035 ----
  
      if (cs_check_for_connections() == FALSE)
      {
! 	(void)emsg(_("E567: no cscope connections"));
  	return FALSE;
      }
  
***************
*** 1127,1133 ****
  	    if (buf != NULL)
  	    {
  		sprintf(buf, nf, *qfpos, *(qfpos-1));
! 		(void)EMSG(buf);
  		vim_free(buf);
  	    }
  	    return FALSE;
--- 1127,1133 ----
  	    if (buf != NULL)
  	    {
  		sprintf(buf, nf, *qfpos, *(qfpos-1));
! 		(void)emsg(buf);
  		vim_free(buf);
  	    }
  	    return FALSE;
***************
*** 1194,1204 ****
  
  	buf = (char *)alloc((unsigned)(strlen(opt) + strlen(pat) + strlen(nf)));
  	if (buf == NULL)
! 	    (void)EMSG(nf);
  	else
  	{
  	    sprintf(buf, nf, opt, pat);
! 	    (void)EMSG(buf);
  	    vim_free(buf);
  	}
  	vim_free(nummatches);
--- 1194,1204 ----
  
  	buf = (char *)alloc((unsigned)(strlen(opt) + strlen(pat) + strlen(nf)));
  	if (buf == NULL)
! 	    (void)emsg(nf);
  	else
  	{
  	    sprintf(buf, nf, opt, pat);
! 	    (void)emsg(buf);
  	    vim_free(buf);
  	}
  	vim_free(nummatches);
***************
*** 1216,1222 ****
  
  	f = mch_fopen((char *)tmp, "w");
  	if (f == NULL)
! 	    EMSG2(_(e_notopen), tmp);
  	else
  	{
  	    cs_file_results(f, nummatches);
--- 1216,1222 ----
  
  	f = mch_fopen((char *)tmp, "w");
  	if (f == NULL)
! 	    semsg(_(e_notopen), tmp);
  	else
  	{
  	    cs_file_results(f, nummatches);
***************
*** 1289,1295 ****
  	/* Use %*s rather than %30s to ensure proper alignment in utf-8 */
  	if (space_cnt < 0)
  	    space_cnt = 0;
! 	(void)smsg((char_u *)_("%-5s: %s%*s (Usage: %s)"),
  				      cmdp->name,
  				      help, space_cnt, " ",
  				      cmdp->usage);
--- 1289,1295 ----
  	/* Use %*s rather than %30s to ensure proper alignment in utf-8 */
  	if (space_cnt < 0)
  	    space_cnt = 0;
! 	(void)smsg(_("%-5s: %s%*s (Usage: %s)"),
  				      cmdp->name,
  				      help, space_cnt, " ",
  				      cmdp->usage);
***************
*** 1378,1395 ****
  
  		if (winmsg != NULL)
  		{
! 		    (void)EMSG2(cant_msg, winmsg);
  		    LocalFree(winmsg);
  		}
  		else
  		    /* subst filename if can't get error text */
! 		    (void)EMSG2(cant_msg, fname);
  	    }
  	    return -1;
  
  	case FILEINFO_INFO_FAIL:    /* GetFileInformationByHandle() failed */
  	    if (p_csverbose)
! 		(void)EMSG(_("E626: cannot get cscope database information"));
  	    return -1;
      }
  #endif
--- 1378,1395 ----
  
  		if (winmsg != NULL)
  		{
! 		    (void)semsg(cant_msg, winmsg);
  		    LocalFree(winmsg);
  		}
  		else
  		    /* subst filename if can't get error text */
! 		    (void)semsg(cant_msg, fname);
  	    }
  	    return -1;
  
  	case FILEINFO_INFO_FAIL:    /* GetFileInformationByHandle() failed */
  	    if (p_csverbose)
! 		(void)emsg(_("E626: cannot get cscope database information"));
  	    return -1;
      }
  #endif
***************
*** 1412,1418 ****
  	    )
  	{
  	    if (p_csverbose)
! 		(void)EMSG(_("E568: duplicate cscope database not added"));
  	    return -1;
  	}
  
--- 1412,1418 ----
  	    )
  	{
  	    if (p_csverbose)
! 		(void)emsg(_("E568: duplicate cscope database not added"));
  	    return -1;
  	}
  
***************
*** 1555,1561 ****
      if ((i != -1) && (i >= csinfo_size || i < -1 || csinfo[i].fname == NULL))
      {
  	if (p_csverbose)
! 	    (void)EMSG2(_("E261: cscope connection %s not found"), stok);
      }
      else
      {
--- 1555,1561 ----
      if ((i != -1) && (i >= csinfo_size || i < -1 || csinfo[i].fname == NULL))
      {
  	if (p_csverbose)
! 	    (void)semsg(_("E261: cscope connection %s not found"), stok);
      }
      else
      {
***************
*** 1587,1593 ****
      {
  	msg_clr_eos();
  	(void)smsg_attr(HL_ATTR(HLF_R) | MSG_HIST,
! 		(char_u *)_("cscope connection %s closed"), cname);
      }
      cs_release_csp(i, TRUE);
  }
--- 1587,1593 ----
      {
  	msg_clr_eos();
  	(void)smsg_attr(HL_ATTR(HLF_R) | MSG_HIST,
! 			_("cscope connection %s closed"), cname);
      }
      cs_release_csp(i, TRUE);
  }
***************
*** 1723,1729 ****
  	cs_print_tags_priv(mp, cp, cnt);
  	break;
      default:	/* should not reach here */
! 	IEMSG(_("E570: fatal error in cs_manage_matches"));
  	return NULL;
      }
  
--- 1723,1729 ----
  	cs_print_tags_priv(mp, cp, cnt);
  	break;
      default:	/* should not reach here */
! 	iemsg(_("E570: fatal error in cs_manage_matches"));
  	return NULL;
      }
  
***************
*** 2141,2147 ****
  			buf[bufpos - epromptlen] = NUL;
  
  			/* print message to user */
! 			(void)EMSG2(cs_emsg, buf);
  
  			/* send RETURN to cscope */
  			(void)putc('\n', csinfo[i].to_fp);
--- 2141,2147 ----
  			buf[bufpos - epromptlen] = NUL;
  
  			/* print message to user */
! 			(void)semsg(cs_emsg, buf);
  
  			/* send RETURN to cscope */
  			(void)putc('\n', csinfo[i].to_fp);
***************
*** 2162,2168 ****
  	    {
  		PERROR("cs_read_prompt EOF");
  		if (buf != NULL && buf[0] != NUL)
! 		    (void)EMSG2(cs_emsg, buf);
  		else if (p_csverbose)
  		    cs_reading_emsg(i); /* don't have additional information */
  		cs_release_csp(i, TRUE);
--- 2162,2168 ----
  	    {
  		PERROR("cs_read_prompt EOF");
  		if (buf != NULL && buf[0] != NUL)
! 		    (void)semsg(cs_emsg, buf);
  		else if (p_csverbose)
  		    cs_reading_emsg(i); /* don't have additional information */
  		cs_release_csp(i, TRUE);
***************
*** 2476,2485 ****
  		continue;
  
  	    if (csinfo[i].ppath != NULL)
! 		(void)smsg((char_u *)"%2d %-5ld  %-34s  %-32s",
  		    i, (long)csinfo[i].pid, csinfo[i].fname, csinfo[i].ppath);
  	    else
! 		(void)smsg((char_u *)"%2d %-5ld  %-34s  <none>",
  			   i, (long)csinfo[i].pid, csinfo[i].fname);
  	}
      }
--- 2476,2485 ----
  		continue;
  
  	    if (csinfo[i].ppath != NULL)
! 		(void)smsg("%2d %-5ld  %-34s  %-32s",
  		    i, (long)csinfo[i].pid, csinfo[i].fname, csinfo[i].ppath);
  	    else
! 		(void)smsg("%2d %-5ld  %-34s  <none>",
  			   i, (long)csinfo[i].pid, csinfo[i].fname);
  	}
      }
*** ../vim-8.1.0742/src/if_lua.c	2019-01-01 00:41:50.040176062 +0100
--- src/if_lua.c	2019-01-13 19:51:49.644401160 +0100
***************
*** 415,421 ****
      if (!hinstLua)
      {
  	if (verbose)
! 	    EMSG2(_(e_loadlib), libname);
  	return FAIL;
      }
      for (reg = luaV_dll; reg->func; reg++)
--- 415,421 ----
      if (!hinstLua)
      {
  	if (verbose)
! 	    semsg(_(e_loadlib), libname);
  	return FAIL;
      }
      for (reg = luaV_dll; reg->func; reg++)
***************
*** 425,431 ****
  	    close_dll(hinstLua);
  	    hinstLua = 0;
  	    if (verbose)
! 		EMSG2(_(e_loadfunc), reg->name);
  	    return FAIL;
  	}
      }
--- 425,431 ----
  	    close_dll(hinstLua);
  	    hinstLua = 0;
  	    if (verbose)
! 		semsg(_(e_loadfunc), reg->name);
  	    return FAIL;
  	}
      }
***************
*** 1795,1801 ****
  	return 0;
      }
      if (luaV_totypval(L, -1, rettv) == FAIL)
! 	EMSG("luaeval: cannot convert value");
      return 0;
  }
  
--- 1795,1801 ----
  	return 0;
      }
      if (luaV_totypval(L, -1, rettv) == FAIL)
! 	emsg("luaeval: cannot convert value");
      return 0;
  }
  
***************
*** 1926,1932 ****
  #ifdef DYNAMIC_LUA
  	if (!lua_enabled(TRUE))
  	{
! 	    EMSG(_("Lua library cannot be loaded."));
  	    return FAIL;
  	}
  #endif
--- 1926,1932 ----
  #ifdef DYNAMIC_LUA
  	if (!lua_enabled(TRUE))
  	{
! 	    emsg(_("Lua library cannot be loaded."));
  	    return FAIL;
  	}
  #endif
***************
*** 1978,1984 ****
      if (lua_init() == FAIL) return;
      if (u_save(eap->line1 - 1, eap->line2 + 1) == FAIL)
      {
! 	EMSG(_("cannot save undo information"));
  	return;
      }
      luaV_setrange(L, eap->line1, eap->line2);
--- 1978,1984 ----
      if (lua_init() == FAIL) return;
      if (u_save(eap->line1 - 1, eap->line2 + 1) == FAIL)
      {
! 	emsg(_("cannot save undo information"));
  	return;
      }
      luaV_setrange(L, eap->line1, eap->line2);
*** ../vim-8.1.0742/src/if_mzsch.c	2019-01-10 22:56:25.525250963 +0100
--- src/if_mzsch.c	2019-01-13 19:51:58.384322647 +0100
***************
*** 672,685 ****
      if (!hMzGC)
      {
  	if (verbose)
! 	    EMSG2(_(e_loadlib), gc_dll);
  	return FAIL;
      }
  
      if (!hMzSch)
      {
  	if (verbose)
! 	    EMSG2(_(e_loadlib), sch_dll);
  	return FAIL;
      }
  
--- 672,685 ----
      if (!hMzGC)
      {
  	if (verbose)
! 	    semsg(_(e_loadlib), gc_dll);
  	return FAIL;
      }
  
      if (!hMzSch)
      {
  	if (verbose)
! 	    semsg(_(e_loadlib), sch_dll);
  	return FAIL;
      }
  
***************
*** 693,699 ****
  	    FreeLibrary(hMzGC);
  	    hMzGC = 0;
  	    if (verbose)
! 		EMSG2(_(e_loadfunc), thunk->name);
  	    return FAIL;
  	}
      }
--- 693,699 ----
  	    FreeLibrary(hMzGC);
  	    hMzGC = 0;
  	    if (verbose)
! 		semsg(_(e_loadfunc), thunk->name);
  	    return FAIL;
  	}
      }
***************
*** 707,713 ****
  	    FreeLibrary(hMzGC);
  	    hMzGC = 0;
  	    if (verbose)
! 		EMSG2(_(e_loadfunc), thunk->name);
  	    return FAIL;
  	}
      }
--- 707,713 ----
  	    FreeLibrary(hMzGC);
  	    hMzGC = 0;
  	    if (verbose)
! 		semsg(_(e_loadfunc), thunk->name);
  	    return FAIL;
  	}
      }
***************
*** 1260,1272 ****
  #ifdef DYNAMIC_MZSCHEME
  	if (disabled || !mzscheme_enabled(TRUE))
  	{
! 	    EMSG(_("E815: Sorry, this command is disabled, the MzScheme libraries could not be loaded."));
  	    return -1;
  	}
  #endif
  	if (load_base_module_failed || startup_mzscheme())
  	{
! 	    EMSG(_("E895: Sorry, this command is disabled, the MzScheme's racket/base module could not be loaded."));
  	    return -1;
  	}
  	initialized = TRUE;
--- 1260,1272 ----
  #ifdef DYNAMIC_MZSCHEME
  	if (disabled || !mzscheme_enabled(TRUE))
  	{
! 	    emsg(_("E815: Sorry, this command is disabled, the MzScheme libraries could not be loaded."));
  	    return -1;
  	}
  #endif
  	if (load_base_module_failed || startup_mzscheme())
  	{
! 	    emsg(_("E895: Sorry, this command is disabled, the MzScheme's racket/base module could not be loaded."));
  	    return -1;
  	}
  	initialized = TRUE;
***************
*** 1572,1578 ****
      {
  	*p = '\0';
  	if (error)
! 	    EMSG(prev);
  	else
  	    MSG(prev);
  	prev = p + 1;
--- 1572,1578 ----
      {
  	*p = '\0';
  	if (error)
! 	    emsg(prev);
  	else
  	    MSG(prev);
  	prev = p + 1;
***************
*** 1580,1586 ****
      }
  
      if (error)
! 	EMSG(prev);
      else
  	MSG(prev);
  }
--- 1580,1586 ----
      }
  
      if (error)
! 	emsg(prev);
      else
  	MSG(prev);
  }
*** ../vim-8.1.0742/src/if_perl.xs	2019-01-12 22:47:01.260088089 +0100
--- src/if_perl.xs	2019-01-13 19:58:15.057080455 +0100
***************
*** 695,701 ****
      if ((hPerlLib = load_dll(libname)) == NULL)
      {
  	if (verbose)
! 	    EMSG2(_("E370: Could not load library %s"), libname);
  	return FAIL;
      }
      for (i = 0; perl_funcname_table[i].ptr; ++i)
--- 695,701 ----
      if ((hPerlLib = load_dll(libname)) == NULL)
      {
  	if (verbose)
! 	    semsg(_("E370: Could not load library %s"), libname);
  	return FAIL;
      }
      for (i = 0; perl_funcname_table[i].ptr; ++i)
***************
*** 706,712 ****
  	    close_dll(hPerlLib);
  	    hPerlLib = NULL;
  	    if (verbose)
! 		EMSG2(_(e_loadfunc), perl_funcname_table[i].name);
  	    return FAIL;
  	}
      }
--- 706,712 ----
  	    close_dll(hPerlLib);
  	    hPerlLib = NULL;
  	    if (verbose)
! 		semsg((const char *)_(e_loadfunc), perl_funcname_table[i].name);
  	    return FAIL;
  	}
      }
***************
*** 998,1004 ****
  #ifdef DYNAMIC_PERL
  	if (!perl_enabled(TRUE))
  	{
! 	    EMSG(_(e_noperl));
  	    vim_free(script);
  	    return;
  	}
--- 998,1004 ----
  #ifdef DYNAMIC_PERL
  	if (!perl_enabled(TRUE))
  	{
! 	    emsg(_(e_noperl));
  	    vim_free(script);
  	    return;
  	}
***************
*** 1025,1031 ****
  	safe = perl_get_sv("VIM::safe", FALSE);
  # ifndef MAKE_TEST  /* avoid a warning for unreachable code */
  	if (safe == NULL || !SvTRUE(safe))
! 	    EMSG(_("E299: Perl evaluation forbidden in sandbox without the Safe module"));
  	else
  # endif
  	{
--- 1025,1031 ----
  	safe = perl_get_sv("VIM::safe", FALSE);
  # ifndef MAKE_TEST  /* avoid a warning for unreachable code */
  	if (safe == NULL || !SvTRUE(safe))
! 	    emsg(_("E299: Perl evaluation forbidden in sandbox without the Safe module"));
  	else
  # endif
  	{
***************
*** 1235,1241 ****
  		    key = hv_iterkey(entry, &key_len);
  
  		    if (!key || !key_len || strlen(key) < (size_t)key_len) {
! 			EMSG2("Malformed key Dictionary '%s'", key && *key ? key : "(empty)");
  			break;
  		    }
  
--- 1235,1241 ----
  		    key = hv_iterkey(entry, &key_len);
  
  		    if (!key || !key_len || strlen(key) < (size_t)key_len) {
! 			semsg("Malformed key Dictionary '%s'", key && *key ? key : "(empty)");
  			break;
  		    }
  
***************
*** 1286,1292 ****
  #ifdef DYNAMIC_PERL
  	if (!perl_enabled(TRUE))
  	{
! 	    EMSG(_(e_noperl));
  	    return;
  	}
  #endif
--- 1286,1292 ----
  #ifdef DYNAMIC_PERL
  	if (!perl_enabled(TRUE))
  	{
! 	    emsg(_(e_noperl));
  	    return;
  	}
  #endif
***************
*** 1304,1310 ****
  	    safe = get_sv("VIM::safe", FALSE);
  # ifndef MAKE_TEST  /* avoid a warning for unreachable code */
  	    if (safe == NULL || !SvTRUE(safe))
! 		EMSG(_("E299: Perl evaluation forbidden in sandbox without the Safe module"));
  	    else
  # endif
  	    {
--- 1304,1310 ----
  	    safe = get_sv("VIM::safe", FALSE);
  # ifndef MAKE_TEST  /* avoid a warning for unreachable code */
  	    if (safe == NULL || !SvTRUE(safe))
! 		emsg(_("E299: Perl evaluation forbidden in sandbox without the Safe module"));
  	    else
  # endif
  	    {
***************
*** 1356,1362 ****
  #ifdef DYNAMIC_PERL
  	if (!perl_enabled(TRUE))
  	{
! 	    EMSG(_(e_noperl));
  	    return;
  	}
  #endif
--- 1356,1362 ----
  #ifdef DYNAMIC_PERL
  	if (!perl_enabled(TRUE))
  	{
! 	    emsg(_(e_noperl));
  	    return;
  	}
  #endif
*** ../vim-8.1.0742/src/if_py_both.h	2019-01-12 22:47:01.260088089 +0100
--- src/if_py_both.h	2019-01-13 19:58:18.909048411 +0100
***************
*** 536,542 ****
  
      if (PyErr_Occurred())
      {
! 	EMSG(_("E264: Python: Error initialising I/O objects"));
  	return -1;
      }
  
--- 536,542 ----
  
      if (PyErr_Occurred())
      {
! 	emsg(_("E264: Python: Error initialising I/O objects"));
  	return -1;
      }
  
***************
*** 5664,5670 ****
      }
      else if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_SystemExit))
      {
! 	EMSG2(_(e_py_systemexit), "python");
  	PyErr_Clear();
      }
      else
--- 5664,5670 ----
      }
      else if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_SystemExit))
      {
! 	semsg(_(e_py_systemexit), "python");
  	PyErr_Clear();
      }
      else
***************
*** 5691,5697 ****
  
      if (u_save((linenr_T)RangeStart - 1, (linenr_T)RangeEnd + 1) != OK)
      {
! 	EMSG(_("cannot save undo information"));
  	return;
      }
  
--- 5691,5697 ----
  
      if (u_save((linenr_T)RangeStart - 1, (linenr_T)RangeEnd + 1) != OK)
      {
! 	emsg(_("cannot save undo information"));
  	return;
      }
  
***************
*** 5709,5715 ****
      else if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_SystemExit))
      {
  	PyMem_Free(code);
! 	EMSG2(_(e_py_systemexit), "python");
  	PyErr_Clear();
  	return;
      }
--- 5709,5715 ----
      else if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_SystemExit))
      {
  	PyMem_Free(code);
! 	semsg(_(e_py_systemexit), "python");
  	PyErr_Clear();
  	return;
      }
***************
*** 5720,5726 ****
  
      if (status)
      {
! 	EMSG(_("failed to run the code"));
  	return;
      }
  
--- 5720,5726 ----
  
      if (status)
      {
! 	emsg(_("failed to run the code"));
  	return;
      }
  
***************
*** 5810,5829 ****
      {
  	if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_SystemExit))
  	{
! 	    EMSG2(_(e_py_systemexit), "python");
  	    PyErr_Clear();
  	}
  	else
  	{
  	    if (PyErr_Occurred() && !msg_silent)
  		PyErr_PrintEx(0);
! 	    EMSG(_("E858: Eval did not return a valid python object"));
  	}
      }
      else
      {
  	if (ConvertFromPyObject(run_ret, rettv) == -1)
! 	    EMSG(_("E859: Failed to convert returned python object to vim value"));
  	Py_DECREF(run_ret);
      }
      PyErr_Clear();
--- 5810,5829 ----
      {
  	if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_SystemExit))
  	{
! 	    semsg(_(e_py_systemexit), "python");
  	    PyErr_Clear();
  	}
  	else
  	{
  	    if (PyErr_Occurred() && !msg_silent)
  		PyErr_PrintEx(0);
! 	    emsg(_("E858: Eval did not return a valid python object"));
  	}
      }
      else
      {
  	if (ConvertFromPyObject(run_ret, rettv) == -1)
! 	    emsg(_("E859: Failed to convert returned python object to vim value"));
  	Py_DECREF(run_ret);
      }
      PyErr_Clear();
***************
*** 6727,6733 ****
      else
      {
  	VimTryStart();
! 	EMSG(_("Failed to set path hook: sys.path_hooks is not a list\n"
  	       "You should now do the following:\n"
  	       "- append vim.path_hook to sys.path_hooks\n"
  	       "- append vim.VIM_SPECIAL_PATH to sys.path\n"));
--- 6727,6733 ----
      else
      {
  	VimTryStart();
! 	emsg(_("Failed to set path hook: sys.path_hooks is not a list\n"
  	       "You should now do the following:\n"
  	       "- append vim.path_hook to sys.path_hooks\n"
  	       "- append vim.VIM_SPECIAL_PATH to sys.path\n"));
***************
*** 6757,6763 ****
      else
      {
  	VimTryStart();
! 	EMSG(_("Failed to set path: sys.path is not a list\n"
  	       "You should now append vim.VIM_SPECIAL_PATH to sys.path"));
  	VimTryEnd(); /* Discard the error */
      }
--- 6757,6763 ----
      else
      {
  	VimTryStart();
! 	emsg(_("Failed to set path: sys.path is not a list\n"
  	       "You should now append vim.VIM_SPECIAL_PATH to sys.path"));
  	VimTryEnd(); /* Discard the error */
      }
*** ../vim-8.1.0742/src/if_python.c	2019-01-12 22:47:01.260088089 +0100
--- src/if_python.c	2019-01-13 19:52:08.008236404 +0100
***************
*** 685,691 ****
      if (python3_loaded())
      {
  	if (verbose)
! 	    EMSG(_("E836: This Vim cannot execute :python after using :py3"));
  	return FAIL;
      }
  #endif
--- 685,691 ----
      if (python3_loaded())
      {
  	if (verbose)
! 	    emsg(_("E836: This Vim cannot execute :python after using :py3"));
  	return FAIL;
      }
  #endif
***************
*** 696,702 ****
      if (!hinstPython)
      {
  	if (verbose)
! 	    EMSG2(_(e_loadlib), libname);
  	return FAIL;
      }
  
--- 696,702 ----
      if (!hinstPython)
      {
  	if (verbose)
! 	    semsg(_(e_loadlib), libname);
  	return FAIL;
      }
  
***************
*** 708,714 ****
  	    close_dll(hinstPython);
  	    hinstPython = 0;
  	    if (verbose)
! 		EMSG2(_(e_loadfunc), python_funcname_table[i].name);
  	    return FAIL;
  	}
      }
--- 708,714 ----
  	    close_dll(hinstPython);
  	    hinstPython = 0;
  	    if (verbose)
! 		semsg(_(e_loadfunc), python_funcname_table[i].name);
  	    return FAIL;
  	}
      }
***************
*** 725,731 ****
  	close_dll(hinstPython);
  	hinstPython = 0;
  	if (verbose)
! 	    EMSG2(_(e_loadfunc), "PyUnicode_UCSX_*");
  	return FAIL;
      }
  
--- 725,731 ----
  	close_dll(hinstPython);
  	hinstPython = 0;
  	if (verbose)
! 	    semsg(_(e_loadfunc), "PyUnicode_UCSX_*");
  	return FAIL;
      }
  
***************
*** 928,934 ****
  #ifdef DYNAMIC_PYTHON
  	if (!python_enabled(TRUE))
  	{
! 	    EMSG(_("E263: Sorry, this command is disabled, the Python library could not be loaded."));
  	    goto fail;
  	}
  #endif
--- 928,934 ----
  #ifdef DYNAMIC_PYTHON
  	if (!python_enabled(TRUE))
  	{
! 	    emsg(_("E263: Sorry, this command is disabled, the Python library could not be loaded."));
  	    goto fail;
  	}
  #endif
***************
*** 960,966 ****
  	site = PyImport_ImportModule("site");
  	if (site == NULL)
  	{
! 	    EMSG(_("E887: Sorry, this command is disabled, the Python's site module could not be loaded."));
  	    goto fail;
  	}
  	Py_DECREF(site);
--- 960,966 ----
  	site = PyImport_ImportModule("site");
  	if (site == NULL)
  	{
! 	    emsg(_("E887: Sorry, this command is disabled, the Python's site module could not be loaded."));
  	    goto fail;
  	}
  	Py_DECREF(site);
***************
*** 1035,1041 ****
  #ifndef PY_CAN_RECURSE
      if (recursive)
      {
! 	EMSG(_("E659: Cannot invoke Python recursively"));
  	return;
      }
      ++recursive;
--- 1035,1041 ----
  #ifndef PY_CAN_RECURSE
      if (recursive)
      {
! 	emsg(_("E659: Cannot invoke Python recursively"));
  	return;
      }
      ++recursive;
*** ../vim-8.1.0742/src/if_python3.c	2019-01-12 22:47:01.260088089 +0100
--- src/if_python3.c	2019-01-13 19:52:20.724122796 +0100
***************
*** 634,640 ****
      if (python_loaded())
      {
  	if (verbose)
! 	    EMSG(_("E837: This Vim cannot execute :py3 after using :python"));
  	return FAIL;
      }
  # endif
--- 634,640 ----
      if (python_loaded())
      {
  	if (verbose)
! 	    emsg(_("E837: This Vim cannot execute :py3 after using :python"));
  	return FAIL;
      }
  # endif
***************
*** 646,652 ****
      if (!hinstPy3)
      {
  	if (verbose)
! 	    EMSG2(_(e_loadlib), libname);
  	return FAIL;
      }
  
--- 646,652 ----
      if (!hinstPy3)
      {
  	if (verbose)
! 	    semsg(_(e_loadlib), libname);
  	return FAIL;
      }
  
***************
*** 658,664 ****
  	    close_dll(hinstPy3);
  	    hinstPy3 = 0;
  	    if (verbose)
! 		EMSG2(_(e_loadfunc), py3_funcname_table[i].name);
  	    return FAIL;
  	}
      }
--- 658,664 ----
  	    close_dll(hinstPy3);
  	    hinstPy3 = 0;
  	    if (verbose)
! 		semsg(_(e_loadfunc), py3_funcname_table[i].name);
  	    return FAIL;
  	}
      }
***************
*** 693,699 ****
  	close_dll(hinstPy3);
  	hinstPy3 = 0;
  	if (verbose)
! 	    EMSG2(_(e_loadfunc), "PyUnicode_UCSX_*");
  	return FAIL;
      }
  
--- 693,699 ----
  	close_dll(hinstPy3);
  	hinstPy3 = 0;
  	if (verbose)
! 	    semsg(_(e_loadfunc), "PyUnicode_UCSX_*");
  	return FAIL;
      }
  
***************
*** 864,870 ****
  #ifdef DYNAMIC_PYTHON3
  	if (!python3_enabled(TRUE))
  	{
! 	    EMSG(_("E263: Sorry, this command is disabled, the Python library could not be loaded."));
  	    goto fail;
  	}
  #endif
--- 864,870 ----
  #ifdef DYNAMIC_PYTHON3
  	if (!python3_enabled(TRUE))
  	{
! 	    emsg(_("E263: Sorry, this command is disabled, the Python library could not be loaded."));
  	    goto fail;
  	}
  #endif
*** ../vim-8.1.0742/src/if_ruby.c	2019-01-12 22:47:01.264088074 +0100
--- src/if_ruby.c	2019-01-13 19:52:26.720069358 +0100
***************
*** 745,751 ****
      if (!hinstRuby)
      {
  	if (verbose)
! 	    EMSG2(_(e_loadlib), libname);
  	return FAIL;
      }
  
--- 745,751 ----
      if (!hinstRuby)
      {
  	if (verbose)
! 	    semsg(_(e_loadlib), libname);
  	return FAIL;
      }
  
***************
*** 757,763 ****
  	    close_dll(hinstRuby);
  	    hinstRuby = NULL;
  	    if (verbose)
! 		EMSG2(_(e_loadfunc), ruby_funcname_table[i].name);
  	    return FAIL;
  	}
      }
--- 757,763 ----
  	    close_dll(hinstRuby);
  	    hinstRuby = NULL;
  	    if (verbose)
! 		semsg(_(e_loadfunc), ruby_funcname_table[i].name);
  	    return FAIL;
  	}
      }
***************
*** 885,891 ****
  	    {
  		if (TYPE(line) != T_STRING)
  		{
! 		    EMSG(_("E265: $_ must be an instance of String"));
  		    return;
  		}
  		ml_replace(i, (char_u *) StringValuePtr(line), 1);
--- 885,891 ----
  	    {
  		if (TYPE(line) != T_STRING)
  		{
! 		    emsg(_("E265: $_ must be an instance of String"));
  		    return;
  		}
  		ml_replace(i, (char_u *) StringValuePtr(line), 1);
***************
*** 979,985 ****
  	}
  	else
  	{
! 	    EMSG(_("E266: Sorry, this command is disabled, the Ruby library could not be loaded."));
  	    return 0;
  	}
  #endif
--- 979,985 ----
  	}
  	else
  	{
! 	    emsg(_("E266: Sorry, this command is disabled, the Ruby library could not be loaded."));
  	    return 0;
  	}
  #endif
***************
*** 1013,1031 ****
      switch (state)
      {
      case TAG_RETURN:
! 	EMSG(_("E267: unexpected return"));
  	break;
      case TAG_NEXT:
! 	EMSG(_("E268: unexpected next"));
  	break;
      case TAG_BREAK:
! 	EMSG(_("E269: unexpected break"));
  	break;
      case TAG_REDO:
! 	EMSG(_("E270: unexpected redo"));
  	break;
      case TAG_RETRY:
! 	EMSG(_("E271: retry outside of rescue clause"));
  	break;
      case TAG_RAISE:
      case TAG_FATAL:
--- 1013,1031 ----
      switch (state)
      {
      case TAG_RETURN:
! 	emsg(_("E267: unexpected return"));
  	break;
      case TAG_NEXT:
! 	emsg(_("E268: unexpected next"));
  	break;
      case TAG_BREAK:
! 	emsg(_("E269: unexpected break"));
  	break;
      case TAG_REDO:
! 	emsg(_("E270: unexpected redo"));
  	break;
      case TAG_RETRY:
! 	emsg(_("E271: retry outside of rescue clause"));
  	break;
      case TAG_RAISE:
      case TAG_FATAL:
***************
*** 1038,1044 ****
  	einfo = rb_obj_as_string(error);
  	if (eclass == rb_eRuntimeError && RSTRING_LEN(einfo) == 0)
  	{
! 	    EMSG(_("E272: unhandled exception"));
  	}
  	else
  	{
--- 1038,1044 ----
  	einfo = rb_obj_as_string(error);
  	if (eclass == rb_eRuntimeError && RSTRING_LEN(einfo) == 0)
  	{
! 	    emsg(_("E272: unhandled exception"));
  	}
  	else
  	{
***************
*** 1050,1056 ****
  		     RSTRING_PTR(epath), RSTRING_PTR(einfo));
  	    p = strchr(buff, '\n');
  	    if (p) *p = '\0';
! 	    EMSG(buff);
  	}
  
  	attr = syn_name2attr((char_u *)"Error");
--- 1050,1056 ----
  		     RSTRING_PTR(epath), RSTRING_PTR(einfo));
  	    p = strchr(buff, '\n');
  	    if (p) *p = '\0';
! 	    emsg(buff);
  	}
  
  	attr = syn_name2attr((char_u *)"Error");
***************
*** 1066,1072 ****
  	break;
      default:
  	vim_snprintf(buff, BUFSIZ, _("E273: unknown longjmp status %d"), state);
! 	EMSG(buff);
  	break;
      }
  }
--- 1066,1072 ----
  	break;
      default:
  	vim_snprintf(buff, BUFSIZ, _("E273: unknown longjmp status %d"), state);
! 	emsg(buff);
  	break;
      }
  }
*** ../vim-8.1.0742/src/if_tcl.c	2018-11-16 16:21:01.641310033 +0100
--- src/if_tcl.c	2019-01-13 19:52:34.236002492 +0100
***************
*** 213,219 ****
      if (!(hTclLib = load_dll(libname)))
      {
  	if (verbose)
! 	    EMSG2(_(e_loadlib), libname);
  	return FAIL;
      }
      for (i = 0; tcl_funcname_table[i].ptr; ++i)
--- 213,219 ----
      if (!(hTclLib = load_dll(libname)))
      {
  	if (verbose)
! 	    semsg(_(e_loadlib), libname);
  	return FAIL;
      }
      for (i = 0; tcl_funcname_table[i].ptr; ++i)
***************
*** 224,230 ****
  	    close_dll(hTclLib);
  	    hTclLib = NULL;
  	    if (verbose)
! 		EMSG2(_(e_loadfunc), tcl_funcname_table[i].name);
  	    return FAIL;
  	}
      }
--- 224,230 ----
  	    close_dll(hTclLib);
  	    hTclLib = NULL;
  	    if (verbose)
! 		semsg(_(e_loadfunc), tcl_funcname_table[i].name);
  	    return FAIL;
  	}
      }
***************
*** 1539,1545 ****
  	reflist = reflist->next;
      }
      /* This should never happen.  Famous last word? */
!     EMSG(_("E280: TCL FATAL ERROR: reflist corrupt!? Please report this to vim-dev@vim.org"));
      Tcl_SetResult(interp, _("cannot register callback command: buffer/window reference not found"), TCL_STATIC);
      return TCL_ERROR;
  }
--- 1539,1545 ----
  	reflist = reflist->next;
      }
      /* This should never happen.  Famous last word? */
!     emsg(_("E280: TCL FATAL ERROR: reflist corrupt!? Please report this to vim-dev@vim.org"));
      Tcl_SetResult(interp, _("cannot register callback command: buffer/window reference not found"), TCL_STATIC);
      return TCL_ERROR;
  }
***************
*** 1709,1715 ****
  #ifdef DYNAMIC_TCL
      if (!tcl_enabled(TRUE))
      {
! 	EMSG(_("E571: Sorry, this command is disabled: the Tcl library could not be loaded."));
  	return FAIL;
      }
  #endif
--- 1709,1715 ----
  #ifdef DYNAMIC_TCL
      if (!tcl_enabled(TRUE))
      {
! 	emsg(_("E571: Sorry, this command is disabled: the Tcl library could not be loaded."));
  	return FAIL;
      }
  #endif
***************
*** 1817,1827 ****
      while ((next=strchr(text, '\n')))
      {
  	*next++ = '\0';
! 	EMSG(text);
  	text = next;
      }
      if (*text)
! 	EMSG(text);
  }
  
      static void
--- 1817,1827 ----
      while ((next=strchr(text, '\n')))
      {
  	*next++ = '\0';
! 	emsg(text);
  	text = next;
      }
      if (*text)
! 	emsg(text);
  }
  
      static void
*** ../vim-8.1.0742/src/if_xcmdsrv.c	2018-09-30 21:43:17.195693290 +0200
--- src/if_xcmdsrv.c	2019-01-13 19:52:40.651945512 +0100
***************
*** 427,433 ****
      if (w == None)
      {
  	if (!silent)
! 	    EMSG2(_(e_noserver), name);
  	return -1;
      }
      else if (loosename != NULL)
--- 427,433 ----
      if (w == None)
      {
  	if (!silent)
! 	    semsg(_(e_noserver), name);
  	return -1;
      }
      else if (loosename != NULL)
***************
*** 467,473 ****
      vim_free(property);
      if (res < 0)
      {
! 	EMSG(_("E248: Failed to send command to the destination program"));
  	return -1;
      }
  
--- 467,473 ----
      vim_free(property);
      if (res < 0)
      {
! 	emsg(_("E248: Failed to send command to the destination program"));
  	return -1;
      }
  
***************
*** 732,738 ****
  
      sscanf((char *)str, "0x%x", &id);
      if (id == None)
! 	EMSG2(_("E573: Invalid server id used: %s"), str);
  
      return (Window)id;
  }
--- 732,738 ----
  
      sscanf((char *)str, "0x%x", &id);
      if (id == None)
! 	semsg(_("E573: Invalid server id used: %s"), str);
  
      return (Window)id;
  }
***************
*** 1110,1116 ****
  	    XFree(*regPropp);
  	XDeleteProperty(dpy, RootWindow(dpy, 0), registryProperty);
  	if (domsg)
! 	    EMSG(_("E251: VIM instance registry property is badly formed.  Deleted!"));
  	return FAIL;
      }
      return OK;
--- 1110,1116 ----
  	    XFree(*regPropp);
  	XDeleteProperty(dpy, RootWindow(dpy, 0), registryProperty);
  	if (domsg)
! 	    emsg(_("E251: VIM instance registry property is badly formed.  Deleted!"));
  	return FAIL;
      }
      return OK;
*** ../vim-8.1.0742/src/json.c	2019-01-12 22:47:01.264088074 +0100
--- src/json.c	2019-01-13 19:52:49.323868645 +0100
***************
*** 232,238 ****
  	case VAR_JOB:
  	case VAR_CHANNEL:
  	    /* no JSON equivalent TODO: better error */
! 	    EMSG(_(e_invarg));
  	    return FAIL;
  
  	case VAR_BLOB:
--- 232,238 ----
  	case VAR_JOB:
  	case VAR_CHANNEL:
  	    /* no JSON equivalent TODO: better error */
! 	    emsg(_(e_invarg));
  	    return FAIL;
  
  	case VAR_BLOB:
***************
*** 739,745 ****
  			retval = json_decode_string(reader, cur_item, *p);
  		    else
  		    {
! 			EMSG(_(e_invarg));
  			retval = FAIL;
  		    }
  		    break;
--- 739,745 ----
  			retval = json_decode_string(reader, cur_item, *p);
  		    else
  		    {
! 			emsg(_(e_invarg));
  			retval = FAIL;
  		    }
  		    break;
***************
*** 747,753 ****
  		case ',': /* comma: empty item */
  		    if ((options & JSON_JS) == 0)
  		    {
! 			EMSG(_(e_invarg));
  			retval = FAIL;
  			break;
  		    }
--- 747,753 ----
  		case ',': /* comma: empty item */
  		    if ((options & JSON_JS) == 0)
  		    {
! 			emsg(_(e_invarg));
  			retval = FAIL;
  			break;
  		    }
***************
*** 777,783 ****
  			    }
  			    if (!VIM_ISDIGIT(*sp))
  			    {
! 				EMSG(_(e_invarg));
  				retval = FAIL;
  				break;
  			    }
--- 777,783 ----
  			    }
  			    if (!VIM_ISDIGIT(*sp))
  			    {
! 				emsg(_(e_invarg));
  				retval = FAIL;
  				break;
  			    }
***************
*** 915,921 ****
  		if (top_item->jd_key == NULL)
  		{
  		    clear_tv(cur_item);
! 		    EMSG(_(e_invarg));
  		    retval = FAIL;
  		    goto theend;
  		}
--- 915,921 ----
  		if (top_item->jd_key == NULL)
  		{
  		    clear_tv(cur_item);
! 		    emsg(_(e_invarg));
  		    retval = FAIL;
  		    goto theend;
  		}
***************
*** 953,959 ****
  			retval = MAYBE;
  		    else
  		    {
! 			EMSG(_(e_invarg));
  			retval = FAIL;
  		    }
  		    goto theend;
--- 953,959 ----
  			retval = MAYBE;
  		    else
  		    {
! 			emsg(_(e_invarg));
  			retval = FAIL;
  		    }
  		    goto theend;
***************
*** 971,977 ****
  			retval = MAYBE;
  		    else
  		    {
! 			EMSG(_(e_invarg));
  			retval = FAIL;
  		    }
  		    goto theend;
--- 971,977 ----
  			retval = MAYBE;
  		    else
  		    {
! 			emsg(_(e_invarg));
  			retval = FAIL;
  		    }
  		    goto theend;
***************
*** 988,994 ****
  			&& dict_find(top_item->jd_tv.vval.v_dict,
  						 top_item->jd_key, -1) != NULL)
  		{
! 		    EMSG2(_("E938: Duplicate key in JSON: \"%s\""),
  							     top_item->jd_key);
  		    clear_tv(&top_item->jd_key_tv);
  		    clear_tv(cur_item);
--- 988,994 ----
  			&& dict_find(top_item->jd_tv.vval.v_dict,
  						 top_item->jd_key, -1) != NULL)
  		{
! 		    semsg(_("E938: Duplicate key in JSON: \"%s\""),
  							     top_item->jd_key);
  		    clear_tv(&top_item->jd_key_tv);
  		    clear_tv(cur_item);
***************
*** 1027,1033 ****
  			retval = MAYBE;
  		    else
  		    {
! 			EMSG(_(e_invarg));
  			retval = FAIL;
  		    }
  		    goto theend;
--- 1027,1033 ----
  			retval = MAYBE;
  		    else
  		    {
! 			emsg(_(e_invarg));
  			retval = FAIL;
  		    }
  		    goto theend;
***************
*** 1046,1052 ****
  	res->v_type = VAR_SPECIAL;
  	res->vval.v_number = VVAL_NONE;
      }
!     EMSG(_(e_invarg));
  
  theend:
      ga_clear(&stack);
--- 1046,1052 ----
  	res->v_type = VAR_SPECIAL;
  	res->vval.v_number = VVAL_NONE;
      }
!     emsg(_(e_invarg));
  
  theend:
      ga_clear(&stack);
***************
*** 1070,1082 ****
      if (ret != OK)
      {
  	if (ret == MAYBE)
! 	    EMSG(_(e_invarg));
  	return FAIL;
      }
      json_skip_white(reader);
      if (reader->js_buf[reader->js_used] != NUL)
      {
! 	EMSG(_(e_trailing));
  	return FAIL;
      }
      return OK;
--- 1070,1082 ----
      if (ret != OK)
      {
  	if (ret == MAYBE)
! 	    emsg(_(e_invarg));
  	return FAIL;
      }
      json_skip_white(reader);
      if (reader->js_buf[reader->js_used] != NUL)
      {
! 	emsg(_(e_trailing));
  	return FAIL;
      }
      return OK;
*** ../vim-8.1.0742/src/list.c	2018-12-21 16:04:16.316437487 +0100
--- src/list.c	2019-01-13 19:52:56.739803042 +0100
***************
*** 417,423 ****
      li = list_find(l, idx - 1);
      if (li == NULL)
      {
! 	EMSGN(_(e_listidx), idx);
  	return NULL;
      }
      return tv_get_string(&li->li_tv);
--- 417,423 ----
      li = list_find(l, idx - 1);
      if (li == NULL)
      {
! 	semsg(_(e_listidx), idx);
  	return NULL;
      }
      return tv_get_string(&li->li_tv);
***************
*** 914,920 ****
  	    break;
  	if (**arg != ',')
  	{
! 	    EMSG2(_("E696: Missing comma in List: %s"), *arg);
  	    goto failret;
  	}
  	*arg = skipwhite(*arg + 1);
--- 914,920 ----
  	    break;
  	if (**arg != ',')
  	{
! 	    semsg(_("E696: Missing comma in List: %s"), *arg);
  	    goto failret;
  	}
  	*arg = skipwhite(*arg + 1);
***************
*** 922,928 ****
  
      if (**arg != ']')
      {
! 	EMSG2(_("E697: Missing end of List ']': %s"), *arg);
  failret:
  	if (evaluate)
  	    list_free(l);
--- 922,928 ----
  
      if (**arg != ']')
      {
! 	semsg(_("E697: Missing end of List ']': %s"), *arg);
  failret:
  	if (evaluate)
  	    list_free(l);
***************
*** 969,975 ****
  	    }
  	if (ret == FAIL)
  	{
! 	    EMSG(_(e_write));
  	    break;
  	}
      }
--- 969,975 ----
  	    }
  	if (ret == FAIL)
  	{
! 	    emsg(_(e_write));
  	    break;
  	}
      }
*** ../vim-8.1.0742/src/main.c	2019-01-11 20:34:18.296314730 +0100
--- src/main.c	2019-01-13 19:27:43.424613996 +0100
***************
*** 945,951 ****
  
      /*
       * Allocate space for the generic buffers (needed for set_init_1() and
!      * EMSG2()).
       */
      if ((IObuff = alloc(IOSIZE)) == NULL
  	    || (NameBuff = alloc(MAXPATHL)) == NULL)
--- 945,951 ----
  
      /*
       * Allocate space for the generic buffers (needed for set_init_1() and
!      * emsg()).
       */
      if ((IObuff = alloc(IOSIZE)) == NULL
  	    || (NameBuff = alloc(MAXPATHL)) == NULL)
***************
*** 3020,3026 ****
  	else
  	{
  	    if (do_source(parmp->use_vimrc, FALSE, DOSO_NONE) != OK)
! 		EMSG2(_("E282: Cannot read from \"%s\""), parmp->use_vimrc);
  	}
      }
      else if (!silent_mode)
--- 3020,3026 ----
  	else
  	{
  	    if (do_source(parmp->use_vimrc, FALSE, DOSO_NONE) != OK)
! 		semsg(_("E282: Cannot read from \"%s\""), parmp->use_vimrc);
  	}
      }
      else if (!silent_mode)
*** ../vim-8.1.0742/src/mark.c	2018-12-31 23:58:20.246887218 +0100
--- src/mark.c	2019-01-13 19:55:26.054505500 +0100
***************
*** 606,612 ****
  {
      if (pos == NULL)
      {
! 	EMSG(_(e_umark));
  	return FAIL;
      }
      if (pos->lnum <= 0)
--- 606,612 ----
  {
      if (pos == NULL)
      {
! 	emsg(_(e_umark));
  	return FAIL;
      }
      if (pos->lnum <= 0)
***************
*** 614,625 ****
  	/* lnum is negative if mark is in another file can can't get that
  	 * file, error message already give then. */
  	if (pos->lnum == 0)
! 	    EMSG(_(e_marknotset));
  	return FAIL;
      }
      if (pos->lnum > curbuf->b_ml.ml_line_count)
      {
! 	EMSG(_(e_markinval));
  	return FAIL;
      }
      return OK;
--- 614,625 ----
  	/* lnum is negative if mark is in another file can can't get that
  	 * file, error message already give then. */
  	if (pos->lnum == 0)
! 	    emsg(_(e_marknotset));
  	return FAIL;
      }
      if (pos->lnum > curbuf->b_ml.ml_line_count)
      {
! 	emsg(_(e_markinval));
  	return FAIL;
      }
      return OK;
***************
*** 763,769 ****
  	    if (arg == NULL)
  		MSG(_("No marks set"));
  	    else
! 		EMSG2(_("E283: No marks matching \"%s\""), arg);
  	}
      }
      /* don't output anything if 'q' typed at --more-- prompt */
--- 763,769 ----
  	    if (arg == NULL)
  		MSG(_("No marks set"));
  	    else
! 		semsg(_("E283: No marks matching \"%s\""), arg);
  	}
      }
      /* don't output anything if 'q' typed at --more-- prompt */
***************
*** 815,823 ****
  	/* clear all marks */
  	clrallmarks(curbuf);
      else if (eap->forceit)
! 	EMSG(_(e_invarg));
      else if (*eap->arg == NUL)
! 	EMSG(_(e_argreq));
      else
      {
  	/* clear specified marks only */
--- 815,823 ----
  	/* clear all marks */
  	clrallmarks(curbuf);
      else if (eap->forceit)
! 	emsg(_(e_invarg));
      else if (*eap->arg == NUL)
! 	emsg(_(e_argreq));
      else
      {
  	/* clear specified marks only */
***************
*** 837,843 ****
  				    : ASCII_ISUPPER(p[2])))
  			    || to < from)
  		    {
! 			EMSG2(_(e_invarg2), p);
  			return;
  		    }
  		    p += 2;
--- 837,843 ----
  				    : ASCII_ISUPPER(p[2])))
  			    || to < from)
  		    {
! 			semsg(_(e_invarg2), p);
  			return;
  		    }
  		    p += 2;
***************
*** 875,881 ****
  		    case '<': curbuf->b_visual.vi_start.lnum = 0; break;
  		    case '>': curbuf->b_visual.vi_end.lnum   = 0; break;
  		    case ' ': break;
! 		    default:  EMSG2(_(e_invarg2), p);
  			      return;
  		}
  	}
--- 875,881 ----
  		    case '<': curbuf->b_visual.vi_start.lnum = 0; break;
  		    case '>': curbuf->b_visual.vi_end.lnum   = 0; break;
  		    case ' ': break;
! 		    default:  semsg(_(e_invarg2), p);
  			      return;
  		}
  	}
*** ../vim-8.1.0742/src/mbyte.c	2018-09-30 21:43:17.195693290 +0200
--- src/mbyte.c	2019-01-13 20:12:29.878230171 +0100
***************
*** 199,205 ****
  	fd = mch_fopen("xim.log", "w");
  	if (fd == NULL)
  	{
! 	    EMSG("Cannot open xim.log");
  	    fd = (FILE *)-1;
  	    return;
  	}
--- 199,205 ----
  	fd = mch_fopen("xim.log", "w");
  	if (fd == NULL)
  	{
! 	    emsg("Cannot open xim.log");
  	    fd = (FILE *)-1;
  	    return;
  	}
***************
*** 509,515 ****
   * When there is something wrong: Returns an error message and doesn't change
   * anything.
   */
!     char_u *
  mb_init(void)
  {
      int		i;
--- 509,515 ----
   * When there is something wrong: Returns an error message and doesn't change
   * anything.
   */
!     char *
  mb_init(void)
  {
      int		i;
***************
*** 4749,4755 ****
  	if (verbose && p_verbose > 0)
  	{
  	    verbose_enter();
! 	    EMSG2(_(e_loadlib),
  		    hIconvDLL == 0 ? DYNAMIC_ICONV_DLL : DYNAMIC_MSVCRT_DLL);
  	    verbose_leave();
  	}
--- 4749,4755 ----
  	if (verbose && p_verbose > 0)
  	{
  	    verbose_enter();
! 	    semsg(_(e_loadlib),
  		    hIconvDLL == 0 ? DYNAMIC_ICONV_DLL : DYNAMIC_MSVCRT_DLL);
  	    verbose_leave();
  	}
***************
*** 4771,4777 ****
  	if (verbose && p_verbose > 0)
  	{
  	    verbose_enter();
! 	    EMSG2(_(e_loadfunc), "for libiconv");
  	    verbose_leave();
  	}
  	return FALSE;
--- 4771,4777 ----
  	if (verbose && p_verbose > 0)
  	{
  	    verbose_enter();
! 	    semsg(_(e_loadfunc), "for libiconv");
  	    verbose_leave();
  	}
  	return FALSE;
***************
*** 6028,6034 ****
  					XNLineSpace, line_space,
  					NULL);
  	if (XSetICValues(xic, XNPreeditAttributes, attr_list, NULL))
! 	    EMSG(_("E284: Cannot set IC values"));
  	XFree(attr_list);
      }
  }
--- 6028,6034 ----
  					XNLineSpace, line_space,
  					NULL);
  	if (XSetICValues(xic, XNPreeditAttributes, attr_list, NULL))
! 	    emsg(_("E284: Cannot set IC values"));
  	XFree(attr_list);
      }
  }
***************
*** 6187,6193 ****
  	if (p_verbose > 0)
  	{
  	    verbose_enter();
! 	    EMSG(_("E286: Failed to open input method"));
  	    verbose_leave();
  	}
  	return FALSE;
--- 6187,6193 ----
  	if (p_verbose > 0)
  	{
  	    verbose_enter();
! 	    emsg(_("E286: Failed to open input method"));
  	    verbose_leave();
  	}
  	return FALSE;
***************
*** 6200,6212 ****
  	destroy_cb.callback = xim_destroy_cb;
  	destroy_cb.client_data = NULL;
  	if (XSetIMValues(xim, XNDestroyCallback, &destroy_cb, NULL))
! 	    EMSG(_("E287: Warning: Could not set destroy callback to IM"));
      }
  #  endif
  
      if (XGetIMValues(xim, XNQueryInputStyle, &xim_styles, NULL) || !xim_styles)
      {
! 	EMSG(_("E288: input method doesn't support any style"));
  	XCloseIM(xim);
  	return FALSE;
      }
--- 6200,6212 ----
  	destroy_cb.callback = xim_destroy_cb;
  	destroy_cb.client_data = NULL;
  	if (XSetIMValues(xim, XNDestroyCallback, &destroy_cb, NULL))
! 	    emsg(_("E287: Warning: Could not set destroy callback to IM"));
      }
  #  endif
  
      if (XGetIMValues(xim, XNQueryInputStyle, &xim_styles, NULL) || !xim_styles)
      {
! 	emsg(_("E288: input method doesn't support any style"));
  	XCloseIM(xim);
  	return FALSE;
      }
***************
*** 6265,6271 ****
  	if (p_verbose > 0)
  	{
  	    verbose_enter();
! 	    EMSG(_("E289: input method doesn't support my preedit type"));
  	    verbose_leave();
  	}
  	XCloseIM(xim);
--- 6265,6271 ----
  	if (p_verbose > 0)
  	{
  	    verbose_enter();
! 	    emsg(_("E289: input method doesn't support my preedit type"));
  	    verbose_leave();
  	}
  	XCloseIM(xim);
***************
*** 6329,6335 ****
      else
      {
  	if (!is_not_a_term())
! 	    EMSG(_(e_xim));
  	XCloseIM(xim);
  	return FALSE;
      }
--- 6329,6335 ----
      else
      {
  	if (!is_not_a_term())
! 	    emsg(_(e_xim));
  	XCloseIM(xim);
  	return FALSE;
      }
*** ../vim-8.1.0742/src/memfile.c	2018-09-21 14:48:49.644214400 +0200
--- src/memfile.c	2019-01-13 19:55:35.550424328 +0100
***************
*** 245,251 ****
      if (mfp->mf_fd >= 0)
      {
  	if (close(mfp->mf_fd) < 0)
! 	    EMSG(_(e_swapclose));
      }
      if (del_file && mfp->mf_fname != NULL)
  	mch_remove(mfp->mf_fname);
--- 245,251 ----
      if (mfp->mf_fd >= 0)
      {
  	if (close(mfp->mf_fd) < 0)
! 	    emsg(_(e_swapclose));
      }
      if (del_file && mfp->mf_fname != NULL)
  	mch_remove(mfp->mf_fname);
***************
*** 291,297 ****
      }
  
      if (close(mfp->mf_fd) < 0)			/* close the file */
! 	EMSG(_(e_swapclose));
      mfp->mf_fd = -1;
  
      if (mfp->mf_fname != NULL)
--- 291,297 ----
      }
  
      if (close(mfp->mf_fd) < 0)			/* close the file */
! 	emsg(_(e_swapclose));
      mfp->mf_fd = -1;
  
      if (mfp->mf_fname != NULL)
***************
*** 480,486 ****
      flags = hp->bh_flags;
  
      if ((flags & BH_LOCKED) == 0)
! 	IEMSG(_("E293: block was not locked"));
      flags &= ~BH_LOCKED;
      if (dirty)
      {
--- 480,486 ----
      flags = hp->bh_flags;
  
      if ((flags & BH_LOCKED) == 0)
! 	iemsg(_("E293: block was not locked"));
      flags &= ~BH_LOCKED;
      if (dirty)
      {
***************
*** 1040,1046 ****
  	     * space becomes available.
  	     */
  	    if (!did_swapwrite_msg)
! 		EMSG(_("E297: Write error in swap file"));
  	    did_swapwrite_msg = TRUE;
  	    return FAIL;
  	}
--- 1040,1046 ----
  	     * space becomes available.
  	     */
  	    if (!did_swapwrite_msg)
! 		emsg(_("E297: Write error in swap file"));
  	    did_swapwrite_msg = TRUE;
  	    return FAIL;
  	}
***************
*** 1256,1262 ****
      if ((flags & O_CREAT) && mch_lstat((char *)mfp->mf_fname, &sb) >= 0)
      {
  	mfp->mf_fd = -1;
! 	EMSG(_("E300: Swap file already exists (symlink attack?)"));
      }
      else
  #endif
--- 1256,1262 ----
      if ((flags & O_CREAT) && mch_lstat((char *)mfp->mf_fname, &sb) >= 0)
      {
  	mfp->mf_fd = -1;
! 	emsg(_("E300: Swap file already exists (symlink attack?)"));
      }
      else
  #endif
*** ../vim-8.1.0742/src/memline.c	2019-01-04 15:09:52.918373097 +0100
--- src/memline.c	2019-01-13 19:55:40.714380247 +0100
***************
*** 8,14 ****
   */
  
  /* for debugging */
! /* #define CHECK(c, s)	do { if (c) EMSG(s); } while (0) */
  #define CHECK(c, s)	do { /**/ } while (0)
  
  /*
--- 8,14 ----
   */
  
  /* for debugging */
! /* #define CHECK(c, s)	do { if (c) emsg((s)); } while (0) */
  #define CHECK(c, s)	do { /**/ } while (0)
  
  /*
***************
*** 328,334 ****
  	goto error;
      if (hp->bh_bnum != 0)
      {
! 	IEMSG(_("E298: Didn't get block nr 0?"));
  	goto error;
      }
      b0p = (ZERO_BL *)(hp->bh_data);
--- 328,334 ----
  	goto error;
      if (hp->bh_bnum != 0)
      {
! 	iemsg(_("E298: Didn't get block nr 0?"));
  	goto error;
      }
      b0p = (ZERO_BL *)(hp->bh_data);
***************
*** 378,384 ****
  	goto error;
      if (hp->bh_bnum != 1)
      {
! 	IEMSG(_("E298: Didn't get block nr 1?"));
  	goto error;
      }
      pp = (PTR_BL *)(hp->bh_data);
--- 378,384 ----
  	goto error;
      if (hp->bh_bnum != 1)
      {
! 	iemsg(_("E298: Didn't get block nr 1?"));
  	goto error;
      }
      pp = (PTR_BL *)(hp->bh_data);
***************
*** 396,402 ****
  	goto error;
      if (hp->bh_bnum != 2)
      {
! 	IEMSG(_("E298: Didn't get block nr 2?"));
  	goto error;
      }
  
--- 396,402 ----
  	goto error;
      if (hp->bh_bnum != 2)
      {
! 	iemsg(_("E298: Didn't get block nr 2?"));
  	goto error;
      }
  
***************
*** 610,616 ****
  	    mf_put(mfp, hp, FALSE, FALSE);  /* release previous block */
  
  	if (error > 0)
! 	    EMSG(_("E843: Error while updating swap file crypt"));
      }
  
      mfp->mf_old_key = NULL;
--- 610,616 ----
  	    mf_put(mfp, hp, FALSE, FALSE);  /* release previous block */
  
  	if (error > 0)
! 	    emsg(_("E843: Error while updating swap file crypt"));
      }
  
      mfp->mf_old_key = NULL;
***************
*** 708,714 ****
  	if (mfp->mf_fd < 0)
  	{
  	    /* could not (re)open the swap file, what can we do???? */
! 	    EMSG(_("E301: Oops, lost the swap file!!!"));
  	    return;
  	}
  #ifdef HAVE_FD_CLOEXEC
--- 708,714 ----
  	if (mfp->mf_fd < 0)
  	{
  	    /* could not (re)open the swap file, what can we do???? */
! 	    emsg(_("E301: Oops, lost the swap file!!!"));
  	    return;
  	}
  #ifdef HAVE_FD_CLOEXEC
***************
*** 720,726 ****
  #endif
      }
      if (!success)
! 	EMSG(_("E302: Could not rename swap file"));
  }
  
  /*
--- 720,726 ----
  #endif
      }
      if (!success)
! 	emsg(_("E302: Could not rename swap file"));
  }
  
  /*
***************
*** 811,817 ****
      {
  	need_wait_return = TRUE;	/* call wait_return later */
  	++no_wait_return;
! 	(void)EMSG2(_("E303: Unable to open swap file for \"%s\", recovery impossible"),
  		    buf_spname(buf) != NULL ? buf_spname(buf) : buf->b_fname);
  	--no_wait_return;
      }
--- 811,817 ----
      {
  	need_wait_return = TRUE;	/* call wait_return later */
  	++no_wait_return;
! 	(void)semsg(_("E303: Unable to open swap file for \"%s\", recovery impossible"),
  		    buf_spname(buf) != NULL ? buf_spname(buf) : buf->b_fname);
  	--no_wait_return;
      }
***************
*** 946,952 ****
  
      b0p = (ZERO_BL *)(hp->bh_data);
      if (ml_check_b0_id(b0p) == FAIL)
! 	IEMSG(_("E304: ml_upd_block0(): Didn't get block 0??"));
      else
      {
  	if (what == UB_FNAME)
--- 946,952 ----
  
      b0p = (ZERO_BL *)(hp->bh_data);
      if (ml_check_b0_id(b0p) == FAIL)
! 	iemsg(_("E304: ml_upd_block0(): Didn't get block 0??"));
      else
      {
  	if (what == UB_FNAME)
***************
*** 1164,1170 ****
  	len = recover_names(fname, FALSE, 0, NULL);
  	if (len == 0)		    /* no swap files found */
  	{
! 	    EMSG2(_("E305: No swap file found for %s"), fname);
  	    goto theend;
  	}
  	if (len == 1)		    /* one swap file found, use it */
--- 1164,1170 ----
  	len = recover_names(fname, FALSE, 0, NULL);
  	if (len == 0)		    /* no swap files found */
  	{
! 	    semsg(_("E305: No swap file found for %s"), fname);
  	    goto theend;
  	}
  	if (len == 1)		    /* one swap file found, use it */
***************
*** 1221,1227 ****
      if (mfp == NULL || mfp->mf_fd < 0)
      {
  	if (fname_used != NULL)
! 	    EMSG2(_("E306: Cannot open %s"), fname_used);
  	goto theend;
      }
      buf->b_ml.ml_mfp = mfp;
--- 1221,1227 ----
      if (mfp == NULL || mfp->mf_fd < 0)
      {
  	if (fname_used != NULL)
! 	    semsg(_("E306: Cannot open %s"), fname_used);
  	goto theend;
      }
      buf->b_ml.ml_mfp = mfp;
***************
*** 1263,1269 ****
      }
      if (ml_check_b0_id(b0p) == FAIL)
      {
! 	EMSG2(_("E307: %s does not look like a Vim swap file"), mfp->mf_fname);
  	goto theend;
      }
      if (b0_magic_wrong(b0p))
--- 1263,1269 ----
      }
      if (ml_check_b0_id(b0p) == FAIL)
      {
! 	semsg(_("E307: %s does not look like a Vim swap file"), mfp->mf_fname);
  	goto theend;
      }
      if (b0_magic_wrong(b0p))
***************
*** 1297,1303 ****
  #else
      if (b0p->b0_id[1] != BLOCK0_ID1)
      {
! 	EMSG2(_("E833: %s is encrypted and this version of Vim does not support encryption"), mfp->mf_fname);
  	goto theend;
      }
  #endif
--- 1297,1303 ----
  #else
      if (b0p->b0_id[1] != BLOCK0_ID1)
      {
! 	semsg(_("E833: %s is encrypted and this version of Vim does not support encryption"), mfp->mf_fname);
  	goto theend;
      }
  #endif
***************
*** 1347,1359 ****
      }
  
      home_replace(NULL, mfp->mf_fname, NameBuff, MAXPATHL, TRUE);
!     smsg((char_u *)_("Using swap file \"%s\""), NameBuff);
  
      if (buf_spname(curbuf) != NULL)
  	vim_strncpy(NameBuff, buf_spname(curbuf), MAXPATHL - 1);
      else
  	home_replace(NULL, curbuf->b_ffname, NameBuff, MAXPATHL, TRUE);
!     smsg((char_u *)_("Original file \"%s\""), NameBuff);
      msg_putchar('\n');
  
      /*
--- 1347,1359 ----
      }
  
      home_replace(NULL, mfp->mf_fname, NameBuff, MAXPATHL, TRUE);
!     smsg(_("Using swap file \"%s\""), NameBuff);
  
      if (buf_spname(curbuf) != NULL)
  	vim_strncpy(NameBuff, buf_spname(curbuf), MAXPATHL - 1);
      else
  	home_replace(NULL, curbuf->b_ffname, NameBuff, MAXPATHL, TRUE);
!     smsg(_("Original file \"%s\""), NameBuff);
      msg_putchar('\n');
  
      /*
***************
*** 1366,1372 ****
  		    && org_stat.st_mtime > swp_stat.st_mtime)
  		|| org_stat.st_mtime != mtime))
      {
! 	EMSG(_("E308: Warning: Original file may have been changed"));
      }
      out_flush();
  
--- 1366,1372 ----
  		    && org_stat.st_mtime > swp_stat.st_mtime)
  		|| org_stat.st_mtime != mtime))
      {
! 	emsg(_("E308: Warning: Original file may have been changed"));
      }
      out_flush();
  
***************
*** 1412,1425 ****
  	 * without a key, will probably get garbage text. */
  	if (*curbuf->b_p_key != NUL)
  	{
! 	    smsg((char_u *)_("Swap file is encrypted: \"%s\""), fname_used);
  	    MSG_PUTS(_("\nIf you entered a new crypt key but did not write the text file,"));
  	    MSG_PUTS(_("\nenter the new crypt key."));
  	    MSG_PUTS(_("\nIf you wrote the text file after changing the crypt key press enter"));
  	    MSG_PUTS(_("\nto use the same key for text file and swap file"));
  	}
  	else
! 	    smsg((char_u *)_(need_key_msg), fname_used);
  	buf->b_p_key = crypt_get_key(FALSE, FALSE);
  	if (buf->b_p_key == NULL)
  	    buf->b_p_key = curbuf->b_p_key;
--- 1412,1425 ----
  	 * without a key, will probably get garbage text. */
  	if (*curbuf->b_p_key != NUL)
  	{
! 	    smsg(_("Swap file is encrypted: \"%s\""), fname_used);
  	    MSG_PUTS(_("\nIf you entered a new crypt key but did not write the text file,"));
  	    MSG_PUTS(_("\nenter the new crypt key."));
  	    MSG_PUTS(_("\nIf you wrote the text file after changing the crypt key press enter"));
  	    MSG_PUTS(_("\nto use the same key for text file and swap file"));
  	}
  	else
! 	    smsg(_(need_key_msg), fname_used);
  	buf->b_p_key = crypt_get_key(FALSE, FALSE);
  	if (buf->b_p_key == NULL)
  	    buf->b_p_key = curbuf->b_p_key;
***************
*** 1471,1477 ****
  	{
  	    if (bnum == 1)
  	    {
! 		EMSG2(_("E309: Unable to read block 1 from %s"), mfp->mf_fname);
  		goto theend;
  	    }
  	    ++error;
--- 1471,1477 ----
  	{
  	    if (bnum == 1)
  	    {
! 		semsg(_("E309: Unable to read block 1 from %s"), mfp->mf_fname);
  		goto theend;
  	    }
  	    ++error;
***************
*** 1557,1563 ****
  		{
  		    if (bnum == 1)
  		    {
! 			EMSG2(_("E310: Block 1 ID wrong (%s not a .swp file?)"),
  							       mfp->mf_fname);
  			goto theend;
  		    }
--- 1557,1563 ----
  		{
  		    if (bnum == 1)
  		    {
! 			semsg(_("E310: Block 1 ID wrong (%s not a .swp file?)"),
  							       mfp->mf_fname);
  			goto theend;
  		    }
***************
*** 1677,1688 ****
  
      recoverymode = FALSE;
      if (got_int)
! 	EMSG(_("E311: Recovery Interrupted"));
      else if (error)
      {
  	++no_wait_return;
  	MSG(">>>>>>>>>>>>>");
! 	EMSG(_("E312: Errors detected while recovering; look for lines starting with ???"));
  	--no_wait_return;
  	MSG(_("See \":help E312\" for more information."));
  	MSG(">>>>>>>>>>>>>");
--- 1677,1688 ----
  
      recoverymode = FALSE;
      if (got_int)
! 	emsg(_("E311: Recovery Interrupted"));
      else if (error)
      {
  	++no_wait_return;
  	MSG(">>>>>>>>>>>>>");
! 	emsg(_("E312: Errors detected while recovering; look for lines starting with ???"));
  	--no_wait_return;
  	MSG(_("See \":help E312\" for more information."));
  	MSG(">>>>>>>>>>>>>");
***************
*** 2361,2367 ****
      if (mfp == NULL || mfp->mf_fname == NULL)
      {
  	if (message)
! 	    EMSG(_("E313: Cannot preserve, there is no swap file"));
  	return;
      }
  
--- 2361,2367 ----
      if (mfp == NULL || mfp->mf_fname == NULL)
      {
  	if (message)
! 	    emsg(_("E313: Cannot preserve, there is no swap file"));
  	return;
      }
  
***************
*** 2416,2422 ****
  	if (status == OK)
  	    MSG(_("File preserved"));
  	else
! 	    EMSG(_("E314: Preserve failed"));
      }
  }
  
--- 2416,2422 ----
  	if (status == OK)
  	    MSG(_("File preserved"));
  	else
! 	    emsg(_("E314: Preserve failed"));
      }
  }
  
***************
*** 2490,2496 ****
  	    /* Avoid giving this message for a recursive call, may happen when
  	     * the GUI redraws part of the text. */
  	    ++recursive;
! 	    IEMSGN(_("E315: ml_get: invalid lnum: %ld"), lnum);
  	    --recursive;
  	}
  errorret:
--- 2490,2496 ----
  	    /* Avoid giving this message for a recursive call, may happen when
  	     * the GUI redraws part of the text. */
  	    ++recursive;
! 	    siemsg(_("E315: ml_get: invalid lnum: %ld"), lnum);
  	    --recursive;
  	}
  errorret:
***************
*** 2529,2535 ****
  		/* Avoid giving this message for a recursive call, may happen
  		 * when the GUI redraws part of the text. */
  		++recursive;
! 		IEMSGN(_("E316: ml_get: cannot find line %ld"), lnum);
  		--recursive;
  	    }
  	    goto errorret;
--- 2529,2535 ----
  		/* Avoid giving this message for a recursive call, may happen
  		 * when the GUI redraws part of the text. */
  		++recursive;
! 		siemsg(_("E316: ml_get: cannot find line %ld"), lnum);
  		--recursive;
  	    }
  	    goto errorret;
***************
*** 3026,3032 ****
  	    pp = (PTR_BL *)(hp->bh_data);   /* must be pointer block */
  	    if (pp->pb_id != PTR_ID)
  	    {
! 		IEMSG(_("E317: pointer block id wrong 3"));
  		mf_put(mfp, hp, FALSE, FALSE);
  		goto theend;
  	    }
--- 3026,3032 ----
  	    pp = (PTR_BL *)(hp->bh_data);   /* must be pointer block */
  	    if (pp->pb_id != PTR_ID)
  	    {
! 		iemsg(_("E317: pointer block id wrong 3"));
  		mf_put(mfp, hp, FALSE, FALSE);
  		goto theend;
  	    }
***************
*** 3168,3174 ****
  	 */
  	if (stack_idx < 0)
  	{
! 	    IEMSG(_("E318: Updated too many blocks?"));
  	    buf->b_ml.ml_stack_top = 0;	/* invalidate stack */
  	}
      }
--- 3168,3174 ----
  	 */
  	if (stack_idx < 0)
  	{
! 	    iemsg(_("E318: Updated too many blocks?"));
  	    buf->b_ml.ml_stack_top = 0;	/* invalidate stack */
  	}
      }
***************
*** 3544,3550 ****
  	    pp = (PTR_BL *)(hp->bh_data);   /* must be pointer block */
  	    if (pp->pb_id != PTR_ID)
  	    {
! 		IEMSG(_("E317: pointer block id wrong 4"));
  		mf_put(mfp, hp, FALSE, FALSE);
  		goto theend;
  	    }
--- 3544,3550 ----
  	    pp = (PTR_BL *)(hp->bh_data);   /* must be pointer block */
  	    if (pp->pb_id != PTR_ID)
  	    {
! 		iemsg(_("E317: pointer block id wrong 4"));
  		mf_put(mfp, hp, FALSE, FALSE);
  		goto theend;
  	    }
***************
*** 3770,3776 ****
  
  	hp = ml_find_line(buf, lnum, ML_FIND);
  	if (hp == NULL)
! 	    IEMSGN(_("E320: Cannot find line %ld"), lnum);
  	else
  	{
  	    dp = (DATA_BL *)(hp->bh_data);
--- 3770,3776 ----
  
  	hp = ml_find_line(buf, lnum, ML_FIND);
  	if (hp == NULL)
! 	    siemsg(_("E320: Cannot find line %ld"), lnum);
  	else
  	{
  	    dp = (DATA_BL *)(hp->bh_data);
***************
*** 4012,4018 ****
  	pp = (PTR_BL *)(dp);		/* must be pointer block */
  	if (pp->pb_id != PTR_ID)
  	{
! 	    IEMSG(_("E317: pointer block id wrong"));
  	    goto error_block;
  	}
  
--- 4012,4018 ----
  	pp = (PTR_BL *)(dp);		/* must be pointer block */
  	if (pp->pb_id != PTR_ID)
  	{
! 	    iemsg(_("E317: pointer block id wrong"));
  	    goto error_block;
  	}
  
***************
*** 4057,4067 ****
  	if (idx >= (int)pp->pb_count)	    /* past the end: something wrong! */
  	{
  	    if (lnum > buf->b_ml.ml_line_count)
! 		IEMSGN(_("E322: line number out of range: %ld past the end"),
  					      lnum - buf->b_ml.ml_line_count);
  
  	    else
! 		IEMSGN(_("E323: line count wrong in block %ld"), bnum);
  	    goto error_block;
  	}
  	if (action == ML_DELETE)
--- 4057,4067 ----
  	if (idx >= (int)pp->pb_count)	    /* past the end: something wrong! */
  	{
  	    if (lnum > buf->b_ml.ml_line_count)
! 		siemsg(_("E322: line number out of range: %ld past the end"),
  					      lnum - buf->b_ml.ml_line_count);
  
  	    else
! 		siemsg(_("E323: line count wrong in block %ld"), bnum);
  	    goto error_block;
  	}
  	if (action == ML_DELETE)
***************
*** 4155,4161 ****
  	if (pp->pb_id != PTR_ID)
  	{
  	    mf_put(mfp, hp, FALSE, FALSE);
! 	    IEMSG(_("E317: pointer block id wrong 2"));
  	    break;
  	}
  	pp->pb_pointer[ip->ip_index].pe_line_count += count;
--- 4155,4161 ----
  	if (pp->pb_id != PTR_ID)
  	{
  	    mf_put(mfp, hp, FALSE, FALSE);
! 	    iemsg(_("E317: pointer block id wrong 2"));
  	    break;
  	}
  	pp->pb_pointer[ip->ip_index].pe_line_count += count;
***************
*** 4190,4196 ****
  	/* Limit symlink depth to 100, catch recursive loops. */
  	if (++depth == 100)
  	{
! 	    EMSG2(_("E773: Symlink loop for \"%s\""), fname);
  	    return FAIL;
  	}
  
--- 4190,4196 ----
  	/* Limit symlink depth to 100, catch recursive loops. */
  	if (++depth == 100)
  	{
! 	    semsg(_("E773: Symlink loop for \"%s\""), fname);
  	    return FAIL;
  	}
  
***************
*** 4372,4378 ****
      char	*p;
  
      ++no_wait_return;
!     (void)EMSG(_("E325: ATTENTION"));
      MSG_PUTS(_("\nFound a swap file by the name \""));
      msg_home_replace(fname);
      MSG_PUTS("\"\n");
--- 4372,4378 ----
      char	*p;
  
      ++no_wait_return;
!     (void)emsg(_("E325: ATTENTION"));
      MSG_PUTS(_("\nFound a swap file by the name \""));
      msg_home_replace(fname);
      MSG_PUTS("\"\n");
***************
*** 4915,4921 ****
  	{
  	    if (fname[n - 2] == 'a')    /* ".saa": tried enough, give up */
  	    {
! 		EMSG(_("E326: Too many swap files found"));
  		VIM_CLEAR(fname);
  		break;
  	    }
--- 4915,4921 ----
  	{
  	    if (fname[n - 2] == 'a')    /* ".saa": tried enough, give up */
  	    {
! 		emsg(_("E326: Too many swap files found"));
  		VIM_CLEAR(fname);
  		break;
  	    }
*** ../vim-8.1.0742/src/menu.c	2019-01-06 13:10:46.328499104 +0100
--- src/menu.c	2019-01-13 19:55:44.242350157 +0100
***************
*** 274,280 ****
      menu_path = arg;
      if (*menu_path == '.')
      {
! 	EMSG2(_(e_invarg2), menu_path);
  	goto theend;
      }
  
--- 274,280 ----
      menu_path = arg;
      if (*menu_path == '.')
      {
! 	semsg(_(e_invarg2), menu_path);
  	goto theend;
      }
  
***************
*** 290,296 ****
      }
      else if (*map_to != NUL && (unmenu || enable != MAYBE))
      {
! 	EMSG(_(e_trailing));
  	goto theend;
      }
  #if defined(FEAT_GUI) && !(defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON))
--- 290,296 ----
      }
      else if (*map_to != NUL && (unmenu || enable != MAYBE))
      {
! 	emsg(_(e_trailing));
  	goto theend;
      }
  #if defined(FEAT_GUI) && !(defined(FEAT_GUI_GTK) || defined(FEAT_GUI_PHOTON))
***************
*** 515,521 ****
  	if (*dname == NUL)
  	{
  	    /* Only a mnemonic or accelerator is not valid. */
! 	    EMSG(_("E792: Empty menu name"));
  	    goto erret;
  	}
  
--- 515,521 ----
  	if (*dname == NUL)
  	{
  	    /* Only a mnemonic or accelerator is not valid. */
! 	    emsg(_("E792: Empty menu name"));
  	    goto erret;
  	}
  
***************
*** 533,539 ****
  		if (*next_name == NUL && menu->children != NULL)
  		{
  		    if (!sys_menu)
! 			EMSG(_("E330: Menu path must not lead to a sub-menu"));
  		    goto erret;
  		}
  		if (*next_name != NUL && menu->children == NULL
--- 533,539 ----
  		if (*next_name == NUL && menu->children != NULL)
  		{
  		    if (!sys_menu)
! 			emsg(_("E330: Menu path must not lead to a sub-menu"));
  		    goto erret;
  		}
  		if (*next_name != NUL && menu->children == NULL
***************
*** 543,549 ****
  			)
  		{
  		    if (!sys_menu)
! 			EMSG(_(e_notsubmenu));
  		    goto erret;
  		}
  		break;
--- 543,549 ----
  			)
  		{
  		    if (!sys_menu)
! 			emsg(_(e_notsubmenu));
  		    goto erret;
  		}
  		break;
***************
*** 572,584 ****
  	{
  	    if (*next_name == NUL && parent == NULL)
  	    {
! 		EMSG(_("E331: Must not add menu items directly to menu bar"));
  		goto erret;
  	    }
  
  	    if (menu_is_separator(dname) && *next_name != NUL)
  	    {
! 		EMSG(_("E332: Separator cannot be part of a menu path"));
  		goto erret;
  	    }
  
--- 572,584 ----
  	{
  	    if (*next_name == NUL && parent == NULL)
  	    {
! 		emsg(_("E331: Must not add menu items directly to menu bar"));
  		goto erret;
  	    }
  
  	    if (menu_is_separator(dname) && *next_name != NUL)
  	    {
! 		emsg(_("E332: Separator cannot be part of a menu path"));
  		goto erret;
  	    }
  
***************
*** 867,873 ****
  	    {
  		if (menu->children == NULL)
  		{
! 		    EMSG(_(e_notsubmenu));
  		    return FAIL;
  		}
  		if (menu_nable_recurse(menu->children, p, modes, enable)
--- 867,873 ----
  	    {
  		if (menu->children == NULL)
  		{
! 		    emsg(_(e_notsubmenu));
  		    return FAIL;
  		}
  		if (menu_nable_recurse(menu->children, p, modes, enable)
***************
*** 892,898 ****
      }
      if (*name != NUL && *name != '*' && menu == NULL)
      {
! 	EMSG2(_(e_nomenu), name);
  	return FAIL;
      }
  
--- 892,898 ----
      }
      if (*name != NUL && *name != '*' && menu == NULL)
      {
! 	semsg(_(e_nomenu), name);
  	return FAIL;
      }
  
***************
*** 933,939 ****
  	    if (*p != NUL && menu->children == NULL)
  	    {
  		if (!silent)
! 		    EMSG(_(e_notsubmenu));
  		return FAIL;
  	    }
  	    if ((menu->modes & modes) != 0x0)
--- 933,939 ----
  	    if (*p != NUL && menu->children == NULL)
  	    {
  		if (!silent)
! 		    emsg(_(e_notsubmenu));
  		return FAIL;
  	    }
  	    if ((menu->modes & modes) != 0x0)
***************
*** 955,961 ****
  	    else if (*name != NUL)
  	    {
  		if (!silent)
! 		    EMSG(_(e_menuothermode));
  		return FAIL;
  	    }
  
--- 955,961 ----
  	    else if (*name != NUL)
  	    {
  		if (!silent)
! 		    emsg(_(e_menuothermode));
  		return FAIL;
  	    }
  
***************
*** 985,991 ****
  	if (menu == NULL)
  	{
  	    if (!silent)
! 		EMSG2(_(e_nomenu), name);
  	    return FAIL;
  	}
  
--- 985,991 ----
  	if (menu == NULL)
  	{
  	    if (!silent)
! 		semsg(_(e_nomenu), name);
  	    return FAIL;
  	}
  
***************
*** 1123,1135 ****
  		/* Found menu */
  		if (*p != NUL && menu->children == NULL)
  		{
! 		    EMSG(_(e_notsubmenu));
  		    vim_free(path_name);
  		    return FAIL;
  		}
  		else if ((menu->modes & modes) == 0x0)
  		{
! 		    EMSG(_(e_menuothermode));
  		    vim_free(path_name);
  		    return FAIL;
  		}
--- 1123,1135 ----
  		/* Found menu */
  		if (*p != NUL && menu->children == NULL)
  		{
! 		    emsg(_(e_notsubmenu));
  		    vim_free(path_name);
  		    return FAIL;
  		}
  		else if ((menu->modes & modes) == 0x0)
  		{
! 		    emsg(_(e_menuothermode));
  		    vim_free(path_name);
  		    return FAIL;
  		}
***************
*** 1139,1145 ****
  	}
  	if (menu == NULL)
  	{
! 	    EMSG2(_(e_nomenu), name);
  	    vim_free(path_name);
  	    return FAIL;
  	}
--- 1139,1145 ----
  	}
  	if (menu == NULL)
  	{
! 	    semsg(_(e_nomenu), name);
  	    vim_free(path_name);
  	    return FAIL;
  	}
***************
*** 2400,2406 ****
  	    default:
  		mode = (char_u *)"Normal";
  	}
! 	EMSG2(_("E335: Menu not defined for %s mode"), mode);
      }
  }
  
--- 2400,2406 ----
  	    default:
  		mode = (char_u *)"Normal";
  	}
! 	semsg(_("E335: Menu not defined for %s mode"), mode);
      }
  }
  
***************
*** 2430,2436 ****
  	    case 't': mode_idx = MENU_INDEX_TERMINAL; break;
  	    case 'i': mode_idx = MENU_INDEX_INSERT; break;
  	    case 'c': mode_idx = MENU_INDEX_CMDLINE; break;
! 	    default: EMSG2(_(e_invarg2), arg);
  		     return;
  	}
  	arg = skipwhite(arg + 2);
--- 2430,2436 ----
  	    case 't': mode_idx = MENU_INDEX_TERMINAL; break;
  	    case 'i': mode_idx = MENU_INDEX_INSERT; break;
  	    case 'c': mode_idx = MENU_INDEX_CMDLINE; break;
! 	    default: semsg(_(e_invarg2), arg);
  		     return;
  	}
  	arg = skipwhite(arg + 2);
***************
*** 2453,2465 ****
  	    {
  		if (*p == NUL && menu->children != NULL)
  		{
! 		    EMSG(_("E333: Menu path must lead to a menu item"));
  		    gave_emsg = TRUE;
  		    menu = NULL;
  		}
  		else if (*p != NUL && menu->children == NULL)
  		{
! 		    EMSG(_(e_notsubmenu));
  		    menu = NULL;
  		}
  		break;
--- 2453,2465 ----
  	    {
  		if (*p == NUL && menu->children != NULL)
  		{
! 		    emsg(_("E333: Menu path must lead to a menu item"));
  		    gave_emsg = TRUE;
  		    menu = NULL;
  		}
  		else if (*p != NUL && menu->children == NULL)
  		{
! 		    emsg(_(e_notsubmenu));
  		    menu = NULL;
  		}
  		break;
***************
*** 2475,2481 ****
      if (menu == NULL)
      {
  	if (!gave_emsg)
! 	    EMSG2(_("E334: Menu not found: %s"), arg);
  	return;
      }
  
--- 2475,2481 ----
      if (menu == NULL)
      {
  	if (!gave_emsg)
! 	    semsg(_("E334: Menu not found: %s"), arg);
  	return;
      }
  
***************
*** 2567,2575 ****
  		{
  		    /* found a menu item instead of a sub-menu */
  		    if (*p == NUL)
! 			EMSG(_("E336: Menu path must lead to a sub-menu"));
  		    else
! 			EMSG(_(e_notsubmenu));
  		    menu = NULL;
  		    goto theend;
  		}
--- 2567,2575 ----
  		{
  		    /* found a menu item instead of a sub-menu */
  		    if (*p == NUL)
! 			emsg(_("E336: Menu path must lead to a sub-menu"));
  		    else
! 			emsg(_(e_notsubmenu));
  		    menu = NULL;
  		    goto theend;
  		}
***************
*** 2588,2594 ****
      }
  
      if (menu == NULL)
! 	EMSG(_("E337: Menu not found - check menu names"));
  theend:
      vim_free(saved_name);
      return menu;
--- 2588,2594 ----
      }
  
      if (menu == NULL)
! 	emsg(_("E337: Menu not found - check menu names"));
  theend:
      vim_free(saved_name);
      return menu;
***************
*** 2654,2660 ****
  	*arg = NUL;
  	arg = menu_skip_part(to);
  	if (arg == to)
! 	    EMSG(_(e_invarg));
  	else
  	{
  	    if (ga_grow(&menutrans_ga, 1) == OK)
--- 2654,2660 ----
  	*arg = NUL;
  	arg = menu_skip_part(to);
  	if (arg == to)
! 	    emsg(_(e_invarg));
  	else
  	{
  	    if (ga_grow(&menutrans_ga, 1) == OK)
*** ../vim-8.1.0742/src/message.c	2018-12-22 13:27:59.119503967 +0100
--- src/message.c	2019-01-13 23:00:36.661000639 +0100
***************
*** 358,380 ****
  
  /*
   * Automatic prototype generation does not understand this function.
!  * Note: Caller of smgs() and smsg_attr() must check the resulting string is
   * shorter than IOSIZE!!!
   */
  #ifndef PROTO
  
! int vim_snprintf(char *str, size_t str_m, char *fmt, ...);
  
      int
  # ifdef __BORLANDC__
  _RTLENTRYF
  # endif
! smsg(char_u *s, ...)
  {
      va_list arglist;
  
      va_start(arglist, s);
!     vim_vsnprintf((char *)IObuff, IOSIZE, (char *)s, arglist);
      va_end(arglist);
      return msg(IObuff);
  }
--- 358,380 ----
  
  /*
   * Automatic prototype generation does not understand this function.
!  * Note: Caller of smsg() and smsg_attr() must check the resulting string is
   * shorter than IOSIZE!!!
   */
  #ifndef PROTO
  
! int vim_snprintf(char *str, size_t str_m, const char *fmt, ...);
  
      int
  # ifdef __BORLANDC__
  _RTLENTRYF
  # endif
! smsg(const char *s, ...)
  {
      va_list arglist;
  
      va_start(arglist, s);
!     vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);
      va_end(arglist);
      return msg(IObuff);
  }
***************
*** 383,394 ****
  # ifdef __BORLANDC__
  _RTLENTRYF
  # endif
! smsg_attr(int attr, char_u *s, ...)
  {
      va_list arglist;
  
      va_start(arglist, s);
!     vim_vsnprintf((char *)IObuff, IOSIZE, (char *)s, arglist);
      va_end(arglist);
      return msg_attr(IObuff, attr);
  }
--- 383,394 ----
  # ifdef __BORLANDC__
  _RTLENTRYF
  # endif
! smsg_attr(int attr, const char *s, ...)
  {
      va_list arglist;
  
      va_start(arglist, s);
!     vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);
      va_end(arglist);
      return msg_attr(IObuff, attr);
  }
***************
*** 397,408 ****
  # ifdef __BORLANDC__
  _RTLENTRYF
  # endif
! smsg_attr_keep(int attr, char_u *s, ...)
  {
      va_list arglist;
  
      va_start(arglist, s);
!     vim_vsnprintf((char *)IObuff, IOSIZE, (char *)s, arglist);
      va_end(arglist);
      return msg_attr_keep(IObuff, attr, TRUE);
  }
--- 397,408 ----
  # ifdef __BORLANDC__
  _RTLENTRYF
  # endif
! smsg_attr_keep(int attr, const char *s, ...)
  {
      va_list arglist;
  
      va_start(arglist, s);
!     vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);
      va_end(arglist);
      return msg_attr_keep(IObuff, attr, TRUE);
  }
***************
*** 582,602 ****
  {
      perror(msg);
      ++emsg_silent;
!     emsg((char_u *)msg);
      --emsg_silent;
  }
  #endif
  
  /*
!  * emsg() - display an error message
   *
   * Rings the bell, if appropriate, and calls message() to do the real work
   * When terminal not initialized (yet) mch_errmsg(..) is used.
   *
!  * return TRUE if wait_return not called
   */
!     int
! emsg(char_u *s)
  {
      int		attr;
      char_u	*p;
--- 582,603 ----
  {
      perror(msg);
      ++emsg_silent;
!     emsg(msg);
      --emsg_silent;
  }
  #endif
  
  /*
!  * emsg_core() - display an error message
   *
   * Rings the bell, if appropriate, and calls message() to do the real work
   * When terminal not initialized (yet) mch_errmsg(..) is used.
   *
!  * Return TRUE if wait_return not called.
!  * Note: caller must check 'emsg_not_now()' before calling this.
   */
!     static int
! emsg_core(char_u *s)
  {
      int		attr;
      char_u	*p;
***************
*** 606,615 ****
      int		severe;
  #endif
  
-     /* Skip this if not giving error messages at the moment. */
-     if (emsg_not_now())
- 	return TRUE;
- 
  #ifdef FEAT_EVAL
      /* When testing some errors are turned into a normal message. */
      if (ignore_error(s))
--- 607,612 ----
***************
*** 727,766 ****
      return r;
  }
  
- 
  /*
!  * Print an error message with one "%s" and one string argument.
   */
      int
! emsg2(char_u *s, char_u *a1)
  {
!     return emsg3(s, a1, NULL);
  }
  
  /*
!  * Print an error message with one or two "%s" and one or two string arguments.
!  * This is not in message.c to avoid a warning for prototypes.
   */
      int
! emsg3(char_u *s, char_u *a1, char_u *a2)
  {
!     if (emsg_not_now())
! 	return TRUE;		/* no error messages at the moment */
!     vim_snprintf((char *)IObuff, IOSIZE, (char *)s, a1, a2);
!     return emsg(IObuff);
! }
  
! /*
!  * Print an error message with one "%ld" and one long int argument.
!  * This is not in message.c to avoid a warning for prototypes.
!  */
!     int
! emsgn(char_u *s, long n)
! {
!     if (emsg_not_now())
! 	return TRUE;		/* no error messages at the moment */
!     vim_snprintf((char *)IObuff, IOSIZE, (char *)s, n);
!     return emsg(IObuff);
  }
  
  /*
--- 724,759 ----
      return r;
  }
  
  /*
!  * Print an error message.
   */
      int
! emsg(char *s)
  {
!     /* Skip this if not giving error messages at the moment. */
!     if (!emsg_not_now())
! 	return emsg_core((char_u *)s);
!     return TRUE;		/* no error messages at the moment */
  }
  
  /*
!  * Print an error message with format string and variable arguments.
!  * Note: caller must not pass 'IObuff' as 1st argument.
   */
      int
! semsg(const char *s, ...)
  {
!     /* Skip this if not giving error messages at the moment. */
!     if (!emsg_not_now())
!     {
! 	va_list ap;
  
! 	va_start(ap, s);
! 	vim_vsnprintf((char *)IObuff, IOSIZE, s, ap);
! 	va_end(ap);
! 	return emsg_core(IObuff);
!     }
!     return TRUE;		/* no error messages at the moment */
  }
  
  /*
***************
*** 769,806 ****
   * detected when fuzzing vim.
   */
      void
! iemsg(char_u *s)
  {
!     emsg(s);
  #ifdef ABORT_ON_INTERNAL_ERROR
      abort();
  #endif
  }
  
- 
  /*
!  * Same as emsg2(...) but abort on error when ABORT_ON_INTERNAL_ERROR is
   * defined. It is used for internal errors only, so that they can be
   * detected when fuzzing vim.
   */
      void
! iemsg2(char_u *s, char_u *a1)
  {
!     emsg2(s, a1);
! #ifdef ABORT_ON_INTERNAL_ERROR
!     abort();
! #endif
! }
  
! /*
!  * Same as emsgn(...) but abort on error when ABORT_ON_INTERNAL_ERROR is
!  * defined. It is used for internal errors only, so that they can be
!  * detected when fuzzing vim.
!  */
!     void
! iemsgn(char_u *s, long n)
! {
!     emsgn(s, n);
  #ifdef ABORT_ON_INTERNAL_ERROR
      abort();
  #endif
--- 762,794 ----
   * detected when fuzzing vim.
   */
      void
! iemsg(char *s)
  {
!     if (!emsg_not_now())
! 	emsg_core((char_u *)s);
  #ifdef ABORT_ON_INTERNAL_ERROR
      abort();
  #endif
  }
  
  /*
!  * Same as semsg(...) but abort on error when ABORT_ON_INTERNAL_ERROR is
   * defined. It is used for internal errors only, so that they can be
   * detected when fuzzing vim.
+  * Note: caller must not pass 'IObuff' as 1st argument.
   */
      void
! siemsg(const char *s, ...)
  {
!     if (!emsg_not_now())
!     {
! 	va_list ap;
  
! 	va_start(ap, s);
! 	vim_vsnprintf((char *)IObuff, IOSIZE, s, ap);
! 	va_end(ap);
! 	emsg_core(IObuff);
!     }
  #ifdef ABORT_ON_INTERNAL_ERROR
      abort();
  #endif
***************
*** 812,818 ****
      void
  internal_error(char *where)
  {
!     IEMSG2(_(e_intern2), where);
  }
  
  /* emsg3() and emsgn() are in misc2.c to avoid warnings for the prototypes. */
--- 800,806 ----
      void
  internal_error(char *where)
  {
!     siemsg(_(e_intern2), where);
  }
  
  /* emsg3() and emsgn() are in misc2.c to avoid warnings for the prototypes. */
***************
*** 820,826 ****
      void
  emsg_invreg(int name)
  {
!     EMSG2(_("E354: Invalid register name: '%s'"), transchar(name));
  }
  
  /*
--- 808,814 ----
      void
  emsg_invreg(int name)
  {
!     semsg(_("E354: Invalid register name: '%s'"), transchar(name));
  }
  
  /*
***************
*** 969,975 ****
  
      if (*eap->arg != NUL)
      {
! 	EMSG(_(e_invarg));
  	return;
      }
  
--- 957,963 ----
  
      if (*eap->arg != NUL)
      {
! 	emsg(_(e_invarg));
  	return;
      }
  
***************
*** 3473,3479 ****
  	verbose_fd = mch_fopen((char *)p_vfile, "a");
  	if (verbose_fd == NULL)
  	{
! 	    EMSG2(_(e_notopen), p_vfile);
  	    return FAIL;
  	}
      }
--- 3461,3467 ----
  	verbose_fd = mch_fopen((char *)p_vfile, "a");
  	if (verbose_fd == NULL)
  	{
! 	    semsg(_(e_notopen), p_vfile);
  	    return FAIL;
  	}
      }
***************
*** 4092,4098 ****
  # endif
      {
  	/* TODO: non-GUI file selector here */
! 	EMSG(_("E338: Sorry, no file browser in console mode"));
  	fname = NULL;
      }
  
--- 4080,4086 ----
  # endif
      {
  	/* TODO: non-GUI file selector here */
! 	emsg(_("E338: Sorry, no file browser in console mode"));
  	fname = NULL;
      }
  
***************
*** 4136,4142 ****
      int		err = FALSE;
  
      if (tvs[idx].v_type == VAR_UNKNOWN)
! 	EMSG(_(e_printf));
      else
      {
  	++*idxp;
--- 4124,4130 ----
      int		err = FALSE;
  
      if (tvs[idx].v_type == VAR_UNKNOWN)
! 	emsg(_(e_printf));
      else
      {
  	++*idxp;
***************
*** 4163,4169 ****
      static char_u   numbuf[NUMBUFLEN];
  
      if (tvs[idx].v_type == VAR_UNKNOWN)
! 	EMSG(_(e_printf));
      else
      {
  	++*idxp;
--- 4151,4157 ----
      static char_u   numbuf[NUMBUFLEN];
  
      if (tvs[idx].v_type == VAR_UNKNOWN)
! 	emsg(_(e_printf));
      else
      {
  	++*idxp;
***************
*** 4186,4192 ****
      double	f = 0;
  
      if (tvs[idx].v_type == VAR_UNKNOWN)
! 	EMSG(_(e_printf));
      else
      {
  	++*idxp;
--- 4174,4180 ----
      double	f = 0;
  
      if (tvs[idx].v_type == VAR_UNKNOWN)
! 	emsg(_(e_printf));
      else
      {
  	++*idxp;
***************
*** 4195,4201 ****
  	else if (tvs[idx].v_type == VAR_NUMBER)
  	    f = (double)tvs[idx].vval.v_number;
  	else
! 	    EMSG(_("E807: Expected Float argument for printf()"));
      }
      return f;
  }
--- 4183,4189 ----
  	else if (tvs[idx].v_type == VAR_NUMBER)
  	    f = (double)tvs[idx].vval.v_number;
  	else
! 	    emsg(_("E807: Expected Float argument for printf()"));
      }
      return f;
  }
***************
*** 4274,4280 ****
  
  /* Like vim_vsnprintf() but append to the string. */
      int
! vim_snprintf_add(char *str, size_t str_m, char *fmt, ...)
  {
      va_list	ap;
      int		str_l;
--- 4262,4268 ----
  
  /* Like vim_vsnprintf() but append to the string. */
      int
! vim_snprintf_add(char *str, size_t str_m, const char *fmt, ...)
  {
      va_list	ap;
      int		str_l;
***************
*** 4292,4298 ****
  }
  
      int
! vim_snprintf(char *str, size_t str_m, char *fmt, ...)
  {
      va_list	ap;
      int		str_l;
--- 4280,4286 ----
  }
  
      int
! vim_snprintf(char *str, size_t str_m, const char *fmt, ...)
  {
      va_list	ap;
      int		str_l;
***************
*** 4307,4313 ****
  vim_vsnprintf(
      char	*str,
      size_t	str_m,
!     char	*fmt,
      va_list	ap)
  {
      return vim_vsnprintf_typval(str, str_m, fmt, ap, NULL);
--- 4295,4301 ----
  vim_vsnprintf(
      char	*str,
      size_t	str_m,
!     const char	*fmt,
      va_list	ap)
  {
      return vim_vsnprintf_typval(str, str_m, fmt, ap, NULL);
***************
*** 4317,4328 ****
  vim_vsnprintf_typval(
      char	*str,
      size_t	str_m,
!     char	*fmt,
      va_list	ap,
      typval_T	*tvs)
  {
      size_t	str_l = 0;
!     char	*p = fmt;
      int		arg_idx = 1;
  
      if (p == NULL)
--- 4305,4316 ----
  vim_vsnprintf_typval(
      char	*str,
      size_t	str_m,
!     const char	*fmt,
      va_list	ap,
      typval_T	*tvs)
  {
      size_t	str_l = 0;
!     const char	*p = fmt;
      int		arg_idx = 1;
  
      if (p == NULL)
***************
*** 4370,4376 ****
  	    char    tmp[TMP_LEN];
  
  	    /* string address in case of string argument */
! 	    char    *str_arg;
  
  	    /* natural field width of arg without padding and sign */
  	    size_t  str_arg_l;
--- 4358,4364 ----
  	    char    tmp[TMP_LEN];
  
  	    /* string address in case of string argument */
! 	    const char  *str_arg = NULL;
  
  	    /* natural field width of arg without padding and sign */
  	    size_t  str_arg_l;
***************
*** 4394,4400 ****
  	    char_u  *tofree = NULL;
  
  
- 	    str_arg = NULL;
  	    p++;  /* skip '%' */
  
  	    /* parse flags */
--- 4382,4387 ----
***************
*** 5239,5245 ****
      }
  
      if (tvs != NULL && tvs[arg_idx - 1].v_type != VAR_UNKNOWN)
! 	EMSG(_("E767: Too many arguments to printf()"));
  
      /* Return the number of characters formatted (excluding trailing nul
       * character), that is, the number of characters that would have been
--- 5226,5232 ----
      }
  
      if (tvs != NULL && tvs[arg_idx - 1].v_type != VAR_UNKNOWN)
! 	emsg(_("E767: Too many arguments to printf()"));
  
      /* Return the number of characters formatted (excluding trailing nul
       * character), that is, the number of characters that would have been
*** ../vim-8.1.0742/src/misc1.c	2019-01-11 14:10:00.344749757 +0100
--- src/misc1.c	2019-01-13 23:00:56.632861979 +0100
***************
*** 2658,2664 ****
      /* If "count" is negative the caller must be doing something wrong. */
      if (count < 1)
      {
! 	IEMSGN("E950: Invalid count for del_bytes(): %ld", count);
  	return FAIL;
      }
  
--- 2658,2664 ----
      /* If "count" is negative the caller must be doing something wrong. */
      if (count < 1)
      {
! 	siemsg("E950: Invalid count for del_bytes(): %ld", count);
  	return FAIL;
      }
  
***************
*** 3521,3527 ****
      while (r != 'y' && r != 'n')
      {
  	/* same highlighting as for wait_return */
! 	smsg_attr(HL_ATTR(HLF_R), (char_u *)"%s (y/n)?", str);
  	if (direct)
  	    r = get_keystroke();
  	else
--- 3521,3527 ----
      while (r != 'y' && r != 'n')
      {
  	/* same highlighting as for wait_return */
! 	smsg_attr(HL_ATTR(HLF_R), "%s (y/n)?", str);
  	if (direct)
  	    r = get_keystroke();
  	else
***************
*** 4060,4066 ****
  	    if (!mch_chdir((char *)var) && mch_dirname(IObuff, IOSIZE) == OK)
  		var = IObuff;
  	    if (mch_chdir((char *)NameBuff) != 0)
! 		EMSG(_(e_prev_dir));
  	}
  #endif
  	homedir = vim_strsave(var);
--- 4060,4066 ----
  	    if (!mch_chdir((char *)var) && mch_dirname(IObuff, IOSIZE) == OK)
  		var = IObuff;
  	    if (mch_chdir((char *)NameBuff) != 0)
! 		emsg(_(e_prev_dir));
  	}
  #endif
  	homedir = vim_strsave(var);
***************
*** 9942,9948 ****
      int		ret = FAIL;
      char_u	*eval_pat = NULL;
      char_u	*exp_pat = *pat;
!     char_u      *ignored_msg;
      int		usedlen;
  
      if (*exp_pat == '%' || *exp_pat == '#' || *exp_pat == '<')
--- 9942,9948 ----
      int		ret = FAIL;
      char_u	*eval_pat = NULL;
      char_u	*exp_pat = *pat;
!     char      *ignored_msg;
      int		usedlen;
  
      if (*exp_pat == '%' || *exp_pat == '#' || *exp_pat == '<')
***************
*** 11434,11440 ****
      /* get a name for the temp file */
      if ((tempname = vim_tempname('o', FALSE)) == NULL)
      {
! 	EMSG(_(e_notmp));
  	return NULL;
      }
  
--- 11434,11440 ----
      /* get a name for the temp file */
      if ((tempname = vim_tempname('o', FALSE)) == NULL)
      {
! 	emsg(_(e_notmp));
  	return NULL;
      }
  
***************
*** 11465,11471 ****
  
      if (fd == NULL)
      {
! 	EMSG2(_(e_notopen), tempname);
  	goto done;
      }
  
--- 11465,11471 ----
  
      if (fd == NULL)
      {
! 	semsg(_(e_notopen), tempname);
  	goto done;
      }
  
***************
*** 11485,11491 ****
  #endif
      if (i != len)
      {
! 	EMSG2(_(e_notread), tempname);
  	VIM_CLEAR(buffer);
      }
      else if (ret_len == NULL)
--- 11485,11491 ----
  #endif
      if (i != len)
      {
! 	semsg(_(e_notread), tempname);
  	VIM_CLEAR(buffer);
      }
      else if (ret_len == NULL)
*** ../vim-8.1.0742/src/misc2.c	2019-01-11 16:15:57.891171040 +0100
--- src/misc2.c	2019-01-13 20:17:36.527835979 +0100
***************
*** 920,926 ****
      {
  	/* Don't hide this message */
  	emsg_silent = 0;
! 	EMSG(_("E340: Line is becoming too long"));
  	return NULL;
      }
  #endif
--- 920,926 ----
      {
  	/* Don't hide this message */
  	emsg_silent = 0;
! 	emsg(_("E340: Line is becoming too long"));
  	return NULL;
      }
  #endif
***************
*** 960,966 ****
      {
  	/* Don't hide this message */
  	emsg_silent = 0;
! 	IEMSGN(_("E341: Internal error: lalloc(%ld, )"), size);
  	return NULL;
      }
  
--- 960,966 ----
      {
  	/* Don't hide this message */
  	emsg_silent = 0;
! 	siemsg(_("E341: Internal error: lalloc(%ld, )"), size);
  	return NULL;
      }
  
***************
*** 1079,1085 ****
  	 * message fails, e.g. when setting v:errmsg. */
  	did_outofmem_msg = TRUE;
  
! 	EMSGN(_("E342: Out of memory!  (allocating %lu bytes)"), size);
      }
  }
  
--- 1079,1085 ----
  	 * message fails, e.g. when setting v:errmsg. */
  	did_outofmem_msg = TRUE;
  
! 	semsg(_("E342: Out of memory!  (allocating %lu bytes)"), size);
      }
  }
  
***************
*** 3272,3278 ****
      if (p_verbose > 3)
      {
  	verbose_enter();
! 	smsg((char_u *)_("Calling shell to execute: \"%s\""),
  						    cmd == NULL ? p_sh : cmd);
  	out_char('\n');
  	cursor_on();
--- 3272,3278 ----
      if (p_verbose > 3)
      {
  	verbose_enter();
! 	smsg(_("Calling shell to execute: \"%s\""),
  						    cmd == NULL ? p_sh : cmd);
  	out_char('\n');
  	cursor_on();
***************
*** 3286,3292 ****
  
      if (*p_sh == NUL)
      {
! 	EMSG(_(e_shellempty));
  	retval = -1;
      }
      else
--- 3286,3292 ----
  
      if (*p_sh == NUL)
      {
! 	emsg(_(e_shellempty));
  	retval = -1;
      }
      else
***************
*** 3538,3544 ****
   * ("what" is SHAPE_MOUSE).
   * Returns error message for an illegal option, NULL otherwise.
   */
!     char_u *
  parse_shape_opt(int what)
  {
      char_u	*modep;
--- 3538,3544 ----
   * ("what" is SHAPE_MOUSE).
   * Returns error message for an illegal option, NULL otherwise.
   */
!     char *
  parse_shape_opt(int what)
  {
      char_u	*modep;
***************
*** 3574,3582 ****
  	    commap = vim_strchr(modep, ',');
  
  	    if (colonp == NULL || (commap != NULL && commap < colonp))
! 		return (char_u *)N_("E545: Missing colon");
  	    if (colonp == modep)
! 		return (char_u *)N_("E546: Illegal mode");
  
  	    /*
  	     * Repeat for all mode's before the colon.
--- 3574,3582 ----
  	    commap = vim_strchr(modep, ',');
  
  	    if (colonp == NULL || (commap != NULL && commap < colonp))
! 		return N_("E545: Missing colon");
  	    if (colonp == modep)
! 		return N_("E546: Illegal mode");
  
  	    /*
  	     * Repeat for all mode's before the colon.
***************
*** 3602,3608 ****
  				break;
  			if (idx == SHAPE_IDX_COUNT
  				   || (shape_table[idx].used_for & what) == 0)
! 			    return (char_u *)N_("E546: Illegal mode");
  			if (len == 2 && modep[0] == 'v' && modep[1] == 'e')
  			    found_ve = TRUE;
  		    }
--- 3602,3608 ----
  				break;
  			if (idx == SHAPE_IDX_COUNT
  				   || (shape_table[idx].used_for & what) == 0)
! 			    return N_("E546: Illegal mode");
  			if (len == 2 && modep[0] == 'v' && modep[1] == 'e')
  			    found_ve = TRUE;
  		    }
***************
*** 3641,3647 ****
  			    if (mshape_names[i] == NULL)
  			    {
  				if (!VIM_ISDIGIT(*p))
! 				    return (char_u *)N_("E547: Illegal mouseshape");
  				if (round == 2)
  				    shape_table[idx].mshape =
  					      getdigits(&p) + MSHAPE_NUMBERED;
--- 3641,3647 ----
  			    if (mshape_names[i] == NULL)
  			    {
  				if (!VIM_ISDIGIT(*p))
! 				    return N_("E547: Illegal mouseshape");
  				if (round == 2)
  				    shape_table[idx].mshape =
  					      getdigits(&p) + MSHAPE_NUMBERED;
***************
*** 3681,3692 ****
  			{
  			    p += len;
  			    if (!VIM_ISDIGIT(*p))
! 				return (char_u *)N_("E548: digit expected");
  			    n = getdigits(&p);
  			    if (len == 3)   /* "ver" or "hor" */
  			    {
  				if (n == 0)
! 				    return (char_u *)N_("E549: Illegal percentage");
  				if (round == 2)
  				{
  				    if (TOLOWER_ASC(i) == 'v')
--- 3681,3692 ----
  			{
  			    p += len;
  			    if (!VIM_ISDIGIT(*p))
! 				return N_("E548: digit expected");
  			    n = getdigits(&p);
  			    if (len == 3)   /* "ver" or "hor" */
  			    {
  				if (n == 0)
! 				    return N_("E549: Illegal percentage");
  				if (round == 2)
  				{
  				    if (TOLOWER_ASC(i) == 'v')
***************
*** 4385,4391 ****
  	{
  	    if (len + 5 >= MAXPATHL)
  	    {
! 		EMSG(_(e_pathtoolong));
  		break;
  	    }
  	    if (STRNCMP(wc_part, "**", 2) == 0)
--- 4385,4391 ----
  	{
  	    if (len + 5 >= MAXPATHL)
  	    {
! 		emsg(_(e_pathtoolong));
  		break;
  	    }
  	    if (STRNCMP(wc_part, "**", 2) == 0)
***************
*** 4404,4410 ****
  		wc_part = (char_u *)errpt;
  		if (*wc_part != NUL && !vim_ispathsep(*wc_part))
  		{
! 		    EMSG2(_("E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'."), PATHSEPSTR);
  		    goto error_return;
  		}
  	    }
--- 4404,4410 ----
  		wc_part = (char_u *)errpt;
  		if (*wc_part != NUL && !vim_ispathsep(*wc_part))
  		{
! 		    semsg(_("E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'."), PATHSEPSTR);
  		    goto error_return;
  		}
  	    }
***************
*** 4436,4442 ****
      if (STRLEN(search_ctx->ffsc_start_dir)
  			  + STRLEN(search_ctx->ffsc_fix_path) + 3 >= MAXPATHL)
      {
! 	EMSG(_(e_pathtoolong));
  	goto error_return;
      }
      STRCPY(ff_expand_buffer, search_ctx->ffsc_start_dir);
--- 4436,4442 ----
      if (STRLEN(search_ctx->ffsc_start_dir)
  			  + STRLEN(search_ctx->ffsc_fix_path) + 3 >= MAXPATHL)
      {
! 	emsg(_(e_pathtoolong));
  	goto error_return;
      }
      STRCPY(ff_expand_buffer, search_ctx->ffsc_start_dir);
***************
*** 4667,4673 ****
  		if (p_verbose >= 5)
  		{
  		    verbose_enter_scroll();
! 		    smsg((char_u *)"Already Searched: %s (%s)",
  				   stackp->ffs_fix_path, stackp->ffs_wc_path);
  		    /* don't overwrite this either */
  		    msg_puts((char_u *)"\n");
--- 4667,4673 ----
  		if (p_verbose >= 5)
  		{
  		    verbose_enter_scroll();
! 		    smsg("Already Searched: %s (%s)",
  				   stackp->ffs_fix_path, stackp->ffs_wc_path);
  		    /* don't overwrite this either */
  		    msg_puts((char_u *)"\n");
***************
*** 4681,4687 ****
  	    else if (p_verbose >= 5)
  	    {
  		verbose_enter_scroll();
! 		smsg((char_u *)"Searching: %s (%s)",
  				   stackp->ffs_fix_path, stackp->ffs_wc_path);
  		/* don't overwrite this either */
  		msg_puts((char_u *)"\n");
--- 4681,4687 ----
  	    else if (p_verbose >= 5)
  	    {
  		verbose_enter_scroll();
! 		smsg("Searching: %s (%s)",
  				   stackp->ffs_fix_path, stackp->ffs_wc_path);
  		/* don't overwrite this either */
  		msg_puts((char_u *)"\n");
***************
*** 4900,4906 ****
  				    if (p_verbose >= 5)
  				    {
  					verbose_enter_scroll();
! 					smsg((char_u *)"Already: %s",
  								   file_path);
  					/* don't overwrite this either */
  					msg_puts((char_u *)"\n");
--- 4900,4906 ----
  				    if (p_verbose >= 5)
  				    {
  					verbose_enter_scroll();
! 					smsg("Already: %s",
  								   file_path);
  					/* don't overwrite this either */
  					msg_puts((char_u *)"\n");
***************
*** 4928,4934 ****
  				if (p_verbose >= 5)
  				{
  				    verbose_enter_scroll();
! 				    smsg((char_u *)"HIT: %s", file_path);
  				    /* don't overwrite this either */
  				    msg_puts((char_u *)"\n");
  				    verbose_leave_scroll();
--- 4928,4934 ----
  				if (p_verbose >= 5)
  				{
  				    verbose_enter_scroll();
! 				    smsg("HIT: %s", file_path);
  				    /* don't overwrite this either */
  				    msg_puts((char_u *)"\n");
  				    verbose_leave_scroll();
***************
*** 5128,5134 ****
  		if (p_verbose >= 5)
  		{
  		    verbose_enter_scroll();
! 		    smsg((char_u *)"ff_get_visited_list: FOUND list for %s",
  								    filename);
  		    /* don't overwrite this either */
  		    msg_puts((char_u *)"\n");
--- 5128,5134 ----
  		if (p_verbose >= 5)
  		{
  		    verbose_enter_scroll();
! 		    smsg("ff_get_visited_list: FOUND list for %s",
  								    filename);
  		    /* don't overwrite this either */
  		    msg_puts((char_u *)"\n");
***************
*** 5145,5151 ****
      if (p_verbose >= 5)
      {
  	verbose_enter_scroll();
! 	smsg((char_u *)"ff_get_visited_list: new list for %s", filename);
  	/* don't overwrite this either */
  	msg_puts((char_u *)"\n");
  	verbose_leave_scroll();
--- 5145,5151 ----
      if (p_verbose >= 5)
      {
  	verbose_enter_scroll();
! 	smsg("ff_get_visited_list: new list for %s", filename);
  	/* don't overwrite this either */
  	msg_puts((char_u *)"\n");
  	verbose_leave_scroll();
***************
*** 5766,5784 ****
  	if (first == TRUE)
  	{
  	    if (find_what == FINDFILE_DIR)
! 		EMSG2(_("E344: Can't find directory \"%s\" in cdpath"),
  			ff_file_to_find);
  	    else
! 		EMSG2(_("E345: Can't find file \"%s\" in path"),
  			ff_file_to_find);
  	}
  	else
  	{
  	    if (find_what == FINDFILE_DIR)
! 		EMSG2(_("E346: No more directory \"%s\" found in cdpath"),
  			ff_file_to_find);
  	    else
! 		EMSG2(_("E347: No more file \"%s\" found in path"),
  			ff_file_to_find);
  	}
      }
--- 5766,5784 ----
  	if (first == TRUE)
  	{
  	    if (find_what == FINDFILE_DIR)
! 		semsg(_("E344: Can't find directory \"%s\" in cdpath"),
  			ff_file_to_find);
  	    else
! 		semsg(_("E345: Can't find file \"%s\" in path"),
  			ff_file_to_find);
  	}
  	else
  	{
  	    if (find_what == FINDFILE_DIR)
! 		semsg(_("E346: No more directory \"%s\" found in cdpath"),
  			ff_file_to_find);
  	    else
! 		semsg(_("E347: No more file \"%s\" found in path"),
  			ff_file_to_find);
  	}
      }
*** ../vim-8.1.0742/src/netbeans.c	2019-01-12 22:47:01.264088074 +0100
--- src/netbeans.c	2019-01-13 23:16:36.741428594 +0100
***************
*** 257,263 ****
      {
  	nbdebug(("Wrong access mode for NetBeans connection info file: \"%s\"\n",
  								       file));
! 	EMSG2(_("E668: Wrong access mode for NetBeans connection info file: \"%s\""),
  									file);
  	return FAIL;
      }
--- 257,263 ----
      {
  	nbdebug(("Wrong access mode for NetBeans connection info file: \"%s\"\n",
  								       file));
! 	semsg(_("E668: Wrong access mode for NetBeans connection info file: \"%s\""),
  									file);
  	return FAIL;
      }
***************
*** 477,483 ****
      if (*verb != ':')
      {
  	nbdebug(("    missing colon: %s\n", cmd));
! 	EMSG2("E627: missing colon: %s", cmd);
  	return;
      }
      ++verb; /* skip colon */
--- 477,483 ----
      if (*verb != ':')
      {
  	nbdebug(("    missing colon: %s\n", cmd));
! 	semsg("E627: missing colon: %s", cmd);
  	return;
      }
      ++verb; /* skip colon */
***************
*** 501,507 ****
      if (isfunc < 0)
      {
  	nbdebug(("    missing ! or / in: %s\n", cmd));
! 	EMSG2("E628: missing ! or / in: %s", cmd);
  	return;
      }
  
--- 501,507 ----
      if (isfunc < 0)
      {
  	nbdebug(("    missing ! or / in: %s\n", cmd));
! 	semsg("E628: missing ! or / in: %s", cmd);
  	return;
      }
  
***************
*** 518,524 ****
  	 * so I'm disabling it except for debugging.
  	 */
  	nbdebug(("nb_parse_cmd: Command error for \"%s\"\n", cmd));
! 	EMSG("E629: bad return from nb_do_cmd");
  #endif
      }
  }
--- 518,524 ----
  	 * so I'm disabling it except for debugging.
  	 */
  	nbdebug(("nb_parse_cmd: Command error for \"%s\"\n", cmd));
! 	emsg("E629: bad return from nb_do_cmd");
  #endif
      }
  }
***************
*** 1032,1038 ****
  	    if (buf == NULL || buf->bufp == NULL)
  	    {
  		nbdebug(("    Invalid buffer identifier in getAnno\n"));
! 		EMSG("E652: Invalid buffer identifier in getAnno");
  		retval = FAIL;
  	    }
  	    else
--- 1032,1038 ----
  	    if (buf == NULL || buf->bufp == NULL)
  	    {
  		nbdebug(("    Invalid buffer identifier in getAnno\n"));
! 		emsg("E652: Invalid buffer identifier in getAnno");
  		retval = FAIL;
  	    }
  	    else
***************
*** 1055,1061 ****
  	    if (buf == NULL || buf->bufp == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in getLength\n"));
! 		EMSG("E632: invalid buffer identifier in getLength");
  		retval = FAIL;
  	    }
  	    else
--- 1055,1061 ----
  	    if (buf == NULL || buf->bufp == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in getLength\n"));
! 		emsg("E632: invalid buffer identifier in getLength");
  		retval = FAIL;
  	    }
  	    else
***************
*** 1077,1083 ****
  	    if (buf == NULL || buf->bufp == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in getText\n"));
! 		EMSG("E633: invalid buffer identifier in getText");
  		retval = FAIL;
  	    }
  	    else
--- 1077,1083 ----
  	    if (buf == NULL || buf->bufp == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in getText\n"));
! 		emsg("E633: invalid buffer identifier in getText");
  		retval = FAIL;
  	    }
  	    else
***************
*** 1141,1147 ****
  	    if (buf == NULL || buf->bufp == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in remove\n"));
! 		EMSG("E634: invalid buffer identifier in remove");
  		retval = FAIL;
  	    }
  	    else
--- 1141,1147 ----
  	    if (buf == NULL || buf->bufp == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in remove\n"));
! 		emsg("E634: invalid buffer identifier in remove");
  		retval = FAIL;
  	    }
  	    else
***************
*** 1311,1317 ****
  	    if (buf == NULL || buf->bufp == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in insert\n"));
! 		EMSG("E635: invalid buffer identifier in insert");
  		retval = FAIL;
  	    }
  	    else if (args != NULL)
--- 1311,1317 ----
  	    if (buf == NULL || buf->bufp == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in insert\n"));
! 		emsg("E635: invalid buffer identifier in insert");
  		retval = FAIL;
  	    }
  	    else if (args != NULL)
***************
*** 1471,1477 ****
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in create\n"));
! 		EMSG("E636: invalid buffer identifier in create");
  		return FAIL;
  	    }
  	    VIM_CLEAR(buf->displayname);
--- 1471,1477 ----
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in create\n"));
! 		emsg("E636: invalid buffer identifier in create");
  		return FAIL;
  	    }
  	    VIM_CLEAR(buf->displayname);
***************
*** 1521,1527 ****
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in startDocumentListen\n"));
! 		EMSG("E637: invalid buffer identifier in startDocumentListen");
  		return FAIL;
  	    }
  	    buf->fireChanges = 1;
--- 1521,1527 ----
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in startDocumentListen\n"));
! 		emsg("E637: invalid buffer identifier in startDocumentListen");
  		return FAIL;
  	    }
  	    buf->fireChanges = 1;
***************
*** 1532,1538 ****
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in stopDocumentListen\n"));
! 		EMSG("E638: invalid buffer identifier in stopDocumentListen");
  		return FAIL;
  	    }
  	    buf->fireChanges = 0;
--- 1532,1538 ----
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in stopDocumentListen\n"));
! 		emsg("E638: invalid buffer identifier in stopDocumentListen");
  		return FAIL;
  	    }
  	    buf->fireChanges = 0;
***************
*** 1541,1547 ****
  		if (!buf->bufp->b_netbeans_file)
  		{
  		    nbdebug(("E658: NetBeans connection lost for buffer %ld\n", buf->bufp->b_fnum));
! 		    EMSGN(_("E658: NetBeans connection lost for buffer %ld"),
  							   buf->bufp->b_fnum);
  		}
  		else
--- 1541,1547 ----
  		if (!buf->bufp->b_netbeans_file)
  		{
  		    nbdebug(("E658: NetBeans connection lost for buffer %ld\n", buf->bufp->b_fnum));
! 		    semsg(_("E658: NetBeans connection lost for buffer %ld"),
  							   buf->bufp->b_fnum);
  		}
  		else
***************
*** 1561,1567 ****
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in setTitle\n"));
! 		EMSG("E639: invalid buffer identifier in setTitle");
  		return FAIL;
  	    }
  	    vim_free(buf->displayname);
--- 1561,1567 ----
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in setTitle\n"));
! 		emsg("E639: invalid buffer identifier in setTitle");
  		return FAIL;
  	    }
  	    vim_free(buf->displayname);
***************
*** 1573,1579 ****
  	    if (buf == NULL || buf->bufp == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in initDone\n"));
! 		EMSG("E640: invalid buffer identifier in initDone");
  		return FAIL;
  	    }
  	    do_update = 1;
--- 1573,1579 ----
  	    if (buf == NULL || buf->bufp == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in initDone\n"));
! 		emsg("E640: invalid buffer identifier in initDone");
  		return FAIL;
  	    }
  	    do_update = 1;
***************
*** 1594,1600 ****
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in setBufferNumber\n"));
! 		EMSG("E641: invalid buffer identifier in setBufferNumber");
  		return FAIL;
  	    }
  	    path = (char_u *)nb_unquote(args, NULL);
--- 1594,1600 ----
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in setBufferNumber\n"));
! 		emsg("E641: invalid buffer identifier in setBufferNumber");
  		return FAIL;
  	    }
  	    path = (char_u *)nb_unquote(args, NULL);
***************
*** 1605,1611 ****
  	    if (bufp == NULL)
  	    {
  		nbdebug(("    File %s not found in setBufferNumber\n", args));
! 		EMSG2("E642: File %s not found in setBufferNumber", args);
  		return FAIL;
  	    }
  	    buf->bufp = bufp;
--- 1605,1611 ----
  	    if (bufp == NULL)
  	    {
  		nbdebug(("    File %s not found in setBufferNumber\n", args));
! 		semsg("E642: File %s not found in setBufferNumber", args);
  		return FAIL;
  	    }
  	    buf->bufp = bufp;
***************
*** 1630,1636 ****
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in setFullName\n"));
! 		EMSG("E643: invalid buffer identifier in setFullName");
  		return FAIL;
  	    }
  	    vim_free(buf->displayname);
--- 1630,1636 ----
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in setFullName\n"));
! 		emsg("E643: invalid buffer identifier in setFullName");
  		return FAIL;
  	    }
  	    vim_free(buf->displayname);
***************
*** 1653,1659 ****
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in editFile\n"));
! 		EMSG("E644: invalid buffer identifier in editFile");
  		return FAIL;
  	    }
  	    /* Edit a file: like create + setFullName + read the file. */
--- 1653,1659 ----
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in editFile\n"));
! 		emsg("E644: invalid buffer identifier in editFile");
  		return FAIL;
  	    }
  	    /* Edit a file: like create + setFullName + read the file. */
***************
*** 1681,1687 ****
  		/* This message was commented out, probably because it can
  		 * happen when shutting down. */
  		if (p_verbose > 0)
! 		    EMSG("E645: invalid buffer identifier in setVisible");
  		return FAIL;
  	    }
  	    if (streq((char *)args, "T") && buf->bufp != curbuf)
--- 1681,1687 ----
  		/* This message was commented out, probably because it can
  		 * happen when shutting down. */
  		if (p_verbose > 0)
! 		    emsg("E645: invalid buffer identifier in setVisible");
  		return FAIL;
  	    }
  	    if (streq((char *)args, "T") && buf->bufp != curbuf)
***************
*** 1721,1727 ****
  		/* This message was commented out, probably because it can
  		 * happen when shutting down. */
  		if (p_verbose > 0)
! 		    EMSG("E646: invalid buffer identifier in setModified");
  		return FAIL;
  	    }
  	    prev_b_changed = buf->bufp->b_changed;
--- 1721,1727 ----
  		/* This message was commented out, probably because it can
  		 * happen when shutting down. */
  		if (p_verbose > 0)
! 		    emsg("E646: invalid buffer identifier in setModified");
  		return FAIL;
  	    }
  	    prev_b_changed = buf->bufp->b_changed;
***************
*** 1803,1809 ****
  	    if (buf == NULL || buf->bufp == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in setDot\n"));
! 		EMSG("E647: invalid buffer identifier in setDot");
  		return FAIL;
  	    }
  
--- 1803,1809 ----
  	    if (buf == NULL || buf->bufp == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in setDot\n"));
! 		emsg("E647: invalid buffer identifier in setDot");
  		return FAIL;
  	    }
  
***************
*** 1856,1862 ****
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in close\n"));
! 		EMSG("E648: invalid buffer identifier in close");
  		return FAIL;
  	    }
  
--- 1856,1862 ----
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in close\n"));
! 		emsg("E648: invalid buffer identifier in close");
  		return FAIL;
  	    }
  
***************
*** 1870,1876 ****
  		/* This message was commented out, probably because it can
  		 * happen when shutting down. */
  		if (p_verbose > 0)
! 		    EMSG("E649: invalid buffer identifier in close");
  	    }
  	    nbdebug(("    CLOSE %d: %s\n", bufno, name));
  #ifdef FEAT_GUI
--- 1870,1876 ----
  		/* This message was commented out, probably because it can
  		 * happen when shutting down. */
  		if (p_verbose > 0)
! 		    emsg("E649: invalid buffer identifier in close");
  	    }
  	    nbdebug(("    CLOSE %d: %s\n", bufno, name));
  #ifdef FEAT_GUI
***************
*** 1909,1915 ****
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in defineAnnoType\n"));
! 		EMSG("E650: invalid buffer identifier in defineAnnoType");
  		return FAIL;
  	    }
  
--- 1909,1915 ----
  	    if (buf == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in defineAnnoType\n"));
! 		emsg("E650: invalid buffer identifier in defineAnnoType");
  		return FAIL;
  	    }
  
***************
*** 1937,1943 ****
  	    bg = vim_strsave(p);
  	    if (STRLEN(fg) > MAX_COLOR_LENGTH || STRLEN(bg) > MAX_COLOR_LENGTH)
  	    {
! 		EMSG("E532: highlighting color name too long in defineAnnoType");
  		vim_free(typeName);
  		parse_error = TRUE;
  	    }
--- 1937,1943 ----
  	    bg = vim_strsave(p);
  	    if (STRLEN(fg) > MAX_COLOR_LENGTH || STRLEN(bg) > MAX_COLOR_LENGTH)
  	    {
! 		emsg("E532: highlighting color name too long in defineAnnoType");
  		vim_free(typeName);
  		parse_error = TRUE;
  	    }
***************
*** 1968,1974 ****
  	    if (buf == NULL || buf->bufp == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in addAnno\n"));
! 		EMSG("E651: invalid buffer identifier in addAnno");
  		return FAIL;
  	    }
  
--- 1968,1974 ----
  	    if (buf == NULL || buf->bufp == NULL)
  	    {
  		nbdebug(("    invalid buffer identifier in addAnno\n"));
! 		emsg("E651: invalid buffer identifier in addAnno");
  		return FAIL;
  	    }
  
***************
*** 2352,2358 ****
  		&& !defined(FEAT_GUI_W32)
      if (gui.in_use)
      {
! 	EMSG(_("E838: netbeans is not supported with this GUI"));
  	return;
      }
  # endif
--- 2352,2358 ----
  		&& !defined(FEAT_GUI_W32)
      if (gui.in_use)
      {
! 	emsg(_("E838: netbeans is not supported with this GUI"));
  	return;
      }
  # endif
***************
*** 2517,2523 ****
  
      if (NETBEANS_OPEN)
      {
! 	EMSG(_("E511: netbeans already connected"));
  	return;
      }
  
--- 2517,2523 ----
  
      if (NETBEANS_OPEN)
      {
! 	emsg(_("E511: netbeans already connected"));
  	return;
      }
  
***************
*** 3482,3491 ****
      }
      else
      {
! 	char_u msgbuf[IOSIZE];
  
! 	vim_snprintf((char *)msgbuf, IOSIZE,
! 		_("E505: %s is read-only (add ! to override)"), IObuff);
  	nbdebug(("    %s\n", msgbuf));
  	emsg(msgbuf);
      }
--- 3482,3491 ----
      }
      else
      {
! 	char msgbuf[IOSIZE];
  
! 	vim_snprintf(msgbuf, IOSIZE,
! 		       _("E505: %s is read-only (add ! to override)"), IObuff);
  	nbdebug(("    %s\n", msgbuf));
  	emsg(msgbuf);
      }
*** ../vim-8.1.0742/src/normal.c	2019-01-11 20:34:18.300314693 +0100
--- src/normal.c	2019-01-13 19:56:01.662201860 +0100
***************
*** 2211,2217 ****
  # endif
  
      if (*p_opfunc == NUL)
! 	EMSG(_("E774: 'operatorfunc' is empty"));
      else
      {
  	/* Set '[ and '] marks to text to be operated on. */
--- 2211,2217 ----
  # endif
  
      if (*p_opfunc == NUL)
! 	emsg(_("E774: 'operatorfunc' is empty"));
      else
      {
  	/* Set '[ and '] marks to text to be operated on. */
***************
*** 2243,2249 ****
  # endif
      }
  #else
!     EMSG(_("E775: Eval feature not available"));
  #endif
  }
  
--- 2243,2249 ----
  # endif
      }
  #else
!     emsg(_("E775: Eval feature not available"));
  #endif
  }
  
***************
*** 3542,3550 ****
  	 * didn't find an identifier or string
  	 */
  	if (find_type & FIND_STRING)
! 	    EMSG(_("E348: No string under cursor"));
  	else
! 	    EMSG(_(e_noident));
  	return 0;
      }
      ptr += col;
--- 3542,3550 ----
  	 * didn't find an identifier or string
  	 */
  	if (find_type & FIND_STRING)
! 	    emsg(_("E348: No string under cursor"));
  	else
! 	    emsg(_(e_noident));
  	return 0;
      }
      ptr += col;
***************
*** 5016,5022 ****
  		    deleteFold((linenr_T)1, curbuf->b_ml.ml_line_count,
  								 TRUE, FALSE);
  		else
! 		    EMSG(_("E352: Cannot erase folds with current 'foldmethod'"));
  		break;
  
  		/* "zn": fold none: reset 'foldenable' */
--- 5016,5022 ----
  		    deleteFold((linenr_T)1, curbuf->b_ml.ml_line_count,
  								 TRUE, FALSE);
  		else
! 		    emsg(_("E352: Cannot erase folds with current 'foldmethod'"));
  		break;
  
  		/* "zn": fold none: reset 'foldenable' */
***************
*** 5616,5622 ****
  						 || STRCMP(kp, ":help") == 0);
      if (kp_help && *skipwhite(ptr) == NUL)
      {
! 	EMSG(_(e_noident));	 /* found white space only */
  	return;
      }
      kp_ex = (*kp == ':');
--- 5616,5622 ----
  						 || STRCMP(kp, ":help") == 0);
      if (kp_help && *skipwhite(ptr) == NUL)
      {
! 	emsg(_(e_noident));	 /* found white space only */
  	return;
      }
      kp_ex = (*kp == ':');
***************
*** 5667,5673 ****
  		}
  		if (n == 0)
  		{
! 		    EMSG(_(e_noident));	 /* found dashes only */
  		    vim_free(buf);
  		    return;
  		}
--- 5667,5673 ----
  		}
  		if (n == 0)
  		{
! 		    emsg(_(e_noident));	 /* found dashes only */
  		    vim_free(buf);
  		    return;
  		}
***************
*** 7275,7281 ****
      else if (!checkclearopq(cap->oap))
      {
  	if (!curbuf->b_p_ma)
! 	    EMSG(_(e_modifiable));
  	else
  	{
  #ifdef FEAT_VIRTUALEDIT
--- 7275,7281 ----
      else if (!checkclearopq(cap->oap))
      {
  	if (!curbuf->b_p_ma)
! 	    emsg(_(e_modifiable));
  	else
  	{
  #ifdef FEAT_VIRTUALEDIT
***************
*** 7302,7308 ****
      else if (!checkclearopq(cap->oap))
      {
  	if (!curbuf->b_p_ma)
! 	    EMSG(_(e_modifiable));
  	else
  	{
  	    if (cap->extra_char == Ctrl_V)	/* get another character */
--- 7302,7308 ----
      else if (!checkclearopq(cap->oap))
      {
  	if (!curbuf->b_p_ma)
! 	    emsg(_(e_modifiable));
  	else
  	{
  	    if (cap->extra_char == Ctrl_V)	/* get another character */
***************
*** 7629,7639 ****
  	else if (cap->cmdchar == 'g')
  	{
  	    if (curbuf->b_changelistlen == 0)
! 		EMSG(_("E664: changelist is empty"));
  	    else if (cap->count1 < 0)
! 		EMSG(_("E662: At start of changelist"));
  	    else
! 		EMSG(_("E663: At end of changelist"));
  	}
  	else
  	    clearopbeep(cap->oap);
--- 7629,7639 ----
  	else if (cap->cmdchar == 'g')
  	{
  	    if (curbuf->b_changelistlen == 0)
! 		emsg(_("E664: changelist is empty"));
  	    else if (cap->count1 < 0)
! 		emsg(_("E662: At start of changelist"));
  	    else
! 		emsg(_("E663: At end of changelist"));
  	}
  	else
  	    clearopbeep(cap->oap);
***************
*** 8514,8527 ****
  	    if (curwin->w_p_cole > 0 && oldline != curwin->w_cursor.lnum)
  		redrawWinline(curwin, oldline);
  #endif
- 	    /* When '#' is in 'cpoptions' ignore the count. */
- 	    if (vim_strchr(p_cpo, CPO_HASH) != NULL)
- 		cap->count1 = 1;
  #ifdef FEAT_SYN_HL
  	    if (curwin->w_p_cul)
  		/* force redraw of cursorline */
  		curwin->w_valid &= ~VALID_CROW;
  #endif
  	    invoke_edit(cap, FALSE, cap->cmdchar, TRUE);
  	}
      }
--- 8514,8527 ----
  	    if (curwin->w_p_cole > 0 && oldline != curwin->w_cursor.lnum)
  		redrawWinline(curwin, oldline);
  #endif
  #ifdef FEAT_SYN_HL
  	    if (curwin->w_p_cul)
  		/* force redraw of cursorline */
  		curwin->w_valid &= ~VALID_CROW;
  #endif
+ 	    /* When '#' is in 'cpoptions' ignore the count. */
+ 	    if (vim_strchr(p_cpo, CPO_HASH) != NULL)
+ 		cap->count1 = 1;
  	    invoke_edit(cap, FALSE, cap->cmdchar, TRUE);
  	}
      }
***************
*** 9107,9113 ****
      else if (!curbuf->b_p_ma && !p_im)
      {
  	/* Only give this error when 'insertmode' is off. */
! 	EMSG(_(e_modifiable));
  	clearop(cap->oap);
  	if (cap->cmdchar == K_PS)
  	    /* drop the pasted text */
--- 9107,9113 ----
      else if (!curbuf->b_p_ma && !p_im)
      {
  	/* Only give this error when 'insertmode' is off. */
! 	emsg(_(e_modifiable));
  	clearop(cap->oap);
  	if (cap->cmdchar == K_PS)
  	    /* drop the pasted text */
*** ../vim-8.1.0742/src/ops.c	2019-01-11 16:15:57.895171010 +0100
--- src/ops.c	2019-01-13 19:56:05.486169368 +0100
***************
*** 712,718 ****
      /* Don't even try when 'modifiable' is off. */
      if (!curbuf->b_p_ma)
      {
! 	EMSG(_(e_modifiable));
  	return;
      }
  
--- 712,718 ----
      /* Don't even try when 'modifiable' is off. */
      if (!curbuf->b_p_ma)
      {
! 	emsg(_(e_modifiable));
  	return;
      }
  
***************
*** 724,730 ****
  	if (i > 1
  		&& (i % 50 == 0 || i == oap->line_count - 1)
  		&& oap->line_count > p_report)
! 	    smsg((char_u *)_("%ld lines to indent... "), i);
  
  	/*
  	 * Be vi-compatible: For lisp indenting the first line is not
--- 724,730 ----
  	if (i > 1
  		&& (i % 50 == 0 || i == oap->line_count - 1)
  		&& oap->line_count > p_report)
! 	    smsg(_("%ld lines to indent... "), i);
  
  	/*
  	 * Be vi-compatible: For lisp indenting the first line is not
***************
*** 770,776 ****
      if (oap->line_count > p_report)
      {
  	i = oap->line_count - (i + 1);
! 	smsg((char_u *)NGETTEXT("%ld line indented ",
  						 "%ld lines indented ", i), i);
      }
      /* set '[ and '] marks */
--- 770,776 ----
      if (oap->line_count > p_report)
      {
  	i = oap->line_count - (i + 1);
! 	smsg(NGETTEXT("%ld line indented ",
  						 "%ld lines indented ", i), i);
      }
      /* set '[ and '] marks */
***************
*** 1218,1224 ****
      {
  	if (execreg_lastc == NUL)
  	{
! 	    EMSG(_("E748: No previously used register"));
  	    return FAIL;
  	}
  	regname = execreg_lastc;
--- 1218,1224 ----
      {
  	if (execreg_lastc == NUL)
  	{
! 	    emsg(_("E748: No previously used register"));
  	    return FAIL;
  	}
  	regname = execreg_lastc;
***************
*** 1243,1249 ****
      {
  	if (last_cmdline == NULL)
  	{
! 	    EMSG(_(e_nolastcmd));
  	    return FAIL;
  	}
  	VIM_CLEAR(new_last_cmdline); /* don't keep the cmdline containing @: */
--- 1243,1249 ----
      {
  	if (last_cmdline == NULL)
  	{
! 	    emsg(_(e_nolastcmd));
  	    return FAIL;
  	}
  	VIM_CLEAR(new_last_cmdline); /* don't keep the cmdline containing @: */
***************
*** 1277,1283 ****
  	p = get_last_insert_save();
  	if (p == NULL)
  	{
! 	    EMSG(_(e_noinstext));
  	    return FAIL;
  	}
  	retval = put_in_typebuf(p, FALSE, colon, silent);
--- 1277,1283 ----
  	p = get_last_insert_save();
  	if (p == NULL)
  	{
! 	    emsg(_(e_noinstext));
  	    return FAIL;
  	}
  	retval = put_in_typebuf(p, FALSE, colon, silent);
***************
*** 1535,1547 ****
  
  	case ':':		/* last command line */
  	    if (last_cmdline == NULL && errmsg)
! 		EMSG(_(e_nolastcmd));
  	    *argp = last_cmdline;
  	    return TRUE;
  
  	case '/':		/* last search-pattern */
  	    if (last_search_pat() == NULL && errmsg)
! 		EMSG(_(e_noprevre));
  	    *argp = last_search_pat();
  	    return TRUE;
  
--- 1535,1547 ----
  
  	case ':':		/* last command line */
  	    if (last_cmdline == NULL && errmsg)
! 		emsg(_(e_nolastcmd));
  	    *argp = last_cmdline;
  	    return TRUE;
  
  	case '/':		/* last search-pattern */
  	    if (last_search_pat() == NULL && errmsg)
! 		emsg(_(e_noprevre));
  	    *argp = last_search_pat();
  	    return TRUE;
  
***************
*** 1549,1555 ****
  	    *argp = get_last_insert_save();
  	    *allocated = TRUE;
  	    if (*argp == NULL && errmsg)
! 		EMSG(_(e_noinstext));
  	    return TRUE;
  
  #ifdef FEAT_SEARCHPATH
--- 1549,1555 ----
  	    *argp = get_last_insert_save();
  	    *allocated = TRUE;
  	    if (*argp == NULL && errmsg)
! 		emsg(_(e_noinstext));
  	    return TRUE;
  
  #ifdef FEAT_SEARCHPATH
***************
*** 1761,1767 ****
  
      if (!curbuf->b_p_ma)
      {
! 	EMSG(_(e_modifiable));
  	return FAIL;
      }
  
--- 1761,1767 ----
  
      if (!curbuf->b_p_ma)
      {
! 	emsg(_(e_modifiable));
  	return FAIL;
      }
  
***************
*** 1884,1890 ****
  	    msg_silent = msg_silent_save;
  	    if (n != 'y')
  	    {
! 		EMSG(_(e_abort));
  		return FAIL;
  	    }
  	}
--- 1884,1890 ----
  	    msg_silent = msg_silent_save;
  	    if (n != 'y')
  	    {
! 		emsg(_(e_abort));
  		return FAIL;
  	    }
  	}
***************
*** 2506,2512 ****
      curbuf->b_op_end = oap->end;
  
      if (oap->line_count > p_report)
! 	smsg((char_u *)NGETTEXT("%ld line changed", "%ld lines changed",
  					    oap->line_count), oap->line_count);
  }
  
--- 2506,2512 ----
      curbuf->b_op_end = oap->end;
  
      if (oap->line_count > p_report)
! 	smsg(NGETTEXT("%ld line changed", "%ld lines changed",
  					    oap->line_count), oap->line_count);
  }
  
***************
*** 3038,3044 ****
  		 * Overwrite this message with any next message.
  		 */
  		++no_wait_return;
! 		smsg((char_u *)_("freeing %ld lines"), i + 1);
  		--no_wait_return;
  		msg_didout = FALSE;
  		msg_col = 0;
--- 3038,3044 ----
  		 * Overwrite this message with any next message.
  		 */
  		++no_wait_return;
! 		smsg(_("freeing %ld lines"), i + 1);
  		--no_wait_return;
  		msg_didout = FALSE;
  		msg_col = 0;
***************
*** 3325,3337 ****
  	    update_topline_redraw();
  	    if (oap->block_mode)
  	    {
! 		smsg((char_u *)NGETTEXT("block of %ld line yanked%s",
  				     "block of %ld lines yanked%s", yanklines),
  			yanklines, namebuf);
  	    }
  	    else
  	    {
! 		smsg((char_u *)NGETTEXT("%ld line yanked%s",
  					      "%ld lines yanked%s", yanklines),
  			yanklines, namebuf);
  	    }
--- 3325,3337 ----
  	    update_topline_redraw();
  	    if (oap->block_mode)
  	    {
! 		smsg(NGETTEXT("block of %ld line yanked%s",
  				     "block of %ld lines yanked%s", yanklines),
  			yanklines, namebuf);
  	    }
  	    else
  	    {
! 		smsg(NGETTEXT("%ld line yanked%s",
  					      "%ld lines yanked%s", yanklines),
  			yanklines, namebuf);
  	    }
***************
*** 3649,3655 ****
  
      if (y_size == 0 || y_array == NULL)
      {
! 	EMSG2(_("E353: Nothing in register %s"),
  		  regname == 0 ? (char_u *)"\"" : transchar(regname));
  	goto end;
      }
--- 3649,3655 ----
  
      if (y_size == 0 || y_array == NULL)
      {
! 	semsg(_("E353: Nothing in register %s"),
  		  regname == 0 ? (char_u *)"\"" : transchar(regname));
  	goto end;
      }
***************
*** 5646,5652 ****
  	    curbuf->b_op_start = startpos;
  
  	if (change_cnt > p_report)
! 	    smsg((char_u *)NGETTEXT("%ld line changed", "%ld lines changed",
  						      change_cnt), change_cnt);
      }
  }
--- 5646,5652 ----
  	    curbuf->b_op_start = startpos;
  
  	if (change_cnt > p_report)
! 	    smsg(NGETTEXT("%ld line changed", "%ld lines changed",
  						      change_cnt), change_cnt);
      }
  }
***************
*** 6423,6431 ****
  		type = (char_u *)"BLOCK";
  		break;
  	    default:
! 		sprintf((char *)IObuff, _("E574: Unknown register type %d"),
! 							    y_ptr->y_type);
! 		emsg(IObuff);
  		type = (char_u *)"LINE";
  		break;
  	}
--- 6423,6429 ----
  		type = (char_u *)"BLOCK";
  		break;
  	    default:
! 		semsg(_("E574: Unknown register type %d"), y_ptr->y_type);
  		type = (char_u *)"LINE";
  		break;
  	}
***************
*** 7054,7060 ****
  	    s = (char_u *)"";
  	else if (strings[1] != NULL)
  	{
! 	    EMSG(_("E883: search pattern and expression register may not "
  			"contain two or more lines"));
  	    return;
  	}
--- 7052,7058 ----
  	    s = (char_u *)"";
  	else if (strings[1] != NULL)
  	{
! 	    emsg(_("E883: search pattern and expression register may not "
  			"contain two or more lines"));
  	    return;
  	}
***************
*** 7110,7116 ****
  
  	    buf = buflist_findnr(num);
  	    if (buf == NULL)
! 		EMSGN(_(e_nobufnr), (long)num);
  	}
  	else
  	    buf = buflist_findnr(buflist_findpat(str, str + STRLEN(str),
--- 7108,7114 ----
  
  	    buf = buflist_findnr(num);
  	    if (buf == NULL)
! 		semsg(_(e_nobufnr), (long)num);
  	}
  	else
  	    buf = buflist_findnr(buflist_findpat(str, str + STRLEN(str),
*** ../vim-8.1.0742/src/option.c	2018-12-21 13:03:24.292337854 +0100
--- src/option.c	2019-01-13 23:05:44.642834290 +0100
***************
*** 3295,3314 ****
  # define insecure_flag(opt_idx, opt_flags) (&options[opt_idx].flags)
  #endif
  static void set_string_option_global(int opt_idx, char_u **varp);
! static char_u *did_set_string_option(int opt_idx, char_u **varp, int new_value_alloced, char_u *oldval, char_u *errbuf, int opt_flags, int *value_checked);
! static char_u *set_chars_option(char_u **varp);
  #ifdef FEAT_CLIPBOARD
! static char_u *check_clipboard_option(void);
  #endif
  #ifdef FEAT_SPELL
! static char_u *did_set_spell_option(int is_spellfile);
! static char_u *compile_cap_prog(synblock_T *synblock);
  #endif
  #ifdef FEAT_EVAL
  static void set_option_sctx_idx(int opt_idx, int opt_flags, sctx_T script_ctx);
  #endif
! static char_u *set_bool_option(int opt_idx, char_u *varp, int value, int opt_flags);
! static char_u *set_num_option(int opt_idx, char_u *varp, long value, char_u *errbuf, size_t errbuflen, int opt_flags);
  static void check_redraw(long_u flags);
  static int findoption(char_u *);
  static int find_key_option(char_u *arg_arg, int has_lt);
--- 3295,3314 ----
  # define insecure_flag(opt_idx, opt_flags) (&options[opt_idx].flags)
  #endif
  static void set_string_option_global(int opt_idx, char_u **varp);
! static char *did_set_string_option(int opt_idx, char_u **varp, int new_value_alloced, char_u *oldval, char *errbuf, int opt_flags, int *value_checked);
! static char *set_chars_option(char_u **varp);
  #ifdef FEAT_CLIPBOARD
! static char *check_clipboard_option(void);
  #endif
  #ifdef FEAT_SPELL
! static char *did_set_spell_option(int is_spellfile);
! static char *compile_cap_prog(synblock_T *synblock);
  #endif
  #ifdef FEAT_EVAL
  static void set_option_sctx_idx(int opt_idx, int opt_flags, sctx_T script_ctx);
  #endif
! static char *set_bool_option(int opt_idx, char_u *varp, int value, int opt_flags);
! static char *set_num_option(int opt_idx, char_u *varp, long value, char *errbuf, size_t errbuflen, int opt_flags);
  static void check_redraw(long_u flags);
  static int findoption(char_u *);
  static int find_key_option(char_u *arg_arg, int has_lt);
***************
*** 3708,3718 ****
  	    }
  
  #if defined(MSWIN) || defined(MACOS_X) || defined(VMS)
! 	    if (STRCMP(p_enc, "latin1") == 0
! # ifdef FEAT_MBYTE
! 		    || enc_utf8
! # endif
! 		    )
  	    {
  		/* Adjust the default for 'isprint' and 'iskeyword' to match
  		 * latin1.  Also set the defaults for when 'nocompatible' is
--- 3708,3714 ----
  	    }
  
  #if defined(MSWIN) || defined(MACOS_X) || defined(VMS)
! 	    if (STRCMP(p_enc, "latin1") == 0 || enc_utf8)
  	    {
  		/* Adjust the default for 'isprint' and 'iskeyword' to match
  		 * latin1.  Also set the defaults for when 'nocompatible' is
***************
*** 4393,4400 ****
      int		opt_flags)
  {
      int		opt_idx;
!     char_u	*errmsg;
!     char_u	errbuf[80];
      char_u	*startarg;
      int		prefix;	/* 1: nothing, 0: "no", 2: "inv" in front of name */
      int		nextchar;	    /* next non-white char after option name */
--- 4389,4396 ----
      int		opt_flags)
  {
      int		opt_idx;
!     char	*errmsg;
!     char	errbuf[80];
      char_u	*startarg;
      int		prefix;	/* 1: nothing, 0: "no", 2: "inv" in front of name */
      int		nextchar;	    /* next non-white char after option name */
***************
*** 4546,4552 ****
  
  	    if (opt_idx == -1 && key == 0)	/* found a mismatch: skip */
  	    {
! 		errmsg = (char_u *)N_("E518: Unknown option");
  		goto skip;
  	    }
  
--- 4542,4548 ----
  
  	    if (opt_idx == -1 && key == 0)	/* found a mismatch: skip */
  	    {
! 		errmsg = N_("E518: Unknown option");
  		goto skip;
  	    }
  
***************
*** 4559,4565 ****
  		    if (vim_strchr((char_u *)"=:!&<", nextchar) == NULL
  			    && (!(options[opt_idx].flags & P_BOOL)
  				|| nextchar == '?'))
! 			errmsg = (char_u *)N_("E519: Option not supported");
  		    goto skip;
  		}
  
--- 4555,4561 ----
  		    if (vim_strchr((char_u *)"=:!&<", nextchar) == NULL
  			    && (!(options[opt_idx].flags & P_BOOL)
  				|| nextchar == '?'))
! 			errmsg = N_("E519: Option not supported");
  		    goto skip;
  		}
  
***************
*** 4597,4603 ****
  	    {
  		if (flags & (P_SECURE | P_NO_ML))
  		{
! 		    errmsg = (char_u *)_("E520: Not allowed in a modeline");
  		    goto skip;
  		}
  #ifdef FEAT_DIFF
--- 4593,4599 ----
  	    {
  		if (flags & (P_SECURE | P_NO_ML))
  		{
! 		    errmsg = _("E520: Not allowed in a modeline");
  		    goto skip;
  		}
  #ifdef FEAT_DIFF
***************
*** 4619,4625 ****
  	    /* Disallow changing some options in the sandbox */
  	    if (sandbox != 0 && (flags & P_SECURE))
  	    {
! 		errmsg = (char_u *)_(e_sandbox);
  		goto skip;
  	    }
  #endif
--- 4615,4621 ----
  	    /* Disallow changing some options in the sandbox */
  	    if (sandbox != 0 && (flags & P_SECURE))
  	    {
! 		errmsg = _(e_sandbox);
  		goto skip;
  	    }
  #endif
***************
*** 4693,4699 ****
  		    p = find_termcode(key_name);
  		    if (p == NULL)
  		    {
! 			errmsg = (char_u *)N_("E846: Key code not set");
  			goto skip;
  		    }
  		    else
--- 4689,4695 ----
  		    p = find_termcode(key_name);
  		    if (p == NULL)
  		    {
! 			errmsg = N_("E846: Key code not set");
  			goto skip;
  		    }
  		    else
***************
*** 4822,4828 ****
  			}
  			else
  			{
! 			    errmsg = (char_u *)N_("E521: Number required after =");
  			    goto skip;
  			}
  
--- 4818,4824 ----
  			}
  			else
  			{
! 			    errmsg = N_("E521: Number required after =");
  			    goto skip;
  			}
  
***************
*** 4923,4929 ****
  			    {
  				STRCPY(errbuf, ":help");
  				save_arg = arg;
! 				arg = errbuf;
  			    }
  			    /*
  			     * Convert 'backspace' number to string, for
--- 4919,4925 ----
  			    {
  				STRCPY(errbuf, ":help");
  				save_arg = arg;
! 				arg = (char_u *)errbuf;
  			    }
  			    /*
  			     * Convert 'backspace' number to string, for
***************
*** 4975,4981 ****
  				if (*errbuf != NUL)	/* remove trailing , */
  				    errbuf[STRLEN(errbuf) - 1] = NUL;
  				save_arg = arg;
! 				arg = errbuf;
  			    }
  			    /*
  			     * Remove '>' before 'dir' and 'bdir', for
--- 4971,4977 ----
  				if (*errbuf != NUL)	/* remove trailing , */
  				    errbuf[STRLEN(errbuf) - 1] = NUL;
  				save_arg = arg;
! 				arg = (char_u *)errbuf;
  			    }
  			    /*
  			     * Remove '>' before 'dir' and 'bdir', for
***************
*** 5259,5265 ****
  			if (nextchar == '&')
  			{
  			    if (add_termcap_entry(key_name, TRUE) == FAIL)
! 				errmsg = (char_u *)N_("E522: Not found in termcap");
  			}
  			else
  			{
--- 5255,5261 ----
  			if (nextchar == '&')
  			{
  			    if (add_termcap_entry(key_name, TRUE) == FAIL)
! 				errmsg = N_("E522: Not found in termcap");
  			}
  			else
  			{
***************
*** 5315,5322 ****
  	    /* make sure all characters are printable */
  	    trans_characters(IObuff, IOSIZE);
  
! 	    ++no_wait_return;	/* wait_return done later */
! 	    emsg(IObuff);	/* show error highlighted */
  	    --no_wait_return;
  
  	    return FAIL;
--- 5311,5318 ----
  	    /* make sure all characters are printable */
  	    trans_characters(IObuff, IOSIZE);
  
! 	    ++no_wait_return;		// wait_return done later
! 	    emsg((char *)IObuff);	// show error highlighted
  	    --no_wait_return;
  
  	    return FAIL;
***************
*** 5371,5381 ****
  	*p = *p & ~P_INSECURE;
  }
  
!     static char_u *
! illegal_char(char_u *errbuf, int c)
  {
      if (errbuf == NULL)
! 	return (char_u *)"";
      sprintf((char *)errbuf, _("E539: Illegal character <%s>"),
  							(char *)transchar(c));
      return errbuf;
--- 5367,5377 ----
  	*p = *p & ~P_INSECURE;
  }
  
!     static char *
! illegal_char(char *errbuf, int c)
  {
      if (errbuf == NULL)
! 	return "";
      sprintf((char *)errbuf, _("E539: Illegal character <%s>"),
  							(char *)transchar(c));
      return errbuf;
***************
*** 5403,5409 ****
   * Check value of 'cedit' and set cedit_key.
   * Returns NULL if value is OK, error message otherwise.
   */
!     static char_u *
  check_cedit(void)
  {
      int n;
--- 5399,5405 ----
   * Check value of 'cedit' and set cedit_key.
   * Returns NULL if value is OK, error message otherwise.
   */
!     static char *
  check_cedit(void)
  {
      int n;
***************
*** 5945,5952 ****
  	idx = findoption(name);
  	if (idx < 0)	/* not found (should not happen) */
  	{
! 	    EMSG2(_(e_intern2), "set_string_option_direct()");
! 	    IEMSG2(_("For option %s"), name);
  	    return;
  	}
      }
--- 5941,5948 ----
  	idx = findoption(name);
  	if (idx < 0)	/* not found (should not happen) */
  	{
! 	    semsg(_(e_intern2), "set_string_option_direct()");
! 	    siemsg(_("For option %s"), name);
  	    return;
  	}
      }
***************
*** 6024,6030 ****
   *
   * Returns NULL on success or error message on error.
   */
!     static char_u *
  set_string_option(
      int		opt_idx,
      char_u	*value,
--- 6020,6026 ----
   *
   * Returns NULL on success or error message on error.
   */
!     static char *
  set_string_option(
      int		opt_idx,
      char_u	*value,
***************
*** 6037,6043 ****
      char_u	*saved_oldval = NULL;
      char_u	*saved_newval = NULL;
  #endif
!     char_u	*r = NULL;
      int		value_checked = FALSE;
  
      if (options[opt_idx].var == NULL)	/* don't set hidden option */
--- 6033,6039 ----
      char_u	*saved_oldval = NULL;
      char_u	*saved_newval = NULL;
  #endif
!     char	*r = NULL;
      int		value_checked = FALSE;
  
      if (options[opt_idx].var == NULL)	/* don't set hidden option */
***************
*** 6100,6117 ****
   * Handle string options that need some action to perform when changed.
   * Returns NULL for success, or an error message for an error.
   */
!     static char_u *
  did_set_string_option(
      int		opt_idx,		// index in options[] table
      char_u	**varp,			// pointer to the option variable
      int		new_value_alloced,	// new value was allocated
      char_u	*oldval,		// previous value of the option
!     char_u	*errbuf,		// buffer for errors, or NULL
      int		opt_flags,		// OPT_LOCAL and/or OPT_GLOBAL
      int		*value_checked)		// value was checked to be save, no
  					// need to set P_INSECURE
  {
!     char_u	*errmsg = NULL;
      char_u	*s, *p;
      int		did_chartab = FALSE;
      char_u	**gvarp;
--- 6096,6113 ----
   * Handle string options that need some action to perform when changed.
   * Returns NULL for success, or an error message for an error.
   */
!     static char *
  did_set_string_option(
      int		opt_idx,		// index in options[] table
      char_u	**varp,			// pointer to the option variable
      int		new_value_alloced,	// new value was allocated
      char_u	*oldval,		// previous value of the option
!     char	*errbuf,		// buffer for errors, or NULL
      int		opt_flags,		// OPT_LOCAL and/or OPT_GLOBAL
      int		*value_checked)		// value was checked to be save, no
  					// need to set P_INSECURE
  {
!     char	*errmsg = NULL;
      char_u	*s, *p;
      int		did_chartab = FALSE;
      char_u	**gvarp;
***************
*** 6155,6169 ****
      else if (varp == &T_NAME)
      {
  	if (T_NAME[0] == NUL)
! 	    errmsg = (char_u *)N_("E529: Cannot set 'term' to empty string");
  #ifdef FEAT_GUI
  	if (gui.in_use)
! 	    errmsg = (char_u *)N_("E530: Cannot change term in GUI");
  	else if (term_is_gui(T_NAME))
! 	    errmsg = (char_u *)N_("E531: Use \":gui\" to start the GUI");
  #endif
  	else if (set_termname(T_NAME) == FAIL)
! 	    errmsg = (char_u *)N_("E522: Not found in termcap");
  	else
  	{
  	    /* Screen colors may have changed. */
--- 6151,6165 ----
      else if (varp == &T_NAME)
      {
  	if (T_NAME[0] == NUL)
! 	    errmsg = N_("E529: Cannot set 'term' to empty string");
  #ifdef FEAT_GUI
  	if (gui.in_use)
! 	    errmsg = N_("E530: Cannot change term in GUI");
  	else if (term_is_gui(T_NAME))
! 	    errmsg = N_("E531: Use \":gui\" to start the GUI");
  #endif
  	else if (set_termname(T_NAME) == FAIL)
! 	    errmsg = N_("E522: Not found in termcap");
  	else
  	{
  	    /* Screen colors may have changed. */
***************
*** 6211,6217 ****
      {
  	if (STRCMP(*p_bex == '.' ? p_bex + 1 : p_bex,
  		     *p_pm == '.' ? p_pm + 1 : p_pm) == 0)
! 	    errmsg = (char_u *)N_("E589: 'backupext' and 'patchmode' are equal");
      }
  #ifdef FEAT_LINEBREAK
      /* 'breakindentopt' */
--- 6207,6213 ----
      {
  	if (STRCMP(*p_bex == '.' ? p_bex + 1 : p_bex,
  		     *p_pm == '.' ? p_pm + 1 : p_pm) == 0)
! 	    errmsg = N_("E589: 'backupext' and 'patchmode' are equal");
      }
  #ifdef FEAT_LINEBREAK
      /* 'breakindentopt' */
***************
*** 6328,6336 ****
  	if (check_opt_strings(p_ambw, p_ambw_values, FALSE) != OK)
  	    errmsg = e_invarg;
  	else if (set_chars_option(&p_lcs) != NULL)
! 	    errmsg = (char_u *)_("E834: Conflicts with value of 'listchars'");
  	else if (set_chars_option(&p_fcs) != NULL)
! 	    errmsg = (char_u *)_("E835: Conflicts with value of 'fillchars'");
      }
  #endif
  
--- 6324,6332 ----
  	if (check_opt_strings(p_ambw, p_ambw_values, FALSE) != OK)
  	    errmsg = e_invarg;
  	else if (set_chars_option(&p_lcs) != NULL)
! 	    errmsg = _("E834: Conflicts with value of 'listchars'");
  	else if (set_chars_option(&p_fcs) != NULL)
! 	    errmsg = _("E835: Conflicts with value of 'fillchars'");
      }
  #endif
  
***************
*** 6454,6460 ****
  	{
  	    /* GTK+ 2 uses only a single encoding, and that is UTF-8. */
  	    if (STRCMP(p_tenc, "utf-8") != 0)
! 		errmsg = (char_u *)N_("E617: Cannot be changed in the GTK+ 2 GUI");
  	}
  # endif
  
--- 6450,6456 ----
  	{
  	    /* GTK+ 2 uses only a single encoding, and that is UTF-8. */
  	    if (STRCMP(p_tenc, "utf-8") != 0)
! 		errmsg = N_("E617: Cannot be changed in the GTK+ 2 GUI");
  	}
  # endif
  
***************
*** 6475,6481 ****
  		if (convert_setup(&input_conv, p_tenc, p_enc) == FAIL
  			|| convert_setup(&output_conv, p_enc, p_tenc) == FAIL)
  		{
! 		    EMSG3(_("E950: Cannot convert between %s and %s"),
  			    p_tenc, p_enc);
  		    errmsg = e_invarg;
  		}
--- 6471,6477 ----
  		if (convert_setup(&input_conv, p_tenc, p_enc) == FAIL
  			|| convert_setup(&output_conv, p_enc, p_tenc) == FAIL)
  		{
! 		    semsg(_("E950: Cannot convert between %s and %s"),
  			    p_tenc, p_enc);
  		    errmsg = e_invarg;
  		}
***************
*** 6748,6756 ****
  		++s;
  	    }
  	    if (*s++ == NUL)
! 		errmsg = (char_u *)N_("E524: Missing colon");
  	    else if (*s == ',' || *s == NUL)
! 		errmsg = (char_u *)N_("E525: Zero length string");
  	    if (errmsg != NULL)
  		break;
  	    while (*s && *s != ',')
--- 6744,6752 ----
  		++s;
  	    }
  	    if (*s++ == NUL)
! 		errmsg = N_("E524: Missing colon");
  	    else if (*s == ',' || *s == NUL)
! 		errmsg = N_("E525: Zero length string");
  	    if (errmsg != NULL)
  		break;
  	    while (*s && *s != ',')
***************
*** 6830,6842 ****
  		{
  		    if (errbuf != NULL)
  		    {
! 			sprintf((char *)errbuf,
! 					 _("E526: Missing number after <%s>"),
  						    transchar_byte(*(s - 1)));
  			errmsg = errbuf;
  		    }
  		    else
! 			errmsg = (char_u *)"";
  		    break;
  		}
  	    }
--- 6826,6837 ----
  		{
  		    if (errbuf != NULL)
  		    {
! 			sprintf(errbuf, _("E526: Missing number after <%s>"),
  						    transchar_byte(*(s - 1)));
  			errmsg = errbuf;
  		    }
  		    else
! 			errmsg = "";
  		    break;
  		}
  	    }
***************
*** 6845,6858 ****
  	    else if (*s)
  	    {
  		if (errbuf != NULL)
! 		    errmsg = (char_u *)N_("E527: Missing comma");
  		else
! 		    errmsg = (char_u *)"";
  		break;
  	    }
  	}
  	if (*p_viminfo && errmsg == NULL && get_viminfo_parameter('\'') < 0)
! 	    errmsg = (char_u *)N_("E528: Must specify a ' value");
      }
  #endif /* FEAT_VIMINFO */
  
--- 6840,6853 ----
  	    else if (*s)
  	    {
  		if (errbuf != NULL)
! 		    errmsg = N_("E527: Missing comma");
  		else
! 		    errmsg = "";
  		break;
  	    }
  	}
  	if (*p_viminfo && errmsg == NULL && get_viminfo_parameter('\'') < 0)
! 	    errmsg = N_("E528: Must specify a ' value");
      }
  #endif /* FEAT_VIMINFO */
  
***************
*** 6917,6923 ****
  	for (s = p_sbr; *s; )
  	{
  	    if (ptr2cells(s) != 1)
! 		errmsg = (char_u *)N_("E595: contains unprintable or wide character");
  	    MB_PTR_ADV(s);
  	}
      }
--- 6912,6918 ----
  	for (s = p_sbr; *s; )
  	{
  	    if (ptr2cells(s) != 1)
! 		errmsg = N_("E595: contains unprintable or wide character");
  	    MB_PTR_ADV(s);
  	}
      }
***************
*** 6961,6967 ****
  		}
  		else
  # endif
! 		    errmsg = (char_u *)N_("E596: Invalid font(s)");
  	    }
  	}
  	redraw_gui_only = TRUE;
--- 6956,6962 ----
  		}
  		else
  # endif
! 		    errmsg = N_("E596: Invalid font(s)");
  	    }
  	}
  	redraw_gui_only = TRUE;
***************
*** 6980,6988 ****
      else if (varp == &p_guifontwide)
      {
  	if (STRCMP(p_guifontwide, "*") == 0)
! 	    errmsg = (char_u *)N_("E533: can't select wide font");
  	else if (gui_get_wide_font() == FAIL)
! 	    errmsg = (char_u *)N_("E534: Invalid wide font");
  	redraw_gui_only = TRUE;
      }
  # endif
--- 6975,6983 ----
      else if (varp == &p_guifontwide)
      {
  	if (STRCMP(p_guifontwide, "*") == 0)
! 	    errmsg = N_("E533: can't select wide font");
  	else if (gui_get_wide_font() == FAIL)
! 	    errmsg = N_("E534: Invalid wide font");
  	redraw_gui_only = TRUE;
      }
  # endif
***************
*** 7285,7291 ****
  			errmsg = errbuf;
  		    }
  		    else
! 			errmsg = (char_u *)"";
  		    break;
  		}
  	    }
--- 7280,7286 ----
  			errmsg = errbuf;
  		    }
  		    else
! 			errmsg = "";
  		    break;
  		}
  	    }
***************
*** 7445,7451 ****
      {
  	p = vim_strchr(*varp, ',');
  	if (p == NULL)
! 	    errmsg = (char_u *)N_("E536: comma required");
  	else if (p == *varp || p[1] == NUL)
  	    errmsg = e_invarg;
  	else if (foldmethodIsMarker(curwin))
--- 7440,7446 ----
      {
  	p = vim_strchr(*varp, ',');
  	if (p == NULL)
! 	    errmsg = N_("E536: comma required");
  	else if (p == *varp || p[1] == NUL)
  	    errmsg = e_invarg;
  	else if (foldmethodIsMarker(curwin))
***************
*** 7455,7461 ****
      else if (gvarp == &p_cms)
      {
  	if (**varp != NUL && strstr((char *)*varp, "%s") == NULL)
! 	    errmsg = (char_u *)N_("E537: 'commentstring' must be empty or contain %s");
      }
      /* 'foldopen' */
      else if (varp == &p_fdo)
--- 7450,7456 ----
      else if (gvarp == &p_cms)
      {
  	if (**varp != NUL && strstr((char *)*varp, "%s") == NULL)
! 	    errmsg = N_("E537: 'commentstring' must be empty or contain %s");
      }
      /* 'foldopen' */
      else if (varp == &p_fdo)
***************
*** 7878,7884 ****
   * Handle setting 'colorcolumn' or 'textwidth' in window "wp".
   * Returns error message, NULL if it's OK.
   */
!     char_u *
  check_colorcolumn(win_T *wp)
  {
      char_u	*s;
--- 7873,7879 ----
   * Handle setting 'colorcolumn' or 'textwidth' in window "wp".
   * Returns error message, NULL if it's OK.
   */
!     char *
  check_colorcolumn(win_T *wp)
  {
      char_u	*s;
***************
*** 7949,7955 ****
   * Handle setting 'listchars' or 'fillchars'.
   * Returns error message, NULL if it's OK.
   */
!     static char_u *
  set_chars_option(char_u **varp)
  {
      int		round, i, len, entries;
--- 7944,7950 ----
   * Handle setting 'listchars' or 'fillchars'.
   * Returns error message, NULL if it's OK.
   */
!     static char *
  set_chars_option(char_u **varp)
  {
      int		round, i, len, entries;
***************
*** 8075,8086 ****
   * Check validity of options with the 'statusline' format.
   * Return error message or NULL.
   */
!     char_u *
  check_stl_option(char_u *s)
  {
      int		itemcnt = 0;
      int		groupdepth = 0;
!     static char_u   errbuf[80];
  
      while (*s && itemcnt < STL_MAX_ITEM)
      {
--- 8070,8081 ----
   * Check validity of options with the 'statusline' format.
   * Return error message or NULL.
   */
!     char *
  check_stl_option(char_u *s)
  {
      int		itemcnt = 0;
      int		groupdepth = 0;
!     static char errbuf[80];
  
      while (*s && itemcnt < STL_MAX_ITEM)
      {
***************
*** 8131,8143 ****
  	    while (*s != '}' && *s)
  		s++;
  	    if (*s != '}')
! 		return (char_u *)N_("E540: Unclosed expression sequence");
  	}
      }
      if (itemcnt >= STL_MAX_ITEM)
! 	return (char_u *)N_("E541: too many items");
      if (groupdepth != 0)
! 	return (char_u *)N_("E542: unbalanced groups");
      return NULL;
  }
  #endif
--- 8126,8138 ----
  	    while (*s != '}' && *s)
  		s++;
  	    if (*s != '}')
! 		return N_("E540: Unclosed expression sequence");
  	}
      }
      if (itemcnt >= STL_MAX_ITEM)
! 	return N_("E541: too many items");
      if (groupdepth != 0)
! 	return N_("E542: unbalanced groups");
      return NULL;
  }
  #endif
***************
*** 8145,8152 ****
  #ifdef FEAT_CLIPBOARD
  /*
   * Extract the items in the 'clipboard' option and set global values.
   */
!     static char_u *
  check_clipboard_option(void)
  {
      int		new_unnamed = 0;
--- 8140,8148 ----
  #ifdef FEAT_CLIPBOARD
  /*
   * Extract the items in the 'clipboard' option and set global values.
+  * Return an error message or NULL for success.
   */
!     static char *
  check_clipboard_option(void)
  {
      int		new_unnamed = 0;
***************
*** 8155,8161 ****
      int		new_autoselectml = FALSE;
      int		new_html = FALSE;
      regprog_T	*new_exclude_prog = NULL;
!     char_u	*errmsg = NULL;
      char_u	*p;
  
      for (p = p_cb; *p != NUL; )
--- 8151,8157 ----
      int		new_autoselectml = FALSE;
      int		new_html = FALSE;
      regprog_T	*new_exclude_prog = NULL;
!     char	*errmsg = NULL;
      char_u	*p;
  
      for (p = p_cb; *p != NUL; )
***************
*** 8235,8244 ****
  #endif
  
  #ifdef FEAT_SPELL
!     static char_u *
  did_set_spell_option(int is_spellfile)
  {
!     char_u  *errmsg = NULL;
      win_T   *wp;
      int	    l;
  
--- 8231,8244 ----
  #endif
  
  #ifdef FEAT_SPELL
! /*
!  * Handle side effects of setting 'spell'.
!  * Return an error message or NULL for success.
!  */
!     static char *
  did_set_spell_option(int is_spellfile)
  {
!     char    *errmsg = NULL;
      win_T   *wp;
      int	    l;
  
***************
*** 8266,8272 ****
   * Set curbuf->b_cap_prog to the regexp program for 'spellcapcheck'.
   * Return error message when failed, NULL when OK.
   */
!     static char_u *
  compile_cap_prog(synblock_T *synblock)
  {
      regprog_T   *rp = synblock->b_cap_prog;
--- 8266,8272 ----
   * Set curbuf->b_cap_prog to the regexp program for 'spellcapcheck'.
   * Return error message when failed, NULL when OK.
   */
!     static char *
  compile_cap_prog(synblock_T *synblock)
  {
      regprog_T   *rp = synblock->b_cap_prog;
***************
*** 8353,8359 ****
   * Set the value of a boolean option, and take care of side effects.
   * Returns NULL for success, or an error message for an error.
   */
!     static char_u *
  set_bool_option(
      int		opt_idx,		/* index in options[] table */
      char_u	*varp,			/* pointer to the option variable */
--- 8353,8359 ----
   * Set the value of a boolean option, and take care of side effects.
   * Returns NULL for success, or an error message for an error.
   */
!     static char *
  set_bool_option(
      int		opt_idx,		/* index in options[] table */
      char_u	*varp,			/* pointer to the option variable */
***************
*** 8471,8477 ****
  		      && curbuf->b_term != NULL && !term_is_finished(curbuf))))
  	{
  	    curbuf->b_p_ma = FALSE;
! 	    return (char_u *)N_("E946: Cannot make a terminal with running job modifiable");
  	}
  # endif
  # ifdef FEAT_TITLE
--- 8471,8477 ----
  		      && curbuf->b_term != NULL && !term_is_finished(curbuf))))
  	{
  	    curbuf->b_p_ma = FALSE;
! 	    return N_("E946: Cannot make a terminal with running job modifiable");
  	}
  # endif
  # ifdef FEAT_TITLE
***************
*** 8607,8613 ****
  		if (win->w_p_pvw && win != curwin)
  		{
  		    curwin->w_p_pvw = FALSE;
! 		    return (char_u *)N_("E590: A preview window already exists");
  		}
  	}
      }
--- 8607,8613 ----
  		if (win->w_p_pvw && win != curwin)
  		{
  		    curwin->w_p_pvw = FALSE;
! 		    return N_("E590: A preview window already exists");
  		}
  	}
      }
***************
*** 8765,8773 ****
      {
  	if (curwin->w_p_spell)
  	{
! 	    char_u	*errmsg = did_set_spelllang(curwin);
  	    if (errmsg != NULL)
! 		EMSG(_(errmsg));
  	}
      }
  #endif
--- 8765,8774 ----
      {
  	if (curwin->w_p_spell)
  	{
! 	    char	*errmsg = did_set_spelllang(curwin);
! 
  	    if (errmsg != NULL)
! 		emsg(_(errmsg));
  	}
      }
  #endif
***************
*** 8989,9005 ****
   * Set the value of a number option, and take care of side effects.
   * Returns NULL for success, or an error message for an error.
   */
!     static char_u *
  set_num_option(
      int		opt_idx,		/* index in options[] table */
      char_u	*varp,			/* pointer to the option variable */
      long	value,			/* new value */
!     char_u	*errbuf,		/* buffer for error messages */
      size_t	errbuflen,		/* length of "errbuf" */
      int		opt_flags)		/* OPT_LOCAL, OPT_GLOBAL and
  					   OPT_MODELINE */
  {
!     char_u	*errmsg = NULL;
      long	old_value = *(long *)varp;
      long	old_Rows = Rows;	/* remember old Rows */
      long	old_Columns = Columns;	/* remember old Columns */
--- 8990,9006 ----
   * Set the value of a number option, and take care of side effects.
   * Returns NULL for success, or an error message for an error.
   */
!     static char *
  set_num_option(
      int		opt_idx,		/* index in options[] table */
      char_u	*varp,			/* pointer to the option variable */
      long	value,			/* new value */
!     char	*errbuf,		/* buffer for error messages */
      size_t	errbuflen,		/* length of "errbuf" */
      int		opt_flags)		/* OPT_LOCAL, OPT_GLOBAL and
  					   OPT_MODELINE */
  {
!     char	*errmsg = NULL;
      long	old_value = *(long *)varp;
      long	old_Rows = Rows;	/* remember old Rows */
      long	old_Columns = Columns;	/* remember old Columns */
***************
*** 9937,9943 ****
   *
   * Returns NULL on success or error message on error.
   */
!     char_u *
  set_option_value(
      char_u	*name,
      long	number,
--- 9938,9944 ----
   *
   * Returns NULL on success or error message on error.
   */
!     char *
  set_option_value(
      char_u	*name,
      long	number,
***************
*** 9975,9981 ****
  	    return NULL;
  	}
  
! 	EMSG2(_("E355: Unknown option: %s"), name);
      }
      else
      {
--- 9976,9982 ----
  	    return NULL;
  	}
  
! 	semsg(_("E355: Unknown option: %s"), name);
      }
      else
      {
***************
*** 9984,9990 ****
  	/* Disallow changing some options in the sandbox */
  	if (sandbox > 0 && (flags & P_SECURE))
  	{
! 	    EMSG(_(e_sandbox));
  	    return NULL;
  	}
  #endif
--- 9985,9991 ----
  	/* Disallow changing some options in the sandbox */
  	if (sandbox > 0 && (flags & P_SECURE))
  	{
! 	    emsg(_(e_sandbox));
  	    return NULL;
  	}
  #endif
***************
*** 10008,10014 ****
  			/* There's another character after zeros or the string
  			 * is empty.  In both cases, we are trying to set a
  			 * num option using a string. */
! 			EMSG3(_("E521: Number required: &%s = '%s'"),
  								name, string);
  			return NULL;     /* do nothing as we hit an error */
  
--- 10009,10015 ----
  			/* There's another character after zeros or the string
  			 * is empty.  In both cases, we are trying to set a
  			 * num option using a string. */
! 			semsg(_("E521: Number required: &%s = '%s'"),
  								name, string);
  			return NULL;     /* do nothing as we hit an error */
  
***************
*** 11086,11092 ****
  	case PV_VSTS:	return (char_u *)&(curbuf->b_p_vsts);
  	case PV_VTS:	return (char_u *)&(curbuf->b_p_vts);
  #endif
! 	default:	IEMSG(_("E356: get_varp ERROR"));
      }
      /* always return a valid pointer to avoid a crash! */
      return (char_u *)&(curbuf->b_p_wm);
--- 11087,11093 ----
  	case PV_VSTS:	return (char_u *)&(curbuf->b_p_vsts);
  	case PV_VTS:	return (char_u *)&(curbuf->b_p_vts);
  #endif
! 	default:	iemsg(_("E356: get_varp ERROR"));
      }
      /* always return a valid pointer to avoid a crash! */
      return (char_u *)&(curbuf->b_p_wm);
***************
*** 12283,12289 ****
  	    }
  	    if (to == NUL)
  	    {
! 		EMSG2(_("E357: 'langmap': Matching character missing for %s"),
  							     transchar(from));
  		return;
  	    }
--- 12284,12290 ----
  	    }
  	    if (to == NUL)
  	    {
! 		semsg(_("E357: 'langmap': Matching character missing for %s"),
  							     transchar(from));
  		return;
  	    }
***************
*** 12307,12313 ****
  		    {
  			if (p[0] != ',')
  			{
! 			    EMSG2(_("E358: 'langmap': Extra characters after semicolon: %s"), p);
  			    return;
  			}
  			++p;
--- 12308,12314 ----
  		    {
  			if (p[0] != ',')
  			{
! 			    semsg(_("E358: 'langmap': Extra characters after semicolon: %s"), p);
  			    return;
  			}
  			++p;
***************
*** 12877,12885 ****
  	    if (strtol((char *)cp, (char **)&end, 10) <= 0)
  	    {
  		if (cp != end)
! 		    EMSG(_(e_positive));
  		else
! 		    EMSG(_(e_invarg));
  		return FALSE;
  	    }
  	}
--- 12878,12886 ----
  	    if (strtol((char *)cp, (char **)&end, 10) <= 0)
  	    {
  		if (cp != end)
! 		    emsg(_(e_positive));
  		else
! 		    emsg(_(e_invarg));
  		return FALSE;
  	    }
  	}
***************
*** 12891,12897 ****
  	    ++valcount;
  	    continue;
  	}
! 	EMSG(_(e_invarg));
  	return FALSE;
      }
  
--- 12892,12898 ----
  	    ++valcount;
  	    continue;
  	}
! 	emsg(_(e_invarg));
  	return FALSE;
      }
  
*** ../vim-8.1.0742/src/os_amiga.c	2018-11-16 16:21:01.641310033 +0100
--- src/os_amiga.c	2019-01-13 19:56:11.854115310 +0100
***************
*** 963,969 ****
      int
  mch_screenmode(char_u *arg)
  {
!     EMSG(_(e_screenmode));
      return FAIL;
  }
  
--- 963,969 ----
      int
  mch_screenmode(char_u *arg)
  {
!     emsg(_(e_screenmode));
      return FAIL;
  }
  
***************
*** 1189,1195 ****
      if (close_win)
      {
  	/* if Vim opened a window: Executing a shell may cause crashes */
! 	EMSG(_("E360: Cannot execute shell with -f option"));
  	return -1;
      }
  
--- 1189,1195 ----
      if (close_win)
      {
  	/* if Vim opened a window: Executing a shell may cause crashes */
! 	emsg(_("E360: Cannot execute shell with -f option"));
  	return -1;
      }
  
***************
*** 1517,1527 ****
      matches = gap->ga_len - start_len;
  
      if (Result == ERROR_BUFFER_OVERFLOW)
! 	EMSG(_("ANCHOR_BUF_SIZE too small."));
      else if (matches == 0 && Result != ERROR_OBJECT_NOT_FOUND
  			  && Result != ERROR_DEVICE_NOT_MOUNTED
  			  && Result != ERROR_NO_MORE_ENTRIES)
! 	EMSG(_("I/O ERROR"));
  
      /*
       * Sort the files for this pattern.
--- 1517,1527 ----
      matches = gap->ga_len - start_len;
  
      if (Result == ERROR_BUFFER_OVERFLOW)
! 	emsg(_("ANCHOR_BUF_SIZE too small."));
      else if (matches == 0 && Result != ERROR_OBJECT_NOT_FOUND
  			  && Result != ERROR_DEVICE_NOT_MOUNTED
  			  && Result != ERROR_NO_MORE_ENTRIES)
! 	emsg(_("I/O ERROR"));
  
      /*
       * Sort the files for this pattern.
*** ../vim-8.1.0742/src/os_mswin.c	2018-12-18 21:56:25.084495836 +0100
--- src/os_mswin.c	2019-01-13 19:56:15.186087048 +0100
***************
*** 776,782 ****
      if (p_verbose >= 5)
      {
  	verbose_enter();
! 	smsg((char_u *)"chdir(%s)", path);
  	verbose_leave();
      }
      if (isalpha(path[0]) && path[1] == ':')	/* has a drive name */
--- 776,782 ----
      if (p_verbose >= 5)
      {
  	verbose_enter();
! 	smsg("chdir(%s)", path);
  	verbose_leave();
      }
      if (isalpha(path[0]) && path[1] == ':')	/* has a drive name */
***************
*** 841,847 ****
      int
  mch_screenmode(char_u *arg UNUSED)
  {
!     EMSG(_(e_screenmode));
      return FAIL;
  }
  
--- 841,847 ----
      int
  mch_screenmode(char_u *arg UNUSED)
  {
!     emsg(_(e_screenmode));
      return FAIL;
  }
  
***************
*** 1004,1010 ****
  
      if (!fRunTimeLinkSuccess)
      {
! 	EMSG2(_(e_libcall), funcname);
  	return FAIL;
      }
  
--- 1004,1010 ----
  
      if (!fRunTimeLinkSuccess)
      {
! 	semsg(_(e_libcall), funcname);
  	return FAIL;
      }
  
***************
*** 1524,1530 ****
  
      if (prt_dlg.hDC == NULL)
      {
! 	EMSG(_("E237: Printer selection failed"));
  	mch_print_cleanup();
  	return FALSE;
      }
--- 1524,1530 ----
  
      if (prt_dlg.hDC == NULL)
      {
! 	emsg(_("E237: Printer selection failed"));
  	mch_print_cleanup();
  	return FALSE;
      }
***************
*** 1601,1607 ****
      vim_memset(&fLogFont, 0, sizeof(fLogFont));
      if (get_logfont(&fLogFont, p_pfn, prt_dlg.hDC, TRUE) == FAIL)
      {
! 	EMSG2(_("E613: Unknown printer font: %s"), p_pfn);
  	mch_print_cleanup();
  	return FALSE;
      }
--- 1601,1607 ----
      vim_memset(&fLogFont, 0, sizeof(fLogFont));
      if (get_logfont(&fLogFont, p_pfn, prt_dlg.hDC, TRUE) == FAIL)
      {
! 	semsg(_("E613: Unknown printer font: %s"), p_pfn);
  	mch_print_cleanup();
  	return FALSE;
      }
***************
*** 1662,1668 ****
  			  FORMAT_MESSAGE_FROM_SYSTEM |
  			  FORMAT_MESSAGE_IGNORE_INSERTS,
  			  NULL, err, 0, (LPTSTR)(&buf), 0, NULL);
! 	    EMSG2(_("E238: Print error: %s"),
  				  buf == NULL ? (char_u *)_("Unknown") : buf);
  	    LocalFree((LPVOID)(buf));
  	}
--- 1662,1668 ----
  			  FORMAT_MESSAGE_FROM_SYSTEM |
  			  FORMAT_MESSAGE_IGNORE_INSERTS,
  			  NULL, err, 0, (LPTSTR)(&buf), 0, NULL);
! 	    semsg(_("E238: Print error: %s"),
  				  buf == NULL ? (char_u *)_("Unknown") : buf);
  	    LocalFree((LPVOID)(buf));
  	}
***************
*** 2504,2510 ****
      if (target == 0)
      {
  	if (!silent)
! 	    EMSG2(_(e_noserver), name);
  	return -1;
      }
  
--- 2504,2510 ----
      if (target == 0)
      {
  	if (!silent)
! 	    semsg(_(e_noserver), name);
  	return -1;
      }
  
***************
*** 3070,3078 ****
  			}
  		    if (cp->name == NULL && verbose)
  		    {
! 			vim_snprintf((char *)IObuff, IOSIZE,
! 				_("E244: Illegal charset name \"%s\" in font name \"%s\""), p, name);
! 			EMSG(IObuff);
  			break;
  		    }
  		    break;
--- 3070,3076 ----
  			}
  		    if (cp->name == NULL && verbose)
  		    {
! 			semsg(_("E244: Illegal charset name \"%s\" in font name \"%s\""), p, name);
  			break;
  		    }
  		    break;
***************
*** 3090,3110 ****
  			}
  		    if (qp->name == NULL && verbose)
  		    {
! 			vim_snprintf((char *)IObuff, IOSIZE,
! 				_("E244: Illegal quality name \"%s\" in font name \"%s\""), p, name);
! 			EMSG(IObuff);
  			break;
  		    }
  		    break;
  		}
  	    default:
  		if (verbose)
! 		{
! 		    vim_snprintf((char *)IObuff, IOSIZE,
! 			    _("E245: Illegal char '%c' in font name \"%s\""),
! 			    p[-1], name);
! 		    EMSG(IObuff);
! 		}
  		goto theend;
  	}
  	while (*p == ':')
--- 3088,3101 ----
  			}
  		    if (qp->name == NULL && verbose)
  		    {
! 			semsg(_("E244: Illegal quality name \"%s\" in font name \"%s\""), p, name);
  			break;
  		    }
  		    break;
  		}
  	    default:
  		if (verbose)
! 		    semsg(_("E245: Illegal char '%c' in font name \"%s\""), p[-1], name);
  		goto theend;
  	}
  	while (*p == ':')
*** ../vim-8.1.0742/src/os_unix.c	2018-12-29 22:28:42.750699129 +0100
--- src/os_unix.c	2019-01-13 19:56:18.662057582 +0100
***************
*** 327,333 ****
      if (p_verbose >= 5)
      {
  	verbose_enter();
! 	smsg((char_u *)"chdir(%s)", path);
  	verbose_leave();
      }
  # ifdef VMS
--- 327,333 ----
      if (p_verbose >= 5)
      {
  	verbose_enter();
! 	smsg("chdir(%s)", path);
  	verbose_leave();
      }
  # ifdef VMS
***************
*** 1004,1010 ****
   *	if (SETJMP(lc_jump_env) != 0)
   *	{
   *	    mch_didjmp();
!  *	    EMSG("crash!");
   *	}
   *	else
   *	{
--- 1004,1010 ----
   *	if (SETJMP(lc_jump_env) != 0)
   *	{
   *	    mch_didjmp();
!  *	    emsg("crash!");
   *	}
   *	else
   *	{
***************
*** 1632,1638 ****
      static void
  xopen_message(long elapsed_msec)
  {
!     smsg((char_u *)_("Opening the X display took %ld msec"), elapsed_msec);
  }
  # endif
  #endif
--- 1632,1638 ----
      static void
  xopen_message(long elapsed_msec)
  {
!     smsg(_("Opening the X display took %ld msec"), elapsed_msec);
  }
  # endif
  #endif
***************
*** 2670,2676 ****
  #endif
  		l = mch_chdir((char *)olddir);
  	    if (l != 0)
! 		EMSG(_(e_prev_dir));
  	}
  
  	l = STRLEN(buf);
--- 2670,2676 ----
  #endif
  		l = mch_chdir((char *)olddir);
  	    if (l != 0)
! 		emsg(_(e_prev_dir));
  	}
  
  	l = STRLEN(buf);
***************
*** 3974,3980 ****
      int
  mch_screenmode(char_u *arg UNUSED)
  {
!     EMSG(_(e_screenmode));
      return FAIL;
  }
  
--- 3974,3980 ----
      int
  mch_screenmode(char_u *arg UNUSED)
  {
!     emsg(_(e_screenmode));
      return FAIL;
  }
  
***************
*** 5454,5460 ****
  	fd_in[0] = mch_open((char *)fname, O_RDONLY, 0);
  	if (fd_in[0] < 0)
  	{
! 	    EMSG2(_(e_notopen), fname);
  	    goto failed;
  	}
      }
--- 5454,5460 ----
  	fd_in[0] = mch_open((char *)fname, O_RDONLY, 0);
  	if (fd_in[0] < 0)
  	{
! 	    semsg(_(e_notopen), fname);
  	    goto failed;
  	}
      }
***************
*** 5472,5478 ****
  	fd_out[1] = mch_open((char *)fname, O_WRONLY | O_CREAT | O_TRUNC, 0644);
  	if (fd_out[1] < 0)
  	{
! 	    EMSG2(_(e_notopen), fname);
  	    goto failed;
  	}
      }
--- 5472,5478 ----
  	fd_out[1] = mch_open((char *)fname, O_WRONLY | O_CREAT | O_TRUNC, 0644);
  	if (fd_out[1] < 0)
  	{
! 	    semsg(_(e_notopen), fname);
  	    goto failed;
  	}
      }
***************
*** 5486,5492 ****
  	fd_err[1] = mch_open((char *)fname, O_WRONLY | O_CREAT | O_TRUNC, 0600);
  	if (fd_err[1] < 0)
  	{
! 	    EMSG2(_(e_notopen), fname);
  	    goto failed;
  	}
      }
--- 5486,5492 ----
  	fd_err[1] = mch_open((char *)fname, O_WRONLY | O_CREAT | O_TRUNC, 0600);
  	if (fd_err[1] < 0)
  	{
! 	    semsg(_(e_notopen), fname);
  	    goto failed;
  	}
      }
***************
*** 6509,6515 ****
       */
      if ((tempname = vim_tempname('o', FALSE)) == NULL)
      {
! 	EMSG(_(e_notmp));
  	return FAIL;
      }
  
--- 6509,6515 ----
       */
      if ((tempname = vim_tempname('o', FALSE)) == NULL)
      {
! 	emsg(_(e_notmp));
  	return FAIL;
      }
  
***************
*** 6763,6769 ****
      if (i != (int)len)
      {
  	/* unexpected read error */
! 	EMSG2(_(e_notread), tempname);
  	vim_free(tempname);
  	vim_free(buffer);
  	return FAIL;
--- 6763,6769 ----
      if (i != (int)len)
      {
  	/* unexpected read error */
! 	semsg(_(e_notread), tempname);
  	vim_free(tempname);
  	vim_free(buffer);
  	return FAIL;
***************
*** 7347,7353 ****
  	/* "dlerr" must be used before dlclose() */
  	dlerr = (char *)dlerror();
  	if (dlerr != NULL)
! 	    EMSG2(_("dlerror = \"%s\""), dlerr);
      }
  # else
      hinstLib = shl_load((const char*)libname, BIND_IMMEDIATE|BIND_VERBOSE, 0L);
--- 7347,7353 ----
  	/* "dlerr" must be used before dlclose() */
  	dlerr = (char *)dlerror();
  	if (dlerr != NULL)
! 	    semsg(_("dlerror = \"%s\""), dlerr);
      }
  # else
      hinstLib = shl_load((const char*)libname, BIND_IMMEDIATE|BIND_VERBOSE, 0L);
***************
*** 7442,7448 ****
  	    for (i = 0; signal_info[i].sig != -1; i++)
  		if (lc_signal == signal_info[i].sig)
  		    break;
! 	    EMSG2("E368: got SIG%s in libcall()", signal_info[i].name);
  	}
  #  endif
  # endif
--- 7442,7448 ----
  	    for (i = 0; signal_info[i].sig != -1; i++)
  		if (lc_signal == signal_info[i].sig)
  		    break;
! 	    semsg("E368: got SIG%s in libcall()", signal_info[i].name);
  	}
  #  endif
  # endif
***************
*** 7450,7456 ****
  # if defined(USE_DLOPEN)
  	/* "dlerr" must be used before dlclose() */
  	if (dlerr != NULL)
! 	    EMSG2(_("dlerror = \"%s\""), dlerr);
  
  	/* Free the DLL module. */
  	(void)dlclose(hinstLib);
--- 7450,7456 ----
  # if defined(USE_DLOPEN)
  	/* "dlerr" must be used before dlclose() */
  	if (dlerr != NULL)
! 	    semsg(_("dlerror = \"%s\""), dlerr);
  
  	/* Free the DLL module. */
  	(void)dlclose(hinstLib);
***************
*** 7461,7467 ****
  
      if (!success)
      {
! 	EMSG2(_(e_libcall), funcname);
  	return FAIL;
      }
  
--- 7461,7467 ----
  
      if (!success)
      {
! 	semsg(_(e_libcall), funcname);
  	return FAIL;
      }
  
*** ../vim-8.1.0742/src/os_win32.c	2018-12-21 16:04:16.320437461 +0100
--- src/os_win32.c	2019-01-13 19:56:23.834013773 +0100
***************
*** 633,639 ****
  	if (p_verbose > 0)
  	{
  	    verbose_enter();
! 	    EMSG2(_(e_loadlib), GETTEXT_DLL);
  	    verbose_leave();
  	}
  	return 0;
--- 633,639 ----
  	if (p_verbose > 0)
  	{
  	    verbose_enter();
! 	    semsg(_(e_loadlib), GETTEXT_DLL);
  	    verbose_leave();
  	}
  	return 0;
***************
*** 648,654 ****
  	    if (p_verbose > 0)
  	    {
  		verbose_enter();
! 		EMSG2(_(e_loadfunc), libintl_entry[i].name);
  		verbose_leave();
  	    }
  	    return 0;
--- 648,654 ----
  	    if (p_verbose > 0)
  	    {
  		verbose_enter();
! 		semsg(_(e_loadfunc), libintl_entry[i].name);
  		verbose_leave();
  	    }
  	    return 0;
***************
*** 5182,5188 ****
  	    {
  		x = -1;
  #ifdef FEAT_GUI_W32
! 		EMSG(_("E371: Command not found"));
  #endif
  	    }
  
--- 5182,5188 ----
  	    {
  		x = -1;
  #ifdef FEAT_GUI_W32
! 		emsg(_("E371: Command not found"));
  #endif
  	    }
  
***************
*** 5260,5266 ****
  #endif
  	    )
      {
! 	smsg((char_u *)_("shell returned %d"), x);
  	msg_putchar('\n');
      }
  #ifdef FEAT_TITLE
--- 5260,5266 ----
  #endif
  	    )
      {
! 	smsg(_("shell returned %d"), x);
  	msg_putchar('\n');
      }
  #ifdef FEAT_TITLE
***************
*** 5489,5495 ****
  		&saAttr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL);
  	if (ifd[0] == INVALID_HANDLE_VALUE)
  	{
! 	    EMSG2(_(e_notopen), fname);
  	    goto failed;
  	}
      }
--- 5489,5495 ----
  		&saAttr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL);
  	if (ifd[0] == INVALID_HANDLE_VALUE)
  	{
! 	    semsg(_(e_notopen), fname);
  	    goto failed;
  	}
      }
***************
*** 5507,5513 ****
  		&saAttr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL);
  	if (ofd[1] == INVALID_HANDLE_VALUE)
  	{
! 	    EMSG2(_(e_notopen), fname);
  	    goto failed;
  	}
      }
--- 5507,5513 ----
  		&saAttr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL);
  	if (ofd[1] == INVALID_HANDLE_VALUE)
  	{
! 	    semsg(_(e_notopen), fname);
  	    goto failed;
  	}
      }
***************
*** 5525,5531 ****
  		&saAttr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL);
  	if (efd[1] == INVALID_HANDLE_VALUE)
  	{
! 	    EMSG2(_(e_notopen), fname);
  	    goto failed;
  	}
      }
--- 5525,5531 ----
  		&saAttr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL);
  	if (efd[1] == INVALID_HANDLE_VALUE)
  	{
! 	    semsg(_(e_notopen), fname);
  	    goto failed;
  	}
      }
*** ../vim-8.1.0742/src/popupmnu.c	2019-01-06 13:10:46.328499104 +0100
--- src/popupmnu.c	2019-01-13 19:27:43.432613941 +0100
***************
*** 1199,1205 ****
      // pum_size being zero.
      if (pum_size <= 0)
      {
! 	EMSG(e_menuothermode);
  	return;
      }
  
--- 1199,1205 ----
      // pum_size being zero.
      if (pum_size <= 0)
      {
! 	emsg(e_menuothermode);
  	return;
      }
  
*** ../vim-8.1.0742/src/proto.h	2019-01-12 22:47:01.264088074 +0100
--- src/proto.h	2019-01-13 19:27:43.432613941 +0100
***************
*** 108,132 ****
  #  ifdef __BORLANDC__
  _RTLENTRYF
  #  endif
! smsg(char_u *, ...);
  
  int
  #  ifdef __BORLANDC__
  _RTLENTRYF
  #  endif
! smsg_attr(int, char_u *, ...);
  
  int
  #  ifdef __BORLANDC__
  _RTLENTRYF
  #  endif
! smsg_attr_keep(int, char_u *, ...);
  
  int
  #  ifdef __BORLANDC__
  _RTLENTRYF
  #  endif
! vim_snprintf_add(char *, size_t, char *, ...)
  #ifdef USE_PRINTF_FORMAT_ATTRIBUTE
      __attribute__((format(printf, 3, 4)))
  #endif
--- 108,132 ----
  #  ifdef __BORLANDC__
  _RTLENTRYF
  #  endif
! smsg(const char *, ...);
  
  int
  #  ifdef __BORLANDC__
  _RTLENTRYF
  #  endif
! smsg_attr(int, const char *, ...);
  
  int
  #  ifdef __BORLANDC__
  _RTLENTRYF
  #  endif
! smsg_attr_keep(int, const char *, ...);
  
  int
  #  ifdef __BORLANDC__
  _RTLENTRYF
  #  endif
! vim_snprintf_add(char *, size_t, const char *, ...)
  #ifdef USE_PRINTF_FORMAT_ATTRIBUTE
      __attribute__((format(printf, 3, 4)))
  #endif
***************
*** 136,149 ****
  #  ifdef __BORLANDC__
  _RTLENTRYF
  #  endif
! vim_snprintf(char *, size_t, char *, ...)
  #ifdef USE_PRINTF_FORMAT_ATTRIBUTE
      __attribute__((format(printf, 3, 4)))
  #endif
      ;
  
! int vim_vsnprintf(char *str, size_t str_m, char *fmt, va_list ap);
! int vim_vsnprintf_typval(char *str, size_t str_m, char *fmt, va_list ap, typval_T *tvs);
  
  # include "message.pro"
  # include "misc1.pro"
--- 136,149 ----
  #  ifdef __BORLANDC__
  _RTLENTRYF
  #  endif
! vim_snprintf(char *, size_t, const char *, ...)
  #ifdef USE_PRINTF_FORMAT_ATTRIBUTE
      __attribute__((format(printf, 3, 4)))
  #endif
      ;
  
! int vim_vsnprintf(char *str, size_t str_m, const char *fmt, va_list ap);
! int vim_vsnprintf_typval(char *str, size_t str_m, const char *fmt, va_list ap, typval_T *tvs);
  
  # include "message.pro"
  # include "misc1.pro"
*** ../vim-8.1.0742/src/proto/buffer.pro	2019-01-01 13:20:05.940711222 +0100
--- src/proto/buffer.pro	2019-01-13 22:46:17.263080785 +0100
***************
*** 8,14 ****
  void buf_freeall(buf_T *buf, int flags);
  void goto_buffer(exarg_T *eap, int start, int dir, int count);
  void handle_swap_exists(bufref_T *old_curbuf);
! char_u *do_bufdel(int command, char_u *arg, int addr_count, int start_bnr, int end_bnr, int forceit);
  int do_buffer(int action, int start, int dir, int count, int forceit);
  void set_curbuf(buf_T *buf, int action);
  void enter_buffer(buf_T *buf);
--- 8,14 ----
  void buf_freeall(buf_T *buf, int flags);
  void goto_buffer(exarg_T *eap, int start, int dir, int count);
  void handle_swap_exists(bufref_T *old_curbuf);
! char *do_bufdel(int command, char_u *arg, int addr_count, int start_bnr, int end_bnr, int forceit);
  int do_buffer(int action, int start, int dir, int count, int forceit);
  void set_curbuf(buf_T *buf, int action);
  void enter_buffer(buf_T *buf);
*** ../vim-8.1.0742/src/proto/digraph.pro	2018-12-14 18:52:57.169528762 +0100
--- src/proto/digraph.pro	2019-01-13 20:13:03.721965113 +0100
***************
*** 5,11 ****
  int getdigraph(int char1, int char2, int meta_char);
  void putdigraph(char_u *str);
  void listdigraphs(int use_headers);
! char_u *keymap_init(void);
  void ex_loadkeymap(exarg_T *eap);
  void keymap_clear(garray_T *kmap);
  /* vim: set ft=c : */
--- 5,11 ----
  int getdigraph(int char1, int char2, int meta_char);
  void putdigraph(char_u *str);
  void listdigraphs(int use_headers);
! char *keymap_init(void);
  void ex_loadkeymap(exarg_T *eap);
  void keymap_clear(garray_T *kmap);
  /* vim: set ft=c : */
*** ../vim-8.1.0742/src/proto/ex_docmd.pro	2018-10-02 16:23:55.323037143 +0200
--- src/proto/ex_docmd.pro	2019-01-13 20:23:38.337025724 +0100
***************
*** 4,18 ****
  int do_cmdline(char_u *cmdline, char_u *(*fgetline)(int, void *, int), void *cookie, int flags);
  int getline_equal(char_u *(*fgetline)(int, void *, int), void *cookie, char_u *(*func)(int, void *, int));
  void *getline_cookie(char_u *(*fgetline)(int, void *, int), void *cookie);
! int parse_command_modifiers(exarg_T *eap, char_u **errormsg, int skip_only);
! int parse_cmd_address(exarg_T *eap, char_u **errormsg, int silent);
  int checkforcmd(char_u **pp, char *cmd, int len);
  int modifier_len(char_u *cmd);
  int cmd_exists(char_u *name);
  char_u *set_one_cmd_context(expand_T *xp, char_u *buff);
  char_u *skip_range(char_u *cmd, int *ctx);
  void ex_ni(exarg_T *eap);
! int expand_filename(exarg_T *eap, char_u **cmdlinep, char_u **errormsgp);
  void separate_nextcmd(exarg_T *eap);
  int get_bad_opt(char_u *p, exarg_T *eap);
  int ends_excmd(int c);
--- 4,18 ----
  int do_cmdline(char_u *cmdline, char_u *(*fgetline)(int, void *, int), void *cookie, int flags);
  int getline_equal(char_u *(*fgetline)(int, void *, int), void *cookie, char_u *(*func)(int, void *, int));
  void *getline_cookie(char_u *(*fgetline)(int, void *, int), void *cookie);
! int parse_command_modifiers(exarg_T *eap, char **errormsg, int skip_only);
! int parse_cmd_address(exarg_T *eap, char **errormsg, int silent);
  int checkforcmd(char_u **pp, char *cmd, int len);
  int modifier_len(char_u *cmd);
  int cmd_exists(char_u *name);
  char_u *set_one_cmd_context(expand_T *xp, char_u *buff);
  char_u *skip_range(char_u *cmd, int *ctx);
  void ex_ni(exarg_T *eap);
! int expand_filename(exarg_T *eap, char_u **cmdlinep, char **errormsgp);
  void separate_nextcmd(exarg_T *eap);
  int get_bad_opt(char_u *p, exarg_T *eap);
  int ends_excmd(int c);
***************
*** 61,67 ****
  void exec_normal_cmd(char_u *cmd, int remap, int silent);
  void exec_normal(int was_typed, int use_vpeekc, int may_use_terminal_loop);
  int find_cmdline_var(char_u *src, int *usedlen);
! char_u *eval_vars(char_u *src, char_u *srcstart, int *usedlen, linenr_T *lnump, char_u **errormsg, int *escaped);
  char_u *expand_sfile(char_u *arg);
  int put_eol(FILE *fd);
  int put_line(FILE *fd, char *s);
--- 61,67 ----
  void exec_normal_cmd(char_u *cmd, int remap, int silent);
  void exec_normal(int was_typed, int use_vpeekc, int may_use_terminal_loop);
  int find_cmdline_var(char_u *src, int *usedlen);
! char_u *eval_vars(char_u *src, char_u *srcstart, int *usedlen, linenr_T *lnump, char **errormsg, int *escaped);
  char_u *expand_sfile(char_u *arg);
  int put_eol(FILE *fd);
  int put_line(FILE *fd, char *s);
*** ../vim-8.1.0742/src/proto/ex_eval.pro	2018-05-17 13:52:34.000000000 +0200
--- src/proto/ex_eval.pro	2019-01-13 22:53:40.539908765 +0100
***************
*** 7,13 ****
  void free_global_msglist(void);
  void do_errthrow(struct condstack *cstack, char_u *cmdname);
  int do_intthrow(struct condstack *cstack);
! char_u *get_exception_string(void *value, except_type_T type, char_u *cmdname, int *should_free);
  void discard_current_exception(void);
  void report_make_pending(int pending, void *value);
  void report_resume_pending(int pending, void *value);
--- 7,13 ----
  void free_global_msglist(void);
  void do_errthrow(struct condstack *cstack, char_u *cmdname);
  int do_intthrow(struct condstack *cstack);
! char *get_exception_string(void *value, except_type_T type, char_u *cmdname, int *should_free);
  void discard_current_exception(void);
  void report_make_pending(int pending, void *value);
  void report_resume_pending(int pending, void *value);
*** ../vim-8.1.0742/src/proto/ex_getln.pro	2018-12-18 21:56:25.084495836 +0100
--- src/proto/ex_getln.pro	2019-01-13 22:59:13.405579368 +0100
***************
*** 4,10 ****
  char_u *getcmdline_prompt(int firstc, char_u *prompt, int attr, int xp_context, char_u *xp_arg);
  int text_locked(void);
  void text_locked_msg(void);
! char_u *get_text_locked_msg(void);
  int curbuf_locked(void);
  int allbuf_locked(void);
  char_u *getexline(int c, void *cookie, int indent);
--- 4,10 ----
  char_u *getcmdline_prompt(int firstc, char_u *prompt, int attr, int xp_context, char_u *xp_arg);
  int text_locked(void);
  void text_locked_msg(void);
! char *get_text_locked_msg(void);
  int curbuf_locked(void);
  int allbuf_locked(void);
  char_u *getexline(int c, void *cookie, int indent);
*** ../vim-8.1.0742/src/proto/hardcopy.pro	2018-09-13 17:26:31.091401618 +0200
--- src/proto/hardcopy.pro	2019-01-13 20:18:29.391424616 +0100
***************
*** 1,6 ****
  /* hardcopy.c */
! char_u *parse_printoptions(void);
! char_u *parse_printmbfont(void);
  int prt_header_height(void);
  int prt_use_number(void);
  int prt_get_unit(int idx);
--- 1,6 ----
  /* hardcopy.c */
! char *parse_printoptions(void);
! char *parse_printmbfont(void);
  int prt_header_height(void);
  int prt_use_number(void);
  int prt_get_unit(int idx);
*** ../vim-8.1.0742/src/proto/mbyte.pro	2018-05-17 13:52:43.000000000 +0200
--- src/proto/mbyte.pro	2019-01-13 20:12:33.254203719 +0100
***************
*** 1,6 ****
  /* mbyte.c */
  int enc_canon_props(char_u *name);
! char_u *mb_init(void);
  int bomb_size(void);
  void remove_bom(char_u *s);
  int mb_get_class(char_u *p);
--- 1,6 ----
  /* mbyte.c */
  int enc_canon_props(char_u *name);
! char *mb_init(void);
  int bomb_size(void);
  void remove_bom(char_u *s);
  int mb_get_class(char_u *p);
*** ../vim-8.1.0742/src/proto/message.pro	2018-05-17 13:52:45.000000000 +0200
--- src/proto/message.pro	2019-01-13 19:44:21.016778813 +0100
***************
*** 10,22 ****
  int emsg_not_now(void);
  void ignore_error_for_testing(char_u *error);
  void do_perror(char *msg);
! int emsg(char_u *s);
! int emsg2(char_u *s, char_u *a1);
! int emsg3(char_u *s, char_u *a1, char_u *a2);
! int emsgn(char_u *s, long n);
! void iemsg(char_u *s);
! void iemsg2(char_u *s, char_u *a1);
! void iemsgn(char_u *s, long n);
  void internal_error(char *where);
  void emsg_invreg(int name);
  char_u *msg_trunc_attr(char_u *s, int force, int attr);
--- 10,19 ----
  int emsg_not_now(void);
  void ignore_error_for_testing(char_u *error);
  void do_perror(char *msg);
! int emsg(char *s);
! int semsg(const char *s, ...);
! void iemsg(char *s);
! void siemsg(const char *s, ...);
  void internal_error(char *where);
  void emsg_invreg(int name);
  char_u *msg_trunc_attr(char_u *s, int force, int attr);
*** ../vim-8.1.0742/src/proto/misc2.pro	2019-01-11 16:15:57.891171040 +0100
--- src/proto/misc2.pro	2019-01-13 20:17:06.076073097 +0100
***************
*** 87,93 ****
  int same_directory(char_u *f1, char_u *f2);
  int vim_chdirfile(char_u *fname, char *trigger_autocmd);
  int vim_stat(const char *name, stat_T *stp);
! char_u *parse_shape_opt(int what);
  int get_shape_idx(int mouse);
  void update_mouseshape(int shape_idx);
  void *vim_findfile_init(char_u *path, char_u *filename, char_u *stopdirs, int level, int free_visited, int find_what, void *search_ctx_arg, int tagfile, char_u *rel_fname);
--- 87,93 ----
  int same_directory(char_u *f1, char_u *f2);
  int vim_chdirfile(char_u *fname, char *trigger_autocmd);
  int vim_stat(const char *name, stat_T *stp);
! char *parse_shape_opt(int what);
  int get_shape_idx(int mouse);
  void update_mouseshape(int shape_idx);
  void *vim_findfile_init(char_u *path, char_u *filename, char_u *stopdirs, int level, int free_visited, int find_what, void *search_ctx_arg, int tagfile, char_u *rel_fname);
*** ../vim-8.1.0742/src/proto/option.pro	2018-11-22 03:07:30.948596188 +0100
--- src/proto/option.pro	2019-01-13 23:05:48.282800884 +0100
***************
*** 21,33 ****
  int set_term_option_alloced(char_u **p);
  int was_set_insecurely(char_u *opt, int opt_flags);
  void set_string_option_direct(char_u *name, int opt_idx, char_u *val, int opt_flags, int set_sid);
! char_u *check_colorcolumn(win_T *wp);
! char_u *check_stl_option(char_u *s);
  void set_term_option_sctx_idx(char *name, int opt_idx);
  int get_option_value(char_u *name, long *numval, char_u **stringval, int opt_flags);
  int get_option_value_strict(char_u *name, long *numval, char_u **stringval, int opt_type, void *from);
  char_u *option_iter_next(void **option, int opt_type);
! char_u *set_option_value(char_u *name, long number, char_u *string, int opt_flags);
  char_u *get_term_code(char_u *tname);
  char_u *get_highlight_default(void);
  char_u *get_encoding_default(void);
--- 21,33 ----
  int set_term_option_alloced(char_u **p);
  int was_set_insecurely(char_u *opt, int opt_flags);
  void set_string_option_direct(char_u *name, int opt_idx, char_u *val, int opt_flags, int set_sid);
! char *check_colorcolumn(win_T *wp);
! char *check_stl_option(char_u *s);
  void set_term_option_sctx_idx(char *name, int opt_idx);
  int get_option_value(char_u *name, long *numval, char_u **stringval, int opt_flags);
  int get_option_value_strict(char_u *name, long *numval, char_u **stringval, int opt_type, void *from);
  char_u *option_iter_next(void **option, int opt_type);
! char *set_option_value(char_u *name, long number, char_u *string, int opt_flags);
  char_u *get_term_code(char_u *tname);
  char_u *get_highlight_default(void);
  char_u *get_encoding_default(void);
*** ../vim-8.1.0742/src/proto/spell.pro	2018-05-17 13:52:51.000000000 +0200
--- src/proto/spell.pro	2019-01-13 23:02:21.472273624 +0100
***************
*** 10,16 ****
  void count_common_word(slang_T *lp, char_u *word, int len, int count);
  int byte_in_str(char_u *str, int n);
  int init_syl_tab(slang_T *slang);
! char_u *did_set_spelllang(win_T *wp);
  int captype(char_u *word, char_u *end);
  void spell_delete_wordlist(void);
  void spell_free_all(void);
--- 10,16 ----
  void count_common_word(slang_T *lp, char_u *word, int len, int count);
  int byte_in_str(char_u *str, int n);
  int init_syl_tab(slang_T *slang);
! char *did_set_spelllang(win_T *wp);
  int captype(char_u *word, char_u *end);
  void spell_delete_wordlist(void);
  void spell_free_all(void);
*** ../vim-8.1.0742/src/quickfix.c	2019-01-11 14:49:25.380107431 +0100
--- src/quickfix.c	2019-01-13 23:12:52.299190164 +0100
***************
*** 239,255 ****
  	char_u	*regpat,
  	efm_T	*efminfo,
  	int	idx,
! 	int	round,
! 	char_u	*errmsg)
  {
      char_u	*srcptr;
  
      if (efminfo->addr[idx])
      {
  	// Each errorformat pattern can occur only once
! 	sprintf((char *)errmsg,
! 		_("E372: Too many %%%c in format string"), *efmpat);
! 	EMSG(errmsg);
  	return NULL;
      }
      if ((idx && idx < 6
--- 239,252 ----
  	char_u	*regpat,
  	efm_T	*efminfo,
  	int	idx,
! 	int	round)
  {
      char_u	*srcptr;
  
      if (efminfo->addr[idx])
      {
  	// Each errorformat pattern can occur only once
! 	semsg(_("E372: Too many %%%c in format string"), *efmpat);
  	return NULL;
      }
      if ((idx && idx < 6
***************
*** 257,265 ****
  	    || (idx == 6
  		&& vim_strchr((char_u *)"OPQ", efminfo->prefix) == NULL))
      {
! 	sprintf((char *)errmsg,
! 		_("E373: Unexpected %%%c in format string"), *efmpat);
! 	EMSG(errmsg);
  	return NULL;
      }
      efminfo->addr[idx] = (char_u)++round;
--- 254,260 ----
  	    || (idx == 6
  		&& vim_strchr((char_u *)"OPQ", efminfo->prefix) == NULL))
      {
! 	semsg(_("E373: Unexpected %%%c in format string"), *efmpat);
  	return NULL;
      }
      efminfo->addr[idx] = (char_u)++round;
***************
*** 316,323 ****
  	char_u	**pefmp,
  	char_u	*efm,
  	int	len,
! 	char_u	*regpat,
! 	char_u	*errmsg)
  {
      char_u	*efmp = *pefmp;
  
--- 311,317 ----
  	char_u	**pefmp,
  	char_u	*efm,
  	int	len,
! 	char_u	*regpat)
  {
      char_u	*efmp = *pefmp;
  
***************
*** 335,341 ****
  		    // skip ;
  		if (efmp == efm + len)
  		{
! 		    EMSG(_("E374: Missing ] in format string"));
  		    return NULL;
  		}
  	    }
--- 329,335 ----
  		    // skip ;
  		if (efmp == efm + len)
  		{
! 		    emsg(_("E374: Missing ] in format string"));
  		    return NULL;
  		}
  	    }
***************
*** 348,356 ****
      else
      {
  	// TODO: scanf()-like: %*ud, %*3c, %*f, ... ?
! 	sprintf((char *)errmsg,
! 		_("E375: Unsupported %%%c in format string"), *efmp);
! 	EMSG(errmsg);
  	return NULL;
      }
  
--- 342,348 ----
      else
      {
  	// TODO: scanf()-like: %*ud, %*3c, %*f, ... ?
! 	semsg(_("E375: Unsupported %%%c in format string"), *efmp);
  	return NULL;
      }
  
***************
*** 363,369 ****
   * Analyze/parse an errorformat prefix.
   */
      static char_u *
! efm_analyze_prefix(char_u *efmp, efm_T *efminfo, char_u *errmsg)
  {
      if (vim_strchr((char_u *)"+-", *efmp) != NULL)
  	efminfo->flags = *efmp++;
--- 355,361 ----
   * Analyze/parse an errorformat prefix.
   */
      static char_u *
! efm_analyze_prefix(char_u *efmp, efm_T *efminfo)
  {
      if (vim_strchr((char_u *)"+-", *efmp) != NULL)
  	efminfo->flags = *efmp++;
***************
*** 371,379 ****
  	efminfo->prefix = *efmp;
      else
      {
! 	sprintf((char *)errmsg,
! 		_("E376: Invalid %%%c in format string prefix"), *efmp);
! 	EMSG(errmsg);
  	return NULL;
      }
  
--- 363,369 ----
  	efminfo->prefix = *efmp;
      else
      {
! 	semsg(_("E376: Invalid %%%c in format string prefix"), *efmp);
  	return NULL;
      }
  
***************
*** 391,398 ****
  	char_u	*efm,
  	int	len,
  	efm_T	*fmt_ptr,
! 	char_u	*regpat,
! 	char_u	*errmsg)
  {
      char_u	*ptr;
      char_u	*efmp;
--- 381,387 ----
  	char_u	*efm,
  	int	len,
  	efm_T	*fmt_ptr,
! 	char_u	*regpat)
  {
      char_u	*ptr;
      char_u	*efmp;
***************
*** 413,420 ****
  		    break;
  	    if (idx < FMT_PATTERNS)
  	    {
! 		ptr = efmpat_to_regpat(efmp, ptr, fmt_ptr, idx, round,
! 								errmsg);
  		if (ptr == NULL)
  		    return FAIL;
  		round++;
--- 402,408 ----
  		    break;
  	    if (idx < FMT_PATTERNS)
  	    {
! 		ptr = efmpat_to_regpat(efmp, ptr, fmt_ptr, idx, round);
  		if (ptr == NULL)
  		    return FAIL;
  		round++;
***************
*** 422,428 ****
  	    else if (*efmp == '*')
  	    {
  		++efmp;
! 		ptr = scanf_fmt_to_regpat(&efmp, efm, len, ptr, errmsg);
  		if (ptr == NULL)
  		    return FAIL;
  	    }
--- 410,416 ----
  	    else if (*efmp == '*')
  	    {
  		++efmp;
! 		ptr = scanf_fmt_to_regpat(&efmp, efm, len, ptr);
  		if (ptr == NULL)
  		    return FAIL;
  	    }
***************
*** 436,450 ****
  	    {
  		// prefix is allowed only at the beginning of the errorformat
  		// option part
! 		efmp = efm_analyze_prefix(efmp, fmt_ptr, errmsg);
  		if (efmp == NULL)
  		    return FAIL;
  	    }
  	    else
  	    {
! 		sprintf((char *)errmsg,
! 			_("E377: Invalid %%%c in format string"), *efmp);
! 		EMSG(errmsg);
  		return FAIL;
  	    }
  	}
--- 424,436 ----
  	    {
  		// prefix is allowed only at the beginning of the errorformat
  		// option part
! 		efmp = efm_analyze_prefix(efmp, fmt_ptr);
  		if (efmp == NULL)
  		    return FAIL;
  	    }
  	    else
  	    {
! 		semsg(_("E377: Invalid %%%c in format string"), *efmp);
  		return FAIL;
  	    }
  	}
***************
*** 526,533 ****
      static efm_T *
  parse_efm_option(char_u *efm)
  {
-     char_u	*errmsg = NULL;
-     int		errmsglen;
      efm_T	*fmt_ptr = NULL;
      efm_T	*fmt_first = NULL;
      efm_T	*fmt_last = NULL;
--- 512,517 ----
***************
*** 535,545 ****
      int		len;
      int		sz;
  
-     errmsglen = CMDBUFFSIZE + 1;
-     errmsg = alloc_id(errmsglen, aid_qf_errmsg);
-     if (errmsg == NULL)
- 	goto parse_efm_end;
- 
      // Each part of the format string is copied and modified from errorformat
      // to regex prog.  Only a few % characters are allowed.
  
--- 519,524 ----
***************
*** 563,569 ****
  	// Isolate one part in the 'errorformat' option
  	len = efm_option_part_len(efm);
  
! 	if (efm_to_regpat(efm, len, fmt_ptr, fmtstr, errmsg) == FAIL)
  	    goto parse_efm_error;
  	if ((fmt_ptr->prog = vim_regcomp(fmtstr, RE_MAGIC + RE_STRING)) == NULL)
  	    goto parse_efm_error;
--- 542,548 ----
  	// Isolate one part in the 'errorformat' option
  	len = efm_option_part_len(efm);
  
! 	if (efm_to_regpat(efm, len, fmt_ptr, fmtstr) == FAIL)
  	    goto parse_efm_error;
  	if ((fmt_ptr->prog = vim_regcomp(fmtstr, RE_MAGIC + RE_STRING)) == NULL)
  	    goto parse_efm_error;
***************
*** 572,578 ****
      }
  
      if (fmt_first == NULL)	// nothing found
! 	EMSG(_("E378: 'errorformat' contains no pattern"));
  
      goto parse_efm_end;
  
--- 551,557 ----
      }
  
      if (fmt_first == NULL)	// nothing found
! 	emsg(_("E378: 'errorformat' contains no pattern"));
  
      goto parse_efm_end;
  
***************
*** 581,587 ****
  
  parse_efm_end:
      vim_free(fmtstr);
-     vim_free(errmsg);
  
      return fmt_first;
  }
--- 560,565 ----
***************
*** 1271,1277 ****
      {
  	if (*fields->namebuf == NUL)
  	{
! 	    EMSG(_("E379: Missing or empty directory name"));
  	    return QF_FAIL;
  	}
  	qfl->qf_directory =
--- 1249,1255 ----
      {
  	if (*fields->namebuf == NUL)
  	{
! 	    emsg(_("E379: Missing or empty directory name"));
  	    return QF_FAIL;
  	}
  	qfl->qf_directory =
***************
*** 1568,1574 ****
  
      if (efile != NULL && (pstate->fd = mch_fopen((char *)efile, "r")) == NULL)
      {
! 	EMSG2(_(e_openerrf), efile);
  	return FAIL;
      }
  
--- 1546,1552 ----
  
      if (efile != NULL && (pstate->fd = mch_fopen((char *)efile, "r")) == NULL)
      {
! 	semsg(_(e_openerrf), efile);
  	return FAIL;
      }
  
***************
*** 1751,1757 ****
  	retval = qfl->qf_count;
  	goto qf_init_end;
      }
!     EMSG(_(e_readerrf));
  error2:
      if (!adding)
      {
--- 1729,1735 ----
  	retval = qfl->qf_count;
  	goto qf_init_end;
      }
!     emsg(_(e_readerrf));
  error2:
      if (!adding)
      {
***************
*** 1968,1974 ****
  #ifdef ABORT_ON_INTERNAL_ERROR
      if (quickfix_busy < 0)
      {
! 	EMSG("quickfix_busy has become negative");
  	abort();
      }
  #endif
--- 1946,1952 ----
  #ifdef ABORT_ON_INTERNAL_ERROR
      if (quickfix_busy < 0)
      {
! 	emsg("quickfix_busy has become negative");
  	abort();
      }
  #endif
***************
*** 1980,1986 ****
  {
      if (quickfix_busy != 0)
      {
! 	EMSGN("quickfix_busy not zero on exit: %ld", (long)quickfix_busy);
  # ifdef ABORT_ON_INTERNAL_ERROR
  	abort();
  # endif
--- 1958,1964 ----
  {
      if (quickfix_busy != 0)
      {
! 	semsg("quickfix_busy not zero on exit: %ld", (long)quickfix_busy);
  # ifdef ABORT_ON_INTERNAL_ERROR
  	abort();
  # endif
***************
*** 2635,2641 ****
  	    qf_idx = prev_index;
  	    if (err != NULL)
  	    {
! 		EMSG(_(err));
  		return NULL;
  	    }
  	    break;
--- 2613,2619 ----
  	    qf_idx = prev_index;
  	    if (err != NULL)
  	    {
! 		emsg(_(err));
  		return NULL;
  	    }
  	    break;
***************
*** 3041,3054 ****
      // present.
      if (qfl_type == QFLT_LOCATION && !win_valid_any_tab(oldwin))
      {
! 	EMSG(_("E924: Current window was closed"));
  	*opened_window = FALSE;
  	return NOTDONE;
      }
  
      if (qfl_type == QFLT_QUICKFIX && !qflist_valid(NULL, save_qfid))
      {
! 	EMSG(_("E925: Current quickfix was changed"));
  	return NOTDONE;
      }
  
--- 3019,3032 ----
      // present.
      if (qfl_type == QFLT_LOCATION && !win_valid_any_tab(oldwin))
      {
! 	emsg(_("E924: Current window was closed"));
  	*opened_window = FALSE;
  	return NOTDONE;
      }
  
      if (qfl_type == QFLT_QUICKFIX && !qflist_valid(NULL, save_qfid))
      {
! 	emsg(_("E925: Current quickfix was changed"));
  	return NOTDONE;
      }
  
***************
*** 3056,3064 ****
  	    || !is_qf_entry_present(qfl, qf_ptr))
      {
  	if (qfl_type == QFLT_QUICKFIX)
! 	    EMSG(_("E925: Current quickfix was changed"));
  	else
! 	    EMSG(_(e_loc_list_changed));
  	return NOTDONE;
      }
  
--- 3034,3042 ----
  	    || !is_qf_entry_present(qfl, qf_ptr))
      {
  	if (qfl_type == QFLT_QUICKFIX)
! 	    emsg(_("E925: Current quickfix was changed"));
  	else
! 	    emsg(_(e_loc_list_changed));
  	return NOTDONE;
      }
  
***************
*** 3315,3321 ****
  
      if (qf_stack_empty(qi) || qf_list_empty(qi, qi->qf_curlist))
      {
! 	EMSG(_(e_quickfix));
  	return;
      }
  
--- 3293,3299 ----
  
      if (qf_stack_empty(qi) || qf_list_empty(qi, qi->qf_curlist))
      {
! 	emsg(_(e_quickfix));
  	return;
      }
  
***************
*** 3497,3510 ****
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	{
! 	    EMSG(_(e_loclist));
  	    return;
  	}
      }
  
      if (qf_stack_empty(qi) || qf_list_empty(qi, qi->qf_curlist))
      {
! 	EMSG(_(e_quickfix));
  	return;
      }
      if (*arg == '+')
--- 3475,3488 ----
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	{
! 	    emsg(_(e_loclist));
  	    return;
  	}
      }
  
      if (qf_stack_empty(qi) || qf_list_empty(qi, qi->qf_curlist))
      {
! 	emsg(_(e_quickfix));
  	return;
      }
      if (*arg == '+')
***************
*** 3514,3520 ****
      }
      if (!get_list_range(&arg, &idx1, &idx2) || *arg != NUL)
      {
! 	EMSG(_(e_trailing));
  	return;
      }
      qfl = &qi->qf_lists[qi->qf_curlist];
--- 3492,3498 ----
      }
      if (!get_list_range(&arg, &idx1, &idx2) || *arg != NUL)
      {
! 	emsg(_(e_trailing));
  	return;
      }
      qfl = &qi->qf_lists[qi->qf_curlist];
***************
*** 3643,3649 ****
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	{
! 	    EMSG(_(e_loclist));
  	    return;
  	}
      }
--- 3621,3627 ----
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	{
! 	    emsg(_(e_loclist));
  	    return;
  	}
      }
***************
*** 3658,3664 ****
  	{
  	    if (qi->qf_curlist == 0)
  	    {
! 		EMSG(_("E380: At bottom of quickfix stack"));
  		break;
  	    }
  	    --qi->qf_curlist;
--- 3636,3642 ----
  	{
  	    if (qi->qf_curlist == 0)
  	    {
! 		emsg(_("E380: At bottom of quickfix stack"));
  		break;
  	    }
  	    --qi->qf_curlist;
***************
*** 3667,3673 ****
  	{
  	    if (qi->qf_curlist >= qi->qf_listcount - 1)
  	    {
! 		EMSG(_("E381: At top of quickfix stack"));
  		break;
  	    }
  	    ++qi->qf_curlist;
--- 3645,3651 ----
  	{
  	    if (qi->qf_curlist >= qi->qf_listcount - 1)
  	    {
! 		emsg(_("E381: At top of quickfix stack"));
  		break;
  	    }
  	    ++qi->qf_curlist;
***************
*** 3870,3876 ****
  
      if (qf_list_empty(qi, qi->qf_curlist))
      {
! 	EMSG(_(e_quickfix));
  	return;
      }
  
--- 3848,3854 ----
  
      if (qf_list_empty(qi, qi->qf_curlist))
      {
! 	emsg(_(e_quickfix));
  	return;
      }
  
***************
*** 4081,4087 ****
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	{
! 	    EMSG(_(e_loclist));
  	    return;
  	}
      }
--- 4059,4065 ----
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	{
! 	    emsg(_(e_loclist));
  	    return;
  	}
      }
***************
*** 4163,4169 ****
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	{
! 	    EMSG(_(e_loclist));
  	    return;
  	}
      }
--- 4141,4147 ----
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	{
! 	    emsg(_(e_loclist));
  	    return;
  	}
      }
***************
*** 4609,4615 ****
      {
  	name = vim_tempname('e', FALSE);
  	if (name == NULL)
! 	    EMSG(_(e_notmp));
  	return name;
      }
  
--- 4587,4593 ----
      {
  	name = vim_tempname('e', FALSE);
  	if (name == NULL)
! 	    emsg(_(e_notmp));
  	return name;
      }
  
***************
*** 4941,4947 ****
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	{
! 	    EMSG(_(e_loclist));
  	    return;
  	}
      }
--- 4919,4925 ----
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	{
! 	    emsg(_(e_loclist));
  	    return;
  	}
      }
***************
*** 4992,4998 ****
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	{
! 	    EMSG(_(e_loclist));
  	    return;
  	}
      }
--- 4970,4976 ----
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	{
! 	    emsg(_(e_loclist));
  	    return;
  	}
      }
***************
*** 5148,5154 ****
  	// Pattern is empty, use last search pattern.
  	if (last_search_pat() == NULL)
  	{
! 	    EMSG(_(e_noprevre));
  	    return;
  	}
  	regmatch->regprog = vim_regcomp(last_search_pat(), RE_MAGIC);
--- 5126,5132 ----
  	// Pattern is empty, use last search pattern.
  	if (last_search_pat() == NULL)
  	{
! 	    emsg(_(e_noprevre));
  	    return;
  	}
  	regmatch->regprog = vim_regcomp(last_search_pat(), RE_MAGIC);
***************
*** 5238,5244 ****
  	if (wp != NULL)
  	{
  	    // An autocmd has freed the location list.
! 	    EMSG(_(e_loc_list_changed));
  	    return FALSE;
  	}
  	else
--- 5216,5222 ----
  	if (wp != NULL)
  	{
  	    // An autocmd has freed the location list.
! 	    emsg(_(e_loc_list_changed));
  	    return FALSE;
  	}
  	else
***************
*** 5417,5423 ****
      p = skip_vimgrep_pat(eap->arg, &s, &flags);
      if (p == NULL)
      {
! 	EMSG(_(e_invalpat));
  	goto theend;
      }
  
--- 5395,5401 ----
      p = skip_vimgrep_pat(eap->arg, &s, &flags);
      if (p == NULL)
      {
! 	emsg(_(e_invalpat));
  	goto theend;
      }
  
***************
*** 5428,5434 ****
      p = skipwhite(p);
      if (*p == NUL)
      {
! 	EMSG(_("E683: File name missing or invalid pattern"));
  	goto theend;
      }
  
--- 5406,5412 ----
      p = skipwhite(p);
      if (*p == NUL)
      {
! 	emsg(_("E683: File name missing or invalid pattern"));
  	goto theend;
      }
  
***************
*** 5444,5450 ****
  	goto theend;
      if (fcount == 0)
      {
! 	EMSG(_(e_nomatch));
  	goto theend;
      }
  
--- 5422,5428 ----
  	goto theend;
      if (fcount == 0)
      {
! 	emsg(_(e_nomatch));
  	goto theend;
      }
  
***************
*** 5505,5511 ****
  	if (buf == NULL)
  	{
  	    if (!got_int)
! 		smsg((char_u *)_("Cannot open file \"%s\""), fname);
  	}
  	else
  	{
--- 5483,5489 ----
  	if (buf == NULL)
  	{
  	    if (!got_int)
! 		smsg(_("Cannot open file \"%s\""), fname);
  	}
  	else
  	{
***************
*** 5608,5614 ****
  		    first_match_buf, target_dir);
      }
      else
! 	EMSG2(_(e_nomatch2), s);
  
      decr_quickfix_busy();
  
--- 5586,5592 ----
  		    first_match_buf, target_dir);
      }
      else
! 	semsg(_(e_nomatch2), s);
  
      decr_quickfix_busy();
  
***************
*** 6285,6291 ****
  	if (!did_bufnr_emsg)
  	{
  	    did_bufnr_emsg = TRUE;
! 	    EMSGN(_("E92: Buffer %ld not found"), bufnum);
  	}
  	valid = FALSE;
  	bufnum = 0;
--- 6263,6269 ----
  	if (!did_bufnr_emsg)
  	{
  	    did_bufnr_emsg = TRUE;
! 	    semsg(_("E92: Buffer %ld not found"), bufnum);
  	}
  	valid = FALSE;
  	bufnum = 0;
***************
*** 6864,6872 ****
      else if (*skipwhite(skipdigits(eap->arg)) == NUL)
  	buf = buflist_findnr(atoi((char *)eap->arg));
      if (buf == NULL)
! 	EMSG(_(e_invarg));
      else if (buf->b_ml.ml_mfp == NULL)
! 	EMSG(_("E681: Buffer is not loaded"));
      else
      {
  	if (eap->addr_count == 0)
--- 6842,6850 ----
      else if (*skipwhite(skipdigits(eap->arg)) == NUL)
  	buf = buflist_findnr(atoi((char *)eap->arg));
      if (buf == NULL)
! 	emsg(_(e_invarg));
      else if (buf->b_ml.ml_mfp == NULL)
! 	emsg(_("E681: Buffer is not loaded"));
      else
      {
  	if (eap->addr_count == 0)
***************
*** 6876,6882 ****
  	}
  	if (eap->line1 < 1 || eap->line1 > buf->b_ml.ml_line_count
  		|| eap->line2 < 1 || eap->line2 > buf->b_ml.ml_line_count)
! 	    EMSG(_(e_invrange));
  	else
  	{
  	    char_u *qf_title = qf_cmdtitle(*eap->cmdlinep);
--- 6854,6860 ----
  	}
  	if (eap->line1 < 1 || eap->line1 > buf->b_ml.ml_line_count
  		|| eap->line2 < 1 || eap->line2 > buf->b_ml.ml_line_count)
! 	    emsg(_(e_invrange));
  	else
  	{
  	    char_u *qf_title = qf_cmdtitle(*eap->cmdlinep);
***************
*** 7011,7017 ****
  	    decr_quickfix_busy();
  	}
  	else
! 	    EMSG(_("E777: String or List expected"));
  cleanup:
  	free_tv(tv);
      }
--- 6989,6995 ----
  	    decr_quickfix_busy();
  	}
  	else
! 	    emsg(_("E777: String or List expected"));
  cleanup:
  	free_tv(tv);
      }
***************
*** 7310,7316 ****
      if (!qf_list_empty(qi, qi->qf_curlist))
  	qf_jump(qi, 0, 0, FALSE);
      else
! 	EMSG2(_(e_nomatch2), eap->arg);
  
      decr_quickfix_busy();
  
--- 7288,7294 ----
      if (!qf_list_empty(qi, qi->qf_curlist))
  	qf_jump(qi, 0, 0, FALSE);
      else
! 	semsg(_(e_nomatch2), eap->arg);
  
      decr_quickfix_busy();
  
*** ../vim-8.1.0742/src/regexp.c	2019-01-01 22:18:59.808136916 +0100
--- src/regexp.c	2019-01-13 23:14:56.250208631 +0100
***************
*** 334,344 ****
  
  /* Used for an error (down from) vim_regcomp(): give the error message, set
   * rc_did_emsg and return NULL */
! #define EMSG_RET_NULL(m) return (EMSG(m), rc_did_emsg = TRUE, (void *)NULL)
! #define IEMSG_RET_NULL(m) return (IEMSG(m), rc_did_emsg = TRUE, (void *)NULL)
! #define EMSG_RET_FAIL(m) return (EMSG(m), rc_did_emsg = TRUE, FAIL)
! #define EMSG2_RET_NULL(m, c) return (EMSG2((m), (c) ? "" : "\\"), rc_did_emsg = TRUE, (void *)NULL)
! #define EMSG2_RET_FAIL(m, c) return (EMSG2((m), (c) ? "" : "\\"), rc_did_emsg = TRUE, FAIL)
  #define EMSG_ONE_RET_NULL EMSG2_RET_NULL(_("E369: invalid item in %s%%[]"), reg_magic == MAGIC_ALL)
  
  
--- 334,344 ----
  
  /* Used for an error (down from) vim_regcomp(): give the error message, set
   * rc_did_emsg and return NULL */
! #define EMSG_RET_NULL(m) return (emsg((m)), rc_did_emsg = TRUE, (void *)NULL)
! #define IEMSG_RET_NULL(m) return (iemsg((m)), rc_did_emsg = TRUE, (void *)NULL)
! #define EMSG_RET_FAIL(m) return (emsg((m)), rc_did_emsg = TRUE, FAIL)
! #define EMSG2_RET_NULL(m, c) return (semsg((const char *)(m), (c) ? "" : "\\"), rc_did_emsg = TRUE, (void *)NULL)
! #define EMSG2_RET_FAIL(m, c) return (semsg((const char *)(m), (c) ? "" : "\\"), rc_did_emsg = TRUE, FAIL)
  #define EMSG_ONE_RET_NULL EMSG2_RET_NULL(_("E369: invalid item in %s%%[]"), reg_magic == MAGIC_ALL)
  
  
***************
*** 1304,1310 ****
  		break;
  	if (*p == NUL)
  	{
! 	    EMSG(_("E65: Illegal back reference"));
  	    rc_did_emsg = TRUE;
  	    return FALSE;
  	}
--- 1304,1310 ----
  		break;
  	if (*p == NUL)
  	{
! 	    emsg(_("E65: Illegal back reference"));
  	    rc_did_emsg = TRUE;
  	    return FALSE;
  	}
***************
*** 1902,1908 ****
  	else
  	    sprintf((char *)IObuff, _("E62: Nested %s%c"),
  		reg_magic == MAGIC_ALL ? "" : "\\", no_Magic(peekchr()));
! 	EMSG_RET_NULL(IObuff);
      }
  
      return ret;
--- 1902,1908 ----
  	else
  	    sprintf((char *)IObuff, _("E62: Nested %s%c"),
  		reg_magic == MAGIC_ALL ? "" : "\\", no_Magic(peekchr()));
! 	EMSG_RET_NULL((char *)IObuff);
      }
  
      return ret;
***************
*** 2078,2084 ****
  	sprintf((char *)IObuff, _("E64: %s%c follows nothing"),
  		(c == '*' ? reg_magic >= MAGIC_ON : reg_magic == MAGIC_ALL)
  		? "" : "\\", c);
! 	EMSG_RET_NULL(IObuff);
  	/* NOTREACHED */
  
        case Magic('~'):		/* previous substitute pattern */
--- 2078,2084 ----
  	sprintf((char *)IObuff, _("E64: %s%c follows nothing"),
  		(c == '*' ? reg_magic >= MAGIC_ON : reg_magic == MAGIC_ALL)
  		? "" : "\\", c);
! 	EMSG_RET_NULL((char *)IObuff);
  	/* NOTREACHED */
  
        case Magic('~'):		/* previous substitute pattern */
***************
*** 3406,3412 ****
      {
  	sprintf((char *)IObuff, _("E554: Syntax error in %s{...}"),
  					  reg_magic == MAGIC_ALL ? "" : "\\");
! 	EMSG_RET_FAIL(IObuff);
      }
  
      /*
--- 3406,3412 ----
      {
  	sprintf((char *)IObuff, _("E554: Syntax error in %s{...}"),
  					  reg_magic == MAGIC_ALL ? "" : "\\");
! 	EMSG_RET_FAIL((char *)IObuff);
      }
  
      /*
***************
*** 3826,3832 ****
      /* Be paranoid... */
      if (prog == NULL || line == NULL)
      {
! 	EMSG(_(e_null));
  	goto theend;
      }
  
--- 3826,3832 ----
      /* Be paranoid... */
      if (prog == NULL || line == NULL)
      {
! 	emsg(_(e_null));
  	goto theend;
      }
  
***************
*** 5241,5247 ****
  		     * a regstar_T on the regstack. */
  		    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)
  		    {
! 			EMSG(_(e_maxmempat));
  			status = RA_FAIL;
  		    }
  		    else if (ga_grow(&regstack, sizeof(regstar_T)) == FAIL)
--- 5241,5247 ----
  		     * a regstar_T on the regstack. */
  		    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)
  		    {
! 			emsg(_(e_maxmempat));
  			status = RA_FAIL;
  		    }
  		    else if (ga_grow(&regstack, sizeof(regstar_T)) == FAIL)
***************
*** 5286,5292 ****
  	    /* Need a bit of room to store extra positions. */
  	    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)
  	    {
! 		EMSG(_(e_maxmempat));
  		status = RA_FAIL;
  	    }
  	    else if (ga_grow(&regstack, sizeof(regbehind_T)) == FAIL)
--- 5286,5292 ----
  	    /* Need a bit of room to store extra positions. */
  	    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)
  	    {
! 		emsg(_(e_maxmempat));
  		status = RA_FAIL;
  	    }
  	    else if (ga_grow(&regstack, sizeof(regbehind_T)) == FAIL)
***************
*** 5338,5344 ****
  	    break;
  
  	  default:
! 	    EMSG(_(e_re_corr));
  #ifdef DEBUG
  	    printf("Illegal op code %d\n", op);
  #endif
--- 5338,5344 ----
  	    break;
  
  	  default:
! 	    emsg(_(e_re_corr));
  #ifdef DEBUG
  	    printf("Illegal op code %d\n", op);
  #endif
***************
*** 5748,5754 ****
  	     * We get here only if there's trouble -- normally "case END" is
  	     * the terminating point.
  	     */
! 	    EMSG(_(e_re_corr));
  #ifdef DEBUG
  	    printf("Premature EOL\n");
  #endif
--- 5748,5754 ----
  	     * We get here only if there's trouble -- normally "case END" is
  	     * the terminating point.
  	     */
! 	    emsg(_(e_re_corr));
  #ifdef DEBUG
  	    printf("Premature EOL\n");
  #endif
***************
*** 5772,5778 ****
  
      if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)
      {
! 	EMSG(_(e_maxmempat));
  	return NULL;
      }
      if (ga_grow(&regstack, sizeof(regitem_T)) == FAIL)
--- 5772,5778 ----
  
      if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)
      {
! 	emsg(_(e_maxmempat));
  	return NULL;
      }
      if (ga_grow(&regstack, sizeof(regitem_T)) == FAIL)
***************
*** 6185,6191 ****
  	break;
  
        default:			/* Oh dear.  Called inappropriately. */
! 	EMSG(_(e_re_corr));
  #ifdef DEBUG
  	printf("Called regrepeat with op code %d\n", OP(p));
  #endif
--- 6185,6191 ----
  	break;
  
        default:			/* Oh dear.  Called inappropriately. */
! 	emsg(_(e_re_corr));
  #ifdef DEBUG
  	printf("Called regrepeat with op code %d\n", OP(p));
  #endif
***************
*** 6236,6242 ****
  
      if (UCHARAT(((bt_regprog_T *)prog)->program) != REGMAGIC)
      {
! 	EMSG(_(e_re_corr));
  	return TRUE;
      }
      return FALSE;
--- 6236,6242 ----
  
      if (UCHARAT(((bt_regprog_T *)prog)->program) != REGMAGIC)
      {
! 	emsg(_(e_re_corr));
  	return TRUE;
      }
      return FALSE;
***************
*** 7487,7493 ****
      /* Be paranoid... */
      if ((source == NULL && expr == NULL) || dest == NULL)
      {
! 	EMSG(_(e_null));
  	return 0;
      }
      if (prog_magic_wrong())
--- 7487,7493 ----
      /* Be paranoid... */
      if ((source == NULL && expr == NULL) || dest == NULL)
      {
! 	emsg(_(e_null));
  	return 0;
      }
      if (prog_magic_wrong())
***************
*** 7790,7796 ****
  		    else if (*s == NUL) /* we hit NUL. */
  		    {
  			if (copy)
! 			    EMSG(_(e_re_damg));
  			goto exit;
  		    }
  		    else
--- 7790,7796 ----
  		    else if (*s == NUL) /* we hit NUL. */
  		    {
  			if (copy)
! 			    emsg(_(e_re_damg));
  			goto exit;
  		    }
  		    else
***************
*** 8120,8132 ****
  	    regexp_engine = expr[4] - '0';
  	    expr += 5;
  #ifdef DEBUG
! 	    smsg((char_u *)"New regexp mode selected (%d): %s",
  					   regexp_engine, regname[newengine]);
  #endif
  	}
  	else
  	{
! 	    EMSG(_("E864: \\%#= can only be followed by 0, 1, or 2. The automatic engine will be used "));
  	    regexp_engine = AUTOMATIC_ENGINE;
  	}
      }
--- 8120,8132 ----
  	    regexp_engine = expr[4] - '0';
  	    expr += 5;
  #ifdef DEBUG
! 	    smsg("New regexp mode selected (%d): %s",
  					   regexp_engine, regname[newengine]);
  #endif
  	}
  	else
  	{
! 	    emsg(_("E864: \\%#= can only be followed by 0, 1, or 2. The automatic engine will be used "));
  	    regexp_engine = AUTOMATIC_ENGINE;
  	}
      }
***************
*** 8158,8164 ****
  		fclose(f);
  	    }
  	    else
! 		EMSG2("(NFA) Could not open \"%s\" to write !!!",
  			BT_REGEXP_DEBUG_LOG_NAME);
  	}
  #endif
--- 8158,8164 ----
  		fclose(f);
  	    }
  	    else
! 		semsg("(NFA) Could not open \"%s\" to write !!!",
  			BT_REGEXP_DEBUG_LOG_NAME);
  	}
  #endif
***************
*** 8241,8247 ****
      // Cannot use the same prog recursively, it contains state.
      if (rmp->regprog->re_in_use)
      {
! 	EMSG(_(e_recursive));
  	return FALSE;
      }
      rmp->regprog->re_in_use = TRUE;
--- 8241,8247 ----
      // Cannot use the same prog recursively, it contains state.
      if (rmp->regprog->re_in_use)
      {
! 	emsg(_(e_recursive));
  	return FALSE;
      }
      rmp->regprog->re_in_use = TRUE;
***************
*** 8365,8371 ****
      // Cannot use the same prog recursively, it contains state.
      if (rmp->regprog->re_in_use)
      {
! 	EMSG(_(e_recursive));
  	return FALSE;
      }
      rmp->regprog->re_in_use = TRUE;
--- 8365,8371 ----
      // Cannot use the same prog recursively, it contains state.
      if (rmp->regprog->re_in_use)
      {
! 	emsg(_(e_recursive));
  	return FALSE;
      }
      rmp->regprog->re_in_use = TRUE;
*** ../vim-8.1.0742/src/regexp_nfa.c	2018-12-26 22:04:35.494546386 +0100
--- src/regexp_nfa.c	2019-01-13 19:56:58.425721744 +0100
***************
*** 1303,1313 ****
  	    {
  		if (extra == NFA_ADD_NL)
  		{
! 		    EMSGN(_(e_ill_char_class), c);
  		    rc_did_emsg = TRUE;
  		    return FAIL;
  		}
! 		IEMSGN("INTERNAL: Unknown character class char: %ld", c);
  		return FAIL;
  	    }
  #ifdef FEAT_MBYTE
--- 1303,1313 ----
  	    {
  		if (extra == NFA_ADD_NL)
  		{
! 		    semsg(_(e_ill_char_class), c);
  		    rc_did_emsg = TRUE;
  		    return FAIL;
  		}
! 		siemsg("INTERNAL: Unknown character class char: %ld", c);
  		return FAIL;
  	    }
  #ifdef FEAT_MBYTE
***************
*** 1349,1355 ****
  	case Magic('|'):
  	case Magic('&'):
  	case Magic(')'):
! 	    EMSGN(_(e_misplaced), no_Magic(c));
  	    return FAIL;
  
  	case Magic('='):
--- 1349,1355 ----
  	case Magic('|'):
  	case Magic('&'):
  	case Magic(')'):
! 	    semsg(_(e_misplaced), no_Magic(c));
  	    return FAIL;
  
  	case Magic('='):
***************
*** 1359,1365 ****
  	case Magic('*'):
  	case Magic('{'):
  	    /* these should follow an atom, not form an atom */
! 	    EMSGN(_(e_misplaced), no_Magic(c));
  	    return FAIL;
  
  	case Magic('~'):
--- 1359,1365 ----
  	case Magic('*'):
  	case Magic('{'):
  	    /* these should follow an atom, not form an atom */
! 	    semsg(_(e_misplaced), no_Magic(c));
  	    return FAIL;
  
  	case Magic('~'):
***************
*** 1370,1376 ****
  		 * Generated as "\%(pattern\)". */
  		if (reg_prev_sub == NULL)
  		{
! 		    EMSG(_(e_nopresub));
  		    return FAIL;
  		}
  		for (lp = reg_prev_sub; *lp != NUL; MB_CPTR_ADV(lp))
--- 1370,1376 ----
  		 * Generated as "\%(pattern\)". */
  		if (reg_prev_sub == NULL)
  		{
! 		    emsg(_(e_nopresub));
  		    return FAIL;
  		}
  		for (lp = reg_prev_sub; *lp != NUL; MB_CPTR_ADV(lp))
***************
*** 1445,1451 ****
  		    break;
  #endif
  		default:
! 		    EMSGN(_("E867: (NFA) Unknown operator '\\z%c'"),
  								 no_Magic(c));
  		    return FAIL;
  	    }
--- 1445,1451 ----
  		    break;
  #endif
  		default:
! 		    semsg(_("E867: (NFA) Unknown operator '\\z%c'"),
  								 no_Magic(c));
  		    return FAIL;
  	    }
***************
*** 1577,1583 ****
  #if VIM_SIZEOF_INT < VIM_SIZEOF_LONG
  			    if (n > INT_MAX)
  			    {
! 				EMSG(_("E951: \\% value too large"));
  				return FAIL;
  			    }
  #endif
--- 1577,1583 ----
  #if VIM_SIZEOF_INT < VIM_SIZEOF_LONG
  			    if (n > INT_MAX)
  			    {
! 				emsg(_("E951: \\% value too large"));
  				return FAIL;
  			    }
  #endif
***************
*** 1593,1599 ****
  			    break;
  			}
  		    }
! 		    EMSGN(_("E867: (NFA) Unknown operator '\\%%%c'"),
  								 no_Magic(c));
  		    return FAIL;
  	    }
--- 1593,1599 ----
  			    break;
  			}
  		    }
! 		    semsg(_("E867: (NFA) Unknown operator '\\%%%c'"),
  								 no_Magic(c));
  		    return FAIL;
  	    }
***************
*** 2071,2077 ****
  	    }
  	    if (i == 0)
  	    {
! 		EMSGN(_("E869: (NFA) Unknown operator '\\@%c'"), op);
  		return FAIL;
  	    }
  	    EMIT(i);
--- 2071,2077 ----
  	    }
  	    if (i == 0)
  	    {
! 		semsg(_("E869: (NFA) Unknown operator '\\@%c'"), op);
  		return FAIL;
  	    }
  	    EMIT(i);
***************
*** 2928,2934 ****
  	fclose(df);
      }
  #endif
!     EMSG(_("E874: (NFA) Could not pop the stack!"));
  }
  
  /*
--- 2928,2934 ----
  	fclose(df);
      }
  #endif
!     emsg(_("E874: (NFA) Could not pop the stack!"));
  }
  
  /*
***************
*** 4877,4883 ****
  
  	default:
  	    /* should not be here :P */
! 	    IEMSGN(_(e_ill_char_class), class);
  	    return FAIL;
      }
      return FAIL;
--- 4877,4883 ----
  
  	default:
  	    /* should not be here :P */
! 	    siemsg(_(e_ill_char_class), class);
  	    return FAIL;
      }
      return FAIL;
***************
*** 5146,5152 ****
  	    *listids = (int *)lalloc(sizeof(int) * prog->nstate, TRUE);
  	    if (*listids == NULL)
  	    {
! 		EMSG(_("E878: (NFA) Could not allocate memory for branch traversal!"));
  		return 0;
  	    }
  	    *listids_len = prog->nstate;
--- 5146,5152 ----
  	    *listids = (int *)lalloc(sizeof(int) * prog->nstate, TRUE);
  	    if (*listids == NULL)
  	    {
! 		emsg(_("E878: (NFA) Could not allocate memory for branch traversal!"));
  		return 0;
  	    }
  	    *listids_len = prog->nstate;
***************
*** 5201,5207 ****
      }
      else
      {
! 	EMSG(_(e_log_open_failed));
  	log_fd = stderr;
      }
  #endif
--- 5201,5207 ----
      }
      else
      {
! 	emsg(_(e_log_open_failed));
  	log_fd = stderr;
      }
  #endif
***************
*** 5521,5527 ****
      debug = fopen(NFA_REGEXP_DEBUG_LOG, "a");
      if (debug == NULL)
      {
! 	EMSG2("(NFA) COULD NOT OPEN %s!", NFA_REGEXP_DEBUG_LOG);
  	return FALSE;
      }
  #endif
--- 5521,5527 ----
      debug = fopen(NFA_REGEXP_DEBUG_LOG, "a");
      if (debug == NULL)
      {
! 	semsg("(NFA) COULD NOT OPEN %s!", NFA_REGEXP_DEBUG_LOG);
  	return FALSE;
      }
  #endif
***************
*** 5549,5555 ****
      }
      else
      {
! 	EMSG(_(e_log_open_failed));
  	log_fd = stderr;
      }
  #endif
--- 5549,5555 ----
      }
      else
      {
! 	emsg(_(e_log_open_failed));
  	log_fd = stderr;
      }
  #endif
***************
*** 6670,6676 ****
  
  #ifdef DEBUG
  		if (c < 0)
! 		    IEMSGN("INTERNAL: Negative state char: %ld", c);
  #endif
  		result = (c == curc);
  
--- 6670,6676 ----
  
  #ifdef DEBUG
  		if (c < 0)
! 		    siemsg("INTERNAL: Negative state char: %ld", c);
  #endif
  		result = (c == curc);
  
***************
*** 6961,6967 ****
  	fclose(f);
      }
      else
! 	EMSG("Could not open temporary log file for writing");
  #endif
  
      clear_sub(&subs.norm);
--- 6961,6967 ----
  	fclose(f);
      }
      else
! 	emsg("Could not open temporary log file for writing");
  #endif
  
      clear_sub(&subs.norm);
***************
*** 7094,7100 ****
      /* Be paranoid... */
      if (prog == NULL || line == NULL)
      {
! 	EMSG(_(e_null));
  	goto theend;
      }
  
--- 7094,7100 ----
      /* Be paranoid... */
      if (prog == NULL || line == NULL)
      {
! 	emsg(_(e_null));
  	goto theend;
      }
  
***************
*** 7212,7218 ****
      {
  	/* TODO: only give this error for debugging? */
  	if (post_ptr >= post_end)
! 	    IEMSGN("Internal error: estimated max number of states insufficient: %ld", post_end - post_start);
  	goto fail;	    /* Cascaded (syntax?) error */
      }
  
--- 7212,7218 ----
      {
  	/* TODO: only give this error for debugging? */
  	if (post_ptr >= post_end)
! 	    siemsg("Internal error: estimated max number of states insufficient: %ld", post_end - post_start);
  	goto fail;	    /* Cascaded (syntax?) error */
      }
  
*** ../vim-8.1.0742/src/search.c	2018-12-23 19:10:05.006359935 +0100
--- src/search.c	2019-01-13 19:57:22.949515704 +0100
***************
*** 156,164 ****
  	if (spats[i].pat == NULL)	/* pattern was never defined */
  	{
  	    if (pat_use == RE_SUBST)
! 		EMSG(_(e_nopresub));
  	    else
! 		EMSG(_(e_noprevre));
  	    rc_did_emsg = TRUE;
  	    return FAIL;
  	}
--- 156,164 ----
  	if (spats[i].pat == NULL)	/* pattern was never defined */
  	{
  	    if (pat_use == RE_SUBST)
! 		emsg(_(e_nopresub));
  	    else
! 		emsg(_(e_noprevre));
  	    rc_did_emsg = TRUE;
  	    return FAIL;
  	}
***************
*** 369,375 ****
  save_last_search_pattern(void)
  {
      if (did_save_last_search_spat != 0)
! 	IEMSG("did_save_last_search_spat is not zero");
      else
  	++did_save_last_search_spat;
  
--- 369,375 ----
  save_last_search_pattern(void)
  {
      if (did_save_last_search_spat != 0)
! 	iemsg("did_save_last_search_spat is not zero");
      else
  	++did_save_last_search_spat;
  
***************
*** 385,391 ****
  {
      if (did_save_last_search_spat != 1)
      {
! 	IEMSG("did_save_last_search_spat is not one");
  	return;
      }
      --did_save_last_search_spat;
--- 385,391 ----
  {
      if (did_save_last_search_spat != 1)
      {
! 	iemsg("did_save_last_search_spat is not one");
  	return;
      }
      --did_save_last_search_spat;
***************
*** 670,676 ****
  		   (options & (SEARCH_HIS + SEARCH_KEEP)), &regmatch) == FAIL)
      {
  	if ((options & SEARCH_MSG) && !rc_did_emsg)
! 	    EMSG2(_("E383: Invalid search string: %s"), mr_pattern);
  	return FAIL;
      }
  
--- 670,676 ----
  		   (options & (SEARCH_HIS + SEARCH_KEEP)), &regmatch) == FAIL)
      {
  	if ((options & SEARCH_MSG) && !rc_did_emsg)
! 	    semsg(_("E383: Invalid search string: %s"), mr_pattern);
  	return FAIL;
      }
  
***************
*** 1136,1151 ****
      if (!found)		    /* did not find it */
      {
  	if (got_int)
! 	    EMSG(_(e_interr));
  	else if ((options & SEARCH_MSG) == SEARCH_MSG)
  	{
  	    if (p_ws)
! 		EMSG2(_(e_patnotf2), mr_pattern);
  	    else if (lnum == 0)
! 		EMSG2(_("E384: search hit TOP without match for: %s"),
  								  mr_pattern);
  	    else
! 		EMSG2(_("E385: search hit BOTTOM without match for: %s"),
  								  mr_pattern);
  	}
  	return FAIL;
--- 1136,1151 ----
      if (!found)		    /* did not find it */
      {
  	if (got_int)
! 	    emsg(_(e_interr));
  	else if ((options & SEARCH_MSG) == SEARCH_MSG)
  	{
  	    if (p_ws)
! 		semsg(_(e_patnotf2), mr_pattern);
  	    else if (lnum == 0)
! 		semsg(_("E384: search hit TOP without match for: %s"),
  								  mr_pattern);
  	    else
! 		semsg(_("E385: search hit BOTTOM without match for: %s"),
  								  mr_pattern);
  	}
  	return FAIL;
***************
*** 1324,1330 ****
  		searchstr = spats[RE_SUBST].pat;
  		if (searchstr == NULL)
  		{
! 		    EMSG(_(e_noprevre));
  		    retval = 0;
  		    goto end_do_search;
  		}
--- 1324,1330 ----
  		searchstr = spats[RE_SUBST].pat;
  		if (searchstr == NULL)
  		{
! 		    emsg(_(e_noprevre));
  		    retval = 0;
  		    goto end_do_search;
  		}
***************
*** 1581,1587 ****
  	if (dirc != '?' && dirc != '/')
  	{
  	    retval = 0;
! 	    EMSG(_("E386: Expected '?' or '/'  after ';'"));
  	    goto end_do_search;
  	}
  	++pat;
--- 1581,1587 ----
  	if (dirc != '?' && dirc != '/')
  	{
  	    retval = 0;
! 	    emsg(_("E386: Expected '?' or '/'  after ';'"));
  	    goto end_do_search;
  	}
  	++pat;
***************
*** 5219,5225 ****
  			 if (p_verbose >= 5)
  		    {
  			verbose_enter();
! 			smsg((char_u *)_("Searching included file %s"),
  							   (char *)new_fname);
  			verbose_leave();
  		    }
--- 5219,5225 ----
  			 if (p_verbose >= 5)
  		    {
  			verbose_enter();
! 			smsg(_("Searching included file %s"),
  							   (char *)new_fname);
  			verbose_leave();
  		    }
***************
*** 5442,5448 ****
  						      && g_do_tagpreview == 0
  #endif
  						      )
! 		    EMSG(_("E387: Match is on current line"));
  		else if (action == ACTION_SHOW)
  		{
  		    show_pat_in_path(line, type, did_show, action,
--- 5442,5448 ----
  						      && g_do_tagpreview == 0
  #endif
  						      )
! 		    emsg(_("E387: Match is on current line"));
  		else if (action == ACTION_SHOW)
  		{
  		    show_pat_in_path(line, type, did_show, action,
***************
*** 5609,5619 ****
  #else
  	if (got_int)
  #endif
! 	    EMSG(_(e_interr));
  	else if (type == FIND_DEFINE)
! 	    EMSG(_("E388: Couldn't find definition"));
  	else
! 	    EMSG(_("E389: Couldn't find pattern"));
      }
      if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)
  	msg_end();
--- 5609,5619 ----
  #else
  	if (got_int)
  #endif
! 	    emsg(_(e_interr));
  	else if (type == FIND_DEFINE)
! 	    emsg(_("E388: Couldn't find definition"));
  	else
! 	    emsg(_("E389: Couldn't find pattern"));
      }
      if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)
  	msg_end();
*** ../vim-8.1.0742/src/sign.c	2019-01-11 13:42:31.680331155 +0100
--- src/sign.c	2019-01-13 19:57:27.513477447 +0100
***************
*** 752,758 ****
  		if (next_sign_typenr == start)
  		{
  		    vim_free(sp);
! 		    EMSG(_("E612: Too many signs defined"));
  		    return FAIL;
  		}
  		lp = first_sign;  // start all over
--- 752,758 ----
  		if (next_sign_typenr == start)
  		{
  		    vim_free(sp);
! 		    emsg(_("E612: Too many signs defined"));
  		    return FAIL;
  		}
  		lp = first_sign;  // start all over
***************
*** 835,841 ****
  	// Currently must be one or two display cells
  	if (s != endp || cells < 1 || cells > 2)
  	{
! 	    EMSG2(_("E239: Invalid sign text: %s"), text);
  	    return FAIL;
  	}
  
--- 835,841 ----
  	// Currently must be one or two display cells
  	if (s != endp || cells < 1 || cells > 2)
  	{
! 	    semsg(_("E239: Invalid sign text: %s"), text);
  	    return FAIL;
  	}
  
***************
*** 870,876 ****
      sp = sign_find(name, &sp_prev);
      if (sp == NULL)
      {
! 	EMSG2(_("E155: Unknown sign: %s"), name);
  	return FAIL;
      }
      sign_undefine(sp, sp_prev);
--- 870,876 ----
      sp = sign_find(name, &sp_prev);
      if (sp == NULL)
      {
! 	semsg(_("E155: Unknown sign: %s"), name);
  	return FAIL;
      }
      sign_undefine(sp, sp_prev);
***************
*** 890,896 ****
      if (sp != NULL)
  	sign_list_defined(sp);
      else
! 	EMSG2(_("E155: Unknown sign: %s"), name);
  }
  
  /*
--- 890,896 ----
      if (sp != NULL)
  	sign_list_defined(sp);
      else
! 	semsg(_("E155: Unknown sign: %s"), name);
  }
  
  /*
***************
*** 916,922 ****
  	    break;
      if (sp == NULL)
      {
! 	EMSG2(_("E155: Unknown sign: %s"), sign_name);
  	return FAIL;
      }
      if (*sign_id == 0)
--- 916,922 ----
  	    break;
      if (sp == NULL)
      {
! 	semsg(_("E155: Unknown sign: %s"), sign_name);
  	return FAIL;
      }
      if (*sign_id == 0)
***************
*** 933,939 ****
  	redraw_buf_line_later(buf, lnum);
      else
      {
! 	EMSG2(_("E885: Not possible to change sign %s"), sign_name);
  	return FAIL;
      }
  
--- 933,939 ----
  	redraw_buf_line_later(buf, lnum);
      else
      {
! 	semsg(_("E885: Not possible to change sign %s"), sign_name);
  	return FAIL;
      }
  
***************
*** 980,986 ****
      if (id > 0)
  	sign_unplace(id, groupname, curwin->w_buffer, curwin->w_cursor.lnum);
      else
! 	EMSG(_("E159: Missing sign number"));
  }
  
  /*
--- 980,986 ----
      if (id > 0)
  	sign_unplace(id, groupname, curwin->w_buffer, curwin->w_cursor.lnum);
      else
! 	emsg(_("E159: Missing sign number"));
  }
  
  /*
***************
*** 993,999 ****
  
      if ((lnum = buf_findsign(buf, sign_id, sign_group)) <= 0)
      {
! 	EMSGN(_("E157: Invalid sign ID: %ld"), sign_id);
  	return -1;
      }
  
--- 993,999 ----
  
      if ((lnum = buf_findsign(buf, sign_id, sign_group)) <= 0)
      {
! 	semsg(_("E157: Invalid sign ID: %ld"), sign_id);
  	return -1;
      }
  
***************
*** 1010,1016 ****
  
  	if (buf->b_fname == NULL)
  	{
! 	    EMSG(_("E934: Cannot jump to a buffer that does not have a name"));
  	    return -1;
  	}
  	cmd = alloc((unsigned)STRLEN(buf->b_fname) + 25);
--- 1010,1016 ----
  
  	if (buf->b_fname == NULL)
  	{
! 	    emsg(_("E934: Cannot jump to a buffer that does not have a name"));
  	    return -1;
  	}
  	cmd = alloc((unsigned)STRLEN(buf->b_fname) + 25);
***************
*** 1070,1076 ****
  	}
  	else
  	{
! 	    EMSG2(_(e_invarg2), arg);
  	    failed = TRUE;
  	    break;
  	}
--- 1070,1076 ----
  	}
  	else
  	{
! 	    semsg(_(e_invarg2), arg);
  	    failed = TRUE;
  	    break;
  	}
***************
*** 1111,1117 ****
  	//   :sign place group=*
  	if (lnum >= 0 || sign_name != NULL
  		|| (group != NULL && *group == '\0'))
! 	    EMSG(_(e_invarg));
  	else
  	    sign_list_placed(buf, group);
      }
--- 1111,1117 ----
  	//   :sign place group=*
  	if (lnum >= 0 || sign_name != NULL
  		|| (group != NULL && *group == '\0'))
! 	    emsg(_(e_invarg));
  	else
  	    sign_list_placed(buf, group);
      }
***************
*** 1121,1127 ****
  	if (sign_name == NULL || buf == NULL
  		|| (group != NULL && *group == '\0'))
  	{
! 	    EMSG(_(e_invarg));
  	    return;
  	}
  
--- 1121,1127 ----
  	if (sign_name == NULL || buf == NULL
  		|| (group != NULL && *group == '\0'))
  	{
! 	    emsg(_(e_invarg));
  	    return;
  	}
  
***************
*** 1142,1148 ****
  {
      if (lnum >= 0 || sign_name != NULL || (group != NULL && *group == '\0'))
      {
! 	EMSG(_(e_invarg));
  	return;
      }
  
--- 1142,1148 ----
  {
      if (lnum >= 0 || sign_name != NULL || (group != NULL && *group == '\0'))
      {
! 	emsg(_(e_invarg));
  	return;
      }
  
***************
*** 1211,1217 ****
  {
      if (sign_name == NULL && group == NULL && id == -1)
      {
! 	EMSG(_(e_argreq));
  	return;
      }
  
--- 1211,1217 ----
  {
      if (sign_name == NULL && group == NULL && id == -1)
      {
! 	emsg(_(e_argreq));
  	return;
      }
  
***************
*** 1220,1226 ****
      {
  	// File or buffer is not specified or an empty group is used
  	// or a line number or a sign name is specified.
! 	EMSG(_(e_invarg));
  	return;
      }
      (void)sign_jump(id, group, buf);
--- 1220,1226 ----
      {
  	// File or buffer is not specified or an empty group is used
  	// or a line number or a sign name is specified.
! 	emsg(_(e_invarg));
  	return;
      }
      (void)sign_jump(id, group, buf);
***************
*** 1275,1281 ****
  	{
  	    if (*signid != -1)
  	    {
! 		EMSG(_(e_invarg));
  		return FAIL;
  	    }
  	    *signid = -2;
--- 1275,1281 ----
  	{
  	    if (*signid != -1)
  	    {
! 		emsg(_(e_invarg));
  		return FAIL;
  	    }
  	    *signid = -2;
***************
*** 1319,1330 ****
  	    filename = arg;
  	    *buf = buflist_findnr((int)getdigits(&arg));
  	    if (*skipwhite(arg) != NUL)
! 		EMSG(_(e_trailing));
  	    break;
  	}
  	else
  	{
! 	    EMSG(_(e_invarg));
  	    return FAIL;
  	}
  	arg = skipwhite(arg);
--- 1319,1330 ----
  	    filename = arg;
  	    *buf = buflist_findnr((int)getdigits(&arg));
  	    if (*skipwhite(arg) != NUL)
! 		emsg(_(e_trailing));
  	    break;
  	}
  	else
  	{
! 	    emsg(_(e_invarg));
  	    return FAIL;
  	}
  	arg = skipwhite(arg);
***************
*** 1332,1338 ****
  
      if (filename != NULL && *buf == NULL)
      {
! 	EMSG2(_("E158: Invalid buffer name: %s"), filename);
  	return FAIL;
      }
  
--- 1332,1338 ----
  
      if (filename != NULL && *buf == NULL)
      {
! 	semsg(_("E158: Invalid buffer name: %s"), filename);
  	return FAIL;
      }
  
***************
*** 1362,1368 ****
      idx = sign_cmd_idx(arg, p);
      if (idx == SIGNCMD_LAST)
      {
! 	EMSG2(_("E160: Unknown sign command: %s"), arg);
  	return;
      }
      arg = skipwhite(p);
--- 1362,1368 ----
      idx = sign_cmd_idx(arg, p);
      if (idx == SIGNCMD_LAST)
      {
! 	semsg(_("E160: Unknown sign command: %s"), arg);
  	return;
      }
      arg = skipwhite(p);
***************
*** 1377,1383 ****
  		sign_list_defined(sp);
  	}
  	else if (*arg == NUL)
! 	    EMSG(_("E156: Missing sign name"));
  	else
  	{
  	    char_u	*name;
--- 1377,1383 ----
  		sign_list_defined(sp);
  	}
  	else if (*arg == NUL)
! 	    emsg(_("E156: Missing sign name"));
  	else
  	{
  	    char_u	*name;
***************
*** 1591,1597 ****
  {
      char_u	*p;
  
!     smsg((char_u *)"sign %s", sp->sn_name);
      if (sp->sn_icon != NULL)
      {
  	MSG_PUTS(" icon=");
--- 1591,1597 ----
  {
      char_u	*p;
  
!     smsg("sign %s", sp->sn_name);
      if (sp->sn_icon != NULL)
      {
  	MSG_PUTS(" icon=");
*** ../vim-8.1.0742/src/spell.c	2018-11-16 16:21:01.633310065 +0100
--- src/spell.c	2019-01-13 23:15:15.534057954 +0100
***************
*** 717,723 ****
  	    if (endidxcnt == MAXWLEN)
  	    {
  		/* Must be a corrupted spell file. */
! 		EMSG(_(e_format));
  		return;
  	    }
  	    endlen[endidxcnt] = wlen;
--- 717,723 ----
  	    if (endidxcnt == MAXWLEN)
  	    {
  		/* Must be a corrupted spell file. */
! 		emsg(_(e_format));
  		return;
  	    }
  	    endlen[endidxcnt] = wlen;
***************
*** 1537,1543 ****
      if (!wp->w_p_spell || *wp->w_s->b_p_spl == NUL
  					 || wp->w_s->b_langp.ga_len == 0)
      {
! 	EMSG(_("E756: Spell checking is not enabled"));
  	return TRUE;
      }
      return FALSE;
--- 1537,1543 ----
      if (!wp->w_p_spell || *wp->w_s->b_p_spl == NUL
  					 || wp->w_s->b_langp.ga_len == 0)
      {
! 	emsg(_("E756: Spell checking is not enabled"));
  	return TRUE;
      }
      return FALSE;
***************
*** 1888,1894 ****
  
      if (r == FAIL)
      {
! 	smsg((char_u *)
  #ifdef VMS
  	_("Warning: Cannot find word list \"%s_%s.spl\" or \"%s_ascii.spl\""),
  #else
--- 1888,1894 ----
  
      if (r == FAIL)
      {
! 	smsg(
  #ifdef VMS
  	_("Warning: Cannot find word list \"%s_%s.spl\" or \"%s_ascii.spl\""),
  #else
***************
*** 2307,2313 ****
   * Parse 'spelllang' and set w_s->b_langp accordingly.
   * Returns NULL if it's OK, an error message otherwise.
   */
!     char_u *
  did_set_spelllang(win_T *wp)
  {
      garray_T	ga;
--- 2307,2313 ----
   * Parse 'spelllang' and set w_s->b_langp accordingly.
   * Returns NULL if it's OK, an error message otherwise.
   */
!     char *
  did_set_spelllang(win_T *wp)
  {
      garray_T	ga;
***************
*** 2330,2336 ****
      int		i, j;
      langp_T	*lp, *lp2;
      static int	recursive = FALSE;
!     char_u	*ret_msg = NULL;
      char_u	*spl_copy;
      bufref_T	bufref;
  
--- 2330,2336 ----
      int		i, j;
      langp_T	*lp, *lp2;
      static int	recursive = FALSE;
!     char	*ret_msg = NULL;
      char_u	*spl_copy;
      bufref_T	bufref;
  
***************
*** 2435,2441 ****
  		 * destroying the buffer we are using... */
  		if (!bufref_valid(&bufref))
  		{
! 		    ret_msg = (char_u *)N_("E797: SpellFileMissing autocommand deleted buffer");
  		    goto theend;
  		}
  	    }
--- 2435,2441 ----
  		 * destroying the buffer we are using... */
  		if (!bufref_valid(&bufref))
  		{
! 		    ret_msg = N_("E797: SpellFileMissing autocommand deleted buffer");
  		    goto theend;
  		}
  	    }
***************
*** 2464,2471 ****
  			else
  			    /* This is probably an error.  Give a warning and
  			     * accept the words anyway. */
! 			    smsg((char_u *)
! 				    _("Warning: region %s not supported"),
  								      region);
  		    }
  		    else
--- 2464,2470 ----
  			else
  			    /* This is probably an error.  Give a warning and
  			     * accept the words anyway. */
! 			    smsg(_("Warning: region %s not supported"),
  								      region);
  		    }
  		    else
***************
*** 3380,3386 ****
      else if (count > 0)
      {
  	if (count > sug.su_ga.ga_len)
! 	    smsg((char_u *)_("Sorry, only %ld suggestions"),
  						      (long)sug.su_ga.ga_len);
      }
      else
--- 3379,3385 ----
      else if (count > 0)
      {
  	if (count > sug.su_ga.ga_len)
! 	    smsg(_("Sorry, only %ld suggestions"),
  						      (long)sug.su_ga.ga_len);
      }
      else
***************
*** 3615,3621 ****
  
      if (repl_from == NULL || repl_to == NULL)
      {
! 	EMSG(_("E752: No previous spell replacement"));
  	return;
      }
      addlen = (int)(STRLEN(repl_to) - STRLEN(repl_from));
--- 3614,3620 ----
  
      if (repl_from == NULL || repl_to == NULL)
      {
! 	emsg(_("E752: No previous spell replacement"));
  	return;
      }
      addlen = (int)(STRLEN(repl_to) - STRLEN(repl_from));
***************
*** 3665,3671 ****
      vim_free(frompat);
  
      if (sub_nsubs == 0)
! 	EMSG2(_("E753: Not found: %s"), repl_from);
      else
  	do_sub_msg(FALSE);
  }
--- 3664,3670 ----
      vim_free(frompat);
  
      if (sub_nsubs == 0)
! 	semsg(_("E753: Not found: %s"), repl_from);
      else
  	do_sub_msg(FALSE);
  }
***************
*** 3905,3911 ****
      fd = mch_fopen((char *)fname, "r");
      if (fd == NULL)
      {
! 	EMSG2(_(e_notopen), fname);
  	return;
      }
  
--- 3904,3910 ----
      fd = mch_fopen((char *)fname, "r");
      if (fd == NULL)
      {
! 	semsg(_(e_notopen), fname);
  	return;
      }
  
*** ../vim-8.1.0742/src/spellfile.c	2018-11-16 16:21:01.637310049 +0100
--- src/spellfile.c	2019-01-13 19:57:34.861415906 +0100
***************
*** 359,369 ****
      if (fd == NULL)
      {
  	if (!silent)
! 	    EMSG2(_(e_notopen), fname);
  	else if (p_verbose > 2)
  	{
  	    verbose_enter();
! 	    smsg((char_u *)e_notopen, fname);
  	    verbose_leave();
  	}
  	goto endFAIL;
--- 359,369 ----
      if (fd == NULL)
      {
  	if (!silent)
! 	    semsg(_(e_notopen), fname);
  	else if (p_verbose > 2)
  	{
  	    verbose_enter();
! 	    smsg((const char *)e_notopen, fname);
  	    verbose_leave();
  	}
  	goto endFAIL;
***************
*** 371,377 ****
      if (p_verbose > 2)
      {
  	verbose_enter();
! 	smsg((char_u *)_("Reading spell file \"%s\""), fname);
  	verbose_leave();
      }
  
--- 371,377 ----
      if (p_verbose > 2)
      {
  	verbose_enter();
! 	smsg(_("Reading spell file \"%s\""), fname);
  	verbose_leave();
      }
  
***************
*** 403,420 ****
  	buf[i] = getc(fd);				/* <fileID> */
      if (STRNCMP(buf, VIMSPELLMAGIC, VIMSPELLMAGICL) != 0)
      {
! 	EMSG(_("E757: This does not look like a spell file"));
  	goto endFAIL;
      }
      c = getc(fd);					/* <versionnr> */
      if (c < VIMSPELLVERSION)
      {
! 	EMSG(_("E771: Old spell file, needs to be updated"));
  	goto endFAIL;
      }
      else if (c > VIMSPELLVERSION)
      {
! 	EMSG(_("E772: Spell file is for newer version of Vim"));
  	goto endFAIL;
      }
  
--- 403,420 ----
  	buf[i] = getc(fd);				/* <fileID> */
      if (STRNCMP(buf, VIMSPELLMAGIC, VIMSPELLMAGICL) != 0)
      {
! 	emsg(_("E757: This does not look like a spell file"));
  	goto endFAIL;
      }
      c = getc(fd);					/* <versionnr> */
      if (c < VIMSPELLVERSION)
      {
! 	emsg(_("E771: Old spell file, needs to be updated"));
  	goto endFAIL;
      }
      else if (c > VIMSPELLVERSION)
      {
! 	emsg(_("E772: Spell file is for newer version of Vim"));
  	goto endFAIL;
      }
  
***************
*** 521,527 ****
  		 * message.  When it's not required skip the contents. */
  		if (c & SNF_REQUIRED)
  		{
! 		    EMSG(_("E770: Unsupported section in spell file"));
  		    goto endFAIL;
  		}
  		while (--len >= 0)
--- 521,527 ----
  		 * message.  When it's not required skip the contents. */
  		if (c & SNF_REQUIRED)
  		{
! 		    emsg(_("E770: Unsupported section in spell file"));
  		    goto endFAIL;
  		}
  		while (--len >= 0)
***************
*** 532,544 ****
  someerror:
  	if (res == SP_FORMERROR)
  	{
! 	    EMSG(_(e_format));
  	    goto endFAIL;
  	}
  	if (res == SP_TRUNCERROR)
  	{
  truncerr:
! 	    EMSG(_(e_spell_trunc));
  	    goto endFAIL;
  	}
  	if (res == SP_OTHERERROR)
--- 532,544 ----
  someerror:
  	if (res == SP_FORMERROR)
  	{
! 	    emsg(_(e_format));
  	    goto endFAIL;
  	}
  	if (res == SP_TRUNCERROR)
  	{
  truncerr:
! 	    emsg(_(e_spell_trunc));
  	    goto endFAIL;
  	}
  	if (res == SP_OTHERERROR)
***************
*** 695,714 ****
  		buf[i] = getc(fd);			/* <fileID> */
  	    if (STRNCMP(buf, VIMSUGMAGIC, VIMSUGMAGICL) != 0)
  	    {
! 		EMSG2(_("E778: This does not look like a .sug file: %s"),
  							     slang->sl_fname);
  		goto nextone;
  	    }
  	    c = getc(fd);				/* <versionnr> */
  	    if (c < VIMSUGVERSION)
  	    {
! 		EMSG2(_("E779: Old .sug file, needs to be updated: %s"),
  							     slang->sl_fname);
  		goto nextone;
  	    }
  	    else if (c > VIMSUGVERSION)
  	    {
! 		EMSG2(_("E780: .sug file is for newer version of Vim: %s"),
  							     slang->sl_fname);
  		goto nextone;
  	    }
--- 695,714 ----
  		buf[i] = getc(fd);			/* <fileID> */
  	    if (STRNCMP(buf, VIMSUGMAGIC, VIMSUGMAGICL) != 0)
  	    {
! 		semsg(_("E778: This does not look like a .sug file: %s"),
  							     slang->sl_fname);
  		goto nextone;
  	    }
  	    c = getc(fd);				/* <versionnr> */
  	    if (c < VIMSUGVERSION)
  	    {
! 		semsg(_("E779: Old .sug file, needs to be updated: %s"),
  							     slang->sl_fname);
  		goto nextone;
  	    }
  	    else if (c > VIMSUGVERSION)
  	    {
! 		semsg(_("E780: .sug file is for newer version of Vim: %s"),
  							     slang->sl_fname);
  		goto nextone;
  	    }
***************
*** 718,724 ****
  	    timestamp = get8ctime(fd);			/* <timestamp> */
  	    if (timestamp != slang->sl_sugtime)
  	    {
! 		EMSG2(_("E781: .sug file doesn't match .spl file: %s"),
  							     slang->sl_fname);
  		goto nextone;
  	    }
--- 718,724 ----
  	    timestamp = get8ctime(fd);			/* <timestamp> */
  	    if (timestamp != slang->sl_sugtime)
  	    {
! 		semsg(_("E781: .sug file doesn't match .spl file: %s"),
  							     slang->sl_fname);
  		goto nextone;
  	    }
***************
*** 731,737 ****
  							       FALSE, 0) != 0)
  	    {
  someerror:
! 		EMSG2(_("E782: error while reading .sug file: %s"),
  							     slang->sl_fname);
  		slang_clear_sug(slang);
  		goto nextone;
--- 731,737 ----
  							       FALSE, 0) != 0)
  	    {
  someerror:
! 		semsg(_("E782: error while reading .sug file: %s"),
  							     slang->sl_fname);
  		slang_clear_sug(slang);
  		goto nextone;
***************
*** 2225,2231 ****
      fd = mch_fopen((char *)fname, "r");
      if (fd == NULL)
      {
! 	EMSG2(_(e_notopen), fname);
  	return NULL;
      }
  
--- 2225,2231 ----
      fd = mch_fopen((char *)fname, "r");
      if (fd == NULL)
      {
! 	semsg(_(e_notopen), fname);
  	return NULL;
      }
  
***************
*** 2277,2283 ****
  	    pc = string_convert(&spin->si_conv, rline, NULL);
  	    if (pc == NULL)
  	    {
! 		smsg((char_u *)_("Conversion failure for word in %s line %d: %s"),
  							   fname, lnum, rline);
  		continue;
  	    }
--- 2277,2283 ----
  	    pc = string_convert(&spin->si_conv, rline, NULL);
  	    if (pc == NULL)
  	    {
! 		smsg(_("Conversion failure for word in %s line %d: %s"),
  							   fname, lnum, rline);
  		continue;
  	    }
***************
*** 2325,2335 ****
  		if (aff->af_enc != NULL && !spin->si_ascii
  			&& convert_setup(&spin->si_conv, aff->af_enc,
  							       p_enc) == FAIL)
! 		    smsg((char_u *)_("Conversion in %s not supported: from %s to %s"),
  					       fname, aff->af_enc, p_enc);
  		spin->si_conv.vc_fail = TRUE;
  #else
! 		    smsg((char_u *)_("Conversion in %s not supported"), fname);
  #endif
  	    }
  	    else if (is_aff_rule(items, itemcnt, "FLAG", 2)
--- 2325,2335 ----
  		if (aff->af_enc != NULL && !spin->si_ascii
  			&& convert_setup(&spin->si_conv, aff->af_enc,
  							       p_enc) == FAIL)
! 		    smsg(_("Conversion in %s not supported: from %s to %s"),
  					       fname, aff->af_enc, p_enc);
  		spin->si_conv.vc_fail = TRUE;
  #else
! 		    smsg(_("Conversion in %s not supported"), fname);
  #endif
  	    }
  	    else if (is_aff_rule(items, itemcnt, "FLAG", 2)
***************
*** 2342,2348 ****
  		else if (STRCMP(items[1], "caplong") == 0)
  		    aff->af_flagtype = AFT_CAPLONG;
  		else
! 		    smsg((char_u *)_("Invalid value for FLAG in %s line %d: %s"),
  			    fname, lnum, items[1]);
  		if (aff->af_rare != 0
  			|| aff->af_keepcase != 0
--- 2342,2348 ----
  		else if (STRCMP(items[1], "caplong") == 0)
  		    aff->af_flagtype = AFT_CAPLONG;
  		else
! 		    smsg(_("Invalid value for FLAG in %s line %d: %s"),
  			    fname, lnum, items[1]);
  		if (aff->af_rare != 0
  			|| aff->af_keepcase != 0
***************
*** 2355,2361 ****
  			|| compflags != NULL
  			|| aff->af_suff.ht_used > 0
  			|| aff->af_pref.ht_used > 0)
! 		    smsg((char_u *)_("FLAG after using flags in %s line %d: %s"),
  			    fname, lnum, items[1]);
  	    }
  	    else if (spell_info_item(items[0]))
--- 2355,2361 ----
  			|| compflags != NULL
  			|| aff->af_suff.ht_used > 0
  			|| aff->af_pref.ht_used > 0)
! 		    smsg(_("FLAG after using flags in %s line %d: %s"),
  			    fname, lnum, items[1]);
  	    }
  	    else if (spell_info_item(items[0]))
***************
*** 2446,2452 ****
  		aff->af_compforbid = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  		if (aff->af_pref.ht_used > 0)
! 		    smsg((char_u *)_("Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d"),
  			    fname, lnum);
  	    }
  	    else if (is_aff_rule(items, itemcnt, "COMPOUNDPERMITFLAG", 2)
--- 2446,2452 ----
  		aff->af_compforbid = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  		if (aff->af_pref.ht_used > 0)
! 		    smsg(_("Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d"),
  			    fname, lnum);
  	    }
  	    else if (is_aff_rule(items, itemcnt, "COMPOUNDPERMITFLAG", 2)
***************
*** 2455,2461 ****
  		aff->af_comppermit = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  		if (aff->af_pref.ht_used > 0)
! 		    smsg((char_u *)_("Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d"),
  			    fname, lnum);
  	    }
  	    else if (is_aff_rule(items, itemcnt, "COMPOUNDFLAG", 2)
--- 2455,2461 ----
  		aff->af_comppermit = affitem2flag(aff->af_flagtype, items[1],
  								 fname, lnum);
  		if (aff->af_pref.ht_used > 0)
! 		    smsg(_("Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d"),
  			    fname, lnum);
  	    }
  	    else if (is_aff_rule(items, itemcnt, "COMPOUNDFLAG", 2)
***************
*** 2476,2482 ****
  		/* We don't use the count, but do check that it's a number and
  		 * not COMPOUNDRULE mistyped. */
  		if (atoi((char *)items[1]) == 0)
! 		    smsg((char_u *)_("Wrong COMPOUNDRULES value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
  	    else if (is_aff_rule(items, itemcnt, "COMPOUNDRULE", 2))
--- 2476,2482 ----
  		/* We don't use the count, but do check that it's a number and
  		 * not COMPOUNDRULE mistyped. */
  		if (atoi((char *)items[1]) == 0)
! 		    smsg(_("Wrong COMPOUNDRULES value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
  	    else if (is_aff_rule(items, itemcnt, "COMPOUNDRULE", 2))
***************
*** 2507,2513 ****
  	    {
  		compmax = atoi((char *)items[1]);
  		if (compmax == 0)
! 		    smsg((char_u *)_("Wrong COMPOUNDWORDMAX value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
  	    else if (is_aff_rule(items, itemcnt, "COMPOUNDMIN", 2)
--- 2507,2513 ----
  	    {
  		compmax = atoi((char *)items[1]);
  		if (compmax == 0)
! 		    smsg(_("Wrong COMPOUNDWORDMAX value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
  	    else if (is_aff_rule(items, itemcnt, "COMPOUNDMIN", 2)
***************
*** 2515,2521 ****
  	    {
  		compminlen = atoi((char *)items[1]);
  		if (compminlen == 0)
! 		    smsg((char_u *)_("Wrong COMPOUNDMIN value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
  	    else if (is_aff_rule(items, itemcnt, "COMPOUNDSYLMAX", 2)
--- 2515,2521 ----
  	    {
  		compminlen = atoi((char *)items[1]);
  		if (compminlen == 0)
! 		    smsg(_("Wrong COMPOUNDMIN value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
  	    else if (is_aff_rule(items, itemcnt, "COMPOUNDSYLMAX", 2)
***************
*** 2523,2529 ****
  	    {
  		compsylmax = atoi((char *)items[1]);
  		if (compsylmax == 0)
! 		    smsg((char_u *)_("Wrong COMPOUNDSYLMAX value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
  	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDDUP", 1))
--- 2523,2529 ----
  	    {
  		compsylmax = atoi((char *)items[1]);
  		if (compsylmax == 0)
! 		    smsg(_("Wrong COMPOUNDSYLMAX value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
  	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDDUP", 1))
***************
*** 2545,2551 ****
  	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDPATTERN", 2))
  	    {
  		if (atoi((char *)items[1]) == 0)
! 		    smsg((char_u *)_("Wrong CHECKCOMPOUNDPATTERN value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
  	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDPATTERN", 3))
--- 2545,2551 ----
  	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDPATTERN", 2))
  	    {
  		if (atoi((char *)items[1]) == 0)
! 		    smsg(_("Wrong CHECKCOMPOUNDPATTERN value in %s line %d: %s"),
  						       fname, lnum, items[1]);
  	    }
  	    else if (is_aff_rule(items, itemcnt, "CHECKCOMPOUNDPATTERN", 3))
***************
*** 2619,2628 ****
  		{
  		    cur_aff = HI2AH(hi);
  		    if (cur_aff->ah_combine != (*items[2] == 'Y'))
! 			smsg((char_u *)_("Different combining flag in continued affix block in %s line %d: %s"),
  						   fname, lnum, items[1]);
  		    if (!cur_aff->ah_follows)
! 			smsg((char_u *)_("Duplicate affix in %s line %d: %s"),
  						       fname, lnum, items[1]);
  		}
  		else
--- 2619,2628 ----
  		{
  		    cur_aff = HI2AH(hi);
  		    if (cur_aff->ah_combine != (*items[2] == 'Y'))
! 			smsg(_("Different combining flag in continued affix block in %s line %d: %s"),
  						   fname, lnum, items[1]);
  		    if (!cur_aff->ah_follows)
! 			smsg(_("Duplicate affix in %s line %d: %s"),
  						       fname, lnum, items[1]);
  		}
  		else
***************
*** 2644,2650 ****
  			    || cur_aff->ah_flag == aff->af_nosuggest
  			    || cur_aff->ah_flag == aff->af_needcomp
  			    || cur_aff->ah_flag == aff->af_comproot)
! 			smsg((char_u *)_("Affix also used for BAD/RARE/KEEPCASE/NEEDAFFIX/NEEDCOMPOUND/NOSUGGEST in %s line %d: %s"),
  						       fname, lnum, items[1]);
  		    STRCPY(cur_aff->ah_key, items[1]);
  		    hash_add(tp, cur_aff->ah_key);
--- 2644,2650 ----
  			    || cur_aff->ah_flag == aff->af_nosuggest
  			    || cur_aff->ah_flag == aff->af_needcomp
  			    || cur_aff->ah_flag == aff->af_comproot)
! 			smsg(_("Affix also used for BAD/RARE/KEEPCASE/NEEDAFFIX/NEEDCOMPOUND/NOSUGGEST in %s line %d: %s"),
  						       fname, lnum, items[1]);
  		    STRCPY(cur_aff->ah_key, items[1]);
  		    hash_add(tp, cur_aff->ah_key);
***************
*** 2665,2674 ****
  		/* Myspell allows extra text after the item, but that might
  		 * mean mistakes go unnoticed.  Require a comment-starter. */
  		if (itemcnt > lasti && *items[lasti] != '#')
! 		    smsg((char_u *)_(e_afftrailing), fname, lnum, items[lasti]);
  
  		if (STRCMP(items[2], "Y") != 0 && STRCMP(items[2], "N") != 0)
! 		    smsg((char_u *)_("Expected Y or N in %s line %d: %s"),
  						       fname, lnum, items[2]);
  
  		if (*items[0] == 'P' && aff->af_pfxpostpone)
--- 2665,2674 ----
  		/* Myspell allows extra text after the item, but that might
  		 * mean mistakes go unnoticed.  Require a comment-starter. */
  		if (itemcnt > lasti && *items[lasti] != '#')
! 		    smsg(_(e_afftrailing), fname, lnum, items[lasti]);
  
  		if (STRCMP(items[2], "Y") != 0 && STRCMP(items[2], "N") != 0)
! 		    smsg(_("Expected Y or N in %s line %d: %s"),
  						       fname, lnum, items[2]);
  
  		if (*items[0] == 'P' && aff->af_pfxpostpone)
***************
*** 2710,2716 ****
  			&& *items[lasti] != '#'
  			&& (STRCMP(items[lasti], "-") != 0
  						     || itemcnt != lasti + 1))
! 		    smsg((char_u *)_(e_afftrailing), fname, lnum, items[lasti]);
  
  		/* New item for an affix letter. */
  		--aff_todo;
--- 2710,2716 ----
  			&& *items[lasti] != '#'
  			&& (STRCMP(items[lasti], "-") != 0
  						     || itemcnt != lasti + 1))
! 		    smsg(_(e_afftrailing), fname, lnum, items[lasti]);
  
  		/* New item for an affix letter. */
  		--aff_todo;
***************
*** 2754,2760 ****
  			aff_entry->ae_prog = vim_regcomp(buf,
  					    RE_MAGIC + RE_STRING + RE_STRICT);
  			if (aff_entry->ae_prog == NULL)
! 			    smsg((char_u *)_("Broken condition in %s line %d: %s"),
  						       fname, lnum, items[4]);
  		    }
  
--- 2754,2760 ----
  			aff_entry->ae_prog = vim_regcomp(buf,
  					    RE_MAGIC + RE_STRING + RE_STRICT);
  			if (aff_entry->ae_prog == NULL)
! 			    smsg(_("Broken condition in %s line %d: %s"),
  						       fname, lnum, items[4]);
  		    }
  
***************
*** 2902,2908 ****
  	    {
  		/* Ignore REP/REPSAL count */;
  		if (!isdigit(*items[1]))
! 		    smsg((char_u *)_("Expected REP(SAL) count in %s line %d"),
  								 fname, lnum);
  	    }
  	    else if ((STRCMP(items[0], "REP") == 0
--- 2902,2908 ----
  	    {
  		/* Ignore REP/REPSAL count */;
  		if (!isdigit(*items[1]))
! 		    smsg(_("Expected REP(SAL) count in %s line %d"),
  								 fname, lnum);
  	    }
  	    else if ((STRCMP(items[0], "REP") == 0
***************
*** 2913,2919 ****
  		/* Myspell ignores extra arguments, we require it starts with
  		 * # to detect mistakes. */
  		if (itemcnt > 3 && items[3][0] != '#')
! 		    smsg((char_u *)_(e_afftrailing), fname, lnum, items[3]);
  		if (items[0][3] == 'S' ? do_repsal : do_rep)
  		{
  		    /* Replace underscore with space (can't include a space
--- 2913,2919 ----
  		/* Myspell ignores extra arguments, we require it starts with
  		 * # to detect mistakes. */
  		if (itemcnt > 3 && items[3][0] != '#')
! 		    smsg(_(e_afftrailing), fname, lnum, items[3]);
  		if (items[0][3] == 'S' ? do_repsal : do_rep)
  		{
  		    /* Replace underscore with space (can't include a space
***************
*** 2937,2943 ****
  		    /* First line contains the count. */
  		    found_map = TRUE;
  		    if (!isdigit(*items[1]))
! 			smsg((char_u *)_("Expected MAP count in %s line %d"),
  								 fname, lnum);
  		}
  		else if (do_mapline)
--- 2937,2943 ----
  		    /* First line contains the count. */
  		    found_map = TRUE;
  		    if (!isdigit(*items[1]))
! 			smsg(_("Expected MAP count in %s line %d"),
  								 fname, lnum);
  		}
  		else if (do_mapline)
***************
*** 2956,2962 ****
  				    && vim_strchr(spin->si_map.ga_data, c)
  								      != NULL)
  				|| vim_strchr(p, c) != NULL)
! 			    smsg((char_u *)_("Duplicate character in MAP in %s line %d"),
  								 fname, lnum);
  		    }
  
--- 2956,2962 ----
  				    && vim_strchr(spin->si_map.ga_data, c)
  								      != NULL)
  				|| vim_strchr(p, c) != NULL)
! 			    smsg(_("Duplicate character in MAP in %s line %d"),
  								 fname, lnum);
  		    }
  
***************
*** 3013,3019 ****
  		}
  	    }
  	    else
! 		smsg((char_u *)_("Unrecognized or duplicate item in %s line %d: %s"),
  						       fname, lnum, items[0]);
  	}
      }
--- 3013,3019 ----
  		}
  	    }
  	    else
! 		smsg(_("Unrecognized or duplicate item in %s line %d: %s"),
  						       fname, lnum, items[0]);
  	}
      }
***************
*** 3041,3047 ****
  		)
  	{
  	    if (fol == NULL || low == NULL || upp == NULL)
! 		smsg((char_u *)_("Missing FOL/LOW/UPP line in %s"), fname);
  	    else
  		(void)set_spell_chartab(fol, low, upp);
  	}
--- 3041,3047 ----
  		)
  	{
  	    if (fol == NULL || low == NULL || upp == NULL)
! 		smsg(_("Missing FOL/LOW/UPP line in %s"), fname);
  	    else
  		(void)set_spell_chartab(fol, low, upp);
  	}
***************
*** 3067,3073 ****
      if (compsylmax != 0)
      {
  	if (syllable == NULL)
! 	    smsg((char_u *)_("COMPOUNDSYLMAX used without SYLLABLE"));
  	aff_check_number(spin->si_compsylmax, compsylmax, "COMPOUNDSYLMAX");
  	spin->si_compsylmax = compsylmax;
      }
--- 3067,3073 ----
      if (compsylmax != 0)
      {
  	if (syllable == NULL)
! 	    smsg(_("COMPOUNDSYLMAX used without SYLLABLE"));
  	aff_check_number(spin->si_compsylmax, compsylmax, "COMPOUNDSYLMAX");
  	spin->si_compsylmax = compsylmax;
      }
***************
*** 3101,3110 ****
      if (sofofrom != NULL || sofoto != NULL)
      {
  	if (sofofrom == NULL || sofoto == NULL)
! 	    smsg((char_u *)_("Missing SOFO%s line in %s"),
  				     sofofrom == NULL ? "FROM" : "TO", fname);
  	else if (spin->si_sal.ga_len > 0)
! 	    smsg((char_u *)_("Both SAL and SOFO lines in %s"), fname);
  	else
  	{
  	    aff_check_string(spin->si_sofofr, sofofrom, "SOFOFROM");
--- 3101,3110 ----
      if (sofofrom != NULL || sofoto != NULL)
      {
  	if (sofofrom == NULL || sofoto == NULL)
! 	    smsg(_("Missing SOFO%s line in %s"),
  				     sofofrom == NULL ? "FROM" : "TO", fname);
  	else if (spin->si_sal.ga_len > 0)
! 	    smsg(_("Both SAL and SOFO lines in %s"), fname);
  	else
  	{
  	    aff_check_string(spin->si_sofofr, sofofrom, "SOFOFROM");
***************
*** 3208,3222 ****
      if (res == 0)
      {
  	if (flagtype == AFT_NUM)
! 	    smsg((char_u *)_("Flag is not a number in %s line %d: %s"),
  							   fname, lnum, item);
  	else
! 	    smsg((char_u *)_("Illegal flag in %s line %d: %s"),
  							   fname, lnum, item);
      }
      if (*p != NUL)
      {
! 	smsg((char_u *)_(e_affname), fname, lnum, item);
  	return 0;
      }
  
--- 3208,3222 ----
      if (res == 0)
      {
  	if (flagtype == AFT_NUM)
! 	    smsg(_("Flag is not a number in %s line %d: %s"),
  							   fname, lnum, item);
  	else
! 	    smsg(_("Illegal flag in %s line %d: %s"),
  							   fname, lnum, item);
      }
      if (*p != NUL)
      {
! 	smsg(_(e_affname), fname, lnum, item);
  	return 0;
      }
  
***************
*** 3419,3425 ****
  aff_check_number(int spinval, int affval, char *name)
  {
      if (spinval != 0 && spinval != affval)
! 	smsg((char_u *)_("%s value differs from what is used in another .aff file"), name);
  }
  
  /*
--- 3419,3425 ----
  aff_check_number(int spinval, int affval, char *name)
  {
      if (spinval != 0 && spinval != affval)
! 	smsg(_("%s value differs from what is used in another .aff file"), name);
  }
  
  /*
***************
*** 3429,3435 ****
  aff_check_string(char_u *spinval, char_u *affval, char *name)
  {
      if (spinval != NULL && STRCMP(spinval, affval) != 0)
! 	smsg((char_u *)_("%s value differs from what is used in another .aff file"), name);
  }
  
  /*
--- 3429,3435 ----
  aff_check_string(char_u *spinval, char_u *affval, char *name)
  {
      if (spinval != NULL && STRCMP(spinval, affval) != 0)
! 	smsg(_("%s value differs from what is used in another .aff file"), name);
  }
  
  /*
***************
*** 3549,3555 ****
      fd = mch_fopen((char *)fname, "r");
      if (fd == NULL)
      {
! 	EMSG2(_(e_notopen), fname);
  	return FAIL;
      }
  
--- 3549,3555 ----
      fd = mch_fopen((char *)fname, "r");
      if (fd == NULL)
      {
! 	semsg(_(e_notopen), fname);
  	return FAIL;
      }
  
***************
*** 3566,3572 ****
      /* Read and ignore the first line: word count. */
      (void)vim_fgets(line, MAXLINELEN, fd);
      if (!vim_isdigit(*skipwhite(line)))
! 	EMSG2(_("E760: No word count in %s"), fname);
  
      /*
       * Read all the lines in the file one by one.
--- 3566,3572 ----
      /* Read and ignore the first line: word count. */
      (void)vim_fgets(line, MAXLINELEN, fd);
      if (!vim_isdigit(*skipwhite(line)))
! 	semsg(_("E760: No word count in %s"), fname);
  
      /*
       * Read all the lines in the file one by one.
***************
*** 3596,3602 ****
  	    pc = string_convert(&spin->si_conv, line, NULL);
  	    if (pc == NULL)
  	    {
! 		smsg((char_u *)_("Conversion failure for word in %s line %d: %s"),
  						       fname, lnum, line);
  		continue;
  	    }
--- 3596,3602 ----
  	    pc = string_convert(&spin->si_conv, line, NULL);
  	    if (pc == NULL)
  	    {
! 		smsg(_("Conversion failure for word in %s line %d: %s"),
  						       fname, lnum, line);
  		continue;
  	    }
***************
*** 3661,3670 ****
  	if (!HASHITEM_EMPTY(hi))
  	{
  	    if (p_verbose > 0)
! 		smsg((char_u *)_("Duplicate word in %s line %d: %s"),
  							     fname, lnum, dw);
  	    else if (duplicate == 0)
! 		smsg((char_u *)_("First duplicate word in %s line %d: %s"),
  							     fname, lnum, dw);
  	    ++duplicate;
  	}
--- 3661,3670 ----
  	if (!HASHITEM_EMPTY(hi))
  	{
  	    if (p_verbose > 0)
! 		smsg(_("Duplicate word in %s line %d: %s"),
  							     fname, lnum, dw);
  	    else if (duplicate == 0)
! 		smsg(_("First duplicate word in %s line %d: %s"),
  							     fname, lnum, dw);
  	    ++duplicate;
  	}
***************
*** 3719,3727 ****
      }
  
      if (duplicate > 0)
! 	smsg((char_u *)_("%d duplicate word(s) in %s"), duplicate, fname);
      if (spin->si_ascii && non_ascii > 0)
! 	smsg((char_u *)_("Ignored %d word(s) with non-ASCII characters in %s"),
  							    non_ascii, fname);
      hash_clear(&ht);
  
--- 3719,3727 ----
      }
  
      if (duplicate > 0)
! 	smsg(_("%d duplicate word(s) in %s"), duplicate, fname);
      if (spin->si_ascii && non_ascii > 0)
! 	smsg(_("Ignored %d word(s) with non-ASCII characters in %s"),
  							    non_ascii, fname);
      hash_clear(&ht);
  
***************
*** 4133,4139 ****
      fd = mch_fopen((char *)fname, "r");
      if (fd == NULL)
      {
! 	EMSG2(_(e_notopen), fname);
  	return FAIL;
      }
  
--- 4133,4139 ----
      fd = mch_fopen((char *)fname, "r");
      if (fd == NULL)
      {
! 	semsg(_(e_notopen), fname);
  	return FAIL;
      }
  
***************
*** 4168,4174 ****
  	    pc = string_convert(&spin->si_conv, rline, NULL);
  	    if (pc == NULL)
  	    {
! 		smsg((char_u *)_("Conversion failure for word in %s line %d: %s"),
  							   fname, lnum, rline);
  		continue;
  	    }
--- 4168,4174 ----
  	    pc = string_convert(&spin->si_conv, rline, NULL);
  	    if (pc == NULL)
  	    {
! 		smsg(_("Conversion failure for word in %s line %d: %s"),
  							   fname, lnum, rline);
  		continue;
  	    }
***************
*** 4187,4196 ****
  	    if (STRNCMP(line, "encoding=", 9) == 0)
  	    {
  		if (spin->si_conv.vc_type != CONV_NONE)
! 		    smsg((char_u *)_("Duplicate /encoding= line ignored in %s line %d: %s"),
  						       fname, lnum, line - 1);
  		else if (did_word)
! 		    smsg((char_u *)_("/encoding= line after word ignored in %s line %d: %s"),
  						       fname, lnum, line - 1);
  		else
  		{
--- 4187,4196 ----
  	    if (STRNCMP(line, "encoding=", 9) == 0)
  	    {
  		if (spin->si_conv.vc_type != CONV_NONE)
! 		    smsg(_("Duplicate /encoding= line ignored in %s line %d: %s"),
  						       fname, lnum, line - 1);
  		else if (did_word)
! 		    smsg(_("/encoding= line after word ignored in %s line %d: %s"),
  						       fname, lnum, line - 1);
  		else
  		{
***************
*** 4203,4214 ****
  		    if (enc != NULL && !spin->si_ascii
  			    && convert_setup(&spin->si_conv, enc,
  							       p_enc) == FAIL)
! 			smsg((char_u *)_("Conversion in %s not supported: from %s to %s"),
  							  fname, line, p_enc);
  		    vim_free(enc);
  		    spin->si_conv.vc_fail = TRUE;
  #else
! 		    smsg((char_u *)_("Conversion in %s not supported"), fname);
  #endif
  		}
  		continue;
--- 4203,4214 ----
  		    if (enc != NULL && !spin->si_ascii
  			    && convert_setup(&spin->si_conv, enc,
  							       p_enc) == FAIL)
! 			smsg(_("Conversion in %s not supported: from %s to %s"),
  							  fname, line, p_enc);
  		    vim_free(enc);
  		    spin->si_conv.vc_fail = TRUE;
  #else
! 		    smsg(_("Conversion in %s not supported"), fname);
  #endif
  		}
  		continue;
***************
*** 4217,4229 ****
  	    if (STRNCMP(line, "regions=", 8) == 0)
  	    {
  		if (spin->si_region_count > 1)
! 		    smsg((char_u *)_("Duplicate /regions= line ignored in %s line %d: %s"),
  						       fname, lnum, line);
  		else
  		{
  		    line += 8;
  		    if (STRLEN(line) > MAXREGIONS * 2)
! 			smsg((char_u *)_("Too many regions in %s line %d: %s"),
  						       fname, lnum, line);
  		    else
  		    {
--- 4217,4229 ----
  	    if (STRNCMP(line, "regions=", 8) == 0)
  	    {
  		if (spin->si_region_count > 1)
! 		    smsg(_("Duplicate /regions= line ignored in %s line %d: %s"),
  						       fname, lnum, line);
  		else
  		{
  		    line += 8;
  		    if (STRLEN(line) > MAXREGIONS * 2)
! 			smsg(_("Too many regions in %s line %d: %s"),
  						       fname, lnum, line);
  		    else
  		    {
***************
*** 4237,4243 ****
  		continue;
  	    }
  
! 	    smsg((char_u *)_("/ line ignored in %s line %d: %s"),
  						       fname, lnum, line - 1);
  	    continue;
  	}
--- 4237,4243 ----
  		continue;
  	    }
  
! 	    smsg(_("/ line ignored in %s line %d: %s"),
  						       fname, lnum, line - 1);
  	    continue;
  	}
***************
*** 4267,4273 ****
  		    l = *p - '0';
  		    if (l == 0 || l > spin->si_region_count)
  		    {
! 			smsg((char_u *)_("Invalid region nr in %s line %d: %s"),
  							  fname, lnum, p);
  			break;
  		    }
--- 4267,4273 ----
  		    l = *p - '0';
  		    if (l == 0 || l > spin->si_region_count)
  		    {
! 			smsg(_("Invalid region nr in %s line %d: %s"),
  							  fname, lnum, p);
  			break;
  		    }
***************
*** 4275,4281 ****
  		}
  		else
  		{
! 		    smsg((char_u *)_("Unrecognized flags in %s line %d: %s"),
  							      fname, lnum, p);
  		    break;
  		}
--- 4275,4281 ----
  		}
  		else
  		{
! 		    smsg(_("Unrecognized flags in %s line %d: %s"),
  							      fname, lnum, p);
  		    break;
  		}
***************
*** 4346,4352 ****
  	{
  	    if (!spin->si_did_emsg)
  	    {
! 		EMSG(_("E845: Insufficient memory, word list will be incomplete"));
  		spin->si_did_emsg = TRUE;
  	    }
  	    return NULL;
--- 4346,4352 ----
  	{
  	    if (!spin->si_did_emsg)
  	    {
! 		emsg(_("E845: Insufficient memory, word list will be incomplete"));
  		spin->si_did_emsg = TRUE;
  	    }
  	    return NULL;
***************
*** 4576,4582 ****
  	node = *prev;
      }
  #ifdef SPELL_PRINTTREE
!     smsg((char_u *)"Added \"%s\"", word);
      spell_print_tree(root->wn_sibling);
  #endif
  
--- 4576,4582 ----
  	node = *prev;
      }
  #ifdef SPELL_PRINTTREE
!     smsg("Added \"%s\"", word);
      spell_print_tree(root->wn_sibling);
  #endif
  
***************
*** 4916,4922 ****
      fd = mch_fopen((char *)fname, "w");
      if (fd == NULL)
      {
! 	EMSG2(_(e_notopen), fname);
  	return FAIL;
      }
  
--- 4916,4922 ----
      fd = mch_fopen((char *)fname, "w");
      if (fd == NULL)
      {
! 	semsg(_(e_notopen), fname);
  	return FAIL;
      }
  
***************
*** 5305,5311 ****
      if (fwv != (size_t)1)
  	retval = FAIL;
      if (retval == FAIL)
! 	EMSG(_(e_write));
  
      return retval;
  }
--- 5305,5311 ----
      if (fwv != (size_t)1)
  	retval = FAIL;
      if (retval == FAIL)
! 	emsg(_(e_write));
  
      return retval;
  }
***************
*** 5450,5456 ****
  	    if (fd != NULL)
  		if (putc(np->wn_byte, fd) == EOF) /* <byte> or <xbyte> */
  		{
! 		    EMSG(_(e_write));
  		    return 0;
  		}
  	}
--- 5450,5456 ----
  	    if (fd != NULL)
  		if (putc(np->wn_byte, fd) == EOF) /* <byte> or <xbyte> */
  		{
! 		    emsg(_(e_write));
  		    return 0;
  		}
  	}
***************
*** 5555,5561 ****
      if (sug_maketable(spin) == FAIL)
  	goto theend;
  
!     smsg((char_u *)_("Number of words after soundfolding: %ld"),
  				 (long)spin->si_spellbuf->b_ml.ml_line_count);
  
      /*
--- 5555,5561 ----
      if (sug_maketable(spin) == FAIL)
  	goto theend;
  
!     smsg(_("Number of words after soundfolding: %ld"),
  				 (long)spin->si_spellbuf->b_ml.ml_line_count);
  
      /*
***************
*** 5682,5688 ****
  	}
      }
  
!     smsg((char_u *)_("Total number of words: %d"), words_done);
  
      return OK;
  }
--- 5682,5688 ----
  	}
      }
  
!     smsg(_("Total number of words: %d"), words_done);
  
      return OK;
  }
***************
*** 5848,5854 ****
      fd = mch_fopen((char *)fname, "w");
      if (fd == NULL)
      {
! 	EMSG2(_(e_notopen), fname);
  	return;
      }
  
--- 5848,5854 ----
      fd = mch_fopen((char *)fname, "w");
      if (fd == NULL)
      {
! 	semsg(_(e_notopen), fname);
  	return;
      }
  
***************
*** 5861,5867 ****
       */
      if (fwrite(VIMSUGMAGIC, VIMSUGMAGICL, (size_t)1, fd) != 1) /* <fileID> */
      {
! 	EMSG(_(e_write));
  	goto theend;
      }
      putc(VIMSUGVERSION, fd);				/* <versionnr> */
--- 5861,5867 ----
       */
      if (fwrite(VIMSUGMAGIC, VIMSUGMAGICL, (size_t)1, fd) != 1) /* <fileID> */
      {
! 	emsg(_(e_write));
  	goto theend;
      }
      putc(VIMSUGVERSION, fd);				/* <versionnr> */
***************
*** 5903,5909 ****
  	len = (int)STRLEN(line) + 1;
  	if (fwrite(line, (size_t)len, (size_t)1, fd) == 0)
  	{
! 	    EMSG(_(e_write));
  	    goto theend;
  	}
  	spin->si_memtot += len;
--- 5903,5909 ----
  	len = (int)STRLEN(line) + 1;
  	if (fwrite(line, (size_t)len, (size_t)1, fd) == 0)
  	{
! 	    emsg(_(e_write));
  	    goto theend;
  	}
  	spin->si_memtot += len;
***************
*** 5911,5917 ****
  
      /* Write another byte to check for errors. */
      if (putc(0, fd) == EOF)
! 	EMSG(_(e_write));
  
      vim_snprintf((char *)IObuff, IOSIZE,
  		 _("Estimated runtime memory use: %d bytes"), spin->si_memtot);
--- 5911,5917 ----
  
      /* Write another byte to check for errors. */
      if (putc(0, fd) == EOF)
! 	emsg(_(e_write));
  
      vim_snprintf((char *)IObuff, IOSIZE,
  		 _("Estimated runtime memory use: %d bytes"), spin->si_memtot);
***************
*** 6010,6032 ****
      }
  
      if (incount <= 0)
! 	EMSG(_(e_invarg));	/* need at least output and input names */
      else if (vim_strchr(gettail(wfname), '_') != NULL)
! 	EMSG(_("E751: Output file name must not have region name"));
      else if (incount > MAXREGIONS)
! 	EMSGN(_("E754: Only up to %ld regions supported"), MAXREGIONS);
      else
      {
  	/* Check for overwriting before doing things that may take a lot of
  	 * time. */
  	if (!over_write && mch_stat((char *)wfname, &st) >= 0)
  	{
! 	    EMSG(_(e_exists));
  	    goto theend;
  	}
  	if (mch_isdir(wfname))
  	{
! 	    EMSG2(_(e_isadir2), wfname);
  	    goto theend;
  	}
  
--- 6010,6032 ----
      }
  
      if (incount <= 0)
! 	emsg(_(e_invarg));	/* need at least output and input names */
      else if (vim_strchr(gettail(wfname), '_') != NULL)
! 	emsg(_("E751: Output file name must not have region name"));
      else if (incount > MAXREGIONS)
! 	semsg(_("E754: Only up to %ld regions supported"), MAXREGIONS);
      else
      {
  	/* Check for overwriting before doing things that may take a lot of
  	 * time. */
  	if (!over_write && mch_stat((char *)wfname, &st) >= 0)
  	{
! 	    emsg(_(e_exists));
  	    goto theend;
  	}
  	if (mch_isdir(wfname))
  	{
! 	    semsg(_(e_isadir2), wfname);
  	    goto theend;
  	}
  
***************
*** 6048,6054 ****
  		if (STRLEN(gettail(innames[i])) < 5
  						|| innames[i][len - 3] != '_')
  		{
! 		    EMSG2(_("E755: Invalid region in %s"), innames[i]);
  		    goto theend;
  		}
  		spin.si_region_name[i * 2] = TOLOWER_ASC(innames[i][len - 2]);
--- 6048,6054 ----
  		if (STRLEN(gettail(innames[i])) < 5
  						|| innames[i][len - 3] != '_')
  		{
! 		    semsg(_("E755: Invalid region in %s"), innames[i]);
  		    goto theend;
  		}
  		spin.si_region_name[i * 2] = TOLOWER_ASC(innames[i][len - 2]);
***************
*** 6260,6266 ****
  
  	if (*curwin->w_s->b_p_spf == NUL)
  	{
! 	    EMSG2(_(e_notset), "spellfile");
  	    return;
  	}
  	fnamebuf = alloc(MAXPATHL);
--- 6260,6266 ----
  
  	if (*curwin->w_s->b_p_spf == NUL)
  	{
! 	    semsg(_(e_notset), "spellfile");
  	    return;
  	}
  	fnamebuf = alloc(MAXPATHL);
***************
*** 6274,6280 ****
  		break;
  	    if (*spf == NUL)
  	    {
! 		EMSGN(_("E765: 'spellfile' does not have %ld entries"), idx);
  		vim_free(fnamebuf);
  		return;
  	    }
--- 6274,6280 ----
  		break;
  	    if (*spf == NUL)
  	    {
! 		semsg(_("E765: 'spellfile' does not have %ld entries"), idx);
  		vim_free(fnamebuf);
  		return;
  	    }
***************
*** 6286,6292 ****
  	    buf = NULL;
  	if (buf != NULL && bufIsChanged(buf))
  	{
! 	    EMSG(_(e_bufloaded));
  	    vim_free(fnamebuf);
  	    return;
  	}
--- 6286,6292 ----
  	    buf = NULL;
  	if (buf != NULL && bufIsChanged(buf))
  	{
! 	    emsg(_(e_bufloaded));
  	    vim_free(fnamebuf);
  	    return;
  	}
***************
*** 6321,6327 ****
  			if (undo)
  			{
  			    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);
! 			    smsg((char_u *)_("Word '%.*s' removed from %s"),
  							 len, word, NameBuff);
  			}
  		    }
--- 6321,6327 ----
  			if (undo)
  			{
  			    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);
! 			    smsg(_("Word '%.*s' removed from %s"),
  							 len, word, NameBuff);
  			}
  		    }
***************
*** 6358,6364 ****
  	}
  
  	if (fd == NULL)
! 	    EMSG2(_(e_notopen), fname);
  	else
  	{
  	    if (bad)
--- 6358,6364 ----
  	}
  
  	if (fd == NULL)
! 	    semsg(_(e_notopen), fname);
  	else
  	{
  	    if (bad)
***************
*** 6368,6374 ****
  	    fclose(fd);
  
  	    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);
! 	    smsg((char_u *)_("Word '%.*s' added to %s"), len, word, NameBuff);
  	}
      }
  
--- 6368,6374 ----
  	    fclose(fd);
  
  	    home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);
! 	    smsg(_("Word '%.*s' added to %s"), len, word, NameBuff);
  	}
      }
  
***************
*** 6485,6491 ****
      {
  	if (*pl == NUL || *pu == NUL)
  	{
! 	    EMSG(_(e_affform));
  	    return FAIL;
  	}
  #ifdef FEAT_MBYTE
--- 6485,6491 ----
      {
  	if (*pl == NUL || *pu == NUL)
  	{
! 	    emsg(_(e_affform));
  	    return FAIL;
  	}
  #ifdef FEAT_MBYTE
***************
*** 6511,6517 ****
  	{
  	    if (f >= 256)
  	    {
! 		EMSG(_(e_affrange));
  		return FAIL;
  	    }
  	    new_st.st_fold[l] = f;
--- 6511,6517 ----
  	{
  	    if (f >= 256)
  	    {
! 		emsg(_(e_affrange));
  		return FAIL;
  	    }
  	    new_st.st_fold[l] = f;
***************
*** 6524,6530 ****
  	{
  	    if (f >= 256)
  	    {
! 		EMSG(_(e_affrange));
  		return FAIL;
  	    }
  	    new_st.st_fold[u] = f;
--- 6524,6530 ----
  	{
  	    if (f >= 256)
  	    {
! 		emsg(_(e_affrange));
  		return FAIL;
  	    }
  	    new_st.st_fold[u] = f;
***************
*** 6535,6541 ****
  
      if (*pl != NUL || *pu != NUL)
      {
! 	EMSG(_(e_affform));
  	return FAIL;
      }
  
--- 6535,6541 ----
  
      if (*pl != NUL || *pu != NUL)
      {
! 	emsg(_(e_affform));
  	return FAIL;
      }
  
***************
*** 6599,6605 ****
  		    || spelltab.st_fold[i] != new_st->st_fold[i]
  		    || spelltab.st_upper[i] != new_st->st_upper[i])
  	    {
! 		EMSG(_("E763: Word characters differ between spell files"));
  		return FAIL;
  	    }
  	}
--- 6599,6605 ----
  		    || spelltab.st_fold[i] != new_st->st_fold[i]
  		    || spelltab.st_upper[i] != new_st->st_upper[i])
  	    {
! 		emsg(_("E763: Word characters differ between spell files"));
  		return FAIL;
  	    }
  	}
***************
*** 6725,6731 ****
  		{
  		    /* This should have been checked when generating the .spl
  		     * file. */
! 		    EMSG(_("E783: duplicate char in MAP entry"));
  		    vim_free(b);
  		}
  	    }
--- 6725,6731 ----
  		{
  		    /* This should have been checked when generating the .spl
  		     * file. */
! 		    emsg(_("E783: duplicate char in MAP entry"));
  		    vim_free(b);
  		}
  	    }
*** ../vim-8.1.0742/src/structs.h	2019-01-12 22:47:01.264088074 +0100
--- src/structs.h	2019-01-13 22:54:25.947589147 +0100
***************
*** 889,896 ****
   */
  struct msglist
  {
!     char_u		*msg;		/* original message */
!     char_u		*throw_msg;	/* msg to throw: usually original one */
      struct msglist	*next;		/* next of several messages in a row */
  };
  
--- 889,896 ----
   */
  struct msglist
  {
!     char		*msg;		/* original message */
!     char		*throw_msg;	/* msg to throw: usually original one */
      struct msglist	*next;		/* next of several messages in a row */
  };
  
***************
*** 912,918 ****
  struct vim_exception
  {
      except_type_T	type;		/* exception type */
!     char_u		*value;		/* exception value */
      struct msglist	*messages;	/* message(s) causing error exception */
      char_u		*throw_name;	/* name of the throw point */
      linenr_T		throw_lnum;	/* line number of the throw point */
--- 912,918 ----
  struct vim_exception
  {
      except_type_T	type;		/* exception type */
!     char		*value;		/* exception value */
      struct msglist	*messages;	/* message(s) causing error exception */
      char_u		*throw_name;	/* name of the throw point */
      linenr_T		throw_lnum;	/* line number of the throw point */
*** ../vim-8.1.0742/src/syntax.c	2018-10-25 13:31:33.829906902 +0200
--- src/syntax.c	2019-01-13 23:15:25.553979855 +0100
***************
*** 3444,3450 ****
      else if (STRNICMP(arg, "off", 3) == 0 && next - arg == 3)
  	curwin->w_s->b_syn_conceal = FALSE;
      else
! 	EMSG2(_("E390: Illegal argument: %s"), arg);
  #endif
  }
  
--- 3444,3450 ----
      else if (STRNICMP(arg, "off", 3) == 0 && next - arg == 3)
  	curwin->w_s->b_syn_conceal = FALSE;
      else
! 	semsg(_("E390: Illegal argument: %s"), arg);
  #endif
  }
  
***************
*** 3474,3480 ****
      else if (STRNICMP(arg, "ignore", 6) == 0 && next - arg == 6)
  	curwin->w_s->b_syn_ic = TRUE;
      else
! 	EMSG2(_("E390: Illegal argument: %s"), arg);
  }
  
  /*
--- 3474,3480 ----
      else if (STRNICMP(arg, "ignore", 6) == 0 && next - arg == 6)
  	curwin->w_s->b_syn_ic = TRUE;
      else
! 	semsg(_("E390: Illegal argument: %s"), arg);
  }
  
  /*
***************
*** 3508,3514 ****
  	curwin->w_s->b_syn_spell = SYNSPL_DEFAULT;
      else
      {
! 	EMSG2(_("E390: Illegal argument: %s"), arg);
  	return;
      }
  
--- 3508,3514 ----
  	curwin->w_s->b_syn_spell = SYNSPL_DEFAULT;
      else
      {
! 	semsg(_("E390: Illegal argument: %s"), arg);
  	return;
      }
  
***************
*** 3764,3770 ****
  		id = syn_scl_namen2id(arg + 1, (int)(arg_end - arg - 1));
  		if (id == 0)
  		{
! 		    EMSG2(_("E391: No such syntax cluster: %s"), arg);
  		    break;
  		}
  		else
--- 3764,3770 ----
  		id = syn_scl_namen2id(arg + 1, (int)(arg_end - arg - 1));
  		if (id == 0)
  		{
! 		    semsg(_("E391: No such syntax cluster: %s"), arg);
  		    break;
  		}
  		else
***************
*** 3784,3790 ****
  		id = syn_namen2id(arg, (int)(arg_end - arg));
  		if (id == 0)
  		{
! 		    EMSG2(_(e_nogroup), arg);
  		    break;
  		}
  		else
--- 3784,3790 ----
  		id = syn_namen2id(arg, (int)(arg_end - arg));
  		if (id == 0)
  		{
! 		    semsg(_(e_nogroup), arg);
  		    break;
  		}
  		else
***************
*** 3969,3975 ****
  	    {
  		id = syn_scl_namen2id(arg + 1, (int)(arg_end - arg - 1));
  		if (id == 0)
! 		    EMSG2(_("E392: No such syntax cluster: %s"), arg);
  		else
  		    syn_list_cluster(id - SYNID_CLUSTER);
  	    }
--- 3969,3975 ----
  	    {
  		id = syn_scl_namen2id(arg + 1, (int)(arg_end - arg - 1));
  		if (id == 0)
! 		    semsg(_("E392: No such syntax cluster: %s"), arg);
  		else
  		    syn_list_cluster(id - SYNID_CLUSTER);
  	    }
***************
*** 3977,3983 ****
  	    {
  		id = syn_namen2id(arg, (int)(arg_end - arg));
  		if (id == 0)
! 		    EMSG2(_(e_nogroup), arg);
  		else
  		    syn_list_one(id, syncing, TRUE);
  	    }
--- 3977,3983 ----
  	    {
  		id = syn_namen2id(arg, (int)(arg_end - arg));
  		if (id == 0)
! 		    semsg(_(e_nogroup), arg);
  		else
  		    syn_list_one(id, syncing, TRUE);
  	    }
***************
*** 4650,4656 ****
  	{
  	    if (!opt->has_cont_list)
  	    {
! 		EMSG(_("E395: contains argument not accepted here"));
  		return NULL;
  	    }
  	    if (get_id_list(&arg, 8, &opt->cont_list, skip) == FAIL)
--- 4650,4656 ----
  	{
  	    if (!opt->has_cont_list)
  	    {
! 		emsg(_("E395: contains argument not accepted here"));
  		return NULL;
  	    }
  	    if (get_id_list(&arg, 8, &opt->cont_list, skip) == FAIL)
***************
*** 4689,4695 ****
  #ifdef FEAT_CONCEAL
  	    if (!vim_isprintc_strict(*conceal_char))
  	    {
! 		EMSG(_("E844: invalid cchar value"));
  		return NULL;
  	    }
  #endif
--- 4689,4695 ----
  #ifdef FEAT_CONCEAL
  	    if (!vim_isprintc_strict(*conceal_char))
  	    {
! 		emsg(_("E844: invalid cchar value"));
  		return NULL;
  	    }
  #endif
***************
*** 4705,4711 ****
  	    {
  		if (opt->sync_idx == NULL)
  		{
! 		    EMSG(_("E393: group[t]here not accepted here"));
  		    return NULL;
  		}
  		gname_start = arg;
--- 4705,4711 ----
  	    {
  		if (opt->sync_idx == NULL)
  		{
! 		    emsg(_("E393: group[t]here not accepted here"));
  		    return NULL;
  		}
  		gname_start = arg;
***************
*** 4729,4735 ****
  			}
  		    if (i < 0)
  		    {
! 			EMSG2(_("E394: Didn't find region item for %s"), gname);
  			vim_free(gname);
  			return NULL;
  		    }
--- 4729,4735 ----
  			}
  		    if (i < 0)
  		    {
! 			semsg(_("E394: Didn't find region item for %s"), gname);
  			vim_free(gname);
  			return NULL;
  		    }
***************
*** 4787,4793 ****
      int		sgl_id = 1;
      char_u	*group_name_end;
      char_u	*rest;
!     char_u	*errormsg = NULL;
      int		prev_toplvl_grp;
      int		prev_syn_inc_tag;
      int		source = FALSE;
--- 4787,4793 ----
      int		sgl_id = 1;
      char_u	*group_name_end;
      char_u	*rest;
!     char	*errormsg = NULL;
      int		prev_toplvl_grp;
      int		prev_syn_inc_tag;
      int		source = FALSE;
***************
*** 4802,4808 ****
  	rest = get_group_name(arg, &group_name_end);
  	if (rest == NULL)
  	{
! 	    EMSG((char_u *)_("E397: Filename required"));
  	    return;
  	}
  	sgl_id = syn_check_cluster(arg, (int)(group_name_end - arg));
--- 4802,4808 ----
  	rest = get_group_name(arg, &group_name_end);
  	if (rest == NULL)
  	{
! 	    emsg(_("E397: Filename required"));
  	    return;
  	}
  	sgl_id = syn_check_cluster(arg, (int)(group_name_end - arg));
***************
*** 4827,4833 ****
  	if (expand_filename(eap, syn_cmdlinep, &errormsg) == FAIL)
  	{
  	    if (errormsg != NULL)
! 		EMSG(errormsg);
  	    return;
  	}
      }
--- 4827,4833 ----
  	if (expand_filename(eap, syn_cmdlinep, &errormsg) == FAIL)
  	{
  	    if (errormsg != NULL)
! 		emsg(errormsg);
  	    return;
  	}
      }
***************
*** 4838,4844 ****
       */
      if (running_syn_inc_tag >= MAX_SYN_INC_TAG)
      {
! 	EMSG((char_u *)_("E847: Too many syntax includes"));
  	return;
      }
      prev_syn_inc_tag = current_syn_inc_tag;
--- 4838,4844 ----
       */
      if (running_syn_inc_tag >= MAX_SYN_INC_TAG)
      {
! 	emsg(_("E847: Too many syntax includes"));
  	return;
      }
      prev_syn_inc_tag = current_syn_inc_tag;
***************
*** 4847,4853 ****
      curwin->w_s->b_syn_topgrp = sgl_id;
      if (source ? do_source(eap->arg, FALSE, DOSO_NONE) == FAIL
  				: source_runtime(eap->arg, DIP_ALL) == FAIL)
! 	EMSG2(_(e_notopen), eap->arg);
      curwin->w_s->b_syn_topgrp = prev_toplvl_grp;
      current_syn_inc_tag = prev_syn_inc_tag;
  }
--- 4847,4853 ----
      curwin->w_s->b_syn_topgrp = sgl_id;
      if (source ? do_source(eap->arg, FALSE, DOSO_NONE) == FAIL
  				: source_runtime(eap->arg, DIP_ALL) == FAIL)
! 	semsg(_(e_notopen), eap->arg);
      curwin->w_s->b_syn_topgrp = prev_toplvl_grp;
      current_syn_inc_tag = prev_syn_inc_tag;
  }
***************
*** 4934,4947 ****
  			    break;
  			if (p[1] == NUL)
  			{
! 			    EMSG2(_("E789: Missing ']': %s"), kw);
  			    goto error;
  			}
  			if (p[1] == ']')
  			{
  			    if (p[2] != NUL)
  			    {
! 				EMSG3(_("E890: trailing char after ']': %s]%s"),
  								kw, &p[2]);
  				goto error;
  			    }
--- 4934,4947 ----
  			    break;
  			if (p[1] == NUL)
  			{
! 			    semsg(_("E789: Missing ']': %s"), kw);
  			    goto error;
  			}
  			if (p[1] == ']')
  			{
  			    if (p[2] != NUL)
  			    {
! 				semsg(_("E890: trailing char after ']': %s]%s"),
  								kw, &p[2]);
  				goto error;
  			    }
***************
*** 4975,4981 ****
      if (rest != NULL)
  	eap->nextcmd = check_nextcmd(rest);
      else
! 	EMSG2(_(e_invarg2), arg);
  
      redraw_curbuf_later(SOME_VALID);
      syn_stack_free_all(curwin->w_s);		/* Need to recompute all syntax. */
--- 4975,4981 ----
      if (rest != NULL)
  	eap->nextcmd = check_nextcmd(rest);
      else
! 	semsg(_(e_invarg2), arg);
  
      redraw_curbuf_later(SOME_VALID);
      syn_stack_free_all(curwin->w_s);		/* Need to recompute all syntax. */
***************
*** 5083,5089 ****
      vim_free(syn_opt_arg.next_list);
  
      if (rest == NULL)
! 	EMSG2(_(e_invarg2), arg);
  }
  
  /*
--- 5083,5089 ----
      vim_free(syn_opt_arg.next_list);
  
      if (rest == NULL)
! 	semsg(_(e_invarg2), arg);
  }
  
  /*
***************
*** 5184,5190 ****
  	if (*rest != '=')
  	{
  	    rest = NULL;
! 	    EMSG2(_("E398: Missing '=': %s"), arg);
  	    break;
  	}
  	rest = skipwhite(rest + 1);
--- 5184,5190 ----
  	if (*rest != '=')
  	{
  	    rest = NULL;
! 	    semsg(_("E398: Missing '=': %s"), arg);
  	    break;
  	}
  	rest = skipwhite(rest + 1);
***************
*** 5347,5355 ****
  	vim_free(syn_opt_arg.cont_in_list);
  	vim_free(syn_opt_arg.next_list);
  	if (not_enough)
! 	    EMSG2(_("E399: Not enough arguments: syntax region %s"), arg);
  	else if (illegal || rest == NULL)
! 	    EMSG2(_(e_invarg2), arg);
      }
  }
  
--- 5347,5355 ----
  	vim_free(syn_opt_arg.cont_in_list);
  	vim_free(syn_opt_arg.next_list);
  	if (not_enough)
! 	    semsg(_("E399: Not enough arguments: syntax region %s"), arg);
  	else if (illegal || rest == NULL)
! 	    semsg(_(e_invarg2), arg);
      }
  }
  
***************
*** 5578,5584 ****
      len = curwin->w_s->b_syn_clusters.ga_len;
      if (len >= MAX_CLUSTER_ID)
      {
! 	EMSG((char_u *)_("E848: Too many syntax clusters"));
  	vim_free(name);
  	return 0;
      }
--- 5578,5584 ----
      len = curwin->w_s->b_syn_clusters.ga_len;
      if (len >= MAX_CLUSTER_ID)
      {
! 	emsg(_("E848: Too many syntax clusters"));
  	vim_free(name);
  	return 0;
      }
***************
*** 5661,5667 ****
  	    clstr_list = NULL;
  	    if (get_id_list(&rest, opt_len, &clstr_list, eap->skip) == FAIL)
  	    {
! 		EMSG2(_(e_invarg2), rest);
  		break;
  	    }
  	    if (scl_id >= 0)
--- 5661,5667 ----
  	    clstr_list = NULL;
  	    if (get_id_list(&rest, opt_len, &clstr_list, eap->skip) == FAIL)
  	    {
! 		semsg(_(e_invarg2), rest);
  		break;
  	    }
  	    if (scl_id >= 0)
***************
*** 5680,5688 ****
      }
  
      if (!got_clstr)
! 	EMSG(_("E400: No cluster specified"));
      if (rest == NULL || !ends_excmd(*rest))
! 	EMSG2(_(e_invarg2), arg);
  }
  
  /*
--- 5680,5688 ----
      }
  
      if (!got_clstr)
! 	emsg(_("E400: No cluster specified"));
      if (rest == NULL || !ends_excmd(*rest))
! 	semsg(_(e_invarg2), arg);
  }
  
  /*
***************
*** 5715,5721 ****
      end = skip_regexp(arg + 1, *arg, TRUE, NULL);
      if (*end != *arg)			    /* end delimiter not found */
      {
! 	EMSG2(_("E401: Pattern delimiter not found: %s"), arg);
  	return NULL;
      }
      /* store the pattern and compiled regexp program */
--- 5715,5721 ----
      end = skip_regexp(arg + 1, *arg, TRUE, NULL);
      if (*end != *arg)			    /* end delimiter not found */
      {
! 	semsg(_("E401: Pattern delimiter not found: %s"), arg);
  	return NULL;
      }
      /* store the pattern and compiled regexp program */
***************
*** 5793,5799 ****
  
      if (!ends_excmd(*end) && !VIM_ISWHITE(*end))
      {
! 	EMSG2(_("E402: Garbage after pattern: %s"), arg);
  	return NULL;
      }
      return skipwhite(end);
--- 5793,5799 ----
  
      if (!ends_excmd(*end) && !VIM_ISWHITE(*end))
      {
! 	semsg(_("E402: Garbage after pattern: %s"), arg);
  	return NULL;
      }
      return skipwhite(end);
***************
*** 5885,5891 ****
  	    }
  	    if (curwin->w_s->b_syn_linecont_pat != NULL)
  	    {
! 		EMSG(_("E403: syntax sync: line continuations pattern specified twice"));
  		finished = TRUE;
  		break;
  	    }
--- 5885,5891 ----
  	    }
  	    if (curwin->w_s->b_syn_linecont_pat != NULL)
  	    {
! 		emsg(_("E403: syntax sync: line continuations pattern specified twice"));
  		finished = TRUE;
  		break;
  	    }
***************
*** 5944,5950 ****
      }
      vim_free(key);
      if (illegal)
! 	EMSG2(_("E404: Illegal arguments: %s"), arg_start);
      else if (!finished)
      {
  	eap->nextcmd = check_nextcmd(arg_start);
--- 5944,5950 ----
      }
      vim_free(key);
      if (illegal)
! 	semsg(_("E404: Illegal arguments: %s"), arg_start);
      else if (!finished)
      {
  	eap->nextcmd = check_nextcmd(arg_start);
***************
*** 5995,6007 ****
  	p = skipwhite(*arg + keylen);
  	if (*p != '=')
  	{
! 	    EMSG2(_("E405: Missing equal sign: %s"), *arg);
  	    break;
  	}
  	p = skipwhite(p + 1);
  	if (ends_excmd(*p))
  	{
! 	    EMSG2(_("E406: Empty argument: %s"), *arg);
  	    break;
  	}
  
--- 5995,6007 ----
  	p = skipwhite(*arg + keylen);
  	if (*p != '=')
  	{
! 	    semsg(_("E405: Missing equal sign: %s"), *arg);
  	    break;
  	}
  	p = skipwhite(p + 1);
  	if (ends_excmd(*p))
  	{
! 	    semsg(_("E406: Empty argument: %s"), *arg);
  	    break;
  	}
  
***************
*** 6027,6040 ****
  	    {
  		if (TOUPPER_ASC(**arg) != 'C')
  		{
! 		    EMSG2(_("E407: %s not allowed here"), name + 1);
  		    failed = TRUE;
  		    vim_free(name);
  		    break;
  		}
  		if (count != 0)
  		{
! 		    EMSG2(_("E408: %s must be first in contains list"),
  								     name + 1);
  		    failed = TRUE;
  		    vim_free(name);
--- 6027,6040 ----
  	    {
  		if (TOUPPER_ASC(**arg) != 'C')
  		{
! 		    semsg(_("E407: %s not allowed here"), name + 1);
  		    failed = TRUE;
  		    vim_free(name);
  		    break;
  		}
  		if (count != 0)
  		{
! 		    semsg(_("E408: %s must be first in contains list"),
  								     name + 1);
  		    failed = TRUE;
  		    vim_free(name);
***************
*** 6108,6114 ****
  	    vim_free(name);
  	    if (id == 0)
  	    {
! 		EMSG2(_("E409: Unknown group name: %s"), p);
  		failed = TRUE;
  		break;
  	    }
--- 6108,6114 ----
  	    vim_free(name);
  	    if (id == 0)
  	    {
! 		semsg(_("E409: Unknown group name: %s"), p);
  		failed = TRUE;
  		break;
  	    }
***************
*** 6343,6349 ****
  	{
  	    if (subcommands[i].name == NULL)
  	    {
! 		EMSG2(_("E410: Invalid :syntax subcommand: %s"), subcmd_name);
  		break;
  	    }
  	    if (STRCMP(subcmd_name, (char_u *)subcommands[i].name) == 0)
--- 6343,6349 ----
  	{
  	    if (subcommands[i].name == NULL)
  	    {
! 		semsg(_("E410: Invalid :syntax subcommand: %s"), subcmd_name);
  		break;
  	    }
  	    if (STRCMP(subcmd_name, (char_u *)subcommands[i].name) == 0)
***************
*** 6648,6654 ****
      else if (STRCMP(eap->arg, "report") == 0)
  	syntime_report();
      else
! 	EMSG2(_(e_invarg2), eap->arg);
  }
  
      static void
--- 6648,6654 ----
      else if (STRCMP(eap->arg, "report") == 0)
  	syntime_report();
      else
! 	semsg(_(e_invarg2), eap->arg);
  }
  
      static void
***************
*** 7158,7164 ****
  	static int	recursive = 0;
  
  	if (recursive >= 5)
! 	    EMSG(_("E679: recursive loop loading syncolor.vim"));
  	else
  	{
  	    ++recursive;
--- 7158,7164 ----
  	static int	recursive = 0;
  
  	if (recursive >= 5)
! 	    emsg(_("E679: recursive loop loading syncolor.vim"));
  	else
  	{
  	    ++recursive;
***************
*** 7407,7413 ****
      {
  	id = syn_namen2id(line, (int)(name_end - line));
  	if (id == 0)
! 	    EMSG2(_("E411: highlight group not found: %s"), line);
  	else
  	    highlight_list_one(id);
  	return;
--- 7407,7413 ----
      {
  	id = syn_namen2id(line, (int)(name_end - line));
  	if (id == 0)
! 	    semsg(_("E411: highlight group not found: %s"), line);
  	else
  	    highlight_list_one(id);
  	return;
***************
*** 7431,7444 ****
  
  	if (ends_excmd(*from_start) || ends_excmd(*to_start))
  	{
! 	    EMSG2(_("E412: Not enough arguments: \":highlight link %s\""),
  								  from_start);
  	    return;
  	}
  
  	if (!ends_excmd(*skipwhite(to_end)))
  	{
! 	    EMSG2(_("E413: Too many arguments: \":highlight link %s\""), from_start);
  	    return;
  	}
  
--- 7431,7444 ----
  
  	if (ends_excmd(*from_start) || ends_excmd(*to_start))
  	{
! 	    semsg(_("E412: Not enough arguments: \":highlight link %s\""),
  								  from_start);
  	    return;
  	}
  
  	if (!ends_excmd(*skipwhite(to_end)))
  	{
! 	    semsg(_("E413: Too many arguments: \":highlight link %s\""), from_start);
  	    return;
  	}
  
***************
*** 7458,7464 ****
  				   && hl_has_settings(from_id - 1, dodefault))
  	    {
  		if (sourcing_name == NULL && !dodefault)
! 		    EMSG(_("E414: group has settings, highlight link ignored"));
  	    }
  	    else if (HL_TABLE()[from_id - 1].sg_link != to_id
  #ifdef FEAT_EVAL
--- 7458,7464 ----
  				   && hl_has_settings(from_id - 1, dodefault))
  	    {
  		if (sourcing_name == NULL && !dodefault)
! 		    emsg(_("E414: group has settings, highlight link ignored"));
  	    }
  	    else if (HL_TABLE()[from_id - 1].sg_link != to_id
  #ifdef FEAT_EVAL
***************
*** 7605,7611 ****
  	key_start = linep;
  	if (*linep == '=')
  	{
! 	    EMSG2(_("E415: unexpected equal sign: %s"), key_start);
  	    error = TRUE;
  	    break;
  	}
--- 7605,7611 ----
  	key_start = linep;
  	if (*linep == '=')
  	{
! 	    semsg(_("E415: unexpected equal sign: %s"), key_start);
  	    error = TRUE;
  	    break;
  	}
***************
*** 7641,7647 ****
  	 */
  	if (*linep != '=')
  	{
! 	    EMSG2(_("E416: missing equal sign: %s"), key_start);
  	    error = TRUE;
  	    break;
  	}
--- 7641,7647 ----
  	 */
  	if (*linep != '=')
  	{
! 	    semsg(_("E416: missing equal sign: %s"), key_start);
  	    error = TRUE;
  	    break;
  	}
***************
*** 7657,7663 ****
  	    linep = vim_strchr(linep, '\'');
  	    if (linep == NULL)
  	    {
! 		EMSG2(_(e_invarg2), key_start);
  		error = TRUE;
  		break;
  	    }
--- 7657,7663 ----
  	    linep = vim_strchr(linep, '\'');
  	    if (linep == NULL)
  	    {
! 		semsg(_(e_invarg2), key_start);
  		error = TRUE;
  		break;
  	    }
***************
*** 7669,7675 ****
  	}
  	if (linep == arg_start)
  	{
! 	    EMSG2(_("E417: missing argument: %s"), key_start);
  	    error = TRUE;
  	    break;
  	}
--- 7669,7675 ----
  	}
  	if (linep == arg_start)
  	{
! 	    semsg(_("E417: missing argument: %s"), key_start);
  	    error = TRUE;
  	    break;
  	}
***************
*** 7706,7712 ****
  		}
  		if (i < 0)
  		{
! 		    EMSG2(_("E418: Illegal value: %s"), arg);
  		    error = TRUE;
  		    break;
  		}
--- 7706,7712 ----
  		}
  		if (i < 0)
  		{
! 		    semsg(_("E418: Illegal value: %s"), arg);
  		    error = TRUE;
  		    break;
  		}
***************
*** 7831,7837 ****
  		    color = cterm_normal_fg_color - 1;
  		else
  		{
! 		    EMSG(_("E419: FG color unknown"));
  		    error = TRUE;
  		    break;
  		}
--- 7831,7837 ----
  		    color = cterm_normal_fg_color - 1;
  		else
  		{
! 		    emsg(_("E419: FG color unknown"));
  		    error = TRUE;
  		    break;
  		}
***************
*** 7842,7848 ****
  		    color = cterm_normal_bg_color - 1;
  		else
  		{
! 		    EMSG(_("E420: BG color unknown"));
  		    error = TRUE;
  		    break;
  		}
--- 7842,7848 ----
  		    color = cterm_normal_bg_color - 1;
  		else
  		{
! 		    emsg(_("E420: BG color unknown"));
  		    error = TRUE;
  		    break;
  		}
***************
*** 7866,7872 ****
  			break;
  		if (i < 0)
  		{
! 		    EMSG2(_("E421: Color name or number not recognized: %s"), key_start);
  		    error = TRUE;
  		    break;
  		}
--- 7866,7872 ----
  			break;
  		if (i < 0)
  		{
! 		    semsg(_("E421: Color name or number not recognized: %s"), key_start);
  		    error = TRUE;
  		    break;
  		}
***************
*** 8113,8119 ****
  		    /* Append it to the already found stuff */
  		    if ((int)(STRLEN(buf) + STRLEN(p)) >= 99)
  		    {
! 			EMSG2(_("E422: terminal code too long: %s"), arg);
  			error = TRUE;
  			break;
  		    }
--- 8113,8119 ----
  		    /* Append it to the already found stuff */
  		    if ((int)(STRLEN(buf) + STRLEN(p)) >= 99)
  		    {
! 			semsg(_("E422: terminal code too long: %s"), arg);
  			error = TRUE;
  			break;
  		    }
***************
*** 8160,8166 ****
  	}
  	else
  	{
! 	    EMSG2(_("E423: Illegal argument: %s"), key_start);
  	    error = TRUE;
  	    break;
  	}
--- 8160,8166 ----
  	}
  	else
  	{
! 	    semsg(_("E423: Illegal argument: %s"), key_start);
  	    error = TRUE;
  	    break;
  	}
***************
*** 8827,8833 ****
  	 */
  	if (recursive)
  	{
! 	    EMSG(_("E424: Too many different highlighting attributes in use"));
  	    return 0;
  	}
  	recursive = TRUE;
--- 8827,8833 ----
  	 */
  	if (recursive)
  	{
! 	    emsg(_("E424: Too many different highlighting attributes in use"));
  	    return 0;
  	}
  	recursive = TRUE;
***************
*** 9716,9722 ****
      {
  	if (!vim_isprintc(*p))
  	{
! 	    EMSG(_("E669: Unprintable character in group name"));
  	    vim_free(name);
  	    return 0;
  	}
--- 9716,9722 ----
      {
  	if (!vim_isprintc(*p))
  	{
! 	    emsg(_("E669: Unprintable character in group name"));
  	    vim_free(name);
  	    return 0;
  	}
***************
*** 9741,9747 ****
  
      if (highlight_ga.ga_len >= MAX_HL_ID)
      {
! 	EMSG(_("E849: Too many highlight and syntax groups"));
  	vim_free(name);
  	return 0;
      }
--- 9741,9747 ----
  
      if (highlight_ga.ga_len >= MAX_HL_ID)
      {
! 	emsg(_("E849: Too many highlight and syntax groups"));
  	vim_free(name);
  	return 0;
      }
*** ../vim-8.1.0742/src/tag.c	2018-12-21 16:04:16.316437487 +0100
--- src/tag.c	2019-01-13 19:57:42.397352867 +0100
***************
*** 279,285 ****
  		    tagstacklen == 0)
  	    {
  		/* empty stack */
! 		EMSG(_(e_tagstack));
  		goto end_do_tag;
  	    }
  
--- 279,285 ----
  		    tagstacklen == 0)
  	    {
  		/* empty stack */
! 		emsg(_(e_tagstack));
  		goto end_do_tag;
  	    }
  
***************
*** 290,296 ****
  #endif
  		if ((tagstackidx -= count) < 0)
  		{
! 		    EMSG(_(bottommsg));
  		    if (tagstackidx + count == 0)
  		    {
  			/* We did [num]^T from the bottom of the stack */
--- 290,296 ----
  #endif
  		if ((tagstackidx -= count) < 0)
  		{
! 		    emsg(_(bottommsg));
  		    if (tagstackidx + count == 0)
  		    {
  			/* We did [num]^T from the bottom of the stack */
***************
*** 304,310 ****
  		}
  		else if (tagstackidx >= tagstacklen)    /* count == 0? */
  		{
! 		    EMSG(_(topmsg));
  		    goto end_do_tag;
  		}
  
--- 304,310 ----
  		}
  		else if (tagstackidx >= tagstacklen)    /* count == 0? */
  		{
! 		    emsg(_(topmsg));
  		    goto end_do_tag;
  		}
  
***************
*** 375,386 ****
  			 * position.
  			 */
  			tagstackidx = tagstacklen - 1;
! 			EMSG(_(topmsg));
  			save_pos = FALSE;
  		    }
  		    else if (tagstackidx < 0)	/* must have been count == 0 */
  		    {
! 			EMSG(_(bottommsg));
  			tagstackidx = 0;
  			goto end_do_tag;
  		    }
--- 375,386 ----
  			 * position.
  			 */
  			tagstackidx = tagstacklen - 1;
! 			emsg(_(topmsg));
  			save_pos = FALSE;
  		    }
  		    else if (tagstackidx < 0)	/* must have been count == 0 */
  		    {
! 			emsg(_(bottommsg));
  			tagstackidx = 0;
  			goto end_do_tag;
  		    }
***************
*** 424,430 ****
  		    cur_match = MAXCOL - 1;
  		else if (cur_match < 0)
  		{
! 		    EMSG(_("E425: Cannot go before first matching tag"));
  		    skip_msg = TRUE;
  		    cur_match = 0;
  		    cur_fnum = curbuf->b_fnum;
--- 424,430 ----
  		    cur_match = MAXCOL - 1;
  		else if (cur_match < 0)
  		{
! 		    emsg(_("E425: Cannot go before first matching tag"));
  		    skip_msg = TRUE;
  		    cur_match = 0;
  		    cur_fnum = curbuf->b_fnum;
***************
*** 566,572 ****
  	if (num_matches <= 0)
  	{
  	    if (verbose)
! 		EMSG2(_("E426: tag not found: %s"), name);
  #if defined(FEAT_QUICKFIX)
  	    g_do_tagpreview = 0;
  #endif
--- 566,572 ----
  	if (num_matches <= 0)
  	{
  	    if (verbose)
! 		semsg(_("E426: tag not found: %s"), name);
  #if defined(FEAT_QUICKFIX)
  	    g_do_tagpreview = 0;
  #endif
***************
*** 950,963 ****
  	    {
  		/* Avoid giving this error when a file wasn't found and we're
  		 * looking for a match in another file, which wasn't found.
! 		 * There will be an EMSG("file doesn't exist") below then. */
  		if ((type == DT_NEXT || type == DT_FIRST)
  						      && nofile_fname == NULL)
  		{
  		    if (num_matches == 1)
! 			EMSG(_("E427: There is only one matching tag"));
  		    else
! 			EMSG(_("E428: Cannot go beyond last matching tag"));
  		    skip_msg = TRUE;
  		}
  		cur_match = num_matches - 1;
--- 950,963 ----
  	    {
  		/* Avoid giving this error when a file wasn't found and we're
  		 * looking for a match in another file, which wasn't found.
! 		 * There will be an emsg("file doesn't exist") below then. */
  		if ((type == DT_NEXT || type == DT_FIRST)
  						      && nofile_fname == NULL)
  		{
  		    if (num_matches == 1)
! 			emsg(_("E427: There is only one matching tag"));
  		    else
! 			emsg(_("E428: Cannot go beyond last matching tag"));
  		    skip_msg = TRUE;
  		}
  		cur_match = num_matches - 1;
***************
*** 978,987 ****
  
  	    /*
  	     * Only when going to try the next match, report that the previous
! 	     * file didn't exist.  Otherwise an EMSG() is given below.
  	     */
  	    if (nofile_fname != NULL && error_cur_match != cur_match)
! 		smsg((char_u *)_("File \"%s\" does not exist"), nofile_fname);
  
  
  	    ic = (matches[cur_match][0] & MT_IC_OFF);
--- 978,987 ----
  
  	    /*
  	     * Only when going to try the next match, report that the previous
! 	     * file didn't exist.  Otherwise an emsg() is given below.
  	     */
  	    if (nofile_fname != NULL && error_cur_match != cur_match)
! 		smsg(_("File \"%s\" does not exist"), nofile_fname);
  
  
  	    ic = (matches[cur_match][0] & MT_IC_OFF);
***************
*** 1053,1059 ****
  		    }
  		    continue;
  		}
! 		EMSG2(_("E429: File \"%s\" does not exist"), nofile_fname);
  	    }
  	    else
  	    {
--- 1053,1059 ----
  		    }
  		    continue;
  		}
! 		semsg(_("E429: File \"%s\" does not exist"), nofile_fname);
  	    }
  	    else
  	    {
***************
*** 1577,1583 ****
  	    if (p_verbose >= 5)
  	    {
  		verbose_enter();
! 		smsg((char_u *)_("Searching tags file %s"), tag_fname);
  		verbose_leave();
  	    }
  	}
--- 1577,1583 ----
  	    if (p_verbose >= 5)
  	    {
  		verbose_enter();
! 		smsg(_("Searching tags file %s"), tag_fname);
  		verbose_leave();
  	    }
  	}
***************
*** 1801,1807 ****
  				if (fp != NULL)
  				{
  				    if (STRLEN(fullpath_ebuf) > LSIZE)
! 					  EMSG2(_("E430: Tag file path truncated for %s\n"), ebuf);
  				    vim_strncpy(tag_fname, fullpath_ebuf,
  								    MAXPATHL);
  				    ++incstack_idx;
--- 1801,1807 ----
  				if (fp != NULL)
  				{
  				    if (STRLEN(fullpath_ebuf) > LSIZE)
! 					  semsg(_("E430: Tag file path truncated for %s\n"), ebuf);
  				    vim_strncpy(tag_fname, fullpath_ebuf,
  								    MAXPATHL);
  				    ++incstack_idx;
***************
*** 2451,2461 ****
  
  	if (line_error)
  	{
! 	    EMSG2(_("E431: Format error in tags file \"%s\""), tag_fname);
  #ifdef FEAT_CSCOPE
  	    if (!use_cscope)
  #endif
! 		EMSGN(_("Before byte %ld"), (long)vim_ftell(fp));
  	    stop_searching = TRUE;
  	    line_error = FALSE;
  	}
--- 2451,2461 ----
  
  	if (line_error)
  	{
! 	    semsg(_("E431: Format error in tags file \"%s\""), tag_fname);
  #ifdef FEAT_CSCOPE
  	    if (!use_cscope)
  #endif
! 		semsg(_("Before byte %ld"), (long)vim_ftell(fp));
  	    stop_searching = TRUE;
  	    line_error = FALSE;
  	}
***************
*** 2481,2487 ****
  	tag_file_sorted = NUL;
  	if (sort_error)
  	{
! 	    EMSG2(_("E432: Tags file not sorted: %s"), tag_fname);
  	    sort_error = FALSE;
  	}
  #endif
--- 2481,2487 ----
  	tag_file_sorted = NUL;
  	if (sort_error)
  	{
! 	    semsg(_("E432: Tags file not sorted: %s"), tag_fname);
  	    sort_error = FALSE;
  	}
  #endif
***************
*** 2525,2531 ****
      if (!stop_searching)
      {
  	if (!did_open && verbose)	/* never opened any tags file */
! 	    EMSG(_("E433: No tags file"));
  	retval = OK;		/* It's OK even when no tag found */
      }
  
--- 2525,2531 ----
      if (!stop_searching)
      {
  	if (!did_open && verbose)	/* never opened any tags file */
! 	    emsg(_("E433: No tags file"));
  	retval = OK;		/* It's OK even when no tag found */
      }
  
***************
*** 3370,3376 ****
  		}
  		if (found == 0)
  		{
! 		    EMSG(_("E434: Can't find tag pattern"));
  		    curwin->w_cursor.lnum = save_lnum;
  		}
  		else
--- 3370,3376 ----
  		}
  		if (found == 0)
  		{
! 		    emsg(_("E434: Can't find tag pattern"));
  		    curwin->w_cursor.lnum = save_lnum;
  		}
  		else
***************
*** 3895,3901 ****
  	if (p_verbose > 0)
  	{
  	    verbose_enter();
! 	    smsg((char_u *)_("Duplicate field name: %s"), field_name);
  	    verbose_leave();
  	}
  	return FAIL;
--- 3895,3901 ----
  	if (p_verbose > 0)
  	{
  	    verbose_enter();
! 	    smsg(_("Duplicate field name: %s"), field_name);
  	    verbose_leave();
  	}
  	return FAIL;
***************
*** 4200,4206 ****
      {
  	if (di->di_tv.v_type != VAR_LIST)
  	{
! 	    EMSG(_(e_listreq));
  	    return FAIL;
  	}
  	l = di->di_tv.vval.v_list;
--- 4200,4206 ----
      {
  	if (di->di_tv.v_type != VAR_LIST)
  	{
! 	    emsg(_(e_listreq));
  	    return FAIL;
  	}
  	l = di->di_tv.vval.v_list;
*** ../vim-8.1.0742/src/term.c	2018-12-07 13:18:16.611655653 +0100
--- src/term.c	2019-01-13 23:17:25.865051566 +0100
***************
*** 92,98 ****
  static int term_7to8bit(char_u *p);
  
  #ifdef HAVE_TGETENT
! static char_u *tgetent_error(char_u *, char_u *);
  
  /*
   * Here is our own prototype for tgetstr(), any prototypes from the include
--- 92,98 ----
  static int term_7to8bit(char_u *p);
  
  #ifdef HAVE_TGETENT
! static char *tgetent_error(char_u *, char_u *);
  
  /*
   * Here is our own prototype for tgetstr(), any prototypes from the include
***************
*** 1357,1363 ****
      t = termgui_mch_get_color(name);
  
      if (t == INVALCOLOR)
! 	EMSG2(_("E254: Cannot allocate color %s"), name);
      return t;
  }
  
--- 1357,1363 ----
      t = termgui_mch_get_color(name);
  
      if (t == INVALCOLOR)
! 	semsg(_("E254: Cannot allocate color %s"), name);
      return t;
  }
  
***************
*** 1696,1709 ****
  #endif
  
      static void
! report_term_error(char_u *error_msg, char_u *term)
  {
      struct builtin_term *termp;
  
      mch_errmsg("\r\n");
      if (error_msg != NULL)
      {
! 	mch_errmsg((char *)error_msg);
  	mch_errmsg("\r\n");
      }
      mch_errmsg("'");
--- 1696,1709 ----
  #endif
  
      static void
! report_term_error(char *error_msg, char_u *term)
  {
      struct builtin_term *termp;
  
      mch_errmsg("\r\n");
      if (error_msg != NULL)
      {
! 	mch_errmsg(error_msg);
  	mch_errmsg("\r\n");
      }
      mch_errmsg("'");
***************
*** 1756,1762 ****
      int		termcap_cleared = FALSE;
  #endif
      int		width = 0, height = 0;
!     char_u	*error_msg = NULL;
      char_u	*bs_p, *del_p;
  
      /* In silect mode (ex -s) we don't use the 'term' option. */
--- 1756,1762 ----
      int		termcap_cleared = FALSE;
  #endif
      int		width = 0, height = 0;
!     char	*error_msg = NULL;
      char_u	*bs_p, *del_p;
  
      /* In silect mode (ex -s) we don't use the 'term' option. */
***************
*** 2191,2197 ****
   * Call tgetent()
   * Return error message if it fails, NULL if it's OK.
   */
!     static char_u *
  tgetent_error(char_u *tbuf, char_u *term)
  {
      int	    i;
--- 2191,2197 ----
   * Call tgetent()
   * Return error message if it fails, NULL if it's OK.
   */
!     static char *
  tgetent_error(char_u *tbuf, char_u *term)
  {
      int	    i;
***************
*** 2210,2222 ****
  
  	if (i < 0)
  # ifdef TGETENT_ZERO_ERR
! 	    return (char_u *)_("E557: Cannot open termcap file");
  	if (i == 0)
  # endif
  #ifdef TERMINFO
! 	    return (char_u *)_("E558: Terminal entry not found in terminfo");
  #else
! 	    return (char_u *)_("E559: Terminal entry not found in termcap");
  #endif
      }
      return NULL;
--- 2210,2222 ----
  
  	if (i < 0)
  # ifdef TGETENT_ZERO_ERR
! 	    return _("E557: Cannot open termcap file");
  	if (i == 0)
  # endif
  #ifdef TERMINFO
! 	    return _("E558: Terminal entry not found in terminfo");
  #else
! 	    return _("E559: Terminal entry not found in termcap");
  #endif
      }
      return NULL;
***************
*** 2282,2288 ****
      char_u  tbuf[TBUFSZ];
      char_u  tstrbuf[TBUFSZ];
      char_u  *tp = tstrbuf;
!     char_u  *error_msg = NULL;
  #endif
  
  /*
--- 2282,2288 ----
      char_u  tbuf[TBUFSZ];
      char_u  tstrbuf[TBUFSZ];
      char_u  *tp = tstrbuf;
!     char    *error_msg = NULL;
  #endif
  
  /*
***************
*** 2369,2378 ****
      {
  #ifdef HAVE_TGETENT
  	if (error_msg != NULL)
! 	    EMSG(error_msg);
  	else
  #endif
! 	    EMSG2(_("E436: No \"%s\" entry in termcap"), name);
      }
      return FAIL;
  }
--- 2369,2378 ----
      {
  #ifdef HAVE_TGETENT
  	if (error_msg != NULL)
! 	    emsg(error_msg);
  	else
  #endif
! 	    semsg(_("E436: No \"%s\" entry in termcap"), name);
      }
      return FAIL;
  }
***************
*** 3055,3061 ****
       * MUST have "cm": cursor motion.
       */
      if (*T_CM == NUL)
! 	EMSG(_("E437: terminal capability \"cm\" required"));
  
      /*
       * if "cs" defined, use a scroll region, it's faster.
--- 3055,3061 ----
       * MUST have "cm": cursor motion.
       */
      if (*T_CM == NUL)
! 	emsg(_("E437: terminal capability \"cm\" required"));
  
      /*
       * if "cs" defined, use a scroll region, it's faster.
***************
*** 6153,6159 ****
  	    if (STRNICMP(src, "<SID>", 5) == 0)
  	    {
  		if (current_sctx.sc_sid <= 0)
! 		    EMSG(_(e_usingsid));
  		else
  		{
  		    src += 5;
--- 6153,6159 ----
  	    if (STRNICMP(src, "<SID>", 5) == 0)
  	    {
  		if (current_sctx.sc_sid <= 0)
! 		    emsg(_(e_usingsid));
  		else
  		{
  		    src += 5;
*** ../vim-8.1.0742/src/terminal.c	2019-01-03 22:19:22.231686171 +0100
--- src/terminal.c	2019-01-13 19:57:49.569292936 +0100
***************
*** 377,383 ****
  	|| (!(opt->jo_set & JO_OUT_IO) && (opt->jo_set & JO_OUT_BUF))
  	|| (!(opt->jo_set & JO_ERR_IO) && (opt->jo_set & JO_ERR_BUF)))
      {
! 	EMSG(_(e_invarg));
  	return NULL;
      }
  
--- 377,383 ----
  	|| (!(opt->jo_set & JO_OUT_IO) && (opt->jo_set & JO_OUT_BUF))
  	|| (!(opt->jo_set & JO_ERR_IO) && (opt->jo_set & JO_ERR_BUF)))
      {
! 	emsg(_(e_invarg));
  	return NULL;
      }
  
***************
*** 719,725 ****
  	{
  	    if (*p)
  		*p = NUL;
! 	    EMSG2(_("E181: Invalid attribute: %s"), cmd);
  	    goto theend;
  	}
  	cmd = skipwhite(p);
--- 719,725 ----
  	{
  	    if (*p)
  		*p = NUL;
! 	    semsg(_("E181: Invalid attribute: %s"), cmd);
  	    goto theend;
  	}
  	cmd = skipwhite(p);
***************
*** 3487,3493 ****
  	    && (var->di_tv.v_type != VAR_LIST
  		|| var->di_tv.vval.v_list == NULL
  		|| set_ansi_colors_list(vterm, var->di_tv.vval.v_list) == FAIL))
! 	EMSG2(_(e_invarg2), "g:terminal_ansi_colors");
  }
  #endif
  
--- 3487,3493 ----
  	    && (var->di_tv.v_type != VAR_LIST
  		|| var->di_tv.vval.v_list == NULL
  		|| set_ansi_colors_list(vterm, var->di_tv.vval.v_list) == FAIL))
! 	semsg(_(e_invarg2), "g:terminal_ansi_colors");
  }
  #endif
  
***************
*** 3914,3920 ****
      term = buf->b_term;
      if (term->tl_vterm == NULL)
      {
! 	EMSG(_("E958: Job already finished"));
  	return;
      }
  
--- 3914,3920 ----
      term = buf->b_term;
      if (term->tl_vterm == NULL)
      {
! 	emsg(_("E958: Job already finished"));
  	return;
      }
  
***************
*** 3924,3930 ****
  
  	if (argvars[2].v_type != VAR_DICT)
  	{
! 	    EMSG(_(e_dictreq));
  	    return;
  	}
  	d = argvars[2].vval.v_dict;
--- 3924,3930 ----
  
  	if (argvars[2].v_type != VAR_DICT)
  	{
! 	    emsg(_(e_dictreq));
  	    return;
  	}
  	d = argvars[2].vval.v_dict;
***************
*** 3940,3952 ****
  	return;
      if (mch_stat((char *)fname, &st) >= 0)
      {
! 	EMSG2(_("E953: File exists: %s"), fname);
  	return;
      }
  
      if (*fname == NUL || (fd = mch_fopen((char *)fname, WRITEBIN)) == NULL)
      {
! 	EMSG2(_(e_notcreate), *fname == NUL ? (char_u *)_("<empty>") : fname);
  	return;
      }
  
--- 3940,3952 ----
  	return;
      if (mch_stat((char *)fname, &st) >= 0)
      {
! 	semsg(_("E953: File exists: %s"), fname);
  	return;
      }
  
      if (*fname == NUL || (fd = mch_fopen((char *)fname, WRITEBIN)) == NULL)
      {
! 	semsg(_(e_notcreate), *fname == NUL ? (char_u *)_("<empty>") : fname);
  	return;
      }
  
***************
*** 4389,4401 ****
  	fname2 = tv_get_string_buf_chk(&argvars[1], buf2);
      if (fname1 == NULL || (do_diff && fname2 == NULL))
      {
! 	EMSG(_(e_invarg));
  	return;
      }
      fd1 = mch_fopen((char *)fname1, READBIN);
      if (fd1 == NULL)
      {
! 	EMSG2(_(e_notread), fname1);
  	return;
      }
      if (do_diff)
--- 4389,4401 ----
  	fname2 = tv_get_string_buf_chk(&argvars[1], buf2);
      if (fname1 == NULL || (do_diff && fname2 == NULL))
      {
! 	emsg(_(e_invarg));
  	return;
      }
      fd1 = mch_fopen((char *)fname1, READBIN);
      if (fd1 == NULL)
      {
! 	semsg(_(e_notread), fname1);
  	return;
      }
      if (do_diff)
***************
*** 4404,4410 ****
  	if (fd2 == NULL)
  	{
  	    fclose(fd1);
! 	    EMSG2(_(e_notread), fname2);
  	    return;
  	}
      }
--- 4404,4410 ----
  	if (fd2 == NULL)
  	{
  	    fclose(fd1);
! 	    semsg(_(e_notread), fname2);
  	    return;
  	}
      }
***************
*** 4922,4928 ****
  
      if (buf == NULL)
      {
! 	EMSG(_("E955: Not a terminal buffer"));
  	return;
      }
      if (buf->b_term->tl_vterm == NULL)
--- 4922,4928 ----
  
      if (buf == NULL)
      {
! 	emsg(_("E955: Not a terminal buffer"));
  	return;
      }
      if (buf->b_term->tl_vterm == NULL)
***************
*** 5007,5013 ****
  		p = buf->b_term->tl_job->jv_tty_in;
  	    break;
  	default:
! 	    EMSG2(_(e_invarg2), tv_get_string(&argvars[1]));
  	    return;
      }
      if (p != NULL)
--- 5007,5013 ----
  		p = buf->b_term->tl_job->jv_tty_in;
  	    break;
  	default:
! 	    semsg(_(e_invarg2), tv_get_string(&argvars[1]));
  	    return;
      }
      if (p != NULL)
***************
*** 5236,5247 ****
  
      if (argvars[1].v_type != VAR_LIST || argvars[1].vval.v_list == NULL)
      {
! 	EMSG(_(e_listreq));
  	return;
      }
  
      if (set_ansi_colors_list(term->tl_vterm, argvars[1].vval.v_list) == FAIL)
! 	EMSG(_(e_invarg));
  }
  #endif
  
--- 5236,5247 ----
  
      if (argvars[1].v_type != VAR_LIST || argvars[1].vval.v_list == NULL)
      {
! 	emsg(_(e_listreq));
  	return;
      }
  
      if (set_ansi_colors_list(term->tl_vterm, argvars[1].vval.v_list) == FAIL)
! 	emsg(_(e_invarg));
  }
  #endif
  
***************
*** 5485,5491 ****
      if (!hWinPtyDLL)
      {
  	if (verbose)
! 	    EMSG2(_(e_loadlib), *p_winptydll != NUL ? p_winptydll
  						       : (char_u *)WINPTY_DLL);
  	return FAIL;
      }
--- 5485,5491 ----
      if (!hWinPtyDLL)
      {
  	if (verbose)
! 	    semsg(_(e_loadlib), *p_winptydll != NUL ? p_winptydll
  						       : (char_u *)WINPTY_DLL);
  	return FAIL;
      }
***************
*** 5496,5502 ****
  					      winpty_entry[i].name)) == NULL)
  	{
  	    if (verbose)
! 		EMSG2(_(e_loadfunc), winpty_entry[i].name);
  	    return FAIL;
  	}
      }
--- 5496,5502 ----
  					      winpty_entry[i].name)) == NULL)
  	{
  	    if (verbose)
! 		semsg(_(e_loadfunc), winpty_entry[i].name);
  	    return FAIL;
  	}
      }
***************
*** 5548,5554 ****
      }
      if (cmd == NULL || *cmd == NUL)
      {
! 	EMSG(_(e_invarg));
  	goto failed;
      }
  
--- 5548,5554 ----
      }
      if (cmd == NULL || *cmd == NUL)
      {
! 	emsg(_(e_invarg));
  	goto failed;
      }
  
***************
*** 5680,5686 ****
  	ch_log(channel, "Opening output file %s", fname);
  	term->tl_out_fd = mch_fopen((char *)fname, WRITEBIN);
  	if (term->tl_out_fd == NULL)
! 	    EMSG2(_(e_notopen), fname);
      }
  
      return OK;
--- 5680,5686 ----
  	ch_log(channel, "Opening output file %s", fname);
  	term->tl_out_fd = mch_fopen((char *)fname, WRITEBIN);
  	if (term->tl_out_fd == NULL)
! 	    semsg(_(e_notopen), fname);
      }
  
      return OK;
***************
*** 5713,5719 ****
  	char_u *msg = utf16_to_enc(
  				(short_u *)winpty_error_msg(winpty_err), NULL);
  
! 	EMSG(msg);
  	winpty_error_free(winpty_err);
      }
      return FAIL;
--- 5713,5719 ----
  	char_u *msg = utf16_to_enc(
  				(short_u *)winpty_error_msg(winpty_err), NULL);
  
! 	emsg(msg);
  	winpty_error_free(winpty_err);
      }
      return FAIL;
*** ../vim-8.1.0742/src/textprop.c	2019-01-08 20:14:31.614957028 +0100
--- src/textprop.c	2019-01-13 19:57:53.269262041 +0100
***************
*** 19,25 ****
   * TODO:
   * - Adjust text property column and length when text is inserted/deleted.
   *   -> a :substitute with a multi-line match
!  *   -> search for changed_bytes() from ex_cmds.c
   * - Perhaps we only need TP_FLAG_CONT_NEXT and can drop TP_FLAG_CONT_PREV?
   * - Add an arrray for global_proptypes, to quickly lookup a prop type by ID
   * - Add an arrray for b_proptypes, to quickly lookup a prop type by ID
--- 19,25 ----
   * TODO:
   * - Adjust text property column and length when text is inserted/deleted.
   *   -> a :substitute with a multi-line match
!  *   -> search for changed_bytes() from misc1.c
   * - Perhaps we only need TP_FLAG_CONT_NEXT and can drop TP_FLAG_CONT_PREV?
   * - Add an arrray for global_proptypes, to quickly lookup a prop type by ID
   * - Add an arrray for b_proptypes, to quickly lookup a prop type by ID
***************
*** 106,112 ****
      if (type == NULL)
  	type = find_prop(name, NULL);
      if (type == NULL)
! 	EMSG2(_(e_type_not_exist), name);
      return type;
  }
  
--- 106,112 ----
      if (type == NULL)
  	type = find_prop(name, NULL);
      if (type == NULL)
! 	semsg(_(e_type_not_exist), name);
      return type;
  }
  
***************
*** 124,130 ****
  
      if (arg->v_type != VAR_DICT)
      {
! 	EMSG(_(e_dictreq));
  	return FAIL;
      }
      if (arg->vval.v_dict == NULL)
--- 124,130 ----
  
      if (arg->v_type != VAR_DICT)
      {
! 	emsg(_(e_dictreq));
  	return FAIL;
      }
      if (arg->vval.v_dict == NULL)
***************
*** 167,185 ****
      start_col = tv_get_number(&argvars[1]);
      if (start_col < 1)
      {
! 	EMSGN(_(e_invalid_col), (long)start_col);
  	return;
      }
      if (argvars[2].v_type != VAR_DICT)
      {
! 	EMSG(_(e_dictreq));
  	return;
      }
      dict = argvars[2].vval.v_dict;
  
      if (dict == NULL || dict_find(dict, (char_u *)"type", -1) == NULL)
      {
! 	EMSG(_("E965: missing property type name"));
  	return;
      }
      type_name = dict_get_string(dict, (char_u *)"type", FALSE);
--- 167,185 ----
      start_col = tv_get_number(&argvars[1]);
      if (start_col < 1)
      {
! 	semsg(_(e_invalid_col), (long)start_col);
  	return;
      }
      if (argvars[2].v_type != VAR_DICT)
      {
! 	emsg(_(e_dictreq));
  	return;
      }
      dict = argvars[2].vval.v_dict;
  
      if (dict == NULL || dict_find(dict, (char_u *)"type", -1) == NULL)
      {
! 	emsg(_("E965: missing property type name"));
  	return;
      }
      type_name = dict_get_string(dict, (char_u *)"type", FALSE);
***************
*** 189,195 ****
  	end_lnum = dict_get_number(dict, (char_u *)"end_lnum");
  	if (end_lnum < start_lnum)
  	{
! 	    EMSG2(_(e_invargval), "end_lnum");
  	    return;
  	}
      }
--- 189,195 ----
  	end_lnum = dict_get_number(dict, (char_u *)"end_lnum");
  	if (end_lnum < start_lnum)
  	{
! 	    semsg(_(e_invargval), "end_lnum");
  	    return;
  	}
      }
***************
*** 202,208 ****
  
  	if (length < 0 || end_lnum > start_lnum)
  	{
! 	    EMSG2(_(e_invargval), "length");
  	    return;
  	}
  	end_col = start_col + length;
--- 202,208 ----
  
  	if (length < 0 || end_lnum > start_lnum)
  	{
! 	    semsg(_(e_invargval), "length");
  	    return;
  	}
  	end_col = start_col + length;
***************
*** 212,218 ****
  	end_col = dict_get_number(dict, (char_u *)"end_col");
  	if (end_col <= 0)
  	{
! 	    EMSG2(_(e_invargval), "end_col");
  	    return;
  	}
      }
--- 212,218 ----
  	end_col = dict_get_number(dict, (char_u *)"end_col");
  	if (end_col <= 0)
  	{
! 	    semsg(_(e_invargval), "end_col");
  	    return;
  	}
      }
***************
*** 233,244 ****
  
      if (start_lnum < 1 || start_lnum > buf->b_ml.ml_line_count)
      {
! 	EMSGN(_(e_invalid_lnum), (long)start_lnum);
  	return;
      }
      if (end_lnum < start_lnum || end_lnum > buf->b_ml.ml_line_count)
      {
! 	EMSGN(_(e_invalid_lnum), (long)end_lnum);
  	return;
      }
  
--- 233,244 ----
  
      if (start_lnum < 1 || start_lnum > buf->b_ml.ml_line_count)
      {
! 	semsg(_(e_invalid_lnum), (long)start_lnum);
  	return;
      }
      if (end_lnum < start_lnum || end_lnum > buf->b_ml.ml_line_count)
      {
! 	semsg(_(e_invalid_lnum), (long)end_lnum);
  	return;
      }
  
***************
*** 257,263 ****
  	    col = 1;
  	if (col - 1 > (colnr_T)textlen)
  	{
! 	    EMSGN(_(e_invalid_col), (long)start_col);
  	    return;
  	}
  
--- 257,263 ----
  	    col = 1;
  	if (col - 1 > (colnr_T)textlen)
  	{
! 	    semsg(_(e_invalid_col), (long)start_col);
  	    return;
  	}
  
***************
*** 340,346 ****
      proplen = buf->b_ml.ml_line_len - textlen;
      if (proplen % sizeof(textprop_T) != 0)
      {
! 	IEMSG(_("E967: text property info corrupted"));
  	return 0;
      }
      if (proplen > 0)
--- 340,346 ----
      proplen = buf->b_ml.ml_line_len - textlen;
      if (proplen % sizeof(textprop_T) != 0)
      {
! 	iemsg(_("E967: text property info corrupted"));
  	return 0;
      }
      if (proplen > 0)
***************
*** 440,446 ****
      }
      if (start < 1 || end < 1)
      {
! 	EMSG(_(e_invrange));
  	return;
      }
  
--- 440,446 ----
      }
      if (start < 1 || end < 1)
      {
! 	emsg(_(e_invrange));
  	return;
      }
  
***************
*** 487,493 ****
      }
      if (lnum < 1 || lnum > buf->b_ml.ml_line_count)
      {
! 	EMSG(_(e_invrange));
  	return;
      }
  
--- 487,493 ----
      }
      if (lnum < 1 || lnum > buf->b_ml.ml_line_count)
      {
! 	emsg(_(e_invrange));
  	return;
      }
  
***************
*** 542,548 ****
      rettv->vval.v_number = 0;
      if (argvars[0].v_type != VAR_DICT || argvars[0].vval.v_dict == NULL)
      {
! 	EMSG(_(e_invarg));
  	return;
      }
  
--- 542,548 ----
      rettv->vval.v_number = 0;
      if (argvars[0].v_type != VAR_DICT || argvars[0].vval.v_dict == NULL)
      {
! 	emsg(_(e_invarg));
  	return;
      }
  
***************
*** 554,560 ****
  	    end = tv_get_number(&argvars[2]);
  	if (start < 1 || end < 1)
  	{
! 	    EMSG(_(e_invrange));
  	    return;
  	}
      }
--- 554,560 ----
  	    end = tv_get_number(&argvars[2]);
  	if (start < 1 || end < 1)
  	{
! 	    emsg(_(e_invrange));
  	    return;
  	}
      }
***************
*** 585,591 ****
      }
      if (id == -1 && type_id == -1)
      {
! 	EMSG(_("E968: Need at least one of 'id' or 'type'"));
  	return;
      }
  
--- 585,591 ----
      }
      if (id == -1 && type_id == -1)
      {
! 	emsg(_("E968: Need at least one of 'id' or 'type'"));
  	return;
      }
  
***************
*** 661,667 ****
      name = tv_get_string(&argvars[0]);
      if (*name == NUL)
      {
! 	EMSG(_(e_invarg));
  	return;
      }
  
--- 661,667 ----
      name = tv_get_string(&argvars[0]);
      if (*name == NUL)
      {
! 	emsg(_(e_invarg));
  	return;
      }
  
***************
*** 676,682 ****
  
  	if (prop != NULL)
  	{
! 	    EMSG2(_("E969: Property type %s already defined"), name);
  	    return;
  	}
  	prop = (proptype_T *)alloc_clear((int)(sizeof(proptype_T) + STRLEN(name)));
--- 676,682 ----
  
  	if (prop != NULL)
  	{
! 	    semsg(_("E969: Property type %s already defined"), name);
  	    return;
  	}
  	prop = (proptype_T *)alloc_clear((int)(sizeof(proptype_T) + STRLEN(name)));
***************
*** 701,707 ****
      {
  	if (prop == NULL)
  	{
! 	    EMSG2(_(e_type_not_exist), name);
  	    return;
  	}
      }
--- 701,707 ----
      {
  	if (prop == NULL)
  	{
! 	    semsg(_(e_type_not_exist), name);
  	    return;
  	}
      }
***************
*** 719,725 ****
  		hl_id = syn_name2id(highlight);
  	    if (hl_id <= 0)
  	    {
! 		EMSG2(_("E970: Unknown highlight group name: '%s'"),
  			highlight == NULL ? (char_u *)"" : highlight);
  		return;
  	    }
--- 719,725 ----
  		hl_id = syn_name2id(highlight);
  	    if (hl_id <= 0)
  	    {
! 		semsg(_("E970: Unknown highlight group name: '%s'"),
  			highlight == NULL ? (char_u *)"" : highlight);
  		return;
  	    }
***************
*** 781,787 ****
      name = tv_get_string(&argvars[0]);
      if (*name == NUL)
      {
! 	EMSG(_(e_invarg));
  	return;
      }
  
--- 781,787 ----
      name = tv_get_string(&argvars[0]);
      if (*name == NUL)
      {
! 	emsg(_(e_invarg));
  	return;
      }
  
***************
*** 816,822 ****
  
      if (*name == NUL)
      {
! 	EMSG(_(e_invarg));
  	return;
      }
      if (rettv_dict_alloc(rettv) == OK)
--- 816,822 ----
  
      if (*name == NUL)
      {
! 	emsg(_(e_invarg));
  	return;
      }
      if (rettv_dict_alloc(rettv) == OK)
*** ../vim-8.1.0742/src/ui.c	2019-01-09 22:24:46.568161097 +0100
--- src/ui.c	2019-01-13 19:57:57.093230132 +0100
***************
*** 337,343 ****
  suspend_shell(void)
  {
      if (*p_sh == NUL)
! 	EMSG(_(e_shellempty));
      else
      {
  	MSG_PUTS(_("new shell started\n"));
--- 337,343 ----
  suspend_shell(void)
  {
      if (*p_sh == NUL)
! 	emsg(_(e_shellempty));
      else
      {
  	MSG_PUTS(_("new shell started\n"));
*** ../vim-8.1.0742/src/undo.c	2019-01-08 20:14:31.614957028 +0100
--- src/undo.c	2019-01-13 19:58:00.577201071 +0100
***************
*** 158,187 ****
      ++header_count;
      if (uhp == curbuf->b_u_curhead && ++seen_b_u_curhead > 1)
      {
! 	EMSG("b_u_curhead found twice (looping?)");
  	return;
      }
      if (uhp == curbuf->b_u_newhead && ++seen_b_u_newhead > 1)
      {
! 	EMSG("b_u_newhead found twice (looping?)");
  	return;
      }
  
      if (uhp->uh_magic != UH_MAGIC)
! 	EMSG("uh_magic wrong (may be using freed memory)");
      else
      {
  	/* Check pointers back are correct. */
  	if (uhp->uh_next.ptr != exp_uh_next)
  	{
! 	    EMSG("uh_next wrong");
! 	    smsg((char_u *)"expected: 0x%x, actual: 0x%x",
  					       exp_uh_next, uhp->uh_next.ptr);
  	}
  	if (uhp->uh_alt_prev.ptr != exp_uh_alt_prev)
  	{
! 	    EMSG("uh_alt_prev wrong");
! 	    smsg((char_u *)"expected: 0x%x, actual: 0x%x",
  				       exp_uh_alt_prev, uhp->uh_alt_prev.ptr);
  	}
  
--- 158,187 ----
      ++header_count;
      if (uhp == curbuf->b_u_curhead && ++seen_b_u_curhead > 1)
      {
! 	emsg("b_u_curhead found twice (looping?)");
  	return;
      }
      if (uhp == curbuf->b_u_newhead && ++seen_b_u_newhead > 1)
      {
! 	emsg("b_u_newhead found twice (looping?)");
  	return;
      }
  
      if (uhp->uh_magic != UH_MAGIC)
! 	emsg("uh_magic wrong (may be using freed memory)");
      else
      {
  	/* Check pointers back are correct. */
  	if (uhp->uh_next.ptr != exp_uh_next)
  	{
! 	    emsg("uh_next wrong");
! 	    smsg("expected: 0x%x, actual: 0x%x",
  					       exp_uh_next, uhp->uh_next.ptr);
  	}
  	if (uhp->uh_alt_prev.ptr != exp_uh_alt_prev)
  	{
! 	    emsg("uh_alt_prev wrong");
! 	    smsg("expected: 0x%x, actual: 0x%x",
  				       exp_uh_alt_prev, uhp->uh_alt_prev.ptr);
  	}
  
***************
*** 190,196 ****
  	{
  	    if (uep->ue_magic != UE_MAGIC)
  	    {
! 		EMSG("ue_magic wrong (may be using freed memory)");
  		break;
  	    }
  	}
--- 190,196 ----
  	{
  	    if (uep->ue_magic != UE_MAGIC)
  	    {
! 		emsg("ue_magic wrong (may be using freed memory)");
  		break;
  	    }
  	}
***************
*** 214,226 ****
  
      if (seen_b_u_newhead == 0 && curbuf->b_u_oldhead != NULL
  	    && !(newhead_may_be_NULL && curbuf->b_u_newhead == NULL))
! 	EMSGN("b_u_newhead invalid: 0x%x", curbuf->b_u_newhead);
      if (curbuf->b_u_curhead != NULL && seen_b_u_curhead == 0)
! 	EMSGN("b_u_curhead invalid: 0x%x", curbuf->b_u_curhead);
      if (header_count != curbuf->b_u_numhead)
      {
! 	EMSG("b_u_numhead invalid");
! 	smsg((char_u *)"expected: %ld, actual: %ld",
  			       (long)header_count, (long)curbuf->b_u_numhead);
      }
  }
--- 214,226 ----
  
      if (seen_b_u_newhead == 0 && curbuf->b_u_oldhead != NULL
  	    && !(newhead_may_be_NULL && curbuf->b_u_newhead == NULL))
! 	semsg("b_u_newhead invalid: 0x%x", curbuf->b_u_newhead);
      if (curbuf->b_u_curhead != NULL && seen_b_u_curhead == 0)
! 	semsg("b_u_curhead invalid: 0x%x", curbuf->b_u_curhead);
      if (header_count != curbuf->b_u_numhead)
      {
! 	emsg("b_u_numhead invalid");
! 	smsg("expected: %ld, actual: %ld",
  			       (long)header_count, (long)curbuf->b_u_numhead);
      }
  }
***************
*** 316,322 ****
      /* Don't allow changes when 'modifiable' is off.  */
      if (!curbuf->b_p_ma)
      {
! 	EMSG(_(e_modifiable));
  	return FALSE;
      }
  
--- 316,322 ----
      /* Don't allow changes when 'modifiable' is off.  */
      if (!curbuf->b_p_ma)
      {
! 	emsg(_(e_modifiable));
  	return FALSE;
      }
  
***************
*** 324,330 ****
      /* In the sandbox it's not allowed to change the text. */
      if (sandbox != 0)
      {
! 	EMSG(_(e_sandbox));
  	return FALSE;
      }
  #endif
--- 324,330 ----
      /* In the sandbox it's not allowed to change the text. */
      if (sandbox != 0)
      {
! 	emsg(_(e_sandbox));
  	return FALSE;
      }
  #endif
***************
*** 333,339 ****
       * caller of getcmdline() may get confused. */
      if (textlock != 0)
      {
! 	EMSG(_(e_secure));
  	return FALSE;
      }
  
--- 333,339 ----
       * caller of getcmdline() may get confused. */
      if (textlock != 0)
      {
! 	emsg(_(e_secure));
  	return FALSE;
      }
  
***************
*** 413,424 ****
  	{
  	    if (netbeans_is_guarded(top, bot))
  	    {
! 		EMSG(_(e_guarded));
  		return FAIL;
  	    }
  	    if (curbuf->b_p_ro)
  	    {
! 		EMSG(_(e_nbreadonly));
  		return FAIL;
  	    }
  	}
--- 413,424 ----
  	{
  	    if (netbeans_is_guarded(top, bot))
  	    {
! 		emsg(_(e_guarded));
  		return FAIL;
  	    }
  	    if (curbuf->b_p_ro)
  	    {
! 		emsg(_(e_nbreadonly));
  		return FAIL;
  	    }
  	}
***************
*** 439,445 ****
  	{
  	    /* This happens when the FileChangedRO autocommand changes the
  	     * file in a way it becomes shorter. */
! 	    EMSG(_("E881: Line count changed unexpectedly"));
  	    return FAIL;
  	}
      }
--- 439,445 ----
  	{
  	    /* This happens when the FileChangedRO autocommand changes the
  	     * file in a way it becomes shorter. */
! 	    emsg(_("E881: Line count changed unexpectedly"));
  	    return FAIL;
  	}
      }
***************
*** 861,867 ****
      static void
  corruption_error(char *mesg, char_u *file_name)
  {
!     EMSG3(_("E825: Corrupted undo file (%s): %s"), mesg, file_name);
  }
  
      static void
--- 861,867 ----
      static void
  corruption_error(char *mesg, char_u *file_name)
  {
!     semsg(_("E825: Corrupted undo file (%s): %s"), mesg, file_name);
  }
  
      static void
***************
*** 1553,1559 ****
  	    if (p_verbose > 0)
  	    {
  		verbose_enter();
! 		smsg((char_u *)
  		   _("Cannot write undo file in any directory in 'undodir'"));
  		verbose_leave();
  	    }
--- 1553,1559 ----
  	    if (p_verbose > 0)
  	    {
  		verbose_enter();
! 		smsg(
  		   _("Cannot write undo file in any directory in 'undodir'"));
  		verbose_leave();
  	    }
***************
*** 1601,1607 ****
  		{
  		    if (name == NULL)
  			verbose_enter();
! 		    smsg((char_u *)
  		      _("Will not overwrite with undo file, cannot read: %s"),
  								   file_name);
  		    if (name == NULL)
--- 1601,1607 ----
  		{
  		    if (name == NULL)
  			verbose_enter();
! 		    smsg(
  		      _("Will not overwrite with undo file, cannot read: %s"),
  								   file_name);
  		    if (name == NULL)
***************
*** 1623,1629 ****
  		    {
  			if (name == NULL)
  			    verbose_enter();
! 			smsg((char_u *)
  			_("Will not overwrite, this is not an undo file: %s"),
  								   file_name);
  			if (name == NULL)
--- 1623,1629 ----
  		    {
  			if (name == NULL)
  			    verbose_enter();
! 			smsg(
  			_("Will not overwrite, this is not an undo file: %s"),
  								   file_name);
  			if (name == NULL)
***************
*** 1649,1662 ****
  			    O_CREAT|O_EXTRA|O_WRONLY|O_EXCL|O_NOFOLLOW, perm);
      if (fd < 0)
      {
! 	EMSG2(_(e_not_open), file_name);
  	goto theend;
      }
      (void)mch_setperm(file_name, perm);
      if (p_verbose > 0)
      {
  	verbose_enter();
! 	smsg((char_u *)_("Writing undo file: %s"), file_name);
  	verbose_leave();
      }
  
--- 1649,1662 ----
  			    O_CREAT|O_EXTRA|O_WRONLY|O_EXCL|O_NOFOLLOW, perm);
      if (fd < 0)
      {
! 	semsg(_(e_not_open), file_name);
  	goto theend;
      }
      (void)mch_setperm(file_name, perm);
      if (p_verbose > 0)
      {
  	verbose_enter();
! 	smsg(_("Writing undo file: %s"), file_name);
  	verbose_leave();
      }
  
***************
*** 1688,1694 ****
      fp = fdopen(fd, "w");
      if (fp == NULL)
      {
! 	EMSG2(_(e_not_open), file_name);
  	close(fd);
  	mch_remove(file_name);
  	goto theend;
--- 1688,1694 ----
      fp = fdopen(fd, "w");
      if (fp == NULL)
      {
! 	semsg(_(e_not_open), file_name);
  	close(fd);
  	mch_remove(file_name);
  	goto theend;
***************
*** 1743,1750 ****
  #ifdef U_DEBUG
      if (headers_written != buf->b_u_numhead)
      {
! 	EMSGN("Written %ld headers, ...", headers_written);
! 	EMSGN("... but numhead is %ld", buf->b_u_numhead);
      }
  #endif
  
--- 1743,1750 ----
  #ifdef U_DEBUG
      if (headers_written != buf->b_u_numhead)
      {
! 	semsg("Written %ld headers, ...", headers_written);
! 	semsg("... but numhead is %ld", buf->b_u_numhead);
      }
  #endif
  
***************
*** 1756,1762 ****
  write_error:
      fclose(fp);
      if (!write_ok)
! 	EMSG2(_("E829: write error in undo file: %s"), file_name);
  
  #if defined(WIN3264)
      /* Copy file attributes; for systems where this can only be done after
--- 1756,1762 ----
  write_error:
      fclose(fp);
      if (!write_ok)
! 	semsg(_("E829: write error in undo file: %s"), file_name);
  
  #if defined(WIN3264)
      /* Copy file attributes; for systems where this can only be done after
***************
*** 1846,1852 ****
  	    if (p_verbose > 0)
  	    {
  		verbose_enter();
! 		smsg((char_u *)_("Not reading undo file, owner differs: %s"),
  								   file_name);
  		verbose_leave();
  	    }
--- 1846,1852 ----
  	    if (p_verbose > 0)
  	    {
  		verbose_enter();
! 		smsg(_("Not reading undo file, owner differs: %s"),
  								   file_name);
  		verbose_leave();
  	    }
***************
*** 1860,1866 ****
      if (p_verbose > 0)
      {
  	verbose_enter();
! 	smsg((char_u *)_("Reading undo file: %s"), file_name);
  	verbose_leave();
      }
  
--- 1860,1866 ----
      if (p_verbose > 0)
      {
  	verbose_enter();
! 	smsg(_("Reading undo file: %s"), file_name);
  	verbose_leave();
      }
  
***************
*** 1868,1874 ****
      if (fp == NULL)
      {
  	if (name != NULL || p_verbose > 0)
! 	    EMSG2(_("E822: Cannot open undo file for reading: %s"), file_name);
  	goto error;
      }
      bi.bi_buf = curbuf;
--- 1868,1874 ----
      if (fp == NULL)
      {
  	if (name != NULL || p_verbose > 0)
! 	    semsg(_("E822: Cannot open undo file for reading: %s"), file_name);
  	goto error;
      }
      bi.bi_buf = curbuf;
***************
*** 1880,1886 ****
      if (fread(magic_buf, UF_START_MAGIC_LEN, 1, fp) != 1
  		|| memcmp(magic_buf, UF_START_MAGIC, UF_START_MAGIC_LEN) != 0)
      {
! 	EMSG2(_("E823: Not an undo file: %s"), file_name);
  	goto error;
      }
      version = get2c(fp);
--- 1880,1886 ----
      if (fread(magic_buf, UF_START_MAGIC_LEN, 1, fp) != 1
  		|| memcmp(magic_buf, UF_START_MAGIC, UF_START_MAGIC_LEN) != 0)
      {
! 	semsg(_("E823: Not an undo file: %s"), file_name);
  	goto error;
      }
      version = get2c(fp);
***************
*** 1889,1902 ****
  #ifdef FEAT_CRYPT
  	if (*curbuf->b_p_key == NUL)
  	{
! 	    EMSG2(_("E832: Non-encrypted file has encrypted undo file: %s"),
  								   file_name);
  	    goto error;
  	}
  	bi.bi_state = crypt_create_from_file(fp, curbuf->b_p_key);
  	if (bi.bi_state == NULL)
  	{
! 	    EMSG2(_("E826: Undo file decryption failed: %s"), file_name);
  	    goto error;
  	}
  	if (crypt_whole_undofile(bi.bi_state->method_nr))
--- 1889,1902 ----
  #ifdef FEAT_CRYPT
  	if (*curbuf->b_p_key == NUL)
  	{
! 	    semsg(_("E832: Non-encrypted file has encrypted undo file: %s"),
  								   file_name);
  	    goto error;
  	}
  	bi.bi_state = crypt_create_from_file(fp, curbuf->b_p_key);
  	if (bi.bi_state == NULL)
  	{
! 	    semsg(_("E826: Undo file decryption failed: %s"), file_name);
  	    goto error;
  	}
  	if (crypt_whole_undofile(bi.bi_state->method_nr))
***************
*** 1912,1924 ****
  	    bi.bi_used = 0;
  	}
  #else
! 	EMSG2(_("E827: Undo file is encrypted: %s"), file_name);
  	goto error;
  #endif
      }
      else if (version != UF_VERSION)
      {
! 	EMSG2(_("E824: Incompatible undo file: %s"), file_name);
  	goto error;
      }
  
--- 1912,1924 ----
  	    bi.bi_used = 0;
  	}
  #else
! 	semsg(_("E827: Undo file is encrypted: %s"), file_name);
  	goto error;
  #endif
      }
      else if (version != UF_VERSION)
      {
! 	semsg(_("E824: Incompatible undo file: %s"), file_name);
  	goto error;
      }
  
***************
*** 2122,2134 ****
  #ifdef U_DEBUG
      for (i = 0; i < num_head; ++i)
  	if (uhp_table_used[i] == 0)
! 	    EMSGN("uhp_table entry %ld not used, leaking memory", i);
      vim_free(uhp_table_used);
      u_check(TRUE);
  #endif
  
      if (name != NULL)
! 	smsg((char_u *)_("Finished reading undo file %s"), file_name);
      goto theend;
  
  error:
--- 2122,2134 ----
  #ifdef U_DEBUG
      for (i = 0; i < num_head; ++i)
  	if (uhp_table_used[i] == 0)
! 	    semsg("uhp_table entry %ld not used, leaking memory", i);
      vim_free(uhp_table_used);
      u_check(TRUE);
  #endif
  
      if (name != NULL)
! 	smsg(_("Finished reading undo file %s"), file_name);
      goto theend;
  
  error:
***************
*** 2488,2494 ****
  
  	if (absolute)
  	{
! 	    EMSGN(_("E830: Undo number %ld not found"), step);
  	    return;
  	}
  
--- 2488,2494 ----
  
  	if (absolute)
  	{
! 	    semsg(_("E830: Undo number %ld not found"), step);
  	    return;
  	}
  
***************
*** 2678,2684 ****
  				      || bot > curbuf->b_ml.ml_line_count + 1)
  	{
  	    unblock_autocmds();
! 	    IEMSG(_("E438: u_undo: line numbers wrong"));
  	    changed();		/* don't want UNCHANGED now */
  	    return;
  	}
--- 2678,2684 ----
  				      || bot > curbuf->b_ml.ml_line_count + 1)
  	{
  	    unblock_autocmds();
! 	    iemsg(_("E438: u_undo: line numbers wrong"));
  	    changed();		/* don't want UNCHANGED now */
  	    return;
  	}
***************
*** 2988,2994 ****
      }
  #endif
  
!     smsg_attr_keep(0, (char_u *)_("%ld %s; %s #%ld  %s"),
  	    u_oldcount < 0 ? -u_oldcount : u_oldcount,
  	    _(msgstr),
  	    did_undo ? _("before") : _("after"),
--- 2988,2994 ----
      }
  #endif
  
!     smsg_attr_keep(0, _("%ld %s; %s #%ld  %s"),
  	    u_oldcount < 0 ? -u_oldcount : u_oldcount,
  	    _(msgstr),
  	    did_undo ? _("before") : _("after"),
***************
*** 3165,3171 ****
  	return;		    /* nothing changed before */
      if (curbuf->b_u_curhead != NULL)
      {
! 	EMSG(_("E790: undojoin is not allowed after undo"));
  	return;
      }
      if (!curbuf->b_u_synced)
--- 3165,3171 ----
  	return;		    /* nothing changed before */
      if (curbuf->b_u_curhead != NULL)
      {
! 	emsg(_("E790: undojoin is not allowed after undo"));
  	return;
      }
      if (!curbuf->b_u_synced)
***************
*** 3270,3276 ****
  {
      if (curbuf->b_u_newhead == NULL || curbuf->b_u_newhead->uh_entry == NULL)
      {
! 	IEMSG(_("E439: undo list corrupt"));
  	return NULL;
      }
      return curbuf->b_u_newhead->uh_entry;
--- 3270,3276 ----
  {
      if (curbuf->b_u_newhead == NULL || curbuf->b_u_newhead->uh_entry == NULL)
      {
! 	iemsg(_("E439: undo list corrupt"));
  	return NULL;
      }
      return curbuf->b_u_newhead->uh_entry;
***************
*** 3302,3308 ****
  	uep->ue_bot = uep->ue_top + uep->ue_size + 1 + extra;
  	if (uep->ue_bot < 1 || uep->ue_bot > curbuf->b_ml.ml_line_count)
  	{
! 	    IEMSG(_("E440: undo line missing"));
  	    uep->ue_bot = uep->ue_top + 1;  /* assume all lines deleted, will
  					     * get all the old lines back
  					     * without deleting the current
--- 3302,3308 ----
  	uep->ue_bot = uep->ue_top + uep->ue_size + 1 + extra;
  	if (uep->ue_bot < 1 || uep->ue_bot > curbuf->b_ml.ml_line_count)
  	{
! 	    iemsg(_("E440: undo line missing"));
  	    uep->ue_bot = uep->ue_top + 1;  /* assume all lines deleted, will
  					     * get all the old lines back
  					     * without deleting the current
*** ../vim-8.1.0742/src/userfunc.c	2018-12-13 22:17:52.881941445 +0100
--- src/userfunc.c	2019-01-13 19:58:05.537159726 +0100
***************
*** 119,125 ****
  		    || (p - arg == 8 && STRNCMP(arg, "lastline", 8) == 0))
  	    {
  		if (!skip)
! 		    EMSG2(_("E125: Illegal argument: %s"), arg);
  		break;
  	    }
  	    if (newargs != NULL && ga_grow(newargs, 1) == FAIL)
--- 119,125 ----
  		    || (p - arg == 8 && STRNCMP(arg, "lastline", 8) == 0))
  	    {
  		if (!skip)
! 		    semsg(_("E125: Illegal argument: %s"), arg);
  		break;
  	    }
  	    if (newargs != NULL && ga_grow(newargs, 1) == FAIL)
***************
*** 139,145 ****
  		for (i = 0; i < newargs->ga_len; ++i)
  		    if (STRCMP(((char_u **)(newargs->ga_data))[i], arg) == 0)
  		    {
! 			EMSG2(_("E853: Duplicate argument name: %s"), arg);
  			vim_free(arg);
  			goto err_ret;
  		    }
--- 139,145 ----
  		for (i = 0; i < newargs->ga_len; ++i)
  		    if (STRCMP(((char_u **)(newargs->ga_data))[i], arg) == 0)
  		    {
! 			semsg(_("E853: Duplicate argument name: %s"), arg);
  			vim_free(arg);
  			goto err_ret;
  		    }
***************
*** 157,163 ****
  	if (mustend && *p != endchar)
  	{
  	    if (!skip)
! 		EMSG2(_(e_invarg2), *argp);
  	    break;
  	}
      }
--- 157,163 ----
  	if (mustend && *p != endchar)
  	{
  	    if (!skip)
! 		semsg(_(e_invarg2), *argp);
  	    break;
  	}
      }
***************
*** 386,392 ****
  	p = concat_str((char_u *)"<SNR>", name + 3);
      else
  	p = name;
!     EMSG2(_(ermsg), p);
      if (p != name)
  	vim_free(p);
  }
--- 386,392 ----
  	p = concat_str((char_u *)"<SNR>", name + 3);
      else
  	p = name;
!     semsg(_(ermsg), p);
      if (p != name)
  	vim_free(p);
  }
***************
*** 713,719 ****
      /* If depth of calling is getting too high, don't execute the function */
      if (depth >= p_mfd)
      {
! 	EMSG(_("E132: Function call depth is higher than 'maxfuncdepth'"));
  	rettv->v_type = VAR_NUMBER;
  	rettv->vval.v_number = -1;
  	return;
--- 713,719 ----
      /* If depth of calling is getting too high, don't execute the function */
      if (depth >= p_mfd)
      {
! 	emsg(_("E132: Function call depth is higher than 'maxfuncdepth'"));
  	rettv->v_type = VAR_NUMBER;
  	rettv->vval.v_number = -1;
  	return;
***************
*** 885,891 ****
  	    ++no_wait_return;
  	    verbose_enter_scroll();
  
! 	    smsg((char_u *)_("calling %s"), sourcing_name);
  	    if (p_verbose >= 14)
  	    {
  		char_u	buf[MSG_BUF_LEN];
--- 885,891 ----
  	    ++no_wait_return;
  	    verbose_enter_scroll();
  
! 	    smsg(_("calling %s"), sourcing_name);
  	    if (p_verbose >= 14)
  	    {
  		char_u	buf[MSG_BUF_LEN];
***************
*** 990,998 ****
  	verbose_enter_scroll();
  
  	if (aborting())
! 	    smsg((char_u *)_("%s aborted"), sourcing_name);
  	else if (fc->rettv->v_type == VAR_NUMBER)
! 	    smsg((char_u *)_("%s returning #%ld"), sourcing_name,
  					       (long)fc->rettv->vval.v_number);
  	else
  	{
--- 990,998 ----
  	verbose_enter_scroll();
  
  	if (aborting())
! 	    smsg(_("%s aborted"), sourcing_name);
  	else if (fc->rettv->v_type == VAR_NUMBER)
! 	    smsg(_("%s returning #%ld"), sourcing_name,
  					       (long)fc->rettv->vval.v_number);
  	else
  	{
***************
*** 1014,1020 ****
  		    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);
  		    s = buf;
  		}
! 		smsg((char_u *)_("%s returning %s"), sourcing_name, s);
  		vim_free(tofree);
  	    }
  	}
--- 1014,1020 ----
  		    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);
  		    s = buf;
  		}
! 		smsg(_("%s returning %s"), sourcing_name, s);
  		vim_free(tofree);
  	    }
  	}
***************
*** 1040,1046 ****
  	++no_wait_return;
  	verbose_enter_scroll();
  
! 	smsg((char_u *)_("continuing in %s"), sourcing_name);
  	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  
  	verbose_leave_scroll();
--- 1040,1046 ----
  	++no_wait_return;
  	verbose_enter_scroll();
  
! 	smsg(_("continuing in %s"), sourcing_name);
  	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  
  	verbose_leave_scroll();
***************
*** 1194,1200 ****
  restore_funccal(void)
  {
      if (funccal_stack == NULL)
! 	IEMSG("INTERNAL: restore_funccal()");
      else
      {
  	current_funccal = funccal_stack->top_funccal;
--- 1194,1200 ----
  restore_funccal(void)
  {
      if (funccal_stack == NULL)
! 	iemsg("INTERNAL: restore_funccal()");
      else
      {
  	current_funccal = funccal_stack->top_funccal;
***************
*** 1312,1318 ****
      {
  	if (argc == MAX_FUNC_ARGS - (partial == NULL ? 0 : partial->pt_argc))
  	{
! 	    EMSG(_("E699: Too many arguments"));
  	    break;
  	}
  	/* Make a copy of each argument.  This is needed to be able to set
--- 1312,1318 ----
      {
  	if (argc == MAX_FUNC_ARGS - (partial == NULL ? 0 : partial->pt_argc))
  	{
! 	    emsg(_("E699: Too many arguments"));
  	    break;
  	}
  	/* Make a copy of each argument.  This is needed to be able to set
***************
*** 1660,1666 ****
      if (end == start)
      {
  	if (!skip)
! 	    EMSG(_("E129: Function name required"));
  	goto theend;
      }
      if (end == NULL || (lv.ll_tv != NULL && (lead > 2 || lv.ll_range)))
--- 1660,1666 ----
      if (end == start)
      {
  	if (!skip)
! 	    emsg(_("E129: Function name required"));
  	goto theend;
      }
      if (end == NULL || (lv.ll_tv != NULL && (lead > 2 || lv.ll_range)))
***************
*** 1673,1679 ****
  	if (!aborting())
  	{
  	    if (end != NULL)
! 		EMSG2(_(e_invarg2), start);
  	}
  	else
  	    *pp = find_name_end(start, NULL, NULL, FNE_INCL_BR);
--- 1673,1679 ----
  	if (!aborting())
  	{
  	    if (end != NULL)
! 		semsg(_(e_invarg2), start);
  	}
  	else
  	    *pp = find_name_end(start, NULL, NULL, FNE_INCL_BR);
***************
*** 1706,1712 ****
  	{
  	    if (!skip && !(flags & TFN_QUIET) && (fdp == NULL
  			     || lv.ll_dict == NULL || fdp->fd_newkey == NULL))
! 		EMSG(_(e_funcref));
  	    else
  		*pp = end;
  	    name = NULL;
--- 1706,1712 ----
  	{
  	    if (!skip && !(flags & TFN_QUIET) && (fdp == NULL
  			     || lv.ll_dict == NULL || fdp->fd_newkey == NULL))
! 		emsg(_(e_funcref));
  	    else
  		*pp = end;
  	    name = NULL;
***************
*** 1789,1795 ****
  	    /* It's "s:" or "<SID>" */
  	    if (current_sctx.sc_sid <= 0)
  	    {
! 		EMSG(_(e_usingsid));
  		goto theend;
  	    }
  	    sprintf((char *)sid_buf, "%ld_", (long)current_sctx.sc_sid);
--- 1789,1795 ----
  	    /* It's "s:" or "<SID>" */
  	    if (current_sctx.sc_sid <= 0)
  	    {
! 		emsg(_(e_usingsid));
  		goto theend;
  	    }
  	    sprintf((char *)sid_buf, "%ld_", (long)current_sctx.sc_sid);
***************
*** 1798,1804 ****
      }
      else if (!(flags & TFN_INT) && builtin_function(lv.ll_name, len))
      {
! 	EMSG2(_("E128: Function name must start with a capital or \"s:\": %s"),
  								       start);
  	goto theend;
      }
--- 1798,1804 ----
      }
      else if (!(flags & TFN_INT) && builtin_function(lv.ll_name, len))
      {
! 	semsg(_("E128: Function name must start with a capital or \"s:\": %s"),
  								       start);
  	goto theend;
      }
***************
*** 1808,1814 ****
  
  	if (cp != NULL && cp < end)
  	{
! 	    EMSG2(_("E884: Function name cannot contain a colon: %s"), start);
  	    goto theend;
  	}
      }
--- 1808,1814 ----
  
  	if (cp != NULL && cp < end)
  	{
! 	    semsg(_("E884: Function name cannot contain a colon: %s"), start);
  	    goto theend;
  	}
      }
***************
*** 1961,1967 ****
  	if (!aborting())
  	{
  	    if (!eap->skip && fudi.fd_newkey != NULL)
! 		EMSG2(_(e_dictkey), fudi.fd_newkey);
  	    vim_free(fudi.fd_newkey);
  	    return;
  	}
--- 1961,1967 ----
  	if (!aborting())
  	{
  	    if (!eap->skip && fudi.fd_newkey != NULL)
! 		semsg(_(e_dictkey), fudi.fd_newkey);
  	    vim_free(fudi.fd_newkey);
  	    return;
  	}
***************
*** 1981,1987 ****
      {
  	if (!ends_excmd(*skipwhite(p)))
  	{
! 	    EMSG(_(e_trailing));
  	    goto ret_free;
  	}
  	eap->nextcmd = check_nextcmd(p);
--- 1981,1987 ----
      {
  	if (!ends_excmd(*skipwhite(p)))
  	{
! 	    emsg(_(e_trailing));
  	    goto ret_free;
  	}
  	eap->nextcmd = check_nextcmd(p);
***************
*** 2027,2033 ****
      {
  	if (!eap->skip)
  	{
! 	    EMSG2(_("E124: Missing '(': %s"), eap->arg);
  	    goto ret_free;
  	}
  	/* attempt to continue by skipping some text */
--- 2027,2033 ----
      {
  	if (!eap->skip)
  	{
! 	    semsg(_("E124: Missing '(': %s"), eap->arg);
  	    goto ret_free;
  	}
  	/* attempt to continue by skipping some text */
***************
*** 2062,2068 ****
  	}
  	/* Disallow using the g: dict. */
  	if (fudi.fd_dict != NULL && fudi.fd_dict->dv_scope == VAR_DEF_SCOPE)
! 	    EMSG(_("E862: Cannot use g: here"));
      }
  
      if (get_function_args(&p, ')', &newargs, &varargs, eap->skip) == FAIL)
--- 2062,2068 ----
  	}
  	/* Disallow using the g: dict. */
  	if (fudi.fd_dict != NULL && fudi.fd_dict->dv_scope == VAR_DEF_SCOPE)
! 	    emsg(_("E862: Cannot use g: here"));
      }
  
      if (get_function_args(&p, ')', &newargs, &varargs, eap->skip) == FAIL)
***************
*** 2107,2113 ****
      if (*p == '\n')
  	line_arg = p + 1;
      else if (*p != NUL && *p != '"' && !eap->skip && !did_emsg)
! 	EMSG(_(e_trailing));
  
      /*
       * Read the body of the function, until ":endfunction" is found.
--- 2107,2113 ----
      if (*p == '\n')
  	line_arg = p + 1;
      else if (*p != NUL && *p != '"' && !eap->skip && !did_emsg)
! 	emsg(_(e_trailing));
  
      /*
       * Read the body of the function, until ":endfunction" is found.
***************
*** 2120,2126 ****
  	if (!eap->skip && !eap->forceit)
  	{
  	    if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)
! 		EMSG(_(e_funcdict));
  	    else if (name != NULL && find_func(name) != NULL)
  		emsg_funcname(e_funcexts, name);
  	}
--- 2120,2126 ----
  	if (!eap->skip && !eap->forceit)
  	{
  	    if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)
! 		emsg(_(e_funcdict));
  	    else if (name != NULL && find_func(name) != NULL)
  		emsg_funcname(e_funcexts, name);
  	}
***************
*** 2170,2176 ****
  	    lines_left = Rows - 1;
  	if (theline == NULL)
  	{
! 	    EMSG(_("E126: Missing :endfunction"));
  	    goto erret;
  	}
  
--- 2170,2176 ----
  	    lines_left = Rows - 1;
  	if (theline == NULL)
  	{
! 	    emsg(_("E126: Missing :endfunction"));
  	    goto erret;
  	}
  
***************
*** 2374,2380 ****
  	fp = NULL;
  	if (fudi.fd_newkey == NULL && !eap->forceit)
  	{
! 	    EMSG(_(e_funcdict));
  	    goto erret;
  	}
  	if (fudi.fd_di == NULL)
--- 2374,2380 ----
  	fp = NULL;
  	if (fudi.fd_newkey == NULL && !eap->forceit)
  	{
! 	    emsg(_(e_funcdict));
  	    goto erret;
  	}
  	if (fudi.fd_di == NULL)
***************
*** 2421,2427 ****
  	    }
  	    if (j == FAIL)
  	    {
! 		EMSG2(_("E746: Function name does not match script file name: %s"), name);
  		goto erret;
  	    }
  	}
--- 2421,2427 ----
  	    }
  	    if (j == FAIL)
  	    {
! 		semsg(_("E746: Function name does not match script file name: %s"), name);
  		goto erret;
  	    }
  	}
***************
*** 2876,2888 ****
      if (name == NULL)
      {
  	if (fudi.fd_dict != NULL && !eap->skip)
! 	    EMSG(_(e_funcref));
  	return;
      }
      if (!ends_excmd(*skipwhite(p)))
      {
  	vim_free(name);
! 	EMSG(_(e_trailing));
  	return;
      }
      eap->nextcmd = check_nextcmd(p);
--- 2876,2888 ----
      if (name == NULL)
      {
  	if (fudi.fd_dict != NULL && !eap->skip)
! 	    emsg(_(e_funcref));
  	return;
      }
      if (!ends_excmd(*skipwhite(p)))
      {
  	vim_free(name);
! 	emsg(_(e_trailing));
  	return;
      }
      eap->nextcmd = check_nextcmd(p);
***************
*** 2898,2909 ****
  	if (fp == NULL)
  	{
  	    if (!eap->forceit)
! 		EMSG2(_(e_nofunc), eap->arg);
  	    return;
  	}
  	if (fp->uf_calls > 0)
  	{
! 	    EMSG2(_("E131: Cannot delete function %s: It is in use"), eap->arg);
  	    return;
  	}
  
--- 2898,2909 ----
  	if (fp == NULL)
  	{
  	    if (!eap->forceit)
! 		semsg(_(e_nofunc), eap->arg);
  	    return;
  	}
  	if (fp->uf_calls > 0)
  	{
! 	    semsg(_("E131: Cannot delete function %s: It is in use"), eap->arg);
  	    return;
  	}
  
***************
*** 3032,3038 ****
  
      if (current_funccal == NULL)
      {
! 	EMSG(_("E133: :return not inside a function"));
  	return;
      }
  
--- 3032,3038 ----
  
      if (current_funccal == NULL)
      {
! 	emsg(_("E133: :return not inside a function"));
  	return;
      }
  
***************
*** 3108,3114 ****
      if (fudi.fd_newkey != NULL)
      {
  	/* Still need to give an error message for missing key. */
! 	EMSG2(_(e_dictkey), fudi.fd_newkey);
  	vim_free(fudi.fd_newkey);
      }
      if (tofree == NULL)
--- 3108,3114 ----
      if (fudi.fd_newkey != NULL)
      {
  	/* Still need to give an error message for missing key. */
! 	semsg(_(e_dictkey), fudi.fd_newkey);
  	vim_free(fudi.fd_newkey);
      }
      if (tofree == NULL)
***************
*** 3133,3139 ****
  
      if (*startarg != '(')
      {
! 	EMSG2(_("E107: Missing parentheses: %s"), eap->arg);
  	goto end;
      }
  
--- 3133,3139 ----
  
      if (*startarg != '(')
      {
! 	semsg(_("E107: Missing parentheses: %s"), eap->arg);
  	goto end;
      }
  
***************
*** 3158,3164 ****
  	    {
  		// If the function deleted lines or switched to another buffer
  		// the line number may become invalid.
! 		EMSG(_(e_invrange));
  		break;
  	    }
  	    curwin->w_cursor.lnum = lnum;
--- 3158,3164 ----
  	    {
  		// If the function deleted lines or switched to another buffer
  		// the line number may become invalid.
! 		emsg(_(e_invrange));
  		break;
  	    }
  	    curwin->w_cursor.lnum = lnum;
***************
*** 3205,3211 ****
  	if (!ends_excmd(*arg))
  	{
  	    emsg_severe = TRUE;
! 	    EMSG(_(e_trailing));
  	}
  	else
  	    eap->nextcmd = check_nextcmd(arg);
--- 3205,3211 ----
  	if (!ends_excmd(*arg))
  	{
  	    emsg_severe = TRUE;
! 	    emsg(_(e_trailing));
  	}
  	else
  	    eap->nextcmd = check_nextcmd(arg);
***************
*** 3267,3273 ****
  		if ((cstack->cs_rettv[idx] = alloc_tv()) != NULL)
  		    *(typval_T *)cstack->cs_rettv[idx] = *(typval_T *)rettv;
  		else
! 		    EMSG(_(e_outofmem));
  	    }
  	    else
  		cstack->cs_rettv[idx] = NULL;
--- 3267,3273 ----
  		if ((cstack->cs_rettv[idx] = alloc_tv()) != NULL)
  		    *(typval_T *)cstack->cs_rettv[idx] = *(typval_T *)rettv;
  		else
! 		    emsg(_(e_outofmem));
  	    }
  	    else
  		cstack->cs_rettv[idx] = NULL;
*** ../vim-8.1.0742/src/vim.h	2019-01-12 22:47:01.264088074 +0100
--- src/vim.h	2019-01-13 19:44:12.812867446 +0100
***************
*** 1625,1638 ****
  
  #define MSG(s)			    msg((char_u *)(s))
  #define MSG_ATTR(s, attr)	    msg_attr((char_u *)(s), (attr))
- #define EMSG(s)			    emsg((char_u *)(s))
- #define EMSG2(s, p)		    emsg2((char_u *)(s), (char_u *)(p))
- #define EMSG3(s, p, q)		    emsg3((char_u *)(s), (char_u *)(p), (char_u *)(q))
- #define EMSGN(s, n)		    emsgn((char_u *)(s), (long)(n))
- #define EMSGU(s, n)		    emsgu((char_u *)(s), (long_u)(n))
- #define IEMSG(s)		    iemsg((char_u *)(s))
- #define IEMSG2(s, p)		    iemsg2((char_u *)(s), (char_u *)(p))
- #define IEMSGN(s, n)		    iemsgn((char_u *)(s), (long)(n))
  #define OUT_STR(s)		    out_str((char_u *)(s))
  #define OUT_STR_NF(s)		    out_str_nf((char_u *)(s))
  #define MSG_PUTS(s)		    msg_puts((char_u *)(s))
--- 1625,1630 ----
***************
*** 1676,1685 ****
  # define GUI_GET_COLOR		    GUI_FUNCTION(get_color)
  #endif
  
! /* Prefer using emsg3(), because perror() may send the output to the wrong
   * destination and mess up the screen. */
  #ifdef HAVE_STRERROR
! # define PERROR(msg)		    (void)emsg3((char_u *)"%s: %s", (char_u *)msg, (char_u *)strerror(errno))
  #else
  # define PERROR(msg)		    do_perror(msg)
  #endif
--- 1668,1677 ----
  # define GUI_GET_COLOR		    GUI_FUNCTION(get_color)
  #endif
  
! /* Prefer using emsgf(), because perror() may send the output to the wrong
   * destination and mess up the screen. */
  #ifdef HAVE_STRERROR
! # define PERROR(msg)		    (void)semsg("%s: %s", (char *)msg, strerror(errno))
  #else
  # define PERROR(msg)		    do_perror(msg)
  #endif
*** ../vim-8.1.0742/src/window.c	2019-01-11 20:34:18.300314693 +0100
--- src/window.c	2019-01-13 19:58:11.409110820 +0100
***************
*** 101,107 ****
      do { \
  	if (cmdwin_type != 0) \
  	{ \
! 	    EMSG(_(e_cmdwin)); \
  	    return; \
  	} \
      } while (0)
--- 101,107 ----
      do { \
  	if (cmdwin_type != 0) \
  	{ \
! 	    emsg(_(e_cmdwin)); \
  	    return; \
  	} \
      } while (0)
***************
*** 156,164 ****
  					? curwin->w_alt_fnum : Prenum) == NULL)
  		{
  		    if (Prenum == 0)
! 			EMSG(_(e_noalt));
  		    else
! 			EMSGN(_("E92: Buffer %ld not found"), Prenum);
  		    break;
  		}
  
--- 156,164 ----
  					? curwin->w_alt_fnum : Prenum) == NULL)
  		{
  		    if (Prenum == 0)
! 			emsg(_(e_noalt));
  		    else
! 			semsg(_("E92: Buffer %ld not found"), Prenum);
  		    break;
  		}
  
***************
*** 220,226 ****
  		    if (wp->w_p_pvw)
  			break;
  		if (wp == NULL)
! 		    EMSG(_("E441: There is no preview window"));
  		else
  		    win_goto(wp);
  		break;
--- 220,226 ----
  		    if (wp->w_p_pvw)
  			break;
  		if (wp == NULL)
! 		    emsg(_("E441: There is no preview window"));
  		else
  		    win_goto(wp);
  		break;
***************
*** 739,745 ****
      flags |= cmdmod.split;
      if ((flags & WSP_TOP) && (flags & WSP_BOT))
      {
! 	EMSG(_("E442: Can't split topleft and botright at the same time"));
  	return FAIL;
      }
  
--- 739,745 ----
      flags |= cmdmod.split;
      if ((flags & WSP_TOP) && (flags & WSP_BOT))
      {
! 	emsg(_("E442: Can't split topleft and botright at the same time"));
  	return FAIL;
      }
  
***************
*** 794,800 ****
      {
  	if (VISIBLE_HEIGHT(oldwin) <= p_wmh && new_wp == NULL)
  	{
! 	    EMSG(_(e_noroom));
  	    return FAIL;
  	}
  	need_status = STATUS_HEIGHT;
--- 794,800 ----
      {
  	if (VISIBLE_HEIGHT(oldwin) <= p_wmh && new_wp == NULL)
  	{
! 	    emsg(_(e_noroom));
  	    return FAIL;
  	}
  	need_status = STATUS_HEIGHT;
***************
*** 852,858 ****
  	}
  	if (available < needed && new_wp == NULL)
  	{
! 	    EMSG(_(e_noroom));
  	    return FAIL;
  	}
  	if (new_size == 0)
--- 852,858 ----
  	}
  	if (available < needed && new_wp == NULL)
  	{
! 	    emsg(_(e_noroom));
  	    return FAIL;
  	}
  	if (new_size == 0)
***************
*** 935,941 ****
  	}
  	if (available < needed && new_wp == NULL)
  	{
! 	    EMSG(_(e_noroom));
  	    return FAIL;
  	}
  	oldwin_height = oldwin->w_height;
--- 935,941 ----
  	}
  	if (available < needed && new_wp == NULL)
  	{
! 	    emsg(_(e_noroom));
  	    return FAIL;
  	}
  	oldwin_height = oldwin->w_height;
***************
*** 1606,1612 ****
      FOR_ALL_FRAMES(frp, curwin->w_frame->fr_parent->fr_child)
  	if (frp->fr_win == NULL)
  	{
! 	    EMSG(_("E443: Cannot rotate when another window is split"));
  	    return;
  	}
  
--- 1606,1612 ----
      FOR_ALL_FRAMES(frp, curwin->w_frame->fr_parent->fr_child)
  	if (frp->fr_win == NULL)
  	{
! 	    emsg(_("E443: Cannot rotate when another window is split"));
  	    return;
  	}
  
***************
*** 2309,2315 ****
  
      if (last_window())
      {
! 	EMSG(_("E444: Cannot close last window"));
  	return FAIL;
      }
  
--- 2309,2315 ----
  
      if (last_window())
      {
! 	emsg(_("E444: Cannot close last window"));
  	return FAIL;
      }
  
***************
*** 2318,2329 ****
  	return FAIL; /* window is already being closed */
      if (win == aucmd_win)
      {
! 	EMSG(_("E813: Cannot close autocmd window"));
  	return FAIL;
      }
      if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())
      {
! 	EMSG(_("E814: Cannot close window, only autocmd window would remain"));
  	return FAIL;
      }
  
--- 2318,2329 ----
  	return FAIL; /* window is already being closed */
      if (win == aucmd_win)
      {
! 	emsg(_("E813: Cannot close autocmd window"));
  	return FAIL;
      }
      if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())
      {
! 	emsg(_("E814: Cannot close window, only autocmd window would remain"));
  	return FAIL;
      }
  
***************
*** 3419,3425 ****
      }
  
      if (message && !ONE_WINDOW)
! 	EMSG(_("E445: Other window contains changes"));
  }
  
  /*
--- 3419,3425 ----
      }
  
      if (message && !ONE_WINDOW)
! 	emsg(_("E445: Other window contains changes"));
  }
  
  /*
***************
*** 5447,5453 ****
  	--p_wmh;
  	if (first)
  	{
! 	    EMSG(_(e_noroom));
  	    first = FALSE;
  	}
      }
--- 5447,5453 ----
  	--p_wmh;
  	if (first)
  	{
! 	    emsg(_(e_noroom));
  	    first = FALSE;
  	}
      }
***************
*** 5473,5479 ****
  	--p_wmw;
  	if (first)
  	{
! 	    EMSG(_(e_noroom));
  	    first = FALSE;
  	}
      }
--- 5473,5479 ----
  	--p_wmw;
  	if (first)
  	{
! 	    emsg(_(e_noroom));
  	    first = FALSE;
  	}
      }
***************
*** 5950,5956 ****
  	    {
  		if (frp == NULL)
  		{
! 		    EMSG(_(e_noroom));
  		    p_ch = old_p_ch;
  		    curtab->tp_ch_used = p_ch;
  		    cmdline_row = Rows - p_ch;
--- 5950,5956 ----
  	    {
  		if (frp == NULL)
  		{
! 		    emsg(_(e_noroom));
  		    p_ch = old_p_ch;
  		    curtab->tp_ch_used = p_ch;
  		    cmdline_row = Rows - p_ch;
***************
*** 6041,6047 ****
  	    {
  		if (fp == topframe)
  		{
! 		    EMSG(_(e_noroom));
  		    return;
  		}
  		/* In a column of frames: go to frame above.  If already at
--- 6041,6047 ----
  	    {
  		if (fp == topframe)
  		{
! 		    emsg(_(e_noroom));
  		    return;
  		}
  		/* In a column of frames: go to frame above.  If already at
***************
*** 6170,6176 ****
      if (*ptr == NUL)		/* nothing found */
      {
  	if (options & FNAME_MESS)
! 	    EMSG(_("E446: No file name under cursor"));
  	return NULL;
      }
  
--- 6170,6176 ----
      if (*ptr == NUL)		/* nothing found */
      {
  	if (options & FNAME_MESS)
! 	    emsg(_("E446: No file name under cursor"));
  	return NULL;
      }
  
***************
*** 6319,6325 ****
  	{
  	    c = ptr[len];
  	    ptr[len] = NUL;
! 	    EMSG2(_("E447: Can't find file \"%s\" in path"), ptr);
  	    ptr[len] = c;
  	}
  
--- 6319,6325 ----
  	{
  	    c = ptr[len];
  	    ptr[len] = NUL;
! 	    semsg(_("E447: Can't find file \"%s\" in path"), ptr);
  	    ptr[len] = c;
  	}
  
***************
*** 6782,6788 ****
  	return -1;
      if (id < -1 || id == 0)
      {
! 	EMSGN(_("E799: Invalid ID: %ld (must be greater than or equal to 1)"), id);
  	return -1;
      }
      if (id != -1)
--- 6782,6788 ----
  	return -1;
      if (id < -1 || id == 0)
      {
! 	semsg(_("E799: Invalid ID: %ld (must be greater than or equal to 1)"), id);
  	return -1;
      }
      if (id != -1)
***************
*** 6792,6798 ****
  	{
  	    if (cur->id == id)
  	    {
! 		EMSGN(_("E801: ID already taken: %ld"), id);
  		return -1;
  	    }
  	    cur = cur->next;
--- 6792,6798 ----
  	{
  	    if (cur->id == id)
  	    {
! 		semsg(_("E801: ID already taken: %ld"), id);
  		return -1;
  	    }
  	    cur = cur->next;
***************
*** 6800,6811 ****
      }
      if ((hlg_id = syn_namen2id(grp, (int)STRLEN(grp))) == 0)
      {
! 	EMSG2(_(e_nogroup), grp);
  	return -1;
      }
      if (pat != NULL && (regprog = vim_regcomp(pat, RE_MAGIC)) == NULL)
      {
! 	EMSG2(_(e_invarg2), pat);
  	return -1;
      }
  
--- 6800,6811 ----
      }
      if ((hlg_id = syn_namen2id(grp, (int)STRLEN(grp))) == 0)
      {
! 	semsg(_(e_nogroup), grp);
  	return -1;
      }
      if (pat != NULL && (regprog = vim_regcomp(pat, RE_MAGIC)) == NULL)
      {
! 	semsg(_(e_invarg2), pat);
  	return -1;
      }
  
***************
*** 6900,6906 ****
  	    }
  	    else
  	    {
! 		EMSG(_("List or number required"));
  		goto fail;
  	    }
  	    if (toplnum == 0 || lnum < toplnum)
--- 6900,6906 ----
  	    }
  	    else
  	    {
! 		emsg(_("List or number required"));
  		goto fail;
  	    }
  	    if (toplnum == 0 || lnum < toplnum)
***************
*** 6969,6975 ****
      if (id < 1)
      {
  	if (perr == TRUE)
! 	    EMSGN(_("E802: Invalid ID: %ld (must be greater than or equal to 1)"),
  									  id);
  	return -1;
      }
--- 6969,6975 ----
      if (id < 1)
      {
  	if (perr == TRUE)
! 	    semsg(_("E802: Invalid ID: %ld (must be greater than or equal to 1)"),
  									  id);
  	return -1;
      }
***************
*** 6981,6987 ****
      if (cur == NULL)
      {
  	if (perr == TRUE)
! 	    EMSGN(_("E803: ID not found: %ld"), id);
  	return -1;
      }
      if (cur == prev)
--- 6981,6987 ----
      if (cur == NULL)
      {
  	if (perr == TRUE)
! 	    semsg(_("E803: ID not found: %ld"), id);
  	return -1;
      }
      if (cur == prev)
*** ../vim-8.1.0742/src/version.c	2019-01-13 19:10:28.963419901 +0100
--- src/version.c	2019-01-13 19:19:37.843871508 +0100
***************
*** 797,798 ****
--- 797,800 ----
  {   /* Add new patch number below this line */
+ /**/
+     743,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
195. Your cat has its own home page.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
