To: vim_dev@googlegroups.com
Subject: Patch 8.1.0379
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.1.0379
Problem:    Build dependencies are incomplete.
Solution:   Update the build dependencies, mainly for xdiff.  Adjust object
            directory for libvterm and xdiff.
Files:	    src/Makefile, src/configure.ac, src/auto/configure,
            src/libvterm/src/screen.c, src/libvterm/src/termscreen.c,
            src/Make_cyg_ming.mak, src/Make_mvc.mak


*** ../vim-8.1.0378/src/Makefile	2018-09-10 17:50:32.709306979 +0200
--- src/Makefile	2018-09-13 17:20:07.798588758 +0200
***************
*** 1471,1476 ****
--- 1471,1478 ----
  .SUFFIXES:
  .SUFFIXES: .c .o .pro
  
+ VTERM_CFLAGS = -Ilibvterm/include
+ 
  PRE_DEFS = -Iproto $(DEFS) $(GUI_DEFS) $(GUI_IPATH) $(CPPFLAGS) $(EXTRA_IPATHS)
  POST_DEFS = $(X_CFLAGS) $(MZSCHEME_CFLAGS) $(EXTRA_DEFS)
  
***************
*** 1480,1486 ****
  # with "-E".
  OSDEF_CFLAGS = $(PRE_DEFS) $(POST_DEFS)
  
! LINT_CFLAGS = -DLINT -I. $(PRE_DEFS) $(POST_DEFS) $(RUBY_CFLAGS) $(LUA_CFLAGS) $(PERL_CFLAGS) $(PYTHON_CFLAGS) $(PYTHON3_CFLAGS) $(TCL_CFLAGS) -Dinline= -D__extension__= -Dalloca=alloca
  
  LINT_EXTRA = -DHANGUL_INPUT -D"__attribute__(x)="
  
--- 1482,1491 ----
  # with "-E".
  OSDEF_CFLAGS = $(PRE_DEFS) $(POST_DEFS)
  
! LINT_CFLAGS = -DLINT -I. $(PRE_DEFS) $(POST_DEFS) \
! 	      $(RUBY_CFLAGS) $(LUA_CFLAGS) $(PERL_CFLAGS) $(PYTHON_CFLAGS) \
! 	      $(PYTHON3_CFLAGS) $(TCL_CFLAGS) $(VTERM_CFLAGS) \
! 	      -Dinline= -D__extension__= -Dalloca=alloca
  
  LINT_EXTRA = -DHANGUL_INPUT -D"__attribute__(x)="
  
***************
*** 1671,1677 ****
  RUN_UNITTESTS = run_json_test run_kword_test run_memfile_test run_message_test
  
  # All sources, also the ones that are not configured
! ALL_SRC = $(BASIC_SRC) $(ALL_GUI_SRC) $(UNITTEST_SRC) $(EXTRA_SRC)
  
  # Which files to check with lint.  Select one of these three lines.  ALL_SRC
  # checks more, but may not work well for checking a GUI that wasn't configured.
--- 1676,1683 ----
  RUN_UNITTESTS = run_json_test run_kword_test run_memfile_test run_message_test
  
  # All sources, also the ones that are not configured
! ALL_SRC = $(BASIC_SRC) $(ALL_GUI_SRC) $(UNITTEST_SRC) \
! 	  $(EXTRA_SRC) $(TERM_SRC) $(XDIFF_SRC)
  
  # Which files to check with lint.  Select one of these three lines.  ALL_SRC
  # checks more, but may not work well for checking a GUI that wasn't configured.
***************
*** 3225,3260 ****
  Makefile:
  	@echo The name of the makefile MUST be "Makefile" (with capital M)!!!!
  
! CCCTERM = $(CCC_NF) -Ilibvterm/include $(ALL_CFLAGS) -DINLINE="" \
  	  -DVSNPRINTF=vim_vsnprintf \
  	  -DIS_COMBINING_FUNCTION=utf_iscomposing_uint \
  	  -DWCWIDTH_FUNCTION=utf_uint2cells
  
! objects/term_encoding.o: libvterm/src/encoding.c $(TERM_DEPS)
  	$(CCCTERM) -o $@ libvterm/src/encoding.c
  
! objects/term_keyboard.o: libvterm/src/keyboard.c $(TERM_DEPS)
  	$(CCCTERM) -o $@ libvterm/src/keyboard.c
  
! objects/term_mouse.o: libvterm/src/mouse.c $(TERM_DEPS)
  	$(CCCTERM) -o $@ libvterm/src/mouse.c
  
! objects/term_parser.o: libvterm/src/parser.c $(TERM_DEPS)
  	$(CCCTERM) -o $@ libvterm/src/parser.c
  
! objects/term_pen.o: libvterm/src/pen.c $(TERM_DEPS)
  	$(CCCTERM) -o $@ libvterm/src/pen.c
  
! objects/term_screen.o: libvterm/src/screen.c $(TERM_DEPS)
! 	$(CCCTERM) -o $@ libvterm/src/screen.c
  
! objects/term_state.o: libvterm/src/state.c $(TERM_DEPS)
  	$(CCCTERM) -o $@ libvterm/src/state.c
  
! objects/term_unicode.o: libvterm/src/unicode.c $(TERM_DEPS)
  	$(CCCTERM) -o $@ libvterm/src/unicode.c
  
! objects/term_vterm.o: libvterm/src/vterm.c $(TERM_DEPS)
  	$(CCCTERM) -o $@ libvterm/src/vterm.c
  
  CCCDIFF = $(CCC_NF) $(ALL_CFLAGS)
--- 3231,3266 ----
  Makefile:
  	@echo The name of the makefile MUST be "Makefile" (with capital M)!!!!
  
! CCCTERM = $(CCC_NF) $(VTERM_CFLAGS) $(ALL_CFLAGS) -DINLINE="" \
  	  -DVSNPRINTF=vim_vsnprintf \
  	  -DIS_COMBINING_FUNCTION=utf_iscomposing_uint \
  	  -DWCWIDTH_FUNCTION=utf_uint2cells
  
! objects/encoding.o: libvterm/src/encoding.c $(TERM_DEPS)
  	$(CCCTERM) -o $@ libvterm/src/encoding.c
  
! objects/keyboard.o: libvterm/src/keyboard.c $(TERM_DEPS)
  	$(CCCTERM) -o $@ libvterm/src/keyboard.c
  
! objects/mouse.o: libvterm/src/mouse.c $(TERM_DEPS)
  	$(CCCTERM) -o $@ libvterm/src/mouse.c
  
! objects/parser.o: libvterm/src/parser.c $(TERM_DEPS)
  	$(CCCTERM) -o $@ libvterm/src/parser.c
  
! objects/pen.o: libvterm/src/pen.c $(TERM_DEPS)
  	$(CCCTERM) -o $@ libvterm/src/pen.c
  
! objects/termscreen.o: libvterm/src/termscreen.c $(TERM_DEPS)
! 	$(CCCTERM) -o $@ libvterm/src/termscreen.c
  
! objects/state.o: libvterm/src/state.c $(TERM_DEPS)
  	$(CCCTERM) -o $@ libvterm/src/state.c
  
! objects/unicode.o: libvterm/src/unicode.c $(TERM_DEPS)
  	$(CCCTERM) -o $@ libvterm/src/unicode.c
  
! objects/vterm.o: libvterm/src/vterm.c $(TERM_DEPS)
  	$(CCCTERM) -o $@ libvterm/src/vterm.c
  
  CCCDIFF = $(CCC_NF) $(ALL_CFLAGS)
***************
*** 3363,3629 ****
  ###############################################################################
  ### (automatically generated by 'make depend')
  ### Dependencies:
! objects/arabic.o: arabic.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/beval.o: beval.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/blowfish.o: blowfish.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/buffer.o: buffer.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h version.h
! objects/charset.o: charset.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/crypt.o: crypt.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/crypt_zip.o: crypt_zip.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/dict.o: dict.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/diff.o: diff.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/digraph.o: digraph.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/edit.o: edit.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/eval.o: eval.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h version.h
! objects/evalfunc.o: evalfunc.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h version.h
! objects/ex_cmds.o: ex_cmds.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h version.h
! objects/ex_cmds2.o: ex_cmds2.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h version.h
! objects/ex_docmd.o: ex_docmd.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h ex_cmdidxs.h
! objects/ex_eval.o: ex_eval.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/ex_getln.o: ex_getln.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/farsi.o: farsi.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/fileio.o: fileio.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/fold.o: fold.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/getchar.o: getchar.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/hardcopy.o: hardcopy.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h version.h
! objects/hashtab.o: hashtab.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/if_cscope.o: if_cscope.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h if_cscope.h
! objects/if_xcmdsrv.o: if_xcmdsrv.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h version.h
! objects/json.o: json.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/list.o: list.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/main.o: main.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/mark.o: mark.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/memfile.o: memfile.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/memline.o: memline.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/menu.o: menu.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/message.o: message.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/misc1.o: misc1.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h version.h
! objects/misc2.o: misc2.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/move.o: move.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/mbyte.o: mbyte.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/normal.o: normal.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/ops.o: ops.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \
!  keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro structs.h \
!  regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \
!  arabic.h
! objects/option.o: option.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/os_unix.o: os_unix.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h if_mzsch.h os_unixx.h
! objects/pathdef.o: auto/pathdef.c vim.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/popupmnu.o: popupmnu.c vim.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/pty.o: pty.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \
!  keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro structs.h \
!  regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \
!  arabic.h
! objects/quickfix.o: quickfix.c vim.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/regexp.o: regexp.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h regexp_nfa.c
! objects/screen.o: screen.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/search.o: search.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/sha256.o: sha256.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/spell.o: spell.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/spellfile.o: spellfile.c vim.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/syntax.o: syntax.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/tag.o: tag.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \
!  keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro structs.h \
!  regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \
!  arabic.h
! objects/term.o: term.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h libvterm/include/vterm.h \
   libvterm/include/vterm_keycodes.h
! objects/terminal.o: terminal.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h libvterm/include/vterm.h \
   libvterm/include/vterm_keycodes.h
! objects/ui.o: ui.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \
!  keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro structs.h \
!  regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \
!  arabic.h
! objects/undo.o: undo.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/userfunc.o: userfunc.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/version.o: version.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h version.h
! objects/window.o: window.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/gui.o: gui.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \
!  keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro structs.h \
!  regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \
!  arabic.h
! objects/gui_gtk.o: gui_gtk.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h gui_gtk_f.h
! objects/gui_gtk_f.o: gui_gtk_f.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h gui_gtk_f.h
! objects/gui_motif.o: gui_motif.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h gui_xmebw.h ../pixmaps/alert.xpm \
   ../pixmaps/error.xpm ../pixmaps/generic.xpm ../pixmaps/info.xpm \
   ../pixmaps/quest.xpm gui_x11_pm.h ../pixmaps/tb_new.xpm \
--- 3369,3635 ----
  ###############################################################################
  ### (automatically generated by 'make depend')
  ### Dependencies:
! objects/arabic.o: arabic.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/beval.o: beval.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/blowfish.o: blowfish.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/buffer.o: buffer.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h version.h
! objects/charset.o: charset.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/crypt.o: crypt.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/crypt_zip.o: crypt_zip.c vim.h protodef.h auto/config.h feature.h \
!  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/dict.o: dict.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/diff.o: diff.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h xdiff/xdiff.h xdiff/../vim.h
! objects/digraph.o: digraph.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/edit.o: edit.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/eval.o: eval.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h version.h
! objects/evalfunc.o: evalfunc.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h version.h
! objects/ex_cmds.o: ex_cmds.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h version.h
! objects/ex_cmds2.o: ex_cmds2.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h version.h
! objects/ex_docmd.o: ex_docmd.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h ex_cmdidxs.h
! objects/ex_eval.o: ex_eval.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/ex_getln.o: ex_getln.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/farsi.o: farsi.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/fileio.o: fileio.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/fold.o: fold.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/getchar.o: getchar.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/hardcopy.o: hardcopy.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h version.h
! objects/hashtab.o: hashtab.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+  proto.h globals.h farsi.h arabic.h
+ objects/if_cscope.o: if_cscope.c vim.h protodef.h auto/config.h feature.h \
+  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h if_cscope.h
! objects/if_xcmdsrv.o: if_xcmdsrv.c vim.h protodef.h auto/config.h feature.h \
!  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h version.h
! objects/json.o: json.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/list.o: list.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/main.o: main.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/mark.o: mark.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/memfile.o: memfile.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/memline.o: memline.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/menu.o: menu.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/message.o: message.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/misc1.o: misc1.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h version.h
! objects/misc2.o: misc2.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/move.o: move.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/mbyte.o: mbyte.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/normal.o: normal.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/ops.o: ops.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/option.o: option.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/os_unix.o: os_unix.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h os_unixx.h
! objects/pathdef.o: auto/pathdef.c vim.h protodef.h auto/config.h feature.h \
!  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/popupmnu.o: popupmnu.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/pty.o: pty.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/quickfix.o: quickfix.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/regexp.o: regexp.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h regexp_nfa.c
! objects/screen.o: screen.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/search.o: search.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/sha256.o: sha256.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/spell.o: spell.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/spellfile.o: spellfile.c vim.h protodef.h auto/config.h feature.h \
!  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/syntax.o: syntax.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/tag.o: tag.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/term.o: term.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h libvterm/include/vterm.h \
   libvterm/include/vterm_keycodes.h
! objects/terminal.o: terminal.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h libvterm/include/vterm.h \
   libvterm/include/vterm_keycodes.h
! objects/ui.o: ui.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/undo.o: undo.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/userfunc.o: userfunc.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/version.o: version.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h version.h
! objects/window.o: window.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+  proto.h globals.h farsi.h arabic.h
+ objects/gui.o: gui.c vim.h protodef.h auto/config.h feature.h os_unix.h \
+  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+  proto.h globals.h farsi.h arabic.h
+ objects/gui_gtk.o: gui_gtk.c vim.h protodef.h auto/config.h feature.h os_unix.h \
+  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+  proto.h globals.h farsi.h arabic.h gui_gtk_f.h
+ objects/gui_gtk_f.o: gui_gtk_f.c vim.h protodef.h auto/config.h feature.h \
+  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+  proto.h globals.h farsi.h arabic.h gui_gtk_f.h
+ objects/gui_motif.o: gui_motif.c vim.h protodef.h auto/config.h feature.h \
+  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h gui_xmebw.h ../pixmaps/alert.xpm \
   ../pixmaps/error.xpm ../pixmaps/generic.xpm ../pixmaps/info.xpm \
   ../pixmaps/quest.xpm gui_x11_pm.h ../pixmaps/tb_new.xpm \
***************
*** 3642,3657 ****
   ../pixmaps/tb_shell.xpm ../pixmaps/tb_replace.xpm \
   ../pixmaps/tb_vsplit.xpm ../pixmaps/tb_maxwidth.xpm \
   ../pixmaps/tb_minwidth.xpm
! objects/gui_xmdlg.o: gui_xmdlg.c vim.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/gui_xmebw.o: gui_xmebw.c vim.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h gui_xmebwp.h gui_xmebw.h
! objects/gui_athena.o: gui_athena.c vim.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h gui_at_sb.h gui_x11_pm.h \
   ../pixmaps/tb_new.xpm ../pixmaps/tb_open.xpm ../pixmaps/tb_close.xpm \
--- 3648,3663 ----
   ../pixmaps/tb_shell.xpm ../pixmaps/tb_replace.xpm \
   ../pixmaps/tb_vsplit.xpm ../pixmaps/tb_maxwidth.xpm \
   ../pixmaps/tb_minwidth.xpm
! objects/gui_xmdlg.o: gui_xmdlg.c vim.h protodef.h auto/config.h feature.h \
!  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/gui_xmebw.o: gui_xmebw.c vim.h protodef.h auto/config.h feature.h \
!  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h gui_xmebwp.h gui_xmebw.h
! objects/gui_athena.o: gui_athena.c vim.h protodef.h auto/config.h feature.h \
!  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h gui_at_sb.h gui_x11_pm.h \
   ../pixmaps/tb_new.xpm ../pixmaps/tb_open.xpm ../pixmaps/tb_close.xpm \
***************
*** 3669,3763 ****
   ../pixmaps/tb_shell.xpm ../pixmaps/tb_replace.xpm \
   ../pixmaps/tb_vsplit.xpm ../pixmaps/tb_maxwidth.xpm \
   ../pixmaps/tb_minwidth.xpm
! objects/gui_gtk_x11.o: gui_gtk_x11.c vim.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h auto/gui_gtk_gresources.h gui_gtk_f.h \
   ../runtime/vim32x32.xpm ../runtime/vim16x16.xpm ../runtime/vim48x48.xpm
! objects/gui_x11.o: gui_x11.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h ../runtime/vim32x32.xpm ../runtime/vim16x16.xpm \
!  ../runtime/vim48x48.xpm
! objects/gui_at_sb.o: gui_at_sb.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h gui_at_sb.h
! objects/gui_at_fs.o: gui_at_fs.c vim.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h gui_at_sb.h
! objects/json_test.o: json_test.c main.c vim.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h json.c
! objects/kword_test.o: kword_test.c main.c vim.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h charset.c
! objects/memfile_test.o: memfile_test.c main.c vim.h auto/config.h feature.h \
   os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h memfile.c
! objects/message_test.o: message_test.c main.c vim.h auto/config.h feature.h \
   os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h message.c
! objects/hangulin.o: hangulin.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/if_lua.o: if_lua.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/if_mzsch.o: if_mzsch.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h if_mzsch.h mzscheme_base.c
! objects/if_perl.o: auto/if_perl.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/if_perlsfio.o: if_perlsfio.c vim.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/if_python.o: if_python.c vim.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h if_py_both.h
! objects/if_python3.o: if_python3.c vim.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h if_py_both.h
! objects/if_tcl.o: if_tcl.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
! objects/if_ruby.o: if_ruby.c auto/config.h vim.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h version.h
! objects/gui_beval.o: gui_beval.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/workshop.o: workshop.c auto/config.h integration.h vim.h feature.h \
   os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h version.h workshop.h
  objects/wsdebug.o: wsdebug.c
! objects/integration.o: integration.c vim.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h integration.h
! objects/netbeans.o: netbeans.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h version.h
! objects/channel.o: channel.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
!  ascii.h keymap.h term.h macros.h option.h beval.h proto/gui_beval.pro \
!  structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h proto.h globals.h \
!  farsi.h arabic.h
  objects/gui_gtk_gresources.o: auto/gui_gtk_gresources.c
--- 3675,3847 ----
   ../pixmaps/tb_shell.xpm ../pixmaps/tb_replace.xpm \
   ../pixmaps/tb_vsplit.xpm ../pixmaps/tb_maxwidth.xpm \
   ../pixmaps/tb_minwidth.xpm
! objects/gui_gtk_x11.o: gui_gtk_x11.c vim.h protodef.h auto/config.h feature.h \
!  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h auto/gui_gtk_gresources.h gui_gtk_f.h \
   ../runtime/vim32x32.xpm ../runtime/vim16x16.xpm ../runtime/vim48x48.xpm
! objects/gui_x11.o: gui_x11.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h ../runtime/vim32x32.xpm \
!  ../runtime/vim16x16.xpm ../runtime/vim48x48.xpm
! objects/gui_at_sb.o: gui_at_sb.c vim.h protodef.h auto/config.h feature.h \
!  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h gui_at_sb.h
! objects/gui_at_fs.o: gui_at_fs.c vim.h protodef.h auto/config.h feature.h \
   os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h gui_at_sb.h
! objects/json_test.o: json_test.c main.c vim.h protodef.h auto/config.h feature.h \
   os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h json.c
! objects/kword_test.o: kword_test.c main.c vim.h protodef.h auto/config.h \
!  feature.h os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h \
!  option.h beval.h proto/gui_beval.pro structs.h regexp.h gui.h alloc.h \
!  ex_cmds.h spell.h proto.h globals.h farsi.h arabic.h charset.c
! objects/memfile_test.o: memfile_test.c main.c vim.h protodef.h auto/config.h \
!  feature.h os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h \
!  option.h beval.h proto/gui_beval.pro structs.h regexp.h gui.h alloc.h \
!  ex_cmds.h spell.h proto.h globals.h farsi.h arabic.h memfile.c
! objects/message_test.o: message_test.c main.c vim.h protodef.h auto/config.h \
!  feature.h os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h \
!  option.h beval.h proto/gui_beval.pro structs.h regexp.h gui.h alloc.h \
!  ex_cmds.h spell.h proto.h globals.h farsi.h arabic.h message.c
! objects/hangulin.o: hangulin.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/if_lua.o: if_lua.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/if_mzsch.o: if_mzsch.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
+  proto.h globals.h farsi.h arabic.h if_mzsch.h
+ objects/if_perl.o: auto/if_perl.c vim.h protodef.h auto/config.h feature.h \
+  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
+  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/if_perlsfio.o: if_perlsfio.c vim.h protodef.h auto/config.h feature.h \
!  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/if_python.o: if_python.c vim.h protodef.h auto/config.h feature.h \
!  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h if_py_both.h
! objects/if_python3.o: if_python3.c vim.h protodef.h auto/config.h feature.h \
!  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h if_py_both.h
! objects/if_tcl.o: if_tcl.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
! objects/if_ruby.o: if_ruby.c protodef.h auto/config.h vim.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h version.h
! objects/gui_beval.o: gui_beval.c vim.h protodef.h auto/config.h feature.h \
   os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
! objects/workshop.o: workshop.c protodef.h auto/config.h integration.h vim.h \
!  feature.h os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h \
!  option.h beval.h proto/gui_beval.pro structs.h regexp.h gui.h alloc.h \
!  ex_cmds.h spell.h proto.h globals.h farsi.h arabic.h version.h \
!  workshop.h
  objects/wsdebug.o: wsdebug.c
! objects/integration.o: integration.c vim.h protodef.h auto/config.h feature.h \
!  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h integration.h
! objects/netbeans.o: netbeans.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h version.h
! objects/channel.o: channel.c vim.h protodef.h auto/config.h feature.h os_unix.h \
!  auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
!  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
!  proto.h globals.h farsi.h arabic.h
  objects/gui_gtk_gresources.o: auto/gui_gtk_gresources.c
+ objects/encoding.o: libvterm/src/encoding.c libvterm/src/vterm_internal.h \
+  libvterm/include/vterm.h libvterm/include/vterm_keycodes.h \
+  libvterm/src/encoding/DECdrawing.inc libvterm/src/encoding/uk.inc
+ objects/keyboard.o: libvterm/src/keyboard.c libvterm/src/vterm_internal.h \
+  libvterm/include/vterm.h libvterm/include/vterm_keycodes.h \
+  libvterm/src/utf8.h
+ objects/mouse.o: libvterm/src/mouse.c libvterm/src/vterm_internal.h \
+  libvterm/include/vterm.h libvterm/include/vterm_keycodes.h \
+  libvterm/src/utf8.h
+ objects/parser.o: libvterm/src/parser.c libvterm/src/vterm_internal.h \
+  libvterm/include/vterm.h libvterm/include/vterm_keycodes.h
+ objects/pen.o: libvterm/src/pen.c libvterm/src/vterm_internal.h \
+  libvterm/include/vterm.h libvterm/include/vterm_keycodes.h
+ objects/state.o: libvterm/src/state.c libvterm/src/vterm_internal.h \
+  libvterm/include/vterm.h libvterm/include/vterm_keycodes.h
+ objects/termscreen.o: libvterm/src/termscreen.c libvterm/src/vterm_internal.h \
+  libvterm/include/vterm.h libvterm/include/vterm_keycodes.h \
+  libvterm/src/rect.h libvterm/src/utf8.h
+ objects/unicode.o: libvterm/src/unicode.c libvterm/src/vterm_internal.h \
+  libvterm/include/vterm.h libvterm/include/vterm_keycodes.h
+ objects/vterm.o: libvterm/src/vterm.c libvterm/src/vterm_internal.h \
+  libvterm/include/vterm.h libvterm/include/vterm_keycodes.h \
+  libvterm/src/utf8.h
+ objects/xdiffi.o: xdiff/xdiffi.c xdiff/xinclude.h xdiff/../auto/config.h \
+  xdiff/xmacros.h xdiff/xdiff.h xdiff/../vim.h xdiff/../protodef.h \
+  xdiff/../auto/config.h xdiff/../feature.h xdiff/../os_unix.h \
+  xdiff/../auto/osdef.h xdiff/../ascii.h xdiff/../keymap.h xdiff/../term.h \
+  xdiff/../macros.h xdiff/../option.h xdiff/../beval.h proto/gui_beval.pro \
+  xdiff/../structs.h xdiff/../regexp.h xdiff/../gui.h xdiff/../alloc.h \
+  xdiff/../ex_cmds.h xdiff/../spell.h xdiff/../proto.h xdiff/../globals.h \
+  xdiff/../farsi.h xdiff/../arabic.h xdiff/xtypes.h xdiff/xutils.h \
+  xdiff/xprepare.h xdiff/xdiffi.h xdiff/xemit.h
+ objects/xemit.o: xdiff/xemit.c xdiff/xinclude.h xdiff/../auto/config.h \
+  xdiff/xmacros.h xdiff/xdiff.h xdiff/../vim.h xdiff/../protodef.h \
+  xdiff/../auto/config.h xdiff/../feature.h xdiff/../os_unix.h \
+  xdiff/../auto/osdef.h xdiff/../ascii.h xdiff/../keymap.h xdiff/../term.h \
+  xdiff/../macros.h xdiff/../option.h xdiff/../beval.h proto/gui_beval.pro \
+  xdiff/../structs.h xdiff/../regexp.h xdiff/../gui.h xdiff/../alloc.h \
+  xdiff/../ex_cmds.h xdiff/../spell.h xdiff/../proto.h xdiff/../globals.h \
+  xdiff/../farsi.h xdiff/../arabic.h xdiff/xtypes.h xdiff/xutils.h \
+  xdiff/xprepare.h xdiff/xdiffi.h xdiff/xemit.h
+ objects/xprepare.o: xdiff/xprepare.c xdiff/xinclude.h xdiff/../auto/config.h \
+  xdiff/xmacros.h xdiff/xdiff.h xdiff/../vim.h xdiff/../protodef.h \
+  xdiff/../auto/config.h xdiff/../feature.h xdiff/../os_unix.h \
+  xdiff/../auto/osdef.h xdiff/../ascii.h xdiff/../keymap.h xdiff/../term.h \
+  xdiff/../macros.h xdiff/../option.h xdiff/../beval.h proto/gui_beval.pro \
+  xdiff/../structs.h xdiff/../regexp.h xdiff/../gui.h xdiff/../alloc.h \
+  xdiff/../ex_cmds.h xdiff/../spell.h xdiff/../proto.h xdiff/../globals.h \
+  xdiff/../farsi.h xdiff/../arabic.h xdiff/xtypes.h xdiff/xutils.h \
+  xdiff/xprepare.h xdiff/xdiffi.h xdiff/xemit.h
+ objects/xutils.o: xdiff/xutils.c xdiff/xinclude.h xdiff/../auto/config.h \
+  xdiff/xmacros.h xdiff/xdiff.h xdiff/../vim.h xdiff/../protodef.h \
+  xdiff/../auto/config.h xdiff/../feature.h xdiff/../os_unix.h \
+  xdiff/../auto/osdef.h xdiff/../ascii.h xdiff/../keymap.h xdiff/../term.h \
+  xdiff/../macros.h xdiff/../option.h xdiff/../beval.h proto/gui_beval.pro \
+  xdiff/../structs.h xdiff/../regexp.h xdiff/../gui.h xdiff/../alloc.h \
+  xdiff/../ex_cmds.h xdiff/../spell.h xdiff/../proto.h xdiff/../globals.h \
+  xdiff/../farsi.h xdiff/../arabic.h xdiff/xtypes.h xdiff/xutils.h \
+  xdiff/xprepare.h xdiff/xdiffi.h xdiff/xemit.h
+ objects/xhistogram.o: xdiff/xhistogram.c xdiff/xinclude.h xdiff/../auto/config.h \
+  xdiff/xmacros.h xdiff/xdiff.h xdiff/../vim.h xdiff/../protodef.h \
+  xdiff/../auto/config.h xdiff/../feature.h xdiff/../os_unix.h \
+  xdiff/../auto/osdef.h xdiff/../ascii.h xdiff/../keymap.h xdiff/../term.h \
+  xdiff/../macros.h xdiff/../option.h xdiff/../beval.h proto/gui_beval.pro \
+  xdiff/../structs.h xdiff/../regexp.h xdiff/../gui.h xdiff/../alloc.h \
+  xdiff/../ex_cmds.h xdiff/../spell.h xdiff/../proto.h xdiff/../globals.h \
+  xdiff/../farsi.h xdiff/../arabic.h xdiff/xtypes.h xdiff/xutils.h \
+  xdiff/xprepare.h xdiff/xdiffi.h xdiff/xemit.h
+ objects/xpatience.o: xdiff/xpatience.c xdiff/xinclude.h xdiff/../auto/config.h \
+  xdiff/xmacros.h xdiff/xdiff.h xdiff/../vim.h xdiff/../protodef.h \
+  xdiff/../auto/config.h xdiff/../feature.h xdiff/../os_unix.h \
+  xdiff/../auto/osdef.h xdiff/../ascii.h xdiff/../keymap.h xdiff/../term.h \
+  xdiff/../macros.h xdiff/../option.h xdiff/../beval.h proto/gui_beval.pro \
+  xdiff/../structs.h xdiff/../regexp.h xdiff/../gui.h xdiff/../alloc.h \
+  xdiff/../ex_cmds.h xdiff/../spell.h xdiff/../proto.h xdiff/../globals.h \
+  xdiff/../farsi.h xdiff/../arabic.h xdiff/xtypes.h xdiff/xutils.h \
+  xdiff/xprepare.h xdiff/xdiffi.h xdiff/xemit.h
*** ../vim-8.1.0378/src/configure.ac	2018-09-12 20:29:05.475670636 +0200
--- src/configure.ac	2018-09-13 17:15:34.048615043 +0200
***************
*** 2114,2122 ****
  fi
  if test "$enable_terminal" = "yes" -a "$enable_channel" = "yes"; then
    AC_DEFINE(FEAT_TERMINAL)
!   TERM_SRC="libvterm/src/encoding.c libvterm/src/keyboard.c libvterm/src/mouse.c libvterm/src/parser.c libvterm/src/pen.c libvterm/src/screen.c libvterm/src/state.c libvterm/src/unicode.c libvterm/src/vterm.c"
    AC_SUBST(TERM_SRC)
!   TERM_OBJ="objects/term_encoding.o objects/term_keyboard.o objects/term_mouse.o objects/term_parser.o objects/term_pen.o objects/term_screen.o objects/term_state.o objects/term_unicode.o objects/term_vterm.o"
    AC_SUBST(TERM_OBJ)
  fi
  
--- 2114,2122 ----
  fi
  if test "$enable_terminal" = "yes" -a "$enable_channel" = "yes"; then
    AC_DEFINE(FEAT_TERMINAL)
!   TERM_SRC="libvterm/src/encoding.c libvterm/src/keyboard.c libvterm/src/mouse.c libvterm/src/parser.c libvterm/src/pen.c libvterm/src/termscreen.c libvterm/src/state.c libvterm/src/unicode.c libvterm/src/vterm.c"
    AC_SUBST(TERM_SRC)
!   TERM_OBJ="objects/encoding.o objects/keyboard.o objects/mouse.o objects/parser.o objects/pen.o objects/termscreen.o objects/state.o objects/unicode.o objects/vterm.o"
    AC_SUBST(TERM_OBJ)
  fi
  
*** ../vim-8.1.0378/src/auto/configure	2018-09-12 20:29:05.479670601 +0200
--- src/auto/configure	2018-09-13 17:16:18.668305363 +0200
***************
*** 7916,7924 ****
  if test "$enable_terminal" = "yes" -a "$enable_channel" = "yes"; then
    $as_echo "#define FEAT_TERMINAL 1" >>confdefs.h
  
!   TERM_SRC="libvterm/src/encoding.c libvterm/src/keyboard.c libvterm/src/mouse.c libvterm/src/parser.c libvterm/src/pen.c libvterm/src/screen.c libvterm/src/state.c libvterm/src/unicode.c libvterm/src/vterm.c"
  
!   TERM_OBJ="objects/term_encoding.o objects/term_keyboard.o objects/term_mouse.o objects/term_parser.o objects/term_pen.o objects/term_screen.o objects/term_state.o objects/term_unicode.o objects/term_vterm.o"
  
  fi
  
--- 7916,7924 ----
  if test "$enable_terminal" = "yes" -a "$enable_channel" = "yes"; then
    $as_echo "#define FEAT_TERMINAL 1" >>confdefs.h
  
!   TERM_SRC="libvterm/src/encoding.c libvterm/src/keyboard.c libvterm/src/mouse.c libvterm/src/parser.c libvterm/src/pen.c libvterm/src/termscreen.c libvterm/src/state.c libvterm/src/unicode.c libvterm/src/vterm.c"
  
!   TERM_OBJ="objects/encoding.o objects/keyboard.o objects/mouse.o objects/parser.o objects/pen.o objects/termscreen.o objects/state.o objects/unicode.o objects/vterm.o"
  
  fi
  
*** ../vim-8.1.0378/src/libvterm/src/screen.c	2018-04-24 18:13:56.000000000 +0200
--- src/libvterm/src/screen.c	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,935 ****
- #include "vterm_internal.h"
- 
- #include <stdio.h>
- #include <string.h>
- 
- #include "rect.h"
- #include "utf8.h"
- 
- #define UNICODE_SPACE 0x20
- #define UNICODE_LINEFEED 0x0a
- 
- /* State of the pen at some moment in time, also used in a cell */
- typedef struct
- {
-   /* After the bitfield */
-   VTermColor   fg, bg;
- 
-   unsigned int bold      : 1;
-   unsigned int underline : 2;
-   unsigned int italic    : 1;
-   unsigned int blink     : 1;
-   unsigned int reverse   : 1;
-   unsigned int strike    : 1;
-   unsigned int font      : 4; /* 0 to 9 */
- 
-   /* Extra state storage that isn't strictly pen-related */
-   unsigned int protected_cell : 1;
-   unsigned int dwl            : 1; /* on a DECDWL or DECDHL line */
-   unsigned int dhl            : 2; /* on a DECDHL line (1=top 2=bottom) */
- } ScreenPen;
- 
- /* Internal representation of a screen cell */
- typedef struct
- {
-   uint32_t chars[VTERM_MAX_CHARS_PER_CELL];
-   ScreenPen pen;
- } ScreenCell;
- 
- static int vterm_screen_set_cell(VTermScreen *screen, VTermPos pos, const VTermScreenCell *cell);
- 
- struct VTermScreen
- {
-   VTerm *vt;
-   VTermState *state;
- 
-   const VTermScreenCallbacks *callbacks;
-   void *cbdata;
- 
-   VTermDamageSize damage_merge;
-   /* start_row == -1 => no damage */
-   VTermRect damaged;
-   VTermRect pending_scrollrect;
-   int pending_scroll_downward, pending_scroll_rightward;
- 
-   int rows;
-   int cols;
-   int global_reverse;
- 
-   /* Primary and Altscreen. buffers[1] is lazily allocated as needed */
-   ScreenCell *buffers[2];
- 
-   /* buffer will == buffers[0] or buffers[1], depending on altscreen */
-   ScreenCell *buffer;
- 
-   /* buffer for a single screen row used in scrollback storage callbacks */
-   VTermScreenCell *sb_buffer;
- 
-   ScreenPen pen;
- };
- 
- static ScreenCell *getcell(const VTermScreen *screen, int row, int col)
- {
-   if(row < 0 || row >= screen->rows)
-     return NULL;
-   if(col < 0 || col >= screen->cols)
-     return NULL;
-   return screen->buffer + (screen->cols * row) + col;
- }
- 
- static ScreenCell *realloc_buffer(VTermScreen *screen, ScreenCell *buffer, int new_rows, int new_cols)
- {
-   ScreenCell *new_buffer = vterm_allocator_malloc(screen->vt, sizeof(ScreenCell) * new_rows * new_cols);
-   int row, col;
- 
-   for(row = 0; row < new_rows; row++) {
-     for(col = 0; col < new_cols; col++) {
-       ScreenCell *new_cell = new_buffer + row*new_cols + col;
- 
-       if(buffer && row < screen->rows && col < screen->cols)
-         *new_cell = buffer[row * screen->cols + col];
-       else {
-         new_cell->chars[0] = 0;
-         new_cell->pen = screen->pen;
-       }
-     }
-   }
- 
-   if(buffer)
-     vterm_allocator_free(screen->vt, buffer);
- 
-   return new_buffer;
- }
- 
- static void damagerect(VTermScreen *screen, VTermRect rect)
- {
-   VTermRect emit;
- 
-   switch(screen->damage_merge) {
-   case VTERM_DAMAGE_CELL:
-     /* Always emit damage event */
-     emit = rect;
-     break;
- 
-   case VTERM_DAMAGE_ROW:
-     /* Emit damage longer than one row. Try to merge with existing damage in
-      * the same row */
-     if(rect.end_row > rect.start_row + 1) {
-       // Bigger than 1 line - flush existing, emit this
-       vterm_screen_flush_damage(screen);
-       emit = rect;
-     }
-     else if(screen->damaged.start_row == -1) {
-       // None stored yet
-       screen->damaged = rect;
-       return;
-     }
-     else if(rect.start_row == screen->damaged.start_row) {
-       // Merge with the stored line
-       if(screen->damaged.start_col > rect.start_col)
-         screen->damaged.start_col = rect.start_col;
-       if(screen->damaged.end_col < rect.end_col)
-         screen->damaged.end_col = rect.end_col;
-       return;
-     }
-     else {
-       // Emit the currently stored line, store a new one
-       emit = screen->damaged;
-       screen->damaged = rect;
-     }
-     break;
- 
-   case VTERM_DAMAGE_SCREEN:
-   case VTERM_DAMAGE_SCROLL:
-     /* Never emit damage event */
-     if(screen->damaged.start_row == -1)
-       screen->damaged = rect;
-     else {
-       rect_expand(&screen->damaged, &rect);
-     }
-     return;
- 
-   default:
-     DEBUG_LOG1("TODO: Maybe merge damage for level %d\n", screen->damage_merge);
-     return;
-   }
- 
-   if(screen->callbacks && screen->callbacks->damage)
-     (*screen->callbacks->damage)(emit, screen->cbdata);
- }
- 
- static void damagescreen(VTermScreen *screen)
- {
-   VTermRect rect = {0,0,0,0};
-   rect.end_row = screen->rows;
-   rect.end_col = screen->cols;
- 
-   damagerect(screen, rect);
- }
- 
- static int putglyph(VTermGlyphInfo *info, VTermPos pos, void *user)
- {
-   int i;
-   int col;
-   VTermRect rect;
- 
-   VTermScreen *screen = user;
-   ScreenCell *cell = getcell(screen, pos.row, pos.col);
- 
-   if(!cell)
-     return 0;
- 
-   for(i = 0; i < VTERM_MAX_CHARS_PER_CELL && info->chars[i]; i++) {
-     cell->chars[i] = info->chars[i];
-     cell->pen = screen->pen;
-   }
-   if(i < VTERM_MAX_CHARS_PER_CELL)
-     cell->chars[i] = 0;
- 
-   for(col = 1; col < info->width; col++)
-     getcell(screen, pos.row, pos.col + col)->chars[0] = (uint32_t)-1;
- 
-   rect.start_row = pos.row;
-   rect.end_row   = pos.row+1;
-   rect.start_col = pos.col;
-   rect.end_col   = pos.col+info->width;
- 
-   cell->pen.protected_cell = info->protected_cell;
-   cell->pen.dwl            = info->dwl;
-   cell->pen.dhl            = info->dhl;
- 
-   damagerect(screen, rect);
- 
-   return 1;
- }
- 
- static int moverect_internal(VTermRect dest, VTermRect src, void *user)
- {
-   VTermScreen *screen = user;
- 
-   if(screen->callbacks && screen->callbacks->sb_pushline &&
-      dest.start_row == 0 && dest.start_col == 0 &&  // starts top-left corner
-      dest.end_col == screen->cols &&                // full width
-      screen->buffer == screen->buffers[0]) {        // not altscreen
-     VTermPos pos;
-     for(pos.row = 0; pos.row < src.start_row; pos.row++) {
-       for(pos.col = 0; pos.col < screen->cols; pos.col++)
-         (void)vterm_screen_get_cell(screen, pos, screen->sb_buffer + pos.col);
- 
-       (screen->callbacks->sb_pushline)(screen->cols, screen->sb_buffer, screen->cbdata);
-     }
-   }
- 
-   {
-     int cols = src.end_col - src.start_col;
-     int downward = src.start_row - dest.start_row;
-     int init_row, test_row, inc_row;
-     int row;
- 
-     if(downward < 0) {
-       init_row = dest.end_row - 1;
-       test_row = dest.start_row - 1;
-       inc_row  = -1;
-     }
-     else {
-       init_row = dest.start_row;
-       test_row = dest.end_row;
-       inc_row  = +1;
-     }
- 
-     for(row = init_row; row != test_row; row += inc_row)
-       memmove(getcell(screen, row, dest.start_col),
- 	      getcell(screen, row + downward, src.start_col),
- 	      cols * sizeof(ScreenCell));
-   }
- 
-   return 1;
- }
- 
- static int moverect_user(VTermRect dest, VTermRect src, void *user)
- {
-   VTermScreen *screen = user;
- 
-   if(screen->callbacks && screen->callbacks->moverect) {
-     if(screen->damage_merge != VTERM_DAMAGE_SCROLL)
-       // Avoid an infinite loop
-       vterm_screen_flush_damage(screen);
- 
-     if((*screen->callbacks->moverect)(dest, src, screen->cbdata))
-       return 1;
-   }
- 
-   damagerect(screen, dest);
- 
-   return 1;
- }
- 
- static int erase_internal(VTermRect rect, int selective, void *user)
- {
-   VTermScreen *screen = user;
-   int row, col;
- 
-   for(row = rect.start_row; row < screen->state->rows && row < rect.end_row; row++) {
-     const VTermLineInfo *info = vterm_state_get_lineinfo(screen->state, row);
- 
-     for(col = rect.start_col; col < rect.end_col; col++) {
-       ScreenCell *cell = getcell(screen, row, col);
- 
-       if(selective && cell->pen.protected_cell)
-         continue;
- 
-       cell->chars[0] = 0;
-       cell->pen = screen->pen;
-       cell->pen.dwl = info->doublewidth;
-       cell->pen.dhl = info->doubleheight;
-     }
-   }
- 
-   return 1;
- }
- 
- static int erase_user(VTermRect rect, int selective UNUSED, void *user)
- {
-   VTermScreen *screen = user;
- 
-   damagerect(screen, rect);
- 
-   return 1;
- }
- 
- static int erase(VTermRect rect, int selective, void *user)
- {
-   erase_internal(rect, selective, user);
-   return erase_user(rect, 0, user);
- }
- 
- static int scrollrect(VTermRect rect, int downward, int rightward, void *user)
- {
-   VTermScreen *screen = user;
- 
-   if(screen->damage_merge != VTERM_DAMAGE_SCROLL) {
-     vterm_scroll_rect(rect, downward, rightward,
-         moverect_internal, erase_internal, screen);
- 
-     vterm_screen_flush_damage(screen);
- 
-     vterm_scroll_rect(rect, downward, rightward,
-         moverect_user, erase_user, screen);
- 
-     return 1;
-   }
- 
-   if(screen->damaged.start_row != -1 &&
-      !rect_intersects(&rect, &screen->damaged)) {
-     vterm_screen_flush_damage(screen);
-   }
- 
-   if(screen->pending_scrollrect.start_row == -1) {
-     screen->pending_scrollrect = rect;
-     screen->pending_scroll_downward  = downward;
-     screen->pending_scroll_rightward = rightward;
-   }
-   else if(rect_equal(&screen->pending_scrollrect, &rect) &&
-      ((screen->pending_scroll_downward  == 0 && downward  == 0) ||
-       (screen->pending_scroll_rightward == 0 && rightward == 0))) {
-     screen->pending_scroll_downward  += downward;
-     screen->pending_scroll_rightward += rightward;
-   }
-   else {
-     vterm_screen_flush_damage(screen);
- 
-     screen->pending_scrollrect = rect;
-     screen->pending_scroll_downward  = downward;
-     screen->pending_scroll_rightward = rightward;
-   }
- 
-   vterm_scroll_rect(rect, downward, rightward,
-       moverect_internal, erase_internal, screen);
- 
-   if(screen->damaged.start_row == -1)
-     return 1;
- 
-   if(rect_contains(&rect, &screen->damaged)) {
-     /* Scroll region entirely contains the damage; just move it */
-     vterm_rect_move(&screen->damaged, -downward, -rightward);
-     rect_clip(&screen->damaged, &rect);
-   }
-   /* There are a number of possible cases here, but lets restrict this to only
-    * the common case where we might actually gain some performance by
-    * optimising it. Namely, a vertical scroll that neatly cuts the damage
-    * region in half.
-    */
-   else if(rect.start_col <= screen->damaged.start_col &&
-           rect.end_col   >= screen->damaged.end_col &&
-           rightward == 0) {
-     if(screen->damaged.start_row >= rect.start_row &&
-        screen->damaged.start_row  < rect.end_row) {
-       screen->damaged.start_row -= downward;
-       if(screen->damaged.start_row < rect.start_row)
-         screen->damaged.start_row = rect.start_row;
-       if(screen->damaged.start_row > rect.end_row)
-         screen->damaged.start_row = rect.end_row;
-     }
-     if(screen->damaged.end_row >= rect.start_row &&
-        screen->damaged.end_row  < rect.end_row) {
-       screen->damaged.end_row -= downward;
-       if(screen->damaged.end_row < rect.start_row)
-         screen->damaged.end_row = rect.start_row;
-       if(screen->damaged.end_row > rect.end_row)
-         screen->damaged.end_row = rect.end_row;
-     }
-   }
-   else {
-     DEBUG_LOG2("TODO: Just flush and redo damaged=" STRFrect " rect=" STRFrect "\n",
-         ARGSrect(screen->damaged), ARGSrect(rect));
-   }
- 
-   return 1;
- }
- 
- static int movecursor(VTermPos pos, VTermPos oldpos, int visible, void *user)
- {
-   VTermScreen *screen = user;
- 
-   if(screen->callbacks && screen->callbacks->movecursor)
-     return (*screen->callbacks->movecursor)(pos, oldpos, visible, screen->cbdata);
- 
-   return 0;
- }
- 
- static int setpenattr(VTermAttr attr, VTermValue *val, void *user)
- {
-   VTermScreen *screen = user;
- 
-   switch(attr) {
-   case VTERM_ATTR_BOLD:
-     screen->pen.bold = val->boolean;
-     return 1;
-   case VTERM_ATTR_UNDERLINE:
-     screen->pen.underline = val->number;
-     return 1;
-   case VTERM_ATTR_ITALIC:
-     screen->pen.italic = val->boolean;
-     return 1;
-   case VTERM_ATTR_BLINK:
-     screen->pen.blink = val->boolean;
-     return 1;
-   case VTERM_ATTR_REVERSE:
-     screen->pen.reverse = val->boolean;
-     return 1;
-   case VTERM_ATTR_STRIKE:
-     screen->pen.strike = val->boolean;
-     return 1;
-   case VTERM_ATTR_FONT:
-     screen->pen.font = val->number;
-     return 1;
-   case VTERM_ATTR_FOREGROUND:
-     screen->pen.fg = val->color;
-     return 1;
-   case VTERM_ATTR_BACKGROUND:
-     screen->pen.bg = val->color;
-     return 1;
- 
-   case VTERM_N_ATTRS:
-     return 0;
-   }
- 
-   return 0;
- }
- 
- static int settermprop(VTermProp prop, VTermValue *val, void *user)
- {
-   VTermScreen *screen = user;
- 
-   switch(prop) {
-   case VTERM_PROP_ALTSCREEN:
-     if(val->boolean && !screen->buffers[1])
-       return 0;
- 
-     screen->buffer = val->boolean ? screen->buffers[1] : screen->buffers[0];
-     /* only send a damage event on disable; because during enable there's an
-      * erase that sends a damage anyway
-      */
-     if(!val->boolean)
-       damagescreen(screen);
-     break;
-   case VTERM_PROP_REVERSE:
-     screen->global_reverse = val->boolean;
-     damagescreen(screen);
-     break;
-   default:
-     ; /* ignore */
-   }
- 
-   if(screen->callbacks && screen->callbacks->settermprop)
-     return (*screen->callbacks->settermprop)(prop, val, screen->cbdata);
- 
-   return 1;
- }
- 
- static int bell(void *user)
- {
-   VTermScreen *screen = user;
- 
-   if(screen->callbacks && screen->callbacks->bell)
-     return (*screen->callbacks->bell)(screen->cbdata);
- 
-   return 0;
- }
- 
- static int resize(int new_rows, int new_cols, VTermPos *delta, void *user)
- {
-   VTermScreen *screen = user;
- 
-   int is_altscreen = (screen->buffers[1] && screen->buffer == screen->buffers[1]);
- 
-   int old_rows = screen->rows;
-   int old_cols = screen->cols;
-   int first_blank_row;
- 
-   if(!is_altscreen && new_rows < old_rows) {
-     // Fewer rows - determine if we're going to scroll at all, and if so, push
-     // those lines to scrollback
-     VTermPos pos = { 0, 0 };
-     VTermPos cursor = screen->state->pos;
-     // Find the first blank row after the cursor.
-     for(pos.row = old_rows - 1; pos.row >= new_rows; pos.row--)
-       if(!vterm_screen_is_eol(screen, pos) || cursor.row == pos.row)
-         break;
- 
-     first_blank_row = pos.row + 1;
-     if(first_blank_row > new_rows) {
-       VTermRect rect = {0,0,0,0};
-       rect.end_row   = old_rows;
-       rect.end_col   = old_cols;
-       scrollrect(rect, first_blank_row - new_rows, 0, user);
-       vterm_screen_flush_damage(screen);
- 
-       delta->row -= first_blank_row - new_rows;
-     }
-   }
- 
-   screen->buffers[0] = realloc_buffer(screen, screen->buffers[0], new_rows, new_cols);
-   if(screen->buffers[1])
-     screen->buffers[1] = realloc_buffer(screen, screen->buffers[1], new_rows, new_cols);
- 
-   screen->buffer = is_altscreen ? screen->buffers[1] : screen->buffers[0];
- 
-   screen->rows = new_rows;
-   screen->cols = new_cols;
- 
-   if(screen->sb_buffer)
-     vterm_allocator_free(screen->vt, screen->sb_buffer);
- 
-   screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * new_cols);
- 
-   if(new_cols > old_cols) {
-     VTermRect rect;
-     rect.start_row = 0;
-     rect.end_row   = old_rows;
-     rect.start_col = old_cols;
-     rect.end_col   = new_cols;
-     damagerect(screen, rect);
-   }
- 
-   if(new_rows > old_rows) {
-     if(!is_altscreen && screen->callbacks && screen->callbacks->sb_popline) {
-       int rows = new_rows - old_rows;
-       while(rows) {
-         VTermRect rect = {0,0,0,0};
-         VTermPos pos = { 0, 0 };
-         if(!(screen->callbacks->sb_popline(screen->cols, screen->sb_buffer, screen->cbdata)))
-           break;
- 
- 	rect.end_row   = screen->rows;
- 	rect.end_col   = screen->cols;
-         scrollrect(rect, -1, 0, user);
- 
-         for(pos.col = 0; pos.col < screen->cols; pos.col += screen->sb_buffer[pos.col].width)
-           vterm_screen_set_cell(screen, pos, screen->sb_buffer + pos.col);
- 
-         rect.end_row = 1;
-         damagerect(screen, rect);
- 
-         vterm_screen_flush_damage(screen);
- 
-         rows--;
-         delta->row++;
-       }
-     }
- 
-     {
-       VTermRect rect;
-       rect.start_row = old_rows;
-       rect.end_row   = new_rows;
-       rect.start_col = 0;
-       rect.end_col   = new_cols;
-       damagerect(screen, rect);
-     }
-   }
- 
-   if(screen->callbacks && screen->callbacks->resize)
-     return (*screen->callbacks->resize)(new_rows, new_cols, screen->cbdata);
- 
-   return 1;
- }
- 
- static int setlineinfo(int row, const VTermLineInfo *newinfo, const VTermLineInfo *oldinfo, void *user)
- {
-   VTermScreen *screen = user;
-   int col;
-   VTermRect rect;
- 
-   if(newinfo->doublewidth != oldinfo->doublewidth ||
-      newinfo->doubleheight != oldinfo->doubleheight) {
-     for(col = 0; col < screen->cols; col++) {
-       ScreenCell *cell = getcell(screen, row, col);
-       cell->pen.dwl = newinfo->doublewidth;
-       cell->pen.dhl = newinfo->doubleheight;
-     }
- 
-     rect.start_row = row;
-     rect.end_row   = row + 1;
-     rect.start_col = 0;
-     rect.end_col   = newinfo->doublewidth ? screen->cols / 2 : screen->cols;
-     damagerect(screen, rect);
- 
-     if(newinfo->doublewidth) {
-       rect.start_col = screen->cols / 2;
-       rect.end_col   = screen->cols;
- 
-       erase_internal(rect, 0, user);
-     }
-   }
- 
-   return 1;
- }
- 
- static VTermStateCallbacks state_cbs = {
-   &putglyph, /* putglyph */
-   &movecursor, /* movecursor */
-   &scrollrect, /* scrollrect */
-   NULL, /* moverect */
-   &erase, /* erase */
-   NULL, /* initpen */
-   &setpenattr, /* setpenattr */
-   &settermprop, /* settermprop */
-   &bell, /* bell */
-   &resize, /* resize */
-   &setlineinfo /* setlineinfo */
- };
- 
- static VTermScreen *screen_new(VTerm *vt)
- {
-   VTermState *state = vterm_obtain_state(vt);
-   VTermScreen *screen;
-   int rows, cols;
- 
-   if(!state)
-     return NULL;
- 
-   screen = vterm_allocator_malloc(vt, sizeof(VTermScreen));
- 
-   vterm_get_size(vt, &rows, &cols);
- 
-   screen->vt = vt;
-   screen->state = state;
- 
-   screen->damage_merge = VTERM_DAMAGE_CELL;
-   screen->damaged.start_row = -1;
-   screen->pending_scrollrect.start_row = -1;
- 
-   screen->rows = rows;
-   screen->cols = cols;
- 
-   screen->callbacks = NULL;
-   screen->cbdata    = NULL;
- 
-   screen->buffers[0] = realloc_buffer(screen, NULL, rows, cols);
- 
-   screen->buffer = screen->buffers[0];
- 
-   screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * cols);
- 
-   vterm_state_set_callbacks(screen->state, &state_cbs, screen);
- 
-   return screen;
- }
- 
- INTERNAL void vterm_screen_free(VTermScreen *screen)
- {
-   vterm_allocator_free(screen->vt, screen->buffers[0]);
-   if(screen->buffers[1])
-     vterm_allocator_free(screen->vt, screen->buffers[1]);
- 
-   vterm_allocator_free(screen->vt, screen->sb_buffer);
- 
-   vterm_allocator_free(screen->vt, screen);
- }
- 
- void vterm_screen_reset(VTermScreen *screen, int hard)
- {
-   screen->damaged.start_row = -1;
-   screen->pending_scrollrect.start_row = -1;
-   vterm_state_reset(screen->state, hard);
-   vterm_screen_flush_damage(screen);
- }
- 
- static size_t _get_chars(const VTermScreen *screen, const int utf8, void *buffer, size_t len, const VTermRect rect)
- {
-   size_t outpos = 0;
-   int padding = 0;
-   int row, col;
- 
- #define PUT(c)                                             \
-   if(utf8) {                                               \
-     size_t thislen = utf8_seqlen(c);                       \
-     if(buffer && outpos + thislen <= len)                  \
-       outpos += fill_utf8((c), (char *)buffer + outpos);   \
-     else                                                   \
-       outpos += thislen;                                   \
-   }                                                        \
-   else {                                                   \
-     if(buffer && outpos + 1 <= len)                        \
-       ((uint32_t*)buffer)[outpos++] = (c);                 \
-     else                                                   \
-       outpos++;                                            \
-   }
- 
-   for(row = rect.start_row; row < rect.end_row; row++) {
-     for(col = rect.start_col; col < rect.end_col; col++) {
-       ScreenCell *cell = getcell(screen, row, col);
-       int i;
- 
-       if(cell->chars[0] == 0)
-         // Erased cell, might need a space
-         padding++;
-       else if(cell->chars[0] == (uint32_t)-1)
-         // Gap behind a double-width char, do nothing
-         ;
-       else {
-         while(padding) {
-           PUT(UNICODE_SPACE);
-           padding--;
-         }
-         for(i = 0; i < VTERM_MAX_CHARS_PER_CELL && cell->chars[i]; i++) {
-           PUT(cell->chars[i]);
-         }
-       }
-     }
- 
-     if(row < rect.end_row - 1) {
-       PUT(UNICODE_LINEFEED);
-       padding = 0;
-     }
-   }
- 
-   return outpos;
- }
- 
- size_t vterm_screen_get_chars(const VTermScreen *screen, uint32_t *chars, size_t len, const VTermRect rect)
- {
-   return _get_chars(screen, 0, chars, len, rect);
- }
- 
- size_t vterm_screen_get_text(const VTermScreen *screen, char *str, size_t len, const VTermRect rect)
- {
-   return _get_chars(screen, 1, str, len, rect);
- }
- 
- /* Copy internal to external representation of a screen cell */
- int vterm_screen_get_cell(const VTermScreen *screen, VTermPos pos, VTermScreenCell *cell)
- {
-   ScreenCell *intcell = getcell(screen, pos.row, pos.col);
-   int i;
- 
-   if(!intcell)
-     return 0;
- 
-   for(i = 0; ; i++) {
-     cell->chars[i] = intcell->chars[i];
-     if(!intcell->chars[i])
-       break;
-   }
- 
-   cell->attrs.bold      = intcell->pen.bold;
-   cell->attrs.underline = intcell->pen.underline;
-   cell->attrs.italic    = intcell->pen.italic;
-   cell->attrs.blink     = intcell->pen.blink;
-   cell->attrs.reverse   = intcell->pen.reverse ^ screen->global_reverse;
-   cell->attrs.strike    = intcell->pen.strike;
-   cell->attrs.font      = intcell->pen.font;
- 
-   cell->attrs.dwl = intcell->pen.dwl;
-   cell->attrs.dhl = intcell->pen.dhl;
- 
-   cell->fg = intcell->pen.fg;
-   cell->bg = intcell->pen.bg;
- 
-   if(pos.col < (screen->cols - 1) &&
-      getcell(screen, pos.row, pos.col + 1)->chars[0] == (uint32_t)-1)
-     cell->width = 2;
-   else
-     cell->width = 1;
- 
-   return 1;
- }
- 
- /* Copy external to internal representation of a screen cell */
- /* static because it's only used internally for sb_popline during resize */
- static int vterm_screen_set_cell(VTermScreen *screen, VTermPos pos, const VTermScreenCell *cell)
- {
-   ScreenCell *intcell = getcell(screen, pos.row, pos.col);
-   int i;
- 
-   if(!intcell)
-     return 0;
- 
-   for(i = 0; ; i++) {
-     intcell->chars[i] = cell->chars[i];
-     if(!cell->chars[i])
-       break;
-   }
- 
-   intcell->pen.bold      = cell->attrs.bold;
-   intcell->pen.underline = cell->attrs.underline;
-   intcell->pen.italic    = cell->attrs.italic;
-   intcell->pen.blink     = cell->attrs.blink;
-   intcell->pen.reverse   = cell->attrs.reverse ^ screen->global_reverse;
-   intcell->pen.strike    = cell->attrs.strike;
-   intcell->pen.font      = cell->attrs.font;
- 
-   intcell->pen.fg = cell->fg;
-   intcell->pen.bg = cell->bg;
- 
-   if(cell->width == 2)
-     getcell(screen, pos.row, pos.col + 1)->chars[0] = (uint32_t)-1;
- 
-   return 1;
- }
- 
- int vterm_screen_is_eol(const VTermScreen *screen, VTermPos pos)
- {
-   /* This cell is EOL if this and every cell to the right is black */
-   for(; pos.col < screen->cols; pos.col++) {
-     ScreenCell *cell = getcell(screen, pos.row, pos.col);
-     if(cell->chars[0] != 0)
-       return 0;
-   }
- 
-   return 1;
- }
- 
- VTermScreen *vterm_obtain_screen(VTerm *vt)
- {
-   if(!vt->screen)
-     vt->screen = screen_new(vt);
-   return vt->screen;
- }
- 
- void vterm_screen_enable_altscreen(VTermScreen *screen, int altscreen)
- {
- 
-   if(!screen->buffers[1] && altscreen) {
-     int rows, cols;
-     vterm_get_size(screen->vt, &rows, &cols);
- 
-     screen->buffers[1] = realloc_buffer(screen, NULL, rows, cols);
-   }
- }
- 
- void vterm_screen_set_callbacks(VTermScreen *screen, const VTermScreenCallbacks *callbacks, void *user)
- {
-   screen->callbacks = callbacks;
-   screen->cbdata = user;
- }
- 
- void *vterm_screen_get_cbdata(VTermScreen *screen)
- {
-   return screen->cbdata;
- }
- 
- void vterm_screen_set_unrecognised_fallbacks(VTermScreen *screen, const VTermParserCallbacks *fallbacks, void *user)
- {
-   vterm_state_set_unrecognised_fallbacks(screen->state, fallbacks, user);
- }
- 
- void *vterm_screen_get_unrecognised_fbdata(VTermScreen *screen)
- {
-   return vterm_state_get_unrecognised_fbdata(screen->state);
- }
- 
- void vterm_screen_flush_damage(VTermScreen *screen)
- {
-   if(screen->pending_scrollrect.start_row != -1) {
-     vterm_scroll_rect(screen->pending_scrollrect, screen->pending_scroll_downward, screen->pending_scroll_rightward,
-         moverect_user, erase_user, screen);
- 
-     screen->pending_scrollrect.start_row = -1;
-   }
- 
-   if(screen->damaged.start_row != -1) {
-     if(screen->callbacks && screen->callbacks->damage)
-       (*screen->callbacks->damage)(screen->damaged, screen->cbdata);
- 
-     screen->damaged.start_row = -1;
-   }
- }
- 
- void vterm_screen_set_damage_merge(VTermScreen *screen, VTermDamageSize size)
- {
-   vterm_screen_flush_damage(screen);
-   screen->damage_merge = size;
- }
- 
- static int attrs_differ(VTermAttrMask attrs, ScreenCell *a, ScreenCell *b)
- {
-   if((attrs & VTERM_ATTR_BOLD_MASK)       && (a->pen.bold != b->pen.bold))
-     return 1;
-   if((attrs & VTERM_ATTR_UNDERLINE_MASK)  && (a->pen.underline != b->pen.underline))
-     return 1;
-   if((attrs & VTERM_ATTR_ITALIC_MASK)     && (a->pen.italic != b->pen.italic))
-     return 1;
-   if((attrs & VTERM_ATTR_BLINK_MASK)      && (a->pen.blink != b->pen.blink))
-     return 1;
-   if((attrs & VTERM_ATTR_REVERSE_MASK)    && (a->pen.reverse != b->pen.reverse))
-     return 1;
-   if((attrs & VTERM_ATTR_STRIKE_MASK)     && (a->pen.strike != b->pen.strike))
-     return 1;
-   if((attrs & VTERM_ATTR_FONT_MASK)       && (a->pen.font != b->pen.font))
-     return 1;
-   if((attrs & VTERM_ATTR_FOREGROUND_MASK) && !vterm_color_equal(a->pen.fg, b->pen.fg))
-     return 1;
-   if((attrs & VTERM_ATTR_BACKGROUND_MASK) && !vterm_color_equal(a->pen.bg, b->pen.bg))
-     return 1;
- 
-   return 0;
- }
- 
- int vterm_screen_get_attrs_extent(const VTermScreen *screen, VTermRect *extent, VTermPos pos, VTermAttrMask attrs)
- {
-   int col;
- 
-   ScreenCell *target = getcell(screen, pos.row, pos.col);
- 
-   // TODO: bounds check
-   extent->start_row = pos.row;
-   extent->end_row   = pos.row + 1;
- 
-   if(extent->start_col < 0)
-     extent->start_col = 0;
-   if(extent->end_col < 0)
-     extent->end_col = screen->cols;
- 
-   for(col = pos.col - 1; col >= extent->start_col; col--)
-     if(attrs_differ(attrs, target, getcell(screen, pos.row, col)))
-       break;
-   extent->start_col = col + 1;
- 
-   for(col = pos.col + 1; col < extent->end_col; col++)
-     if(attrs_differ(attrs, target, getcell(screen, pos.row, col)))
-       break;
-   extent->end_col = col - 1;
- 
-   return 1;
- }
--- 0 ----
*** ../vim-8.1.0378/src/libvterm/src/termscreen.c	2018-09-13 17:22:04.945647519 +0200
--- src/libvterm/src/termscreen.c	2018-04-24 18:13:56.481237547 +0200
***************
*** 0 ****
--- 1,935 ----
+ #include "vterm_internal.h"
+ 
+ #include <stdio.h>
+ #include <string.h>
+ 
+ #include "rect.h"
+ #include "utf8.h"
+ 
+ #define UNICODE_SPACE 0x20
+ #define UNICODE_LINEFEED 0x0a
+ 
+ /* State of the pen at some moment in time, also used in a cell */
+ typedef struct
+ {
+   /* After the bitfield */
+   VTermColor   fg, bg;
+ 
+   unsigned int bold      : 1;
+   unsigned int underline : 2;
+   unsigned int italic    : 1;
+   unsigned int blink     : 1;
+   unsigned int reverse   : 1;
+   unsigned int strike    : 1;
+   unsigned int font      : 4; /* 0 to 9 */
+ 
+   /* Extra state storage that isn't strictly pen-related */
+   unsigned int protected_cell : 1;
+   unsigned int dwl            : 1; /* on a DECDWL or DECDHL line */
+   unsigned int dhl            : 2; /* on a DECDHL line (1=top 2=bottom) */
+ } ScreenPen;
+ 
+ /* Internal representation of a screen cell */
+ typedef struct
+ {
+   uint32_t chars[VTERM_MAX_CHARS_PER_CELL];
+   ScreenPen pen;
+ } ScreenCell;
+ 
+ static int vterm_screen_set_cell(VTermScreen *screen, VTermPos pos, const VTermScreenCell *cell);
+ 
+ struct VTermScreen
+ {
+   VTerm *vt;
+   VTermState *state;
+ 
+   const VTermScreenCallbacks *callbacks;
+   void *cbdata;
+ 
+   VTermDamageSize damage_merge;
+   /* start_row == -1 => no damage */
+   VTermRect damaged;
+   VTermRect pending_scrollrect;
+   int pending_scroll_downward, pending_scroll_rightward;
+ 
+   int rows;
+   int cols;
+   int global_reverse;
+ 
+   /* Primary and Altscreen. buffers[1] is lazily allocated as needed */
+   ScreenCell *buffers[2];
+ 
+   /* buffer will == buffers[0] or buffers[1], depending on altscreen */
+   ScreenCell *buffer;
+ 
+   /* buffer for a single screen row used in scrollback storage callbacks */
+   VTermScreenCell *sb_buffer;
+ 
+   ScreenPen pen;
+ };
+ 
+ static ScreenCell *getcell(const VTermScreen *screen, int row, int col)
+ {
+   if(row < 0 || row >= screen->rows)
+     return NULL;
+   if(col < 0 || col >= screen->cols)
+     return NULL;
+   return screen->buffer + (screen->cols * row) + col;
+ }
+ 
+ static ScreenCell *realloc_buffer(VTermScreen *screen, ScreenCell *buffer, int new_rows, int new_cols)
+ {
+   ScreenCell *new_buffer = vterm_allocator_malloc(screen->vt, sizeof(ScreenCell) * new_rows * new_cols);
+   int row, col;
+ 
+   for(row = 0; row < new_rows; row++) {
+     for(col = 0; col < new_cols; col++) {
+       ScreenCell *new_cell = new_buffer + row*new_cols + col;
+ 
+       if(buffer && row < screen->rows && col < screen->cols)
+         *new_cell = buffer[row * screen->cols + col];
+       else {
+         new_cell->chars[0] = 0;
+         new_cell->pen = screen->pen;
+       }
+     }
+   }
+ 
+   if(buffer)
+     vterm_allocator_free(screen->vt, buffer);
+ 
+   return new_buffer;
+ }
+ 
+ static void damagerect(VTermScreen *screen, VTermRect rect)
+ {
+   VTermRect emit;
+ 
+   switch(screen->damage_merge) {
+   case VTERM_DAMAGE_CELL:
+     /* Always emit damage event */
+     emit = rect;
+     break;
+ 
+   case VTERM_DAMAGE_ROW:
+     /* Emit damage longer than one row. Try to merge with existing damage in
+      * the same row */
+     if(rect.end_row > rect.start_row + 1) {
+       // Bigger than 1 line - flush existing, emit this
+       vterm_screen_flush_damage(screen);
+       emit = rect;
+     }
+     else if(screen->damaged.start_row == -1) {
+       // None stored yet
+       screen->damaged = rect;
+       return;
+     }
+     else if(rect.start_row == screen->damaged.start_row) {
+       // Merge with the stored line
+       if(screen->damaged.start_col > rect.start_col)
+         screen->damaged.start_col = rect.start_col;
+       if(screen->damaged.end_col < rect.end_col)
+         screen->damaged.end_col = rect.end_col;
+       return;
+     }
+     else {
+       // Emit the currently stored line, store a new one
+       emit = screen->damaged;
+       screen->damaged = rect;
+     }
+     break;
+ 
+   case VTERM_DAMAGE_SCREEN:
+   case VTERM_DAMAGE_SCROLL:
+     /* Never emit damage event */
+     if(screen->damaged.start_row == -1)
+       screen->damaged = rect;
+     else {
+       rect_expand(&screen->damaged, &rect);
+     }
+     return;
+ 
+   default:
+     DEBUG_LOG1("TODO: Maybe merge damage for level %d\n", screen->damage_merge);
+     return;
+   }
+ 
+   if(screen->callbacks && screen->callbacks->damage)
+     (*screen->callbacks->damage)(emit, screen->cbdata);
+ }
+ 
+ static void damagescreen(VTermScreen *screen)
+ {
+   VTermRect rect = {0,0,0,0};
+   rect.end_row = screen->rows;
+   rect.end_col = screen->cols;
+ 
+   damagerect(screen, rect);
+ }
+ 
+ static int putglyph(VTermGlyphInfo *info, VTermPos pos, void *user)
+ {
+   int i;
+   int col;
+   VTermRect rect;
+ 
+   VTermScreen *screen = user;
+   ScreenCell *cell = getcell(screen, pos.row, pos.col);
+ 
+   if(!cell)
+     return 0;
+ 
+   for(i = 0; i < VTERM_MAX_CHARS_PER_CELL && info->chars[i]; i++) {
+     cell->chars[i] = info->chars[i];
+     cell->pen = screen->pen;
+   }
+   if(i < VTERM_MAX_CHARS_PER_CELL)
+     cell->chars[i] = 0;
+ 
+   for(col = 1; col < info->width; col++)
+     getcell(screen, pos.row, pos.col + col)->chars[0] = (uint32_t)-1;
+ 
+   rect.start_row = pos.row;
+   rect.end_row   = pos.row+1;
+   rect.start_col = pos.col;
+   rect.end_col   = pos.col+info->width;
+ 
+   cell->pen.protected_cell = info->protected_cell;
+   cell->pen.dwl            = info->dwl;
+   cell->pen.dhl            = info->dhl;
+ 
+   damagerect(screen, rect);
+ 
+   return 1;
+ }
+ 
+ static int moverect_internal(VTermRect dest, VTermRect src, void *user)
+ {
+   VTermScreen *screen = user;
+ 
+   if(screen->callbacks && screen->callbacks->sb_pushline &&
+      dest.start_row == 0 && dest.start_col == 0 &&  // starts top-left corner
+      dest.end_col == screen->cols &&                // full width
+      screen->buffer == screen->buffers[0]) {        // not altscreen
+     VTermPos pos;
+     for(pos.row = 0; pos.row < src.start_row; pos.row++) {
+       for(pos.col = 0; pos.col < screen->cols; pos.col++)
+         (void)vterm_screen_get_cell(screen, pos, screen->sb_buffer + pos.col);
+ 
+       (screen->callbacks->sb_pushline)(screen->cols, screen->sb_buffer, screen->cbdata);
+     }
+   }
+ 
+   {
+     int cols = src.end_col - src.start_col;
+     int downward = src.start_row - dest.start_row;
+     int init_row, test_row, inc_row;
+     int row;
+ 
+     if(downward < 0) {
+       init_row = dest.end_row - 1;
+       test_row = dest.start_row - 1;
+       inc_row  = -1;
+     }
+     else {
+       init_row = dest.start_row;
+       test_row = dest.end_row;
+       inc_row  = +1;
+     }
+ 
+     for(row = init_row; row != test_row; row += inc_row)
+       memmove(getcell(screen, row, dest.start_col),
+ 	      getcell(screen, row + downward, src.start_col),
+ 	      cols * sizeof(ScreenCell));
+   }
+ 
+   return 1;
+ }
+ 
+ static int moverect_user(VTermRect dest, VTermRect src, void *user)
+ {
+   VTermScreen *screen = user;
+ 
+   if(screen->callbacks && screen->callbacks->moverect) {
+     if(screen->damage_merge != VTERM_DAMAGE_SCROLL)
+       // Avoid an infinite loop
+       vterm_screen_flush_damage(screen);
+ 
+     if((*screen->callbacks->moverect)(dest, src, screen->cbdata))
+       return 1;
+   }
+ 
+   damagerect(screen, dest);
+ 
+   return 1;
+ }
+ 
+ static int erase_internal(VTermRect rect, int selective, void *user)
+ {
+   VTermScreen *screen = user;
+   int row, col;
+ 
+   for(row = rect.start_row; row < screen->state->rows && row < rect.end_row; row++) {
+     const VTermLineInfo *info = vterm_state_get_lineinfo(screen->state, row);
+ 
+     for(col = rect.start_col; col < rect.end_col; col++) {
+       ScreenCell *cell = getcell(screen, row, col);
+ 
+       if(selective && cell->pen.protected_cell)
+         continue;
+ 
+       cell->chars[0] = 0;
+       cell->pen = screen->pen;
+       cell->pen.dwl = info->doublewidth;
+       cell->pen.dhl = info->doubleheight;
+     }
+   }
+ 
+   return 1;
+ }
+ 
+ static int erase_user(VTermRect rect, int selective UNUSED, void *user)
+ {
+   VTermScreen *screen = user;
+ 
+   damagerect(screen, rect);
+ 
+   return 1;
+ }
+ 
+ static int erase(VTermRect rect, int selective, void *user)
+ {
+   erase_internal(rect, selective, user);
+   return erase_user(rect, 0, user);
+ }
+ 
+ static int scrollrect(VTermRect rect, int downward, int rightward, void *user)
+ {
+   VTermScreen *screen = user;
+ 
+   if(screen->damage_merge != VTERM_DAMAGE_SCROLL) {
+     vterm_scroll_rect(rect, downward, rightward,
+         moverect_internal, erase_internal, screen);
+ 
+     vterm_screen_flush_damage(screen);
+ 
+     vterm_scroll_rect(rect, downward, rightward,
+         moverect_user, erase_user, screen);
+ 
+     return 1;
+   }
+ 
+   if(screen->damaged.start_row != -1 &&
+      !rect_intersects(&rect, &screen->damaged)) {
+     vterm_screen_flush_damage(screen);
+   }
+ 
+   if(screen->pending_scrollrect.start_row == -1) {
+     screen->pending_scrollrect = rect;
+     screen->pending_scroll_downward  = downward;
+     screen->pending_scroll_rightward = rightward;
+   }
+   else if(rect_equal(&screen->pending_scrollrect, &rect) &&
+      ((screen->pending_scroll_downward  == 0 && downward  == 0) ||
+       (screen->pending_scroll_rightward == 0 && rightward == 0))) {
+     screen->pending_scroll_downward  += downward;
+     screen->pending_scroll_rightward += rightward;
+   }
+   else {
+     vterm_screen_flush_damage(screen);
+ 
+     screen->pending_scrollrect = rect;
+     screen->pending_scroll_downward  = downward;
+     screen->pending_scroll_rightward = rightward;
+   }
+ 
+   vterm_scroll_rect(rect, downward, rightward,
+       moverect_internal, erase_internal, screen);
+ 
+   if(screen->damaged.start_row == -1)
+     return 1;
+ 
+   if(rect_contains(&rect, &screen->damaged)) {
+     /* Scroll region entirely contains the damage; just move it */
+     vterm_rect_move(&screen->damaged, -downward, -rightward);
+     rect_clip(&screen->damaged, &rect);
+   }
+   /* There are a number of possible cases here, but lets restrict this to only
+    * the common case where we might actually gain some performance by
+    * optimising it. Namely, a vertical scroll that neatly cuts the damage
+    * region in half.
+    */
+   else if(rect.start_col <= screen->damaged.start_col &&
+           rect.end_col   >= screen->damaged.end_col &&
+           rightward == 0) {
+     if(screen->damaged.start_row >= rect.start_row &&
+        screen->damaged.start_row  < rect.end_row) {
+       screen->damaged.start_row -= downward;
+       if(screen->damaged.start_row < rect.start_row)
+         screen->damaged.start_row = rect.start_row;
+       if(screen->damaged.start_row > rect.end_row)
+         screen->damaged.start_row = rect.end_row;
+     }
+     if(screen->damaged.end_row >= rect.start_row &&
+        screen->damaged.end_row  < rect.end_row) {
+       screen->damaged.end_row -= downward;
+       if(screen->damaged.end_row < rect.start_row)
+         screen->damaged.end_row = rect.start_row;
+       if(screen->damaged.end_row > rect.end_row)
+         screen->damaged.end_row = rect.end_row;
+     }
+   }
+   else {
+     DEBUG_LOG2("TODO: Just flush and redo damaged=" STRFrect " rect=" STRFrect "\n",
+         ARGSrect(screen->damaged), ARGSrect(rect));
+   }
+ 
+   return 1;
+ }
+ 
+ static int movecursor(VTermPos pos, VTermPos oldpos, int visible, void *user)
+ {
+   VTermScreen *screen = user;
+ 
+   if(screen->callbacks && screen->callbacks->movecursor)
+     return (*screen->callbacks->movecursor)(pos, oldpos, visible, screen->cbdata);
+ 
+   return 0;
+ }
+ 
+ static int setpenattr(VTermAttr attr, VTermValue *val, void *user)
+ {
+   VTermScreen *screen = user;
+ 
+   switch(attr) {
+   case VTERM_ATTR_BOLD:
+     screen->pen.bold = val->boolean;
+     return 1;
+   case VTERM_ATTR_UNDERLINE:
+     screen->pen.underline = val->number;
+     return 1;
+   case VTERM_ATTR_ITALIC:
+     screen->pen.italic = val->boolean;
+     return 1;
+   case VTERM_ATTR_BLINK:
+     screen->pen.blink = val->boolean;
+     return 1;
+   case VTERM_ATTR_REVERSE:
+     screen->pen.reverse = val->boolean;
+     return 1;
+   case VTERM_ATTR_STRIKE:
+     screen->pen.strike = val->boolean;
+     return 1;
+   case VTERM_ATTR_FONT:
+     screen->pen.font = val->number;
+     return 1;
+   case VTERM_ATTR_FOREGROUND:
+     screen->pen.fg = val->color;
+     return 1;
+   case VTERM_ATTR_BACKGROUND:
+     screen->pen.bg = val->color;
+     return 1;
+ 
+   case VTERM_N_ATTRS:
+     return 0;
+   }
+ 
+   return 0;
+ }
+ 
+ static int settermprop(VTermProp prop, VTermValue *val, void *user)
+ {
+   VTermScreen *screen = user;
+ 
+   switch(prop) {
+   case VTERM_PROP_ALTSCREEN:
+     if(val->boolean && !screen->buffers[1])
+       return 0;
+ 
+     screen->buffer = val->boolean ? screen->buffers[1] : screen->buffers[0];
+     /* only send a damage event on disable; because during enable there's an
+      * erase that sends a damage anyway
+      */
+     if(!val->boolean)
+       damagescreen(screen);
+     break;
+   case VTERM_PROP_REVERSE:
+     screen->global_reverse = val->boolean;
+     damagescreen(screen);
+     break;
+   default:
+     ; /* ignore */
+   }
+ 
+   if(screen->callbacks && screen->callbacks->settermprop)
+     return (*screen->callbacks->settermprop)(prop, val, screen->cbdata);
+ 
+   return 1;
+ }
+ 
+ static int bell(void *user)
+ {
+   VTermScreen *screen = user;
+ 
+   if(screen->callbacks && screen->callbacks->bell)
+     return (*screen->callbacks->bell)(screen->cbdata);
+ 
+   return 0;
+ }
+ 
+ static int resize(int new_rows, int new_cols, VTermPos *delta, void *user)
+ {
+   VTermScreen *screen = user;
+ 
+   int is_altscreen = (screen->buffers[1] && screen->buffer == screen->buffers[1]);
+ 
+   int old_rows = screen->rows;
+   int old_cols = screen->cols;
+   int first_blank_row;
+ 
+   if(!is_altscreen && new_rows < old_rows) {
+     // Fewer rows - determine if we're going to scroll at all, and if so, push
+     // those lines to scrollback
+     VTermPos pos = { 0, 0 };
+     VTermPos cursor = screen->state->pos;
+     // Find the first blank row after the cursor.
+     for(pos.row = old_rows - 1; pos.row >= new_rows; pos.row--)
+       if(!vterm_screen_is_eol(screen, pos) || cursor.row == pos.row)
+         break;
+ 
+     first_blank_row = pos.row + 1;
+     if(first_blank_row > new_rows) {
+       VTermRect rect = {0,0,0,0};
+       rect.end_row   = old_rows;
+       rect.end_col   = old_cols;
+       scrollrect(rect, first_blank_row - new_rows, 0, user);
+       vterm_screen_flush_damage(screen);
+ 
+       delta->row -= first_blank_row - new_rows;
+     }
+   }
+ 
+   screen->buffers[0] = realloc_buffer(screen, screen->buffers[0], new_rows, new_cols);
+   if(screen->buffers[1])
+     screen->buffers[1] = realloc_buffer(screen, screen->buffers[1], new_rows, new_cols);
+ 
+   screen->buffer = is_altscreen ? screen->buffers[1] : screen->buffers[0];
+ 
+   screen->rows = new_rows;
+   screen->cols = new_cols;
+ 
+   if(screen->sb_buffer)
+     vterm_allocator_free(screen->vt, screen->sb_buffer);
+ 
+   screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * new_cols);
+ 
+   if(new_cols > old_cols) {
+     VTermRect rect;
+     rect.start_row = 0;
+     rect.end_row   = old_rows;
+     rect.start_col = old_cols;
+     rect.end_col   = new_cols;
+     damagerect(screen, rect);
+   }
+ 
+   if(new_rows > old_rows) {
+     if(!is_altscreen && screen->callbacks && screen->callbacks->sb_popline) {
+       int rows = new_rows - old_rows;
+       while(rows) {
+         VTermRect rect = {0,0,0,0};
+         VTermPos pos = { 0, 0 };
+         if(!(screen->callbacks->sb_popline(screen->cols, screen->sb_buffer, screen->cbdata)))
+           break;
+ 
+ 	rect.end_row   = screen->rows;
+ 	rect.end_col   = screen->cols;
+         scrollrect(rect, -1, 0, user);
+ 
+         for(pos.col = 0; pos.col < screen->cols; pos.col += screen->sb_buffer[pos.col].width)
+           vterm_screen_set_cell(screen, pos, screen->sb_buffer + pos.col);
+ 
+         rect.end_row = 1;
+         damagerect(screen, rect);
+ 
+         vterm_screen_flush_damage(screen);
+ 
+         rows--;
+         delta->row++;
+       }
+     }
+ 
+     {
+       VTermRect rect;
+       rect.start_row = old_rows;
+       rect.end_row   = new_rows;
+       rect.start_col = 0;
+       rect.end_col   = new_cols;
+       damagerect(screen, rect);
+     }
+   }
+ 
+   if(screen->callbacks && screen->callbacks->resize)
+     return (*screen->callbacks->resize)(new_rows, new_cols, screen->cbdata);
+ 
+   return 1;
+ }
+ 
+ static int setlineinfo(int row, const VTermLineInfo *newinfo, const VTermLineInfo *oldinfo, void *user)
+ {
+   VTermScreen *screen = user;
+   int col;
+   VTermRect rect;
+ 
+   if(newinfo->doublewidth != oldinfo->doublewidth ||
+      newinfo->doubleheight != oldinfo->doubleheight) {
+     for(col = 0; col < screen->cols; col++) {
+       ScreenCell *cell = getcell(screen, row, col);
+       cell->pen.dwl = newinfo->doublewidth;
+       cell->pen.dhl = newinfo->doubleheight;
+     }
+ 
+     rect.start_row = row;
+     rect.end_row   = row + 1;
+     rect.start_col = 0;
+     rect.end_col   = newinfo->doublewidth ? screen->cols / 2 : screen->cols;
+     damagerect(screen, rect);
+ 
+     if(newinfo->doublewidth) {
+       rect.start_col = screen->cols / 2;
+       rect.end_col   = screen->cols;
+ 
+       erase_internal(rect, 0, user);
+     }
+   }
+ 
+   return 1;
+ }
+ 
+ static VTermStateCallbacks state_cbs = {
+   &putglyph, /* putglyph */
+   &movecursor, /* movecursor */
+   &scrollrect, /* scrollrect */
+   NULL, /* moverect */
+   &erase, /* erase */
+   NULL, /* initpen */
+   &setpenattr, /* setpenattr */
+   &settermprop, /* settermprop */
+   &bell, /* bell */
+   &resize, /* resize */
+   &setlineinfo /* setlineinfo */
+ };
+ 
+ static VTermScreen *screen_new(VTerm *vt)
+ {
+   VTermState *state = vterm_obtain_state(vt);
+   VTermScreen *screen;
+   int rows, cols;
+ 
+   if(!state)
+     return NULL;
+ 
+   screen = vterm_allocator_malloc(vt, sizeof(VTermScreen));
+ 
+   vterm_get_size(vt, &rows, &cols);
+ 
+   screen->vt = vt;
+   screen->state = state;
+ 
+   screen->damage_merge = VTERM_DAMAGE_CELL;
+   screen->damaged.start_row = -1;
+   screen->pending_scrollrect.start_row = -1;
+ 
+   screen->rows = rows;
+   screen->cols = cols;
+ 
+   screen->callbacks = NULL;
+   screen->cbdata    = NULL;
+ 
+   screen->buffers[0] = realloc_buffer(screen, NULL, rows, cols);
+ 
+   screen->buffer = screen->buffers[0];
+ 
+   screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * cols);
+ 
+   vterm_state_set_callbacks(screen->state, &state_cbs, screen);
+ 
+   return screen;
+ }
+ 
+ INTERNAL void vterm_screen_free(VTermScreen *screen)
+ {
+   vterm_allocator_free(screen->vt, screen->buffers[0]);
+   if(screen->buffers[1])
+     vterm_allocator_free(screen->vt, screen->buffers[1]);
+ 
+   vterm_allocator_free(screen->vt, screen->sb_buffer);
+ 
+   vterm_allocator_free(screen->vt, screen);
+ }
+ 
+ void vterm_screen_reset(VTermScreen *screen, int hard)
+ {
+   screen->damaged.start_row = -1;
+   screen->pending_scrollrect.start_row = -1;
+   vterm_state_reset(screen->state, hard);
+   vterm_screen_flush_damage(screen);
+ }
+ 
+ static size_t _get_chars(const VTermScreen *screen, const int utf8, void *buffer, size_t len, const VTermRect rect)
+ {
+   size_t outpos = 0;
+   int padding = 0;
+   int row, col;
+ 
+ #define PUT(c)                                             \
+   if(utf8) {                                               \
+     size_t thislen = utf8_seqlen(c);                       \
+     if(buffer && outpos + thislen <= len)                  \
+       outpos += fill_utf8((c), (char *)buffer + outpos);   \
+     else                                                   \
+       outpos += thislen;                                   \
+   }                                                        \
+   else {                                                   \
+     if(buffer && outpos + 1 <= len)                        \
+       ((uint32_t*)buffer)[outpos++] = (c);                 \
+     else                                                   \
+       outpos++;                                            \
+   }
+ 
+   for(row = rect.start_row; row < rect.end_row; row++) {
+     for(col = rect.start_col; col < rect.end_col; col++) {
+       ScreenCell *cell = getcell(screen, row, col);
+       int i;
+ 
+       if(cell->chars[0] == 0)
+         // Erased cell, might need a space
+         padding++;
+       else if(cell->chars[0] == (uint32_t)-1)
+         // Gap behind a double-width char, do nothing
+         ;
+       else {
+         while(padding) {
+           PUT(UNICODE_SPACE);
+           padding--;
+         }
+         for(i = 0; i < VTERM_MAX_CHARS_PER_CELL && cell->chars[i]; i++) {
+           PUT(cell->chars[i]);
+         }
+       }
+     }
+ 
+     if(row < rect.end_row - 1) {
+       PUT(UNICODE_LINEFEED);
+       padding = 0;
+     }
+   }
+ 
+   return outpos;
+ }
+ 
+ size_t vterm_screen_get_chars(const VTermScreen *screen, uint32_t *chars, size_t len, const VTermRect rect)
+ {
+   return _get_chars(screen, 0, chars, len, rect);
+ }
+ 
+ size_t vterm_screen_get_text(const VTermScreen *screen, char *str, size_t len, const VTermRect rect)
+ {
+   return _get_chars(screen, 1, str, len, rect);
+ }
+ 
+ /* Copy internal to external representation of a screen cell */
+ int vterm_screen_get_cell(const VTermScreen *screen, VTermPos pos, VTermScreenCell *cell)
+ {
+   ScreenCell *intcell = getcell(screen, pos.row, pos.col);
+   int i;
+ 
+   if(!intcell)
+     return 0;
+ 
+   for(i = 0; ; i++) {
+     cell->chars[i] = intcell->chars[i];
+     if(!intcell->chars[i])
+       break;
+   }
+ 
+   cell->attrs.bold      = intcell->pen.bold;
+   cell->attrs.underline = intcell->pen.underline;
+   cell->attrs.italic    = intcell->pen.italic;
+   cell->attrs.blink     = intcell->pen.blink;
+   cell->attrs.reverse   = intcell->pen.reverse ^ screen->global_reverse;
+   cell->attrs.strike    = intcell->pen.strike;
+   cell->attrs.font      = intcell->pen.font;
+ 
+   cell->attrs.dwl = intcell->pen.dwl;
+   cell->attrs.dhl = intcell->pen.dhl;
+ 
+   cell->fg = intcell->pen.fg;
+   cell->bg = intcell->pen.bg;
+ 
+   if(pos.col < (screen->cols - 1) &&
+      getcell(screen, pos.row, pos.col + 1)->chars[0] == (uint32_t)-1)
+     cell->width = 2;
+   else
+     cell->width = 1;
+ 
+   return 1;
+ }
+ 
+ /* Copy external to internal representation of a screen cell */
+ /* static because it's only used internally for sb_popline during resize */
+ static int vterm_screen_set_cell(VTermScreen *screen, VTermPos pos, const VTermScreenCell *cell)
+ {
+   ScreenCell *intcell = getcell(screen, pos.row, pos.col);
+   int i;
+ 
+   if(!intcell)
+     return 0;
+ 
+   for(i = 0; ; i++) {
+     intcell->chars[i] = cell->chars[i];
+     if(!cell->chars[i])
+       break;
+   }
+ 
+   intcell->pen.bold      = cell->attrs.bold;
+   intcell->pen.underline = cell->attrs.underline;
+   intcell->pen.italic    = cell->attrs.italic;
+   intcell->pen.blink     = cell->attrs.blink;
+   intcell->pen.reverse   = cell->attrs.reverse ^ screen->global_reverse;
+   intcell->pen.strike    = cell->attrs.strike;
+   intcell->pen.font      = cell->attrs.font;
+ 
+   intcell->pen.fg = cell->fg;
+   intcell->pen.bg = cell->bg;
+ 
+   if(cell->width == 2)
+     getcell(screen, pos.row, pos.col + 1)->chars[0] = (uint32_t)-1;
+ 
+   return 1;
+ }
+ 
+ int vterm_screen_is_eol(const VTermScreen *screen, VTermPos pos)
+ {
+   /* This cell is EOL if this and every cell to the right is black */
+   for(; pos.col < screen->cols; pos.col++) {
+     ScreenCell *cell = getcell(screen, pos.row, pos.col);
+     if(cell->chars[0] != 0)
+       return 0;
+   }
+ 
+   return 1;
+ }
+ 
+ VTermScreen *vterm_obtain_screen(VTerm *vt)
+ {
+   if(!vt->screen)
+     vt->screen = screen_new(vt);
+   return vt->screen;
+ }
+ 
+ void vterm_screen_enable_altscreen(VTermScreen *screen, int altscreen)
+ {
+ 
+   if(!screen->buffers[1] && altscreen) {
+     int rows, cols;
+     vterm_get_size(screen->vt, &rows, &cols);
+ 
+     screen->buffers[1] = realloc_buffer(screen, NULL, rows, cols);
+   }
+ }
+ 
+ void vterm_screen_set_callbacks(VTermScreen *screen, const VTermScreenCallbacks *callbacks, void *user)
+ {
+   screen->callbacks = callbacks;
+   screen->cbdata = user;
+ }
+ 
+ void *vterm_screen_get_cbdata(VTermScreen *screen)
+ {
+   return screen->cbdata;
+ }
+ 
+ void vterm_screen_set_unrecognised_fallbacks(VTermScreen *screen, const VTermParserCallbacks *fallbacks, void *user)
+ {
+   vterm_state_set_unrecognised_fallbacks(screen->state, fallbacks, user);
+ }
+ 
+ void *vterm_screen_get_unrecognised_fbdata(VTermScreen *screen)
+ {
+   return vterm_state_get_unrecognised_fbdata(screen->state);
+ }
+ 
+ void vterm_screen_flush_damage(VTermScreen *screen)
+ {
+   if(screen->pending_scrollrect.start_row != -1) {
+     vterm_scroll_rect(screen->pending_scrollrect, screen->pending_scroll_downward, screen->pending_scroll_rightward,
+         moverect_user, erase_user, screen);
+ 
+     screen->pending_scrollrect.start_row = -1;
+   }
+ 
+   if(screen->damaged.start_row != -1) {
+     if(screen->callbacks && screen->callbacks->damage)
+       (*screen->callbacks->damage)(screen->damaged, screen->cbdata);
+ 
+     screen->damaged.start_row = -1;
+   }
+ }
+ 
+ void vterm_screen_set_damage_merge(VTermScreen *screen, VTermDamageSize size)
+ {
+   vterm_screen_flush_damage(screen);
+   screen->damage_merge = size;
+ }
+ 
+ static int attrs_differ(VTermAttrMask attrs, ScreenCell *a, ScreenCell *b)
+ {
+   if((attrs & VTERM_ATTR_BOLD_MASK)       && (a->pen.bold != b->pen.bold))
+     return 1;
+   if((attrs & VTERM_ATTR_UNDERLINE_MASK)  && (a->pen.underline != b->pen.underline))
+     return 1;
+   if((attrs & VTERM_ATTR_ITALIC_MASK)     && (a->pen.italic != b->pen.italic))
+     return 1;
+   if((attrs & VTERM_ATTR_BLINK_MASK)      && (a->pen.blink != b->pen.blink))
+     return 1;
+   if((attrs & VTERM_ATTR_REVERSE_MASK)    && (a->pen.reverse != b->pen.reverse))
+     return 1;
+   if((attrs & VTERM_ATTR_STRIKE_MASK)     && (a->pen.strike != b->pen.strike))
+     return 1;
+   if((attrs & VTERM_ATTR_FONT_MASK)       && (a->pen.font != b->pen.font))
+     return 1;
+   if((attrs & VTERM_ATTR_FOREGROUND_MASK) && !vterm_color_equal(a->pen.fg, b->pen.fg))
+     return 1;
+   if((attrs & VTERM_ATTR_BACKGROUND_MASK) && !vterm_color_equal(a->pen.bg, b->pen.bg))
+     return 1;
+ 
+   return 0;
+ }
+ 
+ int vterm_screen_get_attrs_extent(const VTermScreen *screen, VTermRect *extent, VTermPos pos, VTermAttrMask attrs)
+ {
+   int col;
+ 
+   ScreenCell *target = getcell(screen, pos.row, pos.col);
+ 
+   // TODO: bounds check
+   extent->start_row = pos.row;
+   extent->end_row   = pos.row + 1;
+ 
+   if(extent->start_col < 0)
+     extent->start_col = 0;
+   if(extent->end_col < 0)
+     extent->end_col = screen->cols;
+ 
+   for(col = pos.col - 1; col >= extent->start_col; col--)
+     if(attrs_differ(attrs, target, getcell(screen, pos.row, col)))
+       break;
+   extent->start_col = col + 1;
+ 
+   for(col = pos.col + 1; col < extent->end_col; col++)
+     if(attrs_differ(attrs, target, getcell(screen, pos.row, col)))
+       break;
+   extent->end_col = col - 1;
+ 
+   return 1;
+ }
*** ../vim-8.1.0378/src/Make_cyg_ming.mak	2018-09-10 17:50:32.709306979 +0200
--- src/Make_cyg_ming.mak	2018-09-13 17:19:08.403051373 +0200
***************
*** 818,832 ****
  
  ifeq ($(TERMINAL),yes)
  OBJ += $(OUTDIR)/terminal.o \
! 	$(OUTDIR)/term_encoding.o \
! 	$(OUTDIR)/term_keyboard.o \
! 	$(OUTDIR)/term_mouse.o \
! 	$(OUTDIR)/term_parser.o \
! 	$(OUTDIR)/term_pen.o \
! 	$(OUTDIR)/term_screen.o \
! 	$(OUTDIR)/term_state.o \
! 	$(OUTDIR)/term_unicode.o \
! 	$(OUTDIR)/term_vterm.o
  endif
  
  # Include xdiff
--- 818,832 ----
  
  ifeq ($(TERMINAL),yes)
  OBJ += $(OUTDIR)/terminal.o \
! 	$(OUTDIR)/encoding.o \
! 	$(OUTDIR)/keyboard.o \
! 	$(OUTDIR)/mouse.o \
! 	$(OUTDIR)/parser.o \
! 	$(OUTDIR)/pen.o \
! 	$(OUTDIR)/termscreen.o \
! 	$(OUTDIR)/state.o \
! 	$(OUTDIR)/unicode.o \
! 	$(OUTDIR)/vterm.o
  endif
  
  # Include xdiff
***************
*** 1064,1094 ****
  	  -DIS_COMBINING_FUNCTION=utf_iscomposing_uint \
  	  -DWCWIDTH_FUNCTION=utf_uint2cells
  
! $(OUTDIR)/term_encoding.o: libvterm/src/encoding.c $(TERM_DEPS)
  	$(CCCTERM) libvterm/src/encoding.c -o $@
  
! $(OUTDIR)/term_keyboard.o: libvterm/src/keyboard.c $(TERM_DEPS)
  	$(CCCTERM) libvterm/src/keyboard.c -o $@
  
! $(OUTDIR)/term_mouse.o: libvterm/src/mouse.c $(TERM_DEPS)
  	$(CCCTERM) libvterm/src/mouse.c -o $@
  
! $(OUTDIR)/term_parser.o: libvterm/src/parser.c $(TERM_DEPS)
  	$(CCCTERM) libvterm/src/parser.c -o $@
  
! $(OUTDIR)/term_pen.o: libvterm/src/pen.c $(TERM_DEPS)
  	$(CCCTERM) libvterm/src/pen.c -o $@
  
! $(OUTDIR)/term_screen.o: libvterm/src/screen.c $(TERM_DEPS)
! 	$(CCCTERM) libvterm/src/screen.c -o $@
  
! $(OUTDIR)/term_state.o: libvterm/src/state.c $(TERM_DEPS)
  	$(CCCTERM) libvterm/src/state.c -o $@
  
! $(OUTDIR)/term_unicode.o: libvterm/src/unicode.c $(TERM_DEPS)
  	$(CCCTERM) libvterm/src/unicode.c -o $@
  
! $(OUTDIR)/term_vterm.o: libvterm/src/vterm.c $(TERM_DEPS)
  	$(CCCTERM) libvterm/src/vterm.c -o $@
  
  $(OUTDIR)/xdiffi.o: xdiff/xdiffi.c $(XDIFF_DEPS)
--- 1064,1094 ----
  	  -DIS_COMBINING_FUNCTION=utf_iscomposing_uint \
  	  -DWCWIDTH_FUNCTION=utf_uint2cells
  
! $(OUTDIR)/encoding.o: libvterm/src/encoding.c $(TERM_DEPS)
  	$(CCCTERM) libvterm/src/encoding.c -o $@
  
! $(OUTDIR)/keyboard.o: libvterm/src/keyboard.c $(TERM_DEPS)
  	$(CCCTERM) libvterm/src/keyboard.c -o $@
  
! $(OUTDIR)/mouse.o: libvterm/src/mouse.c $(TERM_DEPS)
  	$(CCCTERM) libvterm/src/mouse.c -o $@
  
! $(OUTDIR)/parser.o: libvterm/src/parser.c $(TERM_DEPS)
  	$(CCCTERM) libvterm/src/parser.c -o $@
  
! $(OUTDIR)/pen.o: libvterm/src/pen.c $(TERM_DEPS)
  	$(CCCTERM) libvterm/src/pen.c -o $@
  
! $(OUTDIR)/termscreen.o: libvterm/src/termscreen.c $(TERM_DEPS)
! 	$(CCCTERM) libvterm/src/termscreen.c -o $@
  
! $(OUTDIR)/state.o: libvterm/src/state.c $(TERM_DEPS)
  	$(CCCTERM) libvterm/src/state.c -o $@
  
! $(OUTDIR)/unicode.o: libvterm/src/unicode.c $(TERM_DEPS)
  	$(CCCTERM) libvterm/src/unicode.c -o $@
  
! $(OUTDIR)/vterm.o: libvterm/src/vterm.c $(TERM_DEPS)
  	$(CCCTERM) libvterm/src/vterm.c -o $@
  
  $(OUTDIR)/xdiffi.o: xdiff/xdiffi.c $(XDIFF_DEPS)
*** ../vim-8.1.0378/src/Make_mvc.mak	2018-09-10 17:50:32.709306979 +0200
--- src/Make_mvc.mak	2018-09-13 17:19:45.166766309 +0200
***************
*** 380,394 ****
  !if "$(TERMINAL)" == "yes"
  TERM_OBJ = \
  	$(OBJDIR)/terminal.obj \
! 	$(OBJDIR)/term_encoding.obj \
! 	$(OBJDIR)/term_keyboard.obj \
! 	$(OBJDIR)/term_mouse.obj \
! 	$(OBJDIR)/term_parser.obj \
! 	$(OBJDIR)/term_pen.obj \
! 	$(OBJDIR)/term_screen.obj \
! 	$(OBJDIR)/term_state.obj \
! 	$(OBJDIR)/term_unicode.obj \
! 	$(OBJDIR)/term_vterm.obj
  TERM_DEFS = -DFEAT_TERMINAL
  TERM_DEPS = \
  	libvterm/include/vterm.h \
--- 380,394 ----
  !if "$(TERMINAL)" == "yes"
  TERM_OBJ = \
  	$(OBJDIR)/terminal.obj \
! 	$(OBJDIR)/encoding.obj \
! 	$(OBJDIR)/keyboard.obj \
! 	$(OBJDIR)/mouse.obj \
! 	$(OBJDIR)/parser.obj \
! 	$(OBJDIR)/pen.obj \
! 	$(OBJDIR)/termscreen.obj \
! 	$(OBJDIR)/state.obj \
! 	$(OBJDIR)/unicode.obj \
! 	$(OBJDIR)/vterm.obj
  TERM_DEFS = -DFEAT_TERMINAL
  TERM_DEPS = \
  	libvterm/include/vterm.h \
***************
*** 1561,1591 ****
  	-DWCWIDTH_FUNCTION=utf_uint2cells \
  	-D_CRT_SECURE_NO_WARNINGS
  
! $(OUTDIR)/term_encoding.obj: $(OUTDIR) libvterm/src/encoding.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/encoding.c
  
! $(OUTDIR)/term_keyboard.obj: $(OUTDIR) libvterm/src/keyboard.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/keyboard.c
  
! $(OUTDIR)/term_mouse.obj: $(OUTDIR) libvterm/src/mouse.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/mouse.c
  
! $(OUTDIR)/term_parser.obj: $(OUTDIR) libvterm/src/parser.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/parser.c
  
! $(OUTDIR)/term_pen.obj: $(OUTDIR) libvterm/src/pen.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/pen.c
  
! $(OUTDIR)/term_screen.obj: $(OUTDIR) libvterm/src/screen.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/screen.c
  
! $(OUTDIR)/term_state.obj: $(OUTDIR) libvterm/src/state.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/state.c
  
! $(OUTDIR)/term_unicode.obj: $(OUTDIR) libvterm/src/unicode.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/unicode.c
  
! $(OUTDIR)/term_vterm.obj: $(OUTDIR) libvterm/src/vterm.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/vterm.c
  
  
--- 1561,1591 ----
  	-DWCWIDTH_FUNCTION=utf_uint2cells \
  	-D_CRT_SECURE_NO_WARNINGS
  
! $(OUTDIR)/encoding.obj: $(OUTDIR) libvterm/src/encoding.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/encoding.c
  
! $(OUTDIR)/keyboard.obj: $(OUTDIR) libvterm/src/keyboard.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/keyboard.c
  
! $(OUTDIR)/mouse.obj: $(OUTDIR) libvterm/src/mouse.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/mouse.c
  
! $(OUTDIR)/parser.obj: $(OUTDIR) libvterm/src/parser.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/parser.c
  
! $(OUTDIR)/pen.obj: $(OUTDIR) libvterm/src/pen.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/pen.c
  
! $(OUTDIR)/termscreen.obj: $(OUTDIR) libvterm/src/screen.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/screen.c
  
! $(OUTDIR)/state.obj: $(OUTDIR) libvterm/src/state.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/state.c
  
! $(OUTDIR)/unicode.obj: $(OUTDIR) libvterm/src/unicode.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/unicode.c
  
! $(OUTDIR)/vterm.obj: $(OUTDIR) libvterm/src/vterm.c $(TERM_DEPS)
  	$(CCCTERM) -Fo$@ libvterm/src/vterm.c
  
  
*** ../vim-8.1.0378/src/version.c	2018-09-13 15:58:55.745722402 +0200
--- src/version.c	2018-09-13 16:44:24.695181110 +0200
***************
*** 796,797 ****
--- 796,799 ----
  {   /* Add new patch number below this line */
+ /**/
+     379,
  /**/

-- 
Well, you come from nothing, you go back to nothing...  What have you
lost?  Nothing!
				-- Monty Python: The life of Brian

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
