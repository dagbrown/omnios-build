To: vim_dev@googlegroups.com
Subject: Patch 8.1.1793
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.1.1793
Problem:    Mixed comment style in globals.
Solution:   Use // comments where appropriate.
Files:	    src/globals.h


*** ../vim-8.1.1792/src/globals.h	2019-07-22 23:03:53.322360395 +0200
--- src/globals.h	2019-08-02 22:02:35.838692280 +0200
***************
*** 17,23 ****
   * They may have different values when the screen wasn't (re)allocated yet
   * after setting Rows or Columns (e.g., when starting up).
   */
! EXTERN long	Rows			/* nr of rows in the screen */
  #ifdef DO_INIT
  # if defined(MSWIN)
  			    = 25L
--- 17,23 ----
   * They may have different values when the screen wasn't (re)allocated yet
   * after setting Rows or Columns (e.g., when starting up).
   */
! EXTERN long	Rows			// nr of rows in the screen
  #ifdef DO_INIT
  # if defined(MSWIN)
  			    = 25L
***************
*** 26,32 ****
  # endif
  #endif
  			    ;
! EXTERN long	Columns INIT(= 80);	/* nr of columns in the screen */
  
  /*
   * The characters that are currently on the screen are kept in ScreenLines[].
--- 26,32 ----
  # endif
  #endif
  			    ;
! EXTERN long	Columns INIT(= 80);	// nr of columns in the screen
  
  /*
   * The characters that are currently on the screen are kept in ScreenLines[].
***************
*** 42,48 ****
  EXTERN schar_T	*ScreenLines INIT(= NULL);
  EXTERN sattr_T	*ScreenAttrs INIT(= NULL);
  EXTERN unsigned	*LineOffset INIT(= NULL);
! EXTERN char_u	*LineWraps INIT(= NULL);	/* line wraps to next line */
  
  /*
   * When using Unicode characters (in UTF-8 encoding) the character in
--- 42,48 ----
  EXTERN schar_T	*ScreenLines INIT(= NULL);
  EXTERN sattr_T	*ScreenAttrs INIT(= NULL);
  EXTERN unsigned	*LineOffset INIT(= NULL);
! EXTERN char_u	*LineWraps INIT(= NULL);	// line wraps to next line
  
  /*
   * When using Unicode characters (in UTF-8 encoding) the character in
***************
*** 52,64 ****
   * ScreenLinesC[0][off] is only to be used when ScreenLinesUC[off] != 0.
   * Note: These three are only allocated when enc_utf8 is set!
   */
! EXTERN u8char_T	*ScreenLinesUC INIT(= NULL);	/* decoded UTF-8 characters */
! EXTERN u8char_T	*ScreenLinesC[MAX_MCO];		/* composing characters */
! EXTERN int	Screen_mco INIT(= 0);		/* value of p_mco used when
! 						   allocating ScreenLinesC[] */
  
! /* Only used for euc-jp: Second byte of a character that starts with 0x8e.
!  * These are single-width. */
  EXTERN schar_T	*ScreenLines2 INIT(= NULL);
  
  /*
--- 52,64 ----
   * ScreenLinesC[0][off] is only to be used when ScreenLinesUC[off] != 0.
   * Note: These three are only allocated when enc_utf8 is set!
   */
! EXTERN u8char_T	*ScreenLinesUC INIT(= NULL);	// decoded UTF-8 characters
! EXTERN u8char_T	*ScreenLinesC[MAX_MCO];		// composing characters
! EXTERN int	Screen_mco INIT(= 0);		// value of p_mco used when
! 						// allocating ScreenLinesC[]
  
! // Only used for euc-jp: Second byte of a character that starts with 0x8e.
! // These are single-width.
  EXTERN schar_T	*ScreenLines2 INIT(= NULL);
  
  /*
***************
*** 88,101 ****
  EXTERN int	screen_zindex INIT(= 0);
  #endif
  
! EXTERN int	screen_Rows INIT(= 0);	    /* actual size of ScreenLines[] */
! EXTERN int	screen_Columns INIT(= 0);   /* actual size of ScreenLines[] */
  
  /*
   * When vgetc() is called, it sets mod_mask to the set of modifiers that are
   * held down based on the MOD_MASK_* symbols that are read first.
   */
! EXTERN int	mod_mask INIT(= 0x0);		/* current key modifiers */
  
  /*
   * Cmdline_row is the row where the command line starts, just below the
--- 88,101 ----
  EXTERN int	screen_zindex INIT(= 0);
  #endif
  
! EXTERN int	screen_Rows INIT(= 0);	    // actual size of ScreenLines[]
! EXTERN int	screen_Columns INIT(= 0);   // actual size of ScreenLines[]
  
  /*
   * When vgetc() is called, it sets mod_mask to the set of modifiers that are
   * held down based on the MOD_MASK_* symbols that are read first.
   */
! EXTERN int	mod_mask INIT(= 0x0);		// current key modifiers
  
  /*
   * Cmdline_row is the row where the command line starts, just below the
***************
*** 117,125 ****
  EXTERN int	cmdline_star INIT(= FALSE);	// cmdline is crypted
  #endif
  
! EXTERN int	exec_from_reg INIT(= FALSE);	/* executing register */
  
! EXTERN int	screen_cleared INIT(= FALSE);	/* screen has been cleared */
  
  /*
   * When '$' is included in 'cpoptions' option set:
--- 117,125 ----
  EXTERN int	cmdline_star INIT(= FALSE);	// cmdline is crypted
  #endif
  
! EXTERN int	exec_from_reg INIT(= FALSE);	// executing register
  
! EXTERN int	screen_cleared INIT(= FALSE);	// screen has been cleared
  
  /*
   * When '$' is included in 'cpoptions' option set:
***************
*** 134,155 ****
   * Variables for Insert mode completion.
   */
  
! /* Length in bytes of the text being completed (this is deleted to be replaced
!  * by the match.) */
  EXTERN int	compl_length INIT(= 0);
  
! /* List of flags for method of completion. */
  EXTERN int	compl_cont_status INIT(= 0);
! # define CONT_ADDING	1	/* "normal" or "adding" expansion */
! # define CONT_INTRPT	(2 + 4)	/* a ^X interrupted the current expansion */
! 				/* it's set only iff N_ADDS is set */
! # define CONT_N_ADDS	4	/* next ^X<> will add-new or expand-current */
! # define CONT_S_IPOS	8	/* next ^X<> will set initial_pos?
! 				 * if so, word-wise-expansion will set SOL */
! # define CONT_SOL	16	/* pattern includes start of line, just for
! 				 * word-wise expansion, not set for ^X^L */
! # define CONT_LOCAL	32	/* for ctrl_x_mode 0, ^X^P/^X^N do a local
! 				 * expansion, (eg use complete=.) */
  #endif
  
  /*
--- 134,155 ----
   * Variables for Insert mode completion.
   */
  
! // Length in bytes of the text being completed (this is deleted to be replaced
! // by the match.)
  EXTERN int	compl_length INIT(= 0);
  
! // List of flags for method of completion.
  EXTERN int	compl_cont_status INIT(= 0);
! # define CONT_ADDING	1	// "normal" or "adding" expansion
! # define CONT_INTRPT	(2 + 4)	// a ^X interrupted the current expansion
! 				// it's set only iff N_ADDS is set
! # define CONT_N_ADDS	4	// next ^X<> will add-new or expand-current
! # define CONT_S_IPOS	8	// next ^X<> will set initial_pos?
! 				// if so, word-wise-expansion will set SOL
! # define CONT_SOL	16	// pattern includes start of line, just for
! 				// word-wise expansion, not set for ^X^L
! # define CONT_LOCAL	32	// for ctrl_x_mode 0, ^X^P/^X^N do a local
! 				// expansion, (eg use complete=.)
  #endif
  
  /*
***************
*** 157,257 ****
   * while keeping ScreenLines[] updated.
   */
  #ifdef FEAT_RIGHTLEFT
! EXTERN int	cmdmsg_rl INIT(= FALSE);    /* cmdline is drawn right to left */
  #endif
  EXTERN int	msg_col;
  EXTERN int	msg_row;
! EXTERN int	msg_scrolled;	/* Number of screen lines that windows have
! 				 * scrolled because of printing messages. */
  EXTERN int	msg_scrolled_ign INIT(= FALSE);
! 				/* when TRUE don't set need_wait_return in
! 				   msg_puts_attr() when msg_scrolled is
! 				   non-zero */
! 
! EXTERN char_u	*keep_msg INIT(= NULL);	    /* msg to be shown after redraw */
! EXTERN int	keep_msg_attr INIT(= 0);    /* highlight attr for keep_msg */
! EXTERN int	keep_msg_more INIT(= FALSE); /* keep_msg was set by msgmore() */
! EXTERN int	need_fileinfo INIT(= FALSE);/* do fileinfo() after redraw */
! EXTERN int	msg_scroll INIT(= FALSE);   /* msg_start() will scroll */
! EXTERN int	msg_didout INIT(= FALSE);   /* msg_outstr() was used in line */
! EXTERN int	msg_didany INIT(= FALSE);   /* msg_outstr() was used at all */
! EXTERN int	msg_nowait INIT(= FALSE);   /* don't wait for this msg */
! EXTERN int	emsg_off INIT(= 0);	    /* don't display errors for now,
! 					       unless 'debug' is set. */
! EXTERN int	info_message INIT(= FALSE); /* printing informative message */
! EXTERN int      msg_hist_off INIT(= FALSE); /* don't add messages to history */
  #ifdef FEAT_EVAL
! EXTERN int	need_clr_eos INIT(= FALSE); /* need to clear text before
! 					       displaying a message. */
! EXTERN int	emsg_skip INIT(= 0);	    /* don't display errors for
! 					       expression that is skipped */
! EXTERN int	emsg_severe INIT(= FALSE);   /* use message of next of several
! 					       emsg() calls for throw */
! EXTERN int	did_endif INIT(= FALSE);    /* just had ":endif" */
! EXTERN dict_T	vimvardict;		    /* Dictionary with v: variables */
! EXTERN dict_T	globvardict;		    /* Dictionary with g: variables */
  #define globvarht globvardict.dv_hashtab
  #endif
! EXTERN int	did_emsg;		    /* set by emsg() when the message
! 					       is displayed or thrown */
  #ifdef FEAT_EVAL
! EXTERN int	called_vim_beep;	    /* set if vim_beep() is called */
! EXTERN int	did_uncaught_emsg;	    /* emsg() was called and did not
! 					       cause an exception */
! #endif
! EXTERN int	did_emsg_syntax;	    /* did_emsg set because of a
! 					       syntax error */
! EXTERN int	called_emsg;		    /* always set by emsg() */
! EXTERN int	ex_exitval INIT(= 0);	    /* exit value for ex mode */
! EXTERN int	emsg_on_display INIT(= FALSE);	/* there is an error message */
! EXTERN int	rc_did_emsg INIT(= FALSE);  /* vim_regcomp() called emsg() */
! 
! EXTERN int	no_wait_return INIT(= 0);   /* don't wait for return for now */
! EXTERN int	need_wait_return INIT(= 0); /* need to wait for return later */
! EXTERN int	did_wait_return INIT(= FALSE);	/* wait_return() was used and
! 						   nothing written since then */
  #ifdef FEAT_TITLE
! EXTERN int	need_maketitle INIT(= TRUE); /* call maketitle() soon */
  #endif
  
! EXTERN int	quit_more INIT(= FALSE);    /* 'q' hit at "--more--" msg */
  #if defined(UNIX) || defined(VMS) || defined(MACOS_X)
! EXTERN int	newline_on_exit INIT(= FALSE);	/* did msg in altern. screen */
! EXTERN int	intr_char INIT(= 0);	    /* extra interrupt character */
  #endif
  #if (defined(UNIX) || defined(VMS)) && defined(FEAT_X11)
! EXTERN int	x_no_connect INIT(= FALSE); /* don't connect to X server */
  # if defined(FEAT_CLIENTSERVER)
! EXTERN int	x_force_connect INIT(= FALSE); /* Do connect to X server.
! 						  Overrules x_no_connect and
! 						  "exclude" in 'clipboard'. */
  # endif
  #endif
! EXTERN int	ex_keep_indent INIT(= FALSE); /* getexmodeline(): keep indent */
! EXTERN int	vgetc_busy INIT(= 0);	    /* when inside vgetc() then > 0 */
  
! EXTERN int	didset_vim INIT(= FALSE);   /* did set $VIM ourselves */
! EXTERN int	didset_vimruntime INIT(= FALSE);   /* idem for $VIMRUNTIME */
  
  /*
   * Lines left before a "more" message.	Ex mode needs to be able to reset this
   * after you type something.
   */
! EXTERN int	lines_left INIT(= -1);	    /* lines left for listing */
! EXTERN int	msg_no_more INIT(= FALSE);  /* don't use more prompt, truncate
! 					       messages */
  
! EXTERN char_u	*sourcing_name INIT( = NULL);/* name of error message source */
! EXTERN linenr_T	sourcing_lnum INIT(= 0);    /* line number of the source file */
  
  #ifdef FEAT_EVAL
! EXTERN int	ex_nesting_level INIT(= 0);	/* nesting level */
! EXTERN int	debug_break_level INIT(= -1);	/* break below this level */
! EXTERN int	debug_did_msg INIT(= FALSE);	/* did "debug mode" message */
! EXTERN int	debug_tick INIT(= 0);		/* breakpoint change count */
! EXTERN int	debug_backtrace_level INIT(= 0); /* breakpoint backtrace level */
  # ifdef FEAT_PROFILE
! EXTERN int	do_profiling INIT(= PROF_NONE);	/* PROF_ values */
  # endif
  EXTERN garray_T script_items INIT(= {0 COMMA 0 COMMA sizeof(scriptitem_T) COMMA 4 COMMA NULL});
  #define SCRIPT_ITEM(id) (((scriptitem_T *)script_items.ga_data)[(id) - 1])
--- 157,257 ----
   * while keeping ScreenLines[] updated.
   */
  #ifdef FEAT_RIGHTLEFT
! EXTERN int	cmdmsg_rl INIT(= FALSE);    // cmdline is drawn right to left
  #endif
  EXTERN int	msg_col;
  EXTERN int	msg_row;
! EXTERN int	msg_scrolled;	// Number of screen lines that windows have
! 				// scrolled because of printing messages.
  EXTERN int	msg_scrolled_ign INIT(= FALSE);
! 				// when TRUE don't set need_wait_return in
! 				// msg_puts_attr() when msg_scrolled is
! 				// non-zero
! 
! EXTERN char_u	*keep_msg INIT(= NULL);	    // msg to be shown after redraw
! EXTERN int	keep_msg_attr INIT(= 0);    // highlight attr for keep_msg
! EXTERN int	keep_msg_more INIT(= FALSE); // keep_msg was set by msgmore()
! EXTERN int	need_fileinfo INIT(= FALSE);// do fileinfo() after redraw
! EXTERN int	msg_scroll INIT(= FALSE);   // msg_start() will scroll
! EXTERN int	msg_didout INIT(= FALSE);   // msg_outstr() was used in line
! EXTERN int	msg_didany INIT(= FALSE);   // msg_outstr() was used at all
! EXTERN int	msg_nowait INIT(= FALSE);   // don't wait for this msg
! EXTERN int	emsg_off INIT(= 0);	    // don't display errors for now,
! 					    // unless 'debug' is set.
! EXTERN int	info_message INIT(= FALSE); // printing informative message
! EXTERN int      msg_hist_off INIT(= FALSE); // don't add messages to history
  #ifdef FEAT_EVAL
! EXTERN int	need_clr_eos INIT(= FALSE); // need to clear text before
! 					    // displaying a message.
! EXTERN int	emsg_skip INIT(= 0);	    // don't display errors for
! 					    // expression that is skipped
! EXTERN int	emsg_severe INIT(= FALSE);  // use message of next of several
! 					    // emsg() calls for throw
! EXTERN int	did_endif INIT(= FALSE);    // just had ":endif"
! EXTERN dict_T	vimvardict;		    // Dictionary with v: variables
! EXTERN dict_T	globvardict;		    // Dictionary with g: variables
  #define globvarht globvardict.dv_hashtab
  #endif
! EXTERN int	did_emsg;		    // set by emsg() when the message
! 					    // is displayed or thrown
  #ifdef FEAT_EVAL
! EXTERN int	called_vim_beep;	    // set if vim_beep() is called
! EXTERN int	did_uncaught_emsg;	    // emsg() was called and did not
! 					    // cause an exception
! #endif
! EXTERN int	did_emsg_syntax;	    // did_emsg set because of a
! 					    // syntax error
! EXTERN int	called_emsg;		    // always set by emsg()
! EXTERN int	ex_exitval INIT(= 0);	    // exit value for ex mode
! EXTERN int	emsg_on_display INIT(= FALSE);	// there is an error message
! EXTERN int	rc_did_emsg INIT(= FALSE);  // vim_regcomp() called emsg()
! 
! EXTERN int	no_wait_return INIT(= 0);   // don't wait for return for now
! EXTERN int	need_wait_return INIT(= 0); // need to wait for return later
! EXTERN int	did_wait_return INIT(= FALSE);	// wait_return() was used and
! 						// nothing written since then
  #ifdef FEAT_TITLE
! EXTERN int	need_maketitle INIT(= TRUE); // call maketitle() soon
  #endif
  
! EXTERN int	quit_more INIT(= FALSE);    // 'q' hit at "--more--" msg
  #if defined(UNIX) || defined(VMS) || defined(MACOS_X)
! EXTERN int	newline_on_exit INIT(= FALSE);	// did msg in altern. screen
! EXTERN int	intr_char INIT(= 0);	    // extra interrupt character
  #endif
  #if (defined(UNIX) || defined(VMS)) && defined(FEAT_X11)
! EXTERN int	x_no_connect INIT(= FALSE); // don't connect to X server
  # if defined(FEAT_CLIENTSERVER)
! EXTERN int	x_force_connect INIT(= FALSE);	// Do connect to X server.
! 						// Overrules x_no_connect and
! 						// "exclude" in 'clipboard'.
  # endif
  #endif
! EXTERN int	ex_keep_indent INIT(= FALSE); // getexmodeline(): keep indent
! EXTERN int	vgetc_busy INIT(= 0);	      // when inside vgetc() then > 0
  
! EXTERN int	didset_vim INIT(= FALSE);	    // did set $VIM ourselves
! EXTERN int	didset_vimruntime INIT(= FALSE);    // idem for $VIMRUNTIME
  
  /*
   * Lines left before a "more" message.	Ex mode needs to be able to reset this
   * after you type something.
   */
! EXTERN int	lines_left INIT(= -1);	    // lines left for listing
! EXTERN int	msg_no_more INIT(= FALSE);  // don't use more prompt, truncate
! 					    // messages
  
! EXTERN char_u	*sourcing_name INIT( = NULL);// name of error message source
! EXTERN linenr_T	sourcing_lnum INIT(= 0);    // line number of the source file
  
  #ifdef FEAT_EVAL
! EXTERN int	ex_nesting_level INIT(= 0);	// nesting level
! EXTERN int	debug_break_level INIT(= -1);	// break below this level
! EXTERN int	debug_did_msg INIT(= FALSE);	// did "debug mode" message
! EXTERN int	debug_tick INIT(= 0);		// breakpoint change count
! EXTERN int	debug_backtrace_level INIT(= 0); // breakpoint backtrace level
  # ifdef FEAT_PROFILE
! EXTERN int	do_profiling INIT(= PROF_NONE);	// PROF_ values
  # endif
  EXTERN garray_T script_items INIT(= {0 COMMA 0 COMMA sizeof(scriptitem_T) COMMA 4 COMMA NULL});
  #define SCRIPT_ITEM(id) (((scriptitem_T *)script_items.ga_data)[(id) - 1])
***************
*** 348,360 ****
  
  EXTERN int	did_source_packages INIT(= FALSE);
  
! /* Magic number used for hashitem "hi_key" value indicating a deleted item.
!  * Only the address is used. */
  EXTERN char_u	hash_removed;
  
  
! EXTERN int	scroll_region INIT(= FALSE); /* term supports scroll region */
! EXTERN int	t_colors INIT(= 0);	    /* int value of T_CCO */
  
  #ifdef FEAT_CMDL_COMPL
  // Flags to indicate an additional string for highlight name completion.
--- 348,360 ----
  
  EXTERN int	did_source_packages INIT(= FALSE);
  
! // Magic number used for hashitem "hi_key" value indicating a deleted item.
! // Only the address is used.
  EXTERN char_u	hash_removed;
  
  
! EXTERN int	scroll_region INIT(= FALSE); // term supports scroll region
! EXTERN int	t_colors INIT(= 0);	    // int value of T_CCO
  
  #ifdef FEAT_CMDL_COMPL
  // Flags to indicate an additional string for highlight name completion.
***************
*** 377,401 ****
  EXTERN linenr_T	search_last_line INIT(= MAXLNUM); // for :{first},{LAST}s/pat
  #endif
  
! EXTERN int	no_smartcase INIT(= FALSE);	/* don't use 'smartcase' once */
  
! EXTERN int	need_check_timestamps INIT(= FALSE); /* need to check file
! 							timestamps asap */
! EXTERN int	did_check_timestamps INIT(= FALSE); /* did check timestamps
! 						       recently */
! EXTERN int	no_check_timestamps INIT(= 0);	/* Don't check timestamps */
  
! EXTERN int	highlight_attr[HLF_COUNT];  /* Highl. attr for each context. */
  #ifdef FEAT_STL_OPT
  # define USER_HIGHLIGHT
  #endif
  #ifdef USER_HIGHLIGHT
! EXTERN int	highlight_user[9];		/* User[1-9] attributes */
  # ifdef FEAT_STL_OPT
! EXTERN int	highlight_stlnc[9];		/* On top of user */
  #  ifdef FEAT_TERMINAL
! EXTERN int	highlight_stlterm[9];		/* On top of user */
! EXTERN int	highlight_stltermnc[9];		/* On top of user */
  #  endif
  # endif
  #endif
--- 377,401 ----
  EXTERN linenr_T	search_last_line INIT(= MAXLNUM); // for :{first},{LAST}s/pat
  #endif
  
! EXTERN int	no_smartcase INIT(= FALSE);	// don't use 'smartcase' once
  
! EXTERN int	need_check_timestamps INIT(= FALSE); // need to check file
! 						     // timestamps asap
! EXTERN int	did_check_timestamps INIT(= FALSE); // did check timestamps
! 						    // recently
! EXTERN int	no_check_timestamps INIT(= 0);	// Don't check timestamps
  
! EXTERN int	highlight_attr[HLF_COUNT];  // Highl. attr for each context.
  #ifdef FEAT_STL_OPT
  # define USER_HIGHLIGHT
  #endif
  #ifdef USER_HIGHLIGHT
! EXTERN int	highlight_user[9];		// User[1-9] attributes
  # ifdef FEAT_STL_OPT
! EXTERN int	highlight_stlnc[9];		// On top of user
  #  ifdef FEAT_TERMINAL
! EXTERN int	highlight_stlterm[9];		// On top of user
! EXTERN int	highlight_stltermnc[9];		// On top of user
  #  endif
  # endif
  #endif
***************
*** 405,411 ****
  EXTERN int	skip_term_loop INIT(= FALSE);
  #endif
  #ifdef FEAT_GUI
! EXTERN char_u	*use_gvimrc INIT(= NULL);	/* "-U" cmdline argument */
  #endif
  EXTERN int	cterm_normal_fg_color INIT(= 0);
  EXTERN int	cterm_normal_fg_bold INIT(= 0);
--- 405,411 ----
  EXTERN int	skip_term_loop INIT(= FALSE);
  #endif
  #ifdef FEAT_GUI
! EXTERN char_u	*use_gvimrc INIT(= NULL);	// "-U" cmdline argument
  #endif
  EXTERN int	cterm_normal_fg_color INIT(= 0);
  EXTERN int	cterm_normal_fg_bold INIT(= 0);
***************
*** 415,441 ****
  EXTERN guicolor_T cterm_normal_bg_gui_color INIT(= INVALCOLOR);
  #endif
  #ifdef FEAT_TERMRESPONSE
! EXTERN int	is_mac_terminal INIT(= FALSE);  /* recognized Terminal.app */
  #endif
  
! EXTERN int	autocmd_busy INIT(= FALSE);	/* Is apply_autocmds() busy? */
! EXTERN int	autocmd_no_enter INIT(= FALSE); /* *Enter autocmds disabled */
! EXTERN int	autocmd_no_leave INIT(= FALSE); /* *Leave autocmds disabled */
! EXTERN int	modified_was_set;		/* did ":set modified" */
! EXTERN int	did_filetype INIT(= FALSE);	/* FileType event found */
  EXTERN int	au_did_filetype INIT(= FALSE);
! EXTERN int	keep_filetype INIT(= FALSE);	/* value for did_filetype when
! 						   starting to execute
! 						   autocommands */
  
! /* When deleting the current buffer, another one must be loaded.  If we know
!  * which one is preferred, au_new_curbuf is set to it */
  EXTERN bufref_T	au_new_curbuf INIT(= {NULL COMMA 0 COMMA 0});
  
! /* When deleting a buffer/window and autocmd_busy is TRUE, do not free the
!  * buffer/window. but link it in the list starting with
!  * au_pending_free_buf/ap_pending_free_win, using b_next/w_next.
!  * Free the buffer/window when autocmd_busy is being set to FALSE. */
  EXTERN buf_T	*au_pending_free_buf INIT(= NULL);
  EXTERN win_T	*au_pending_free_win INIT(= NULL);
  
--- 415,442 ----
  EXTERN guicolor_T cterm_normal_bg_gui_color INIT(= INVALCOLOR);
  #endif
  #ifdef FEAT_TERMRESPONSE
! EXTERN int	is_mac_terminal INIT(= FALSE);  // recognized Terminal.app
  #endif
  
! EXTERN int	autocmd_busy INIT(= FALSE);	// Is apply_autocmds() busy?
! EXTERN int	autocmd_no_enter INIT(= FALSE); // *Enter autocmds disabled
! EXTERN int	autocmd_no_leave INIT(= FALSE); // *Leave autocmds disabled
! 
! EXTERN int	modified_was_set;		// did ":set modified"
! EXTERN int	did_filetype INIT(= FALSE);	// FileType event found
  EXTERN int	au_did_filetype INIT(= FALSE);
! EXTERN int	keep_filetype INIT(= FALSE);	// value for did_filetype when
! 						// starting to execute
! 						// autocommands
  
! // When deleting the current buffer, another one must be loaded.  If we know
! // which one is preferred, au_new_curbuf is set to it
  EXTERN bufref_T	au_new_curbuf INIT(= {NULL COMMA 0 COMMA 0});
  
! // When deleting a buffer/window and autocmd_busy is TRUE, do not free the
! // buffer/window. but link it in the list starting with
! // au_pending_free_buf/ap_pending_free_win, using b_next/w_next.
! // Free the buffer/window when autocmd_busy is being set to FALSE.
  EXTERN buf_T	*au_pending_free_buf INIT(= NULL);
  EXTERN win_T	*au_pending_free_win INIT(= NULL);
  
***************
*** 445,454 ****
   */
  EXTERN int	mouse_row;
  EXTERN int	mouse_col;
! EXTERN int	mouse_past_bottom INIT(= FALSE);/* mouse below last line */
! EXTERN int	mouse_past_eol INIT(= FALSE);	/* mouse right of line */
! EXTERN int	mouse_dragging INIT(= 0);	/* extending Visual area with
! 						   mouse dragging */
  # if defined(FEAT_MOUSE_DEC)
  /*
   * When the DEC mouse has been pressed but not yet released we enable
--- 446,455 ----
   */
  EXTERN int	mouse_row;
  EXTERN int	mouse_col;
! EXTERN int	mouse_past_bottom INIT(= FALSE);// mouse below last line
! EXTERN int	mouse_past_eol INIT(= FALSE);	// mouse right of line
! EXTERN int	mouse_dragging INIT(= 0);	// extending Visual area with
! 						// mouse dragging
  # if defined(FEAT_MOUSE_DEC)
  /*
   * When the DEC mouse has been pressed but not yet released we enable
***************
*** 458,469 ****
  # endif
  
  # ifdef FEAT_GUI
! /* When the window layout is about to be changed, need_mouse_correct is set,
!  * so that gui_mouse_correct() is called afterwards, to correct the mouse
!  * pointer when focus-follow-mouse is being used. */
  EXTERN int	need_mouse_correct INIT(= FALSE);
  
! /* When double clicking, topline must be the same */
  EXTERN linenr_T gui_prev_topline INIT(= 0);
  #  ifdef FEAT_DIFF
  EXTERN int	gui_prev_topfill INIT(= 0);
--- 459,470 ----
  # endif
  
  # ifdef FEAT_GUI
! // When the window layout is about to be changed, need_mouse_correct is set,
! // so that gui_mouse_correct() is called afterwards, to correct the mouse
! // pointer when focus-follow-mouse is being used.
  EXTERN int	need_mouse_correct INIT(= FALSE);
  
! // When double clicking, topline must be the same
  EXTERN linenr_T gui_prev_topline INIT(= 0);
  #  ifdef FEAT_DIFF
  EXTERN int	gui_prev_topfill INIT(= 0);
***************
*** 471,493 ****
  # endif
  
  # ifdef FEAT_MOUSESHAPE
! EXTERN int	drag_status_line INIT(= FALSE);	/* dragging the status line */
! EXTERN int	postponed_mouseshape INIT(= FALSE); /* postponed updating the
! 						       mouse pointer shape */
! EXTERN int	drag_sep_line INIT(= FALSE);	/* dragging vert separator */
  # endif
  
  #endif
  
  #ifdef FEAT_DIFF
! /* Value set from 'diffopt'. */
! EXTERN int	diff_context INIT(= 6);		/* context for folds */
! EXTERN int	diff_foldcolumn INIT(= 2);	/* 'foldcolumn' for diff mode */
  EXTERN int	diff_need_scrollbind INIT(= FALSE);
  #endif
  
  #ifdef FEAT_MENU
! /* The root of the menu hierarchy. */
  EXTERN vimmenu_T	*root_menu INIT(= NULL);
  /*
   * While defining the system menu, sys_menu is TRUE.  This avoids
--- 472,498 ----
  # endif
  
  # ifdef FEAT_MOUSESHAPE
! EXTERN int	drag_status_line INIT(= FALSE);	// dragging the status line
! EXTERN int	postponed_mouseshape INIT(= FALSE); // postponed updating the
! 						    // mouse pointer shape
! EXTERN int	drag_sep_line INIT(= FALSE);	// dragging vert separator
  # endif
  
  #endif
  
  #ifdef FEAT_DIFF
! // Value set from 'diffopt'.
! EXTERN int	diff_context INIT(= 6);		// context for folds
! EXTERN int	diff_foldcolumn INIT(= 2);	// 'foldcolumn' for diff mode
  EXTERN int	diff_need_scrollbind INIT(= FALSE);
  #endif
  
+ // While redrawing the screen this flag is set.  It means the screen size
+ // ('lines' and 'rows') must not be changed.
+ EXTERN int	updating_screen INIT(= FALSE);
+ 
  #ifdef FEAT_MENU
! // The root of the menu hierarchy.
  EXTERN vimmenu_T	*root_menu INIT(= NULL);
  /*
   * While defining the system menu, sys_menu is TRUE.  This avoids
***************
*** 496,539 ****
  EXTERN int	sys_menu INIT(= FALSE);
  #endif
  
- /* While redrawing the screen this flag is set.  It means the screen size
-  * ('lines' and 'rows') must not be changed. */
- EXTERN int	updating_screen INIT(= FALSE);
- 
  #ifdef FEAT_GUI
  # ifdef FEAT_MENU
! /* Menu item just selected, set by check_termcode() */
  EXTERN vimmenu_T	*current_menu;
  
! /* Set to TRUE after adding/removing menus to ensure they are updated */
  EXTERN int force_menu_update INIT(= FALSE);
  # endif
  # ifdef FEAT_GUI_TABLINE
! /* Tab in tab pages line just selected, set by check_termcode() */
  EXTERN int	    current_tab;
  
! /* Menu entry in tab pages line menu just selected, set by check_termcode() */
  EXTERN int	    current_tabmenu;
  #  define TABLINE_MENU_CLOSE	1
  #  define TABLINE_MENU_NEW	2
  #  define TABLINE_MENU_OPEN	3
  # endif
  
! /* Scrollbar moved and new value, set by check_termcode() */
  EXTERN int	current_scrollbar;
  EXTERN long_u	scrollbar_value;
  
! /* found "-rv" or "-reverse" in command line args */
  EXTERN int	found_reverse_arg INIT(= FALSE);
  
! /* "-fn" or "-font" command line argument */
  EXTERN char	*font_argument INIT(= NULL);
  
  # ifdef FEAT_GUI_GTK
! /* "-bg" or "-background" command line argument */
  EXTERN char	*background_argument INIT(= NULL);
  
! /* "-fg" or "-foreground" command line argument */
  EXTERN char	*foreground_argument INIT(= NULL);
  # endif
  
--- 501,540 ----
  EXTERN int	sys_menu INIT(= FALSE);
  #endif
  
  #ifdef FEAT_GUI
  # ifdef FEAT_MENU
! // Menu item just selected, set by check_termcode()
  EXTERN vimmenu_T	*current_menu;
  
! // Set to TRUE after adding/removing menus to ensure they are updated
  EXTERN int force_menu_update INIT(= FALSE);
  # endif
  # ifdef FEAT_GUI_TABLINE
! // Tab in tab pages line just selected, set by check_termcode()
  EXTERN int	    current_tab;
  
! // Menu entry in tab pages line menu just selected, set by check_termcode()
  EXTERN int	    current_tabmenu;
  #  define TABLINE_MENU_CLOSE	1
  #  define TABLINE_MENU_NEW	2
  #  define TABLINE_MENU_OPEN	3
  # endif
  
! // Scrollbar moved and new value, set by check_termcode()
  EXTERN int	current_scrollbar;
  EXTERN long_u	scrollbar_value;
  
! // found "-rv" or "-reverse" in command line args
  EXTERN int	found_reverse_arg INIT(= FALSE);
  
! // "-fn" or "-font" command line argument
  EXTERN char	*font_argument INIT(= NULL);
  
  # ifdef FEAT_GUI_GTK
! // "-bg" or "-background" command line argument
  EXTERN char	*background_argument INIT(= NULL);
  
! // "-fg" or "-foreground" command line argument
  EXTERN char	*foreground_argument INIT(= NULL);
  # endif
  
***************
*** 552,558 ****
  EXTERN int	new_pixel_width INIT(= 0);
  EXTERN int	new_pixel_height INIT(= 0);
  
! /* Window position from ":winpos", to be used when opening the GUI window. */
  EXTERN int	gui_win_x INIT(= -1);
  EXTERN int	gui_win_y INIT(= -1);
  #endif
--- 553,559 ----
  EXTERN int	new_pixel_width INIT(= 0);
  EXTERN int	new_pixel_height INIT(= 0);
  
! // Window position from ":winpos", to be used when opening the GUI window.
  EXTERN int	gui_win_x INIT(= -1);
  EXTERN int	gui_win_y INIT(= -1);
  #endif
***************
*** 568,574 ****
  
  # define CLIP_UNNAMED      1
  # define CLIP_UNNAMED_PLUS 2
! EXTERN int	clip_unnamed INIT(= 0); /* above two values or'ed */
  
  EXTERN int	clip_autoselect_star INIT(= FALSE);
  EXTERN int	clip_autoselect_plus INIT(= FALSE);
--- 569,575 ----
  
  # define CLIP_UNNAMED      1
  # define CLIP_UNNAMED_PLUS 2
! EXTERN int	clip_unnamed INIT(= 0); // above two values or'ed
  
  EXTERN int	clip_autoselect_star INIT(= FALSE);
  EXTERN int	clip_autoselect_plus INIT(= FALSE);
***************
*** 584,592 ****
   * "curwin" to the currently active window.
   * When switching tabs these swapped with the pointers in "tabpage_T".
   */
! EXTERN win_T	*firstwin;		/* first window */
! EXTERN win_T	*lastwin;		/* last window */
! EXTERN win_T	*prevwin INIT(= NULL);	/* previous window */
  #define ONE_WINDOW (firstwin == lastwin)
  #define W_NEXT(wp) ((wp)->w_next)
  #define FOR_ALL_WINDOWS(wp) for (wp = firstwin; wp != NULL; wp = wp->w_next)
--- 585,593 ----
   * "curwin" to the currently active window.
   * When switching tabs these swapped with the pointers in "tabpage_T".
   */
! EXTERN win_T	*firstwin;		// first window
! EXTERN win_T	*lastwin;		// last window
! EXTERN win_T	*prevwin INIT(= NULL);	// previous window
  #define ONE_WINDOW (firstwin == lastwin)
  #define W_NEXT(wp) ((wp)->w_next)
  #define FOR_ALL_WINDOWS(wp) for (wp = firstwin; wp != NULL; wp = wp->w_next)
***************
*** 606,621 ****
  		? firstwin : (tp)->tp_firstwin; (wp); (wp) = (wp)->w_next)
  
  
! EXTERN win_T	*curwin;	/* currently active window */
  
! EXTERN win_T	*aucmd_win;	/* window used in aucmd_prepbuf() */
! EXTERN int	aucmd_win_used INIT(= FALSE);	/* aucmd_win is being used */
  
  #ifdef FEAT_TEXT_PROP
  EXTERN win_T    *first_popupwin;		// first global popup window
  EXTERN win_T	*popup_dragwin INIT(= NULL);	// popup window being dragged
  
! // Set to TRUE if there is any visible popup.
  EXTERN int	popup_visible INIT(= FALSE);
  
  EXTERN int	text_prop_frozen INIT(= 0);
--- 607,622 ----
  		? firstwin : (tp)->tp_firstwin; (wp); (wp) = (wp)->w_next)
  
  
! EXTERN win_T	*curwin;	// currently active window
  
! EXTERN win_T	*aucmd_win;	// window used in aucmd_prepbuf()
! EXTERN int	aucmd_win_used INIT(= FALSE);	// aucmd_win is being used
  
  #ifdef FEAT_TEXT_PROP
  EXTERN win_T    *first_popupwin;		// first global popup window
  EXTERN win_T	*popup_dragwin INIT(= NULL);	// popup window being dragged
  
! // Set to TRUE if there is any visible popup window.
  EXTERN int	popup_visible INIT(= FALSE);
  
  EXTERN int	text_prop_frozen INIT(= 0);
***************
*** 625,631 ****
   * The window layout is kept in a tree of frames.  topframe points to the top
   * of the tree.
   */
! EXTERN frame_T	*topframe;	/* top of the window frame tree */
  
  /*
   * Tab pages are alternative topframes.  "first_tabpage" points to the first
--- 626,632 ----
   * The window layout is kept in a tree of frames.  topframe points to the top
   * of the tree.
   */
! EXTERN frame_T	*topframe;	// top of the window frame tree
  
  /*
   * Tab pages are alternative topframes.  "first_tabpage" points to the first
***************
*** 633,647 ****
   */
  EXTERN tabpage_T    *first_tabpage;
  EXTERN tabpage_T    *curtab;
! EXTERN int	    redraw_tabline INIT(= FALSE);  /* need to redraw tabline */
  
  /*
   * All buffers are linked in a list. 'firstbuf' points to the first entry,
   * 'lastbuf' to the last entry and 'curbuf' to the currently active buffer.
   */
! EXTERN buf_T	*firstbuf INIT(= NULL);	/* first buffer */
! EXTERN buf_T	*lastbuf INIT(= NULL);	/* last buffer */
! EXTERN buf_T	*curbuf INIT(= NULL);	/* currently active buffer */
  
  #define FOR_ALL_BUFFERS(buf) for (buf = firstbuf; buf != NULL; buf = buf->b_next)
  
--- 634,648 ----
   */
  EXTERN tabpage_T    *first_tabpage;
  EXTERN tabpage_T    *curtab;
! EXTERN int	    redraw_tabline INIT(= FALSE);  // need to redraw tabline
  
  /*
   * All buffers are linked in a list. 'firstbuf' points to the first entry,
   * 'lastbuf' to the last entry and 'curbuf' to the currently active buffer.
   */
! EXTERN buf_T	*firstbuf INIT(= NULL);	// first buffer
! EXTERN buf_T	*lastbuf INIT(= NULL);	// last buffer
! EXTERN buf_T	*curbuf INIT(= NULL);	// currently active buffer
  
  #define FOR_ALL_BUFFERS(buf) for (buf = firstbuf; buf != NULL; buf = buf->b_next)
  
***************
*** 649,676 ****
  #define FOR_ALL_SIGNS_IN_BUF(buf, sign) \
  	for (sign = buf->b_signlist; sign != NULL; sign = sign->next)
  
! /* Flag that is set when switching off 'swapfile'.  It means that all blocks
!  * are to be loaded into memory.  Shouldn't be global... */
! EXTERN int	mf_dont_release INIT(= FALSE);	/* don't release blocks */
  
  /*
   * List of files being edited (global argument list).  curwin->w_alist points
   * to this when the window is using the global argument list.
   */
! EXTERN alist_T	global_alist;	/* global argument list */
! EXTERN int	max_alist_id INIT(= 0);	    /* the previous argument list id */
! EXTERN int	arg_had_last INIT(= FALSE); /* accessed last file in
! 					       global_alist */
  
! EXTERN int	ru_col;		/* column for ruler */
  #ifdef FEAT_STL_OPT
! EXTERN int	ru_wid;		/* 'rulerfmt' width of ruler when non-zero */
  #endif
! EXTERN int	sc_col;		/* column for shown command */
  
  #ifdef TEMPDIRNAMES
! EXTERN char_u	*vim_tempdir INIT(= NULL); /* Name of Vim's own temp dir.
! 					      Ends in a slash. */
  #endif
  
  /*
--- 650,677 ----
  #define FOR_ALL_SIGNS_IN_BUF(buf, sign) \
  	for (sign = buf->b_signlist; sign != NULL; sign = sign->next)
  
! // Flag that is set when switching off 'swapfile'.  It means that all blocks
! // are to be loaded into memory.  Shouldn't be global...
! EXTERN int	mf_dont_release INIT(= FALSE);	// don't release blocks
  
  /*
   * List of files being edited (global argument list).  curwin->w_alist points
   * to this when the window is using the global argument list.
   */
! EXTERN alist_T	global_alist;		    // global argument list
! EXTERN int	max_alist_id INIT(= 0);	    // the previous argument list id
! EXTERN int	arg_had_last INIT(= FALSE); // accessed last file in
! 					    // global_alist
  
! EXTERN int	ru_col;		// column for ruler
  #ifdef FEAT_STL_OPT
! EXTERN int	ru_wid;		// 'rulerfmt' width of ruler when non-zero
  #endif
! EXTERN int	sc_col;		// column for shown command
  
  #ifdef TEMPDIRNAMES
! EXTERN char_u	*vim_tempdir INIT(= NULL); // Name of Vim's own temp dir.
! 					   // Ends in a slash.
  #endif
  
  /*
***************
*** 678,751 ****
   * updating).
   */
  EXTERN int	starting INIT(= NO_SCREEN);
! 				/* first NO_SCREEN, then NO_BUFFERS and then
! 				 * set to 0 when starting up finished */
  EXTERN int	exiting INIT(= FALSE);
! 				/* TRUE when planning to exit Vim.  Might
! 				 * still keep on running if there is a changed
! 				 * buffer. */
  EXTERN int	really_exiting INIT(= FALSE);
! 				/* TRUE when we are sure to exit, e.g., after
! 				 * a deadly signal */
! EXTERN int	v_dying INIT(= 0); /* internal value of v:dying */
! EXTERN int	stdout_isatty INIT(= TRUE);	/* is stdout a terminal? */
  
  #if defined(FEAT_AUTOCHDIR)
  EXTERN int	test_autochdir INIT(= FALSE);
  #endif
  #if defined(EXITFREE)
  EXTERN int	entered_free_all_mem INIT(= FALSE);
! 				/* TRUE when in or after free_all_mem() */
  #endif
! /* volatile because it is used in signal handler deathtrap(). */
  EXTERN volatile sig_atomic_t full_screen INIT(= FALSE);
! 				/* TRUE when doing full-screen output
! 				 * otherwise only writing some messages */
  
  EXTERN int	restricted INIT(= FALSE);
! 				/* TRUE when started as "rvim" */
  EXTERN int	secure INIT(= FALSE);
! 				/* non-zero when only "safe" commands are
! 				 * allowed, e.g. when sourcing .exrc or .vimrc
! 				 * in current directory */
  
  EXTERN int	textlock INIT(= 0);
! 				/* non-zero when changing text and jumping to
! 				 * another window or buffer is not allowed */
  
  EXTERN int	curbuf_lock INIT(= 0);
! 				/* non-zero when the current buffer can't be
! 				 * changed.  Used for FileChangedRO. */
  EXTERN int	allbuf_lock INIT(= 0);
! 				/* non-zero when no buffer name can be
! 				 * changed, no buffer can be deleted and
! 				 * current directory can't be changed.
! 				 * Used for SwapExists et al. */
  #ifdef HAVE_SANDBOX
  EXTERN int	sandbox INIT(= 0);
! 				/* Non-zero when evaluating an expression in a
! 				 * "sandbox".  Several things are not allowed
! 				 * then. */
  #endif
  
  EXTERN int	silent_mode INIT(= FALSE);
! 				/* set to TRUE when "-s" commandline argument
! 				 * used for ex */
  
! EXTERN pos_T	VIsual;		/* start position of active Visual selection */
  EXTERN int	VIsual_active INIT(= FALSE);
! 				/* whether Visual mode is active */
  EXTERN int	VIsual_select INIT(= FALSE);
! 				/* whether Select mode is active */
  EXTERN int	VIsual_reselect;
! 				/* whether to restart the selection after a
! 				 * Select mode mapping or menu */
  
  EXTERN int	VIsual_mode INIT(= 'v');
! 				/* type of Visual mode */
  
  EXTERN int	redo_VIsual_busy INIT(= FALSE);
! 				/* TRUE when redoing Visual */
  
  #ifdef FEAT_MOUSE
  /*
--- 679,752 ----
   * updating).
   */
  EXTERN int	starting INIT(= NO_SCREEN);
! 				// first NO_SCREEN, then NO_BUFFERS and then
! 				// set to 0 when starting up finished
  EXTERN int	exiting INIT(= FALSE);
! 				// TRUE when planning to exit Vim.  Might
! 				// still keep on running if there is a changed
! 				// buffer.
  EXTERN int	really_exiting INIT(= FALSE);
! 				// TRUE when we are sure to exit, e.g., after
! 				// a deadly signal
! EXTERN int	v_dying INIT(= 0); // internal value of v:dying
! EXTERN int	stdout_isatty INIT(= TRUE);	// is stdout a terminal?
  
  #if defined(FEAT_AUTOCHDIR)
  EXTERN int	test_autochdir INIT(= FALSE);
  #endif
  #if defined(EXITFREE)
  EXTERN int	entered_free_all_mem INIT(= FALSE);
! 				// TRUE when in or after free_all_mem()
  #endif
! // volatile because it is used in signal handler deathtrap().
  EXTERN volatile sig_atomic_t full_screen INIT(= FALSE);
! 				// TRUE when doing full-screen output
! 				// otherwise only writing some messages
  
  EXTERN int	restricted INIT(= FALSE);
! 				// TRUE when started as "rvim"
  EXTERN int	secure INIT(= FALSE);
! 				// non-zero when only "safe" commands are
! 				// allowed, e.g. when sourcing .exrc or .vimrc
! 				// in current directory
  
  EXTERN int	textlock INIT(= 0);
! 				// non-zero when changing text and jumping to
! 				// another window or buffer is not allowed
  
  EXTERN int	curbuf_lock INIT(= 0);
! 				// non-zero when the current buffer can't be
! 				// changed.  Used for FileChangedRO.
  EXTERN int	allbuf_lock INIT(= 0);
! 				// non-zero when no buffer name can be
! 				// changed, no buffer can be deleted and
! 				// current directory can't be changed.
! 				// Used for SwapExists et al.
  #ifdef HAVE_SANDBOX
  EXTERN int	sandbox INIT(= 0);
! 				// Non-zero when evaluating an expression in a
! 				// "sandbox".  Several things are not allowed
! 				// then.
  #endif
  
  EXTERN int	silent_mode INIT(= FALSE);
! 				// set to TRUE when "-s" commandline argument
! 				// used for ex
  
! EXTERN pos_T	VIsual;		// start position of active Visual selection
  EXTERN int	VIsual_active INIT(= FALSE);
! 				// whether Visual mode is active
  EXTERN int	VIsual_select INIT(= FALSE);
! 				// whether Select mode is active
  EXTERN int	VIsual_reselect;
! 				// whether to restart the selection after a
! 				// Select mode mapping or menu
  
  EXTERN int	VIsual_mode INIT(= 'v');
! 				// type of Visual mode
  
  EXTERN int	redo_VIsual_busy INIT(= FALSE);
! 				// TRUE when redoing Visual
  
  #ifdef FEAT_MOUSE
  /*
***************
*** 807,813 ****
  EXTERN int	can_si_back INIT(= FALSE);
  #endif
  
! EXTERN pos_T	saved_cursor		/* w_cursor before formatting text. */
  #ifdef DO_INIT
  	= {0, 0, 0}
  #endif
--- 808,814 ----
  EXTERN int	can_si_back INIT(= FALSE);
  #endif
  
! EXTERN pos_T	saved_cursor		// w_cursor before formatting text.
  #ifdef DO_INIT
  	= {0, 0, 0}
  #endif
***************
*** 816,823 ****
  /*
   * Stuff for insert mode.
   */
! EXTERN pos_T	Insstart;		/* This is where the latest
! 					 * insert/append mode started. */
  
  /* This is where the latest insert/append mode started. In contrast to
   * Insstart, this won't be reset by certain keys and is needed for
--- 817,824 ----
  /*
   * Stuff for insert mode.
   */
! EXTERN pos_T	Insstart;		// This is where the latest
! 					// insert/append mode started.
  
  /* This is where the latest insert/append mode started. In contrast to
   * Insstart, this won't be reset by certain keys and is needed for
***************
*** 827,834 ****
  /*
   * Stuff for VREPLACE mode.
   */
! EXTERN int	orig_line_count INIT(= 0);  /* Line count when "gR" started */
! EXTERN int	vr_lines_changed INIT(= 0); /* #Lines changed by "gR" so far */
  
  #if defined(FEAT_X11) && defined(FEAT_XCLIPBOARD)
  /* argument to SETJMP() for handling X IO errors */
--- 828,835 ----
  /*
   * Stuff for VREPLACE mode.
   */
! EXTERN int	orig_line_count INIT(= 0);  // Line count when "gR" started
! EXTERN int	vr_lines_changed INIT(= 0); // #Lines changed by "gR" so far
  
  #if defined(FEAT_X11) && defined(FEAT_XCLIPBOARD)
  /* argument to SETJMP() for handling X IO errors */
***************
*** 840,868 ****
   * Note that "enc_utf8" is also set for "unicode", because the characters are
   * internally stored as UTF-8 (to avoid trouble with NUL bytes).
   */
! #define DBCS_JPN	932	/* japan */
! #define DBCS_JPNU	9932	/* euc-jp */
! #define DBCS_KOR	949	/* korea */
! #define DBCS_KORU	9949	/* euc-kr */
! #define DBCS_CHS	936	/* chinese */
! #define DBCS_CHSU	9936	/* euc-cn */
! #define DBCS_CHT	950	/* taiwan */
! #define DBCS_CHTU	9950	/* euc-tw */
! #define DBCS_2BYTE	1	/* 2byte- */
  #define DBCS_DEBUG	-1
  
! EXTERN int	enc_dbcs INIT(= 0);		/* One of DBCS_xxx values if
! 						   DBCS encoding */
! EXTERN int	enc_unicode INIT(= 0);	/* 2: UCS-2 or UTF-16, 4: UCS-4 */
! EXTERN int	enc_utf8 INIT(= FALSE);		/* UTF-8 encoded Unicode */
! EXTERN int	enc_latin1like INIT(= TRUE);	/* 'encoding' is latin1 comp. */
  #if defined(MSWIN) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)
! /* Codepage nr of 'encoding'.  Negative means it's not been set yet, zero
!  * means 'encoding' is not a valid codepage. */
  EXTERN int	enc_codepage INIT(= -1);
! EXTERN int	enc_latin9 INIT(= FALSE);	/* 'encoding' is latin9 */
  #endif
! EXTERN int	has_mbyte INIT(= 0);		/* any multi-byte encoding */
  
  /*
   * To speed up BYTELEN() we fill a table with the byte lengths whenever
--- 841,869 ----
   * Note that "enc_utf8" is also set for "unicode", because the characters are
   * internally stored as UTF-8 (to avoid trouble with NUL bytes).
   */
! #define DBCS_JPN	932	// japan
! #define DBCS_JPNU	9932	// euc-jp
! #define DBCS_KOR	949	// korea
! #define DBCS_KORU	9949	// euc-kr
! #define DBCS_CHS	936	// chinese
! #define DBCS_CHSU	9936	// euc-cn
! #define DBCS_CHT	950	// taiwan
! #define DBCS_CHTU	9950	// euc-tw
! #define DBCS_2BYTE	1	// 2byte-
  #define DBCS_DEBUG	-1
  
! EXTERN int	enc_dbcs INIT(= 0);		// One of DBCS_xxx values if
! 						// DBCS encoding
! EXTERN int	enc_unicode INIT(= 0);	// 2: UCS-2 or UTF-16, 4: UCS-4
! EXTERN int	enc_utf8 INIT(= FALSE);		// UTF-8 encoded Unicode
! EXTERN int	enc_latin1like INIT(= TRUE);	// 'encoding' is latin1 comp.
  #if defined(MSWIN) || defined(FEAT_CYGWIN_WIN32_CLIPBOARD)
! // Codepage nr of 'encoding'.  Negative means it's not been set yet, zero
! // means 'encoding' is not a valid codepage.
  EXTERN int	enc_codepage INIT(= -1);
! EXTERN int	enc_latin9 INIT(= FALSE);	// 'encoding' is latin9
  #endif
! EXTERN int	has_mbyte INIT(= 0);		// any multi-byte encoding
  
  /*
   * To speed up BYTELEN() we fill a table with the byte lengths whenever
***************
*** 870,879 ****
   */
  EXTERN char	mb_bytelen_tab[256];
  
! /* Variables that tell what conversion is used for keyboard input and display
!  * output. */
! EXTERN vimconv_T input_conv;			/* type of input conversion */
! EXTERN vimconv_T output_conv;			/* type of output conversion */
  
  /*
   * Function pointers, used to quickly get to the right function.  Each has
--- 871,880 ----
   */
  EXTERN char	mb_bytelen_tab[256];
  
! // Variables that tell what conversion is used for keyboard input and display
! // output.
! EXTERN vimconv_T input_conv;			// type of input conversion
! EXTERN vimconv_T output_conv;			// type of output conversion
  
  /*
   * Function pointers, used to quickly get to the right function.  Each has
***************
*** 881,893 ****
   * (DBCS).
   * The value is set in mb_init();
   */
! /* length of char in bytes, including following composing chars */
  EXTERN int (*mb_ptr2len)(char_u *p) INIT(= latin_ptr2len);
! /* idem, with limit on string length */
  EXTERN int (*mb_ptr2len_len)(char_u *p, int size) INIT(= latin_ptr2len_len);
! /* byte length of char */
  EXTERN int (*mb_char2len)(int c) INIT(= latin_char2len);
! /* convert char to bytes, return the length */
  EXTERN int (*mb_char2bytes)(int c, char_u *buf) INIT(= latin_char2bytes);
  EXTERN int (*mb_ptr2cells)(char_u *p) INIT(= latin_ptr2cells);
  EXTERN int (*mb_ptr2cells_len)(char_u *p, int size) INIT(= latin_ptr2cells_len);
--- 882,894 ----
   * (DBCS).
   * The value is set in mb_init();
   */
! // length of char in bytes, including following composing chars
  EXTERN int (*mb_ptr2len)(char_u *p) INIT(= latin_ptr2len);
! // idem, with limit on string length
  EXTERN int (*mb_ptr2len_len)(char_u *p, int size) INIT(= latin_ptr2len_len);
! // byte length of char
  EXTERN int (*mb_char2len)(int c) INIT(= latin_char2len);
! // convert char to bytes, return the length
  EXTERN int (*mb_char2bytes)(int c, char_u *buf) INIT(= latin_char2bytes);
  EXTERN int (*mb_ptr2cells)(char_u *p) INIT(= latin_ptr2cells);
  EXTERN int (*mb_ptr2cells_len)(char_u *p, int size) INIT(= latin_ptr2cells_len);
***************
*** 897,903 ****
  EXTERN int (*mb_head_off)(char_u *base, char_u *p) INIT(= latin_head_off);
  
  # if defined(USE_ICONV) && defined(DYNAMIC_ICONV)
! /* Pointers to functions and variables to be loaded at runtime */
  EXTERN size_t (*iconv) (iconv_t cd, const char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);
  EXTERN iconv_t (*iconv_open) (const char *tocode, const char *fromcode);
  EXTERN int (*iconv_close) (iconv_t cd);
--- 898,904 ----
  EXTERN int (*mb_head_off)(char_u *base, char_u *p) INIT(= latin_head_off);
  
  # if defined(USE_ICONV) && defined(DYNAMIC_ICONV)
! // Pointers to functions and variables to be loaded at runtime
  EXTERN size_t (*iconv) (iconv_t cd, const char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);
  EXTERN iconv_t (*iconv_open) (const char *tocode, const char *fromcode);
  EXTERN int (*iconv_close) (iconv_t cd);
***************
*** 919,926 ****
  EXTERN colnr_T		preedit_start_col INIT(= MAXCOL);
  EXTERN colnr_T		preedit_end_col INIT(= MAXCOL);
  
! /* "xim_changed_while_preediting" is set when changed() can set the 'modified'
!  * flag even while preediting. */
  EXTERN int		xim_changed_while_preediting INIT(= FALSE);
  # else
  EXTERN XIC		xic INIT(= NULL);
--- 920,927 ----
  EXTERN colnr_T		preedit_start_col INIT(= MAXCOL);
  EXTERN colnr_T		preedit_end_col INIT(= MAXCOL);
  
! // "xim_changed_while_preediting" is set when changed() can set the 'modified'
! // flag even while preediting.
  EXTERN int		xim_changed_while_preediting INIT(= FALSE);
  # else
  EXTERN XIC		xic INIT(= NULL);
***************
*** 945,1111 ****
   * "motion_force"   Last motion_force  from do_pending_operator()
   * "debug_mode"	    Debug mode.
   */
! EXTERN int	State INIT(= NORMAL);	/* This is the current state of the
! 					 * command interpreter. */
  #ifdef FEAT_EVAL
  EXTERN int	debug_mode INIT(= FALSE);
  #endif
  
! EXTERN int	finish_op INIT(= FALSE);/* TRUE while an operator is pending */
! EXTERN long	opcount INIT(= 0);	/* count for pending operator */
  EXTERN int	motion_force INIT(= 0); // motion force for pending operator
  
  /*
   * Ex mode (Q) state
   */
! EXTERN int exmode_active INIT(= 0);	/* zero, EXMODE_NORMAL or EXMODE_VIM */
! EXTERN int ex_no_reprint INIT(= FALSE); /* no need to print after z or p */
  
! EXTERN int reg_recording INIT(= 0);	/* register for recording  or zero */
! EXTERN int reg_executing INIT(= 0);	/* register being executed or zero */
  
! EXTERN int no_mapping INIT(= FALSE);	/* currently no mapping allowed */
! EXTERN int no_zero_mapping INIT(= 0);	/* mapping zero not allowed */
! EXTERN int allow_keys INIT(= FALSE);	/* allow key codes when no_mapping
! 					 * is set */
! EXTERN int no_u_sync INIT(= 0);		/* Don't call u_sync() */
  #ifdef FEAT_EVAL
! EXTERN int u_sync_once INIT(= 0);	/* Call u_sync() once when evaluating
! 					   an expression. */
  #endif
  
! EXTERN int restart_edit INIT(= 0);	/* call edit when next cmd finished */
! EXTERN int arrow_used;			/* Normally FALSE, set to TRUE after
! 					 * hitting cursor key in insert mode.
! 					 * Used by vgetorpeek() to decide when
! 					 * to call u_sync() */
! EXTERN int	ins_at_eol INIT(= FALSE); /* put cursor after eol when
! 					   restarting edit after CTRL-O */
  #ifdef FEAT_INS_EXPAND
! EXTERN char_u	*edit_submode INIT(= NULL); /* msg for CTRL-X submode */
! EXTERN char_u	*edit_submode_pre INIT(= NULL); /* prepended to edit_submode */
! EXTERN char_u	*edit_submode_extra INIT(= NULL);/* appended to edit_submode */
! EXTERN hlf_T	edit_submode_highl;	/* highl. method for extra info */
  #endif
  
! EXTERN int	no_abbr INIT(= TRUE);	/* TRUE when no abbreviations loaded */
  
  #ifdef USE_EXE_NAME
! EXTERN char_u	*exe_name;		/* the name of the executable */
  #endif
  
  #ifdef USE_ON_FLY_SCROLL
! EXTERN int	dont_scroll INIT(= FALSE);/* don't use scrollbars when TRUE */
  #endif
! EXTERN int	mapped_ctrl_c INIT(= FALSE); /* modes where CTRL-C is mapped */
! EXTERN int	ctrl_c_interrupts INIT(= TRUE);	/* CTRL-C sets got_int */
  
! EXTERN cmdmod_T	cmdmod;			/* Ex command modifiers */
  
! EXTERN int	msg_silent INIT(= 0);	/* don't print messages */
! EXTERN int	emsg_silent INIT(= 0);	/* don't print error messages */
! EXTERN int	emsg_noredir INIT(= 0);	/* don't redirect error messages */
! EXTERN int	cmd_silent INIT(= FALSE); /* don't echo the command line */
  
  EXTERN int	swap_exists_action INIT(= SEA_NONE);
! 					/* For dialog when swap file already
! 					 * exists. */
  EXTERN int	swap_exists_did_quit INIT(= FALSE);
! 					/* Selected "quit" at the dialog. */
  
! EXTERN char_u	*IObuff;		/* sprintf's are done in this buffer,
! 					   size is IOSIZE */
! EXTERN char_u	*NameBuff;		/* file names are expanded in this
! 					 * buffer, size is MAXPATHL */
! EXTERN char	msg_buf[MSG_BUF_LEN];	/* small buffer for messages */
  
! /* When non-zero, postpone redrawing. */
  EXTERN int	RedrawingDisabled INIT(= 0);
  
! EXTERN int	readonlymode INIT(= FALSE); /* Set to TRUE for "view" */
! EXTERN int	recoverymode INIT(= FALSE); /* Set to TRUE for "-r" option */
  
! EXTERN typebuf_T typebuf		/* typeahead buffer */
  #ifdef DO_INIT
  		    = {NULL, NULL, 0, 0, 0, 0, 0, 0, 0}
  #endif
  		    ;
! EXTERN int	ex_normal_busy INIT(= 0); /* recursiveness of ex_normal() */
! EXTERN int	ex_normal_lock INIT(= 0); /* forbid use of ex_normal() */
  #ifdef FEAT_EVAL
! EXTERN int	ignore_script INIT(= FALSE);  /* ignore script input */
  #endif
! EXTERN int	stop_insert_mode;	/* for ":stopinsert" and 'insertmode' */
  
! EXTERN int	KeyTyped;		/* TRUE if user typed current char */
! EXTERN int	KeyStuffed;		/* TRUE if current char from stuffbuf */
  #ifdef HAVE_INPUT_METHOD
! EXTERN int	vgetc_im_active;	/* Input Method was active for last
! 					   character obtained from vgetc() */
  #endif
! EXTERN int	maptick INIT(= 0);	/* tick for each non-mapped char */
  
! EXTERN int	must_redraw INIT(= 0);	    /* type of redraw necessary */
! EXTERN int	skip_redraw INIT(= FALSE);  /* skip redraw once */
! EXTERN int	do_redraw INIT(= FALSE);    /* extra redraw once */
  
  EXTERN int	need_highlight_changed INIT(= TRUE);
  
  #define NSCRIPT 15
! EXTERN FILE	*scriptin[NSCRIPT];	    /* streams to read script from */
! EXTERN int	curscript INIT(= 0);	    /* index in scriptin[] */
! EXTERN FILE	*scriptout  INIT(= NULL);   /* stream to write script to */
! EXTERN int	read_cmd_fd INIT(= 0);	    /* fd to read commands from */
! 
! /* volatile because it is used in signal handler catch_sigint(). */
! EXTERN volatile sig_atomic_t got_int INIT(= FALSE); /* set to TRUE when interrupt
! 						signal occurred */
  #ifdef USE_TERM_CONSOLE
! EXTERN int	term_console INIT(= FALSE); /* set to TRUE when console used */
  #endif
! EXTERN int	termcap_active INIT(= FALSE);	/* set by starttermcap() */
! EXTERN int	cur_tmode INIT(= TMODE_COOK);	/* input terminal mode */
! EXTERN int	bangredo INIT(= FALSE);	    /* set to TRUE with ! command */
! EXTERN int	searchcmdlen;		    /* length of previous search cmd */
  #ifdef FEAT_SYN_HL
! EXTERN int	reg_do_extmatch INIT(= 0);  /* Used when compiling regexp:
! 					     * REX_SET to allow \z\(...\),
! 					     * REX_USE to allow \z\1 et al. */
! EXTERN reg_extmatch_T *re_extmatch_in INIT(= NULL); /* Used by vim_regexec():
! 					     * strings for \z\1...\z\9 */
! EXTERN reg_extmatch_T *re_extmatch_out INIT(= NULL); /* Set by vim_regexec()
! 					     * to store \z\(...\) matches */
  #endif
  
  EXTERN int	did_outofmem_msg INIT(= FALSE);
! 					    /* set after out of memory msg */
  EXTERN int	did_swapwrite_msg INIT(= FALSE);
! 					    /* set after swap write error msg */
! EXTERN int	undo_off INIT(= FALSE);	    /* undo switched off for now */
! EXTERN int	global_busy INIT(= 0);	    /* set when :global is executing */
! EXTERN int	listcmd_busy INIT(= FALSE); /* set when :argdo, :windo or
! 					       :bufdo is executing */
  EXTERN int	need_start_insertmode INIT(= FALSE);
! 					    /* start insert mode soon */
! EXTERN char_u	*last_cmdline INIT(= NULL); /* last command line (for ":) */
! EXTERN char_u	*repeat_cmdline INIT(= NULL); /* command line for "." */
  #ifdef FEAT_CMDHIST
! EXTERN char_u	*new_last_cmdline INIT(= NULL);	/* new value for last_cmdline */
  #endif
! EXTERN char_u	*autocmd_fname INIT(= NULL); /* fname for <afile> on cmdline */
! EXTERN int	autocmd_fname_full;	     /* autocmd_fname is full path */
! EXTERN int	autocmd_bufnr INIT(= 0);     /* fnum for <abuf> on cmdline */
! EXTERN char_u	*autocmd_match INIT(= NULL); /* name for <amatch> on cmdline */
! EXTERN int	did_cursorhold INIT(= FALSE); /* set when CursorHold t'gerd */
! EXTERN pos_T	last_cursormoved	      /* for CursorMoved event */
  # ifdef DO_INIT
  			= {0, 0, 0}
  # endif
  			;
  
! EXTERN int	postponed_split INIT(= 0);  /* for CTRL-W CTRL-] command */
! EXTERN int	postponed_split_flags INIT(= 0);  /* args for win_split() */
! EXTERN int	postponed_split_tab INIT(= 0);  /* cmdmod.tab */
  #ifdef FEAT_QUICKFIX
  EXTERN int	g_do_tagpreview INIT(= 0);  // for tag preview commands:
  					    // height of preview window
--- 946,1112 ----
   * "motion_force"   Last motion_force  from do_pending_operator()
   * "debug_mode"	    Debug mode.
   */
! EXTERN int	State INIT(= NORMAL);	// This is the current state of the
! 					// command interpreter.
  #ifdef FEAT_EVAL
  EXTERN int	debug_mode INIT(= FALSE);
  #endif
  
! EXTERN int	finish_op INIT(= FALSE);// TRUE while an operator is pending
! EXTERN long	opcount INIT(= 0);	// count for pending operator
  EXTERN int	motion_force INIT(= 0); // motion force for pending operator
  
  /*
   * Ex mode (Q) state
   */
! EXTERN int exmode_active INIT(= 0);	// zero, EXMODE_NORMAL or EXMODE_VIM
! EXTERN int ex_no_reprint INIT(= FALSE); // no need to print after z or p
  
! EXTERN int reg_recording INIT(= 0);	// register for recording  or zero
! EXTERN int reg_executing INIT(= 0);	// register being executed or zero
  
! EXTERN int no_mapping INIT(= FALSE);	// currently no mapping allowed
! EXTERN int no_zero_mapping INIT(= 0);	// mapping zero not allowed
! EXTERN int allow_keys INIT(= FALSE);	// allow key codes when no_mapping
! 					// is set
! EXTERN int no_u_sync INIT(= 0);		// Don't call u_sync()
  #ifdef FEAT_EVAL
! EXTERN int u_sync_once INIT(= 0);	// Call u_sync() once when evaluating
! 					// an expression.
  #endif
  
! EXTERN int restart_edit INIT(= 0);	// call edit when next cmd finished
! EXTERN int arrow_used;			// Normally FALSE, set to TRUE after
! 					// hitting cursor key in insert mode.
! 					// Used by vgetorpeek() to decide when
! 					// to call u_sync()
! EXTERN int	ins_at_eol INIT(= FALSE); // put cursor after eol when
! 					  // restarting edit after CTRL-O
  #ifdef FEAT_INS_EXPAND
! EXTERN char_u	*edit_submode INIT(= NULL); // msg for CTRL-X submode
! EXTERN char_u	*edit_submode_pre INIT(= NULL); // prepended to edit_submode
! EXTERN char_u	*edit_submode_extra INIT(= NULL);// appended to edit_submode
! EXTERN hlf_T	edit_submode_highl;	// highl. method for extra info
  #endif
  
! EXTERN int	no_abbr INIT(= TRUE);	// TRUE when no abbreviations loaded
  
  #ifdef USE_EXE_NAME
! EXTERN char_u	*exe_name;		// the name of the executable
  #endif
  
  #ifdef USE_ON_FLY_SCROLL
! EXTERN int	dont_scroll INIT(= FALSE);// don't use scrollbars when TRUE
  #endif
! EXTERN int	mapped_ctrl_c INIT(= FALSE); // modes where CTRL-C is mapped
! EXTERN int	ctrl_c_interrupts INIT(= TRUE);	// CTRL-C sets got_int
  
! EXTERN cmdmod_T	cmdmod;			// Ex command modifiers
  
! EXTERN int	msg_silent INIT(= 0);	// don't print messages
! EXTERN int	emsg_silent INIT(= 0);	// don't print error messages
! EXTERN int	emsg_noredir INIT(= 0);	// don't redirect error messages
! EXTERN int	cmd_silent INIT(= FALSE); // don't echo the command line
  
  EXTERN int	swap_exists_action INIT(= SEA_NONE);
! 					// For dialog when swap file already
! 					// exists.
  EXTERN int	swap_exists_did_quit INIT(= FALSE);
! 					// Selected "quit" at the dialog.
  
! EXTERN char_u	*IObuff;		// sprintf's are done in this buffer,
! 					// size is IOSIZE
! EXTERN char_u	*NameBuff;		// file names are expanded in this
! 					// buffer, size is MAXPATHL
! EXTERN char	msg_buf[MSG_BUF_LEN];	// small buffer for messages
  
! // When non-zero, postpone redrawing.
  EXTERN int	RedrawingDisabled INIT(= 0);
  
! EXTERN int	readonlymode INIT(= FALSE); // Set to TRUE for "view"
! EXTERN int	recoverymode INIT(= FALSE); // Set to TRUE for "-r" option
  
! EXTERN typebuf_T typebuf		// typeahead buffer
  #ifdef DO_INIT
  		    = {NULL, NULL, 0, 0, 0, 0, 0, 0, 0}
  #endif
  		    ;
! EXTERN int	ex_normal_busy INIT(= 0); // recursiveness of ex_normal()
! EXTERN int	ex_normal_lock INIT(= 0); // forbid use of ex_normal()
  #ifdef FEAT_EVAL
! EXTERN int	ignore_script INIT(= FALSE);  // ignore script input
  #endif
! EXTERN int	stop_insert_mode;	// for ":stopinsert" and 'insertmode'
  
! EXTERN int	KeyTyped;		// TRUE if user typed current char
! EXTERN int	KeyStuffed;		// TRUE if current char from stuffbuf
  #ifdef HAVE_INPUT_METHOD
! EXTERN int	vgetc_im_active;	// Input Method was active for last
! 					// character obtained from vgetc()
  #endif
! EXTERN int	maptick INIT(= 0);	// tick for each non-mapped char
  
! EXTERN int	must_redraw INIT(= 0);	    // type of redraw necessary
! EXTERN int	skip_redraw INIT(= FALSE);  // skip redraw once
! EXTERN int	do_redraw INIT(= FALSE);    // extra redraw once
  
  EXTERN int	need_highlight_changed INIT(= TRUE);
  
  #define NSCRIPT 15
! EXTERN FILE	*scriptin[NSCRIPT];	    // streams to read script from
! EXTERN int	curscript INIT(= 0);	    // index in scriptin[]
! EXTERN FILE	*scriptout  INIT(= NULL);   // stream to write script to
! EXTERN int	read_cmd_fd INIT(= 0);	    // fd to read commands from
! 
! // volatile because it is used in signal handler catch_sigint().
! EXTERN volatile sig_atomic_t got_int INIT(= FALSE); // set to TRUE when interrupt
! 						// signal occurred
  #ifdef USE_TERM_CONSOLE
! EXTERN int	term_console INIT(= FALSE); // set to TRUE when console used
  #endif
! EXTERN int	termcap_active INIT(= FALSE);	// set by starttermcap()
! EXTERN int	cur_tmode INIT(= TMODE_COOK);	// input terminal mode
! EXTERN int	bangredo INIT(= FALSE);	    // set to TRUE with ! command
! EXTERN int	searchcmdlen;		    // length of previous search cmd
  #ifdef FEAT_SYN_HL
! EXTERN int	reg_do_extmatch INIT(= 0);  // Used when compiling regexp:
! 					    // REX_SET to allow \z\(...\),
! 					    // REX_USE to allow \z\1 et al.
! EXTERN reg_extmatch_T *re_extmatch_in INIT(= NULL); // Used by vim_regexec():
! 					    // strings for \z\1...\z\9
! EXTERN reg_extmatch_T *re_extmatch_out INIT(= NULL); // Set by vim_regexec()
! 					    // to store \z\(...\) matches
  #endif
  
  EXTERN int	did_outofmem_msg INIT(= FALSE);
! 					    // set after out of memory msg
  EXTERN int	did_swapwrite_msg INIT(= FALSE);
! 					    // set after swap write error msg
! EXTERN int	undo_off INIT(= FALSE);	    // undo switched off for now
! EXTERN int	global_busy INIT(= 0);	    // set when :global is executing
! EXTERN int	listcmd_busy INIT(= FALSE); // set when :argdo, :windo or
! 					    // :bufdo is executing
  EXTERN int	need_start_insertmode INIT(= FALSE);
! 					    // start insert mode soon
! EXTERN char_u	*last_cmdline INIT(= NULL); // last command line (for ":)
! EXTERN char_u	*repeat_cmdline INIT(= NULL); // command line for "."
  #ifdef FEAT_CMDHIST
! EXTERN char_u	*new_last_cmdline INIT(= NULL);	// new value for last_cmdline
  #endif
! EXTERN char_u	*autocmd_fname INIT(= NULL); // fname for <afile> on cmdline
! EXTERN int	autocmd_fname_full;	     // autocmd_fname is full path
! EXTERN int	autocmd_bufnr INIT(= 0);     // fnum for <abuf> on cmdline
! EXTERN char_u	*autocmd_match INIT(= NULL); // name for <amatch> on cmdline
! EXTERN int	did_cursorhold INIT(= FALSE); // set when CursorHold t'gerd
! EXTERN pos_T	last_cursormoved	      // for CursorMoved event
  # ifdef DO_INIT
  			= {0, 0, 0}
  # endif
  			;
  
! EXTERN int	postponed_split INIT(= 0);  // for CTRL-W CTRL-] command
! EXTERN int	postponed_split_flags INIT(= 0);  // args for win_split()
! EXTERN int	postponed_split_tab INIT(= 0);  // cmdmod.tab
  #ifdef FEAT_QUICKFIX
  EXTERN int	g_do_tagpreview INIT(= 0);  // for tag preview commands:
  					    // height of preview window
***************
*** 1114,1125 ****
  					    // from the command line (0) or was
  					    // invoked as a normal command (1)
  
! EXTERN int	replace_offset INIT(= 0);   /* offset for replace_push() */
  
  EXTERN char_u	*escape_chars INIT(= (char_u *)" \t\\\"|");
! 					    /* need backslash in cmd line */
  
! EXTERN int	keep_help_flag INIT(= FALSE); /* doing :ta from help file */
  
  /*
   * When a string option is NULL (which only happens in out-of-memory
--- 1115,1126 ----
  					    // from the command line (0) or was
  					    // invoked as a normal command (1)
  
! EXTERN int	replace_offset INIT(= 0);   // offset for replace_push()
  
  EXTERN char_u	*escape_chars INIT(= (char_u *)" \t\\\"|");
! 					    // need backslash in cmd line
  
! EXTERN int	keep_help_flag INIT(= FALSE); // doing :ta from help file
  
  /*
   * When a string option is NULL (which only happens in out-of-memory
***************
*** 1128,1163 ****
   */
  EXTERN char_u	*empty_option INIT(= (char_u *)"");
  
! EXTERN int  redir_off INIT(= FALSE);	/* no redirection for a moment */
! EXTERN FILE *redir_fd INIT(= NULL);	/* message redirection file */
  #ifdef FEAT_EVAL
! EXTERN int  redir_reg INIT(= 0);	/* message redirection register */
! EXTERN int  redir_vname INIT(= 0);	/* message redirection variable */
! EXTERN int  redir_execute INIT(= 0);	/* execute() redirection */
  #endif
  
  #ifdef FEAT_LANGMAP
! EXTERN char_u	langmap_mapchar[256];	/* mapping for language keys */
  #endif
  
  #ifdef FEAT_WILDMENU
! EXTERN int  save_p_ls INIT(= -1);	/* Save 'laststatus' setting */
! EXTERN int  save_p_wmh INIT(= -1);	/* Save 'winminheight' setting */
  EXTERN int  wild_menu_showing INIT(= 0);
! # define WM_SHOWN	1		/* wildmenu showing */
! # define WM_SCROLLED	2		/* wildmenu showing with scroll */
  #endif
  
  #ifdef MSWIN
! EXTERN char_u	toupper_tab[256];	/* table for toupper() */
! EXTERN char_u	tolower_tab[256];	/* table for tolower() */
  #endif
  
  #ifdef FEAT_LINEBREAK
! EXTERN char	breakat_flags[256];	/* which characters are in 'breakat' */
  #endif
  
! /* These are in version.c, call init_longVersion() before use. */
  extern char *Version;
  #if defined(HAVE_DATE_TIME) && defined(VMS) && defined(VAXC)
  extern char longVersion[];
--- 1129,1164 ----
   */
  EXTERN char_u	*empty_option INIT(= (char_u *)"");
  
! EXTERN int  redir_off INIT(= FALSE);	// no redirection for a moment
! EXTERN FILE *redir_fd INIT(= NULL);	// message redirection file
  #ifdef FEAT_EVAL
! EXTERN int  redir_reg INIT(= 0);	// message redirection register
! EXTERN int  redir_vname INIT(= 0);	// message redirection variable
! EXTERN int  redir_execute INIT(= 0);	// execute() redirection
  #endif
  
  #ifdef FEAT_LANGMAP
! EXTERN char_u	langmap_mapchar[256];	// mapping for language keys
  #endif
  
  #ifdef FEAT_WILDMENU
! EXTERN int  save_p_ls INIT(= -1);	// Save 'laststatus' setting
! EXTERN int  save_p_wmh INIT(= -1);	// Save 'winminheight' setting
  EXTERN int  wild_menu_showing INIT(= 0);
! # define WM_SHOWN	1		// wildmenu showing
! # define WM_SCROLLED	2		// wildmenu showing with scroll
  #endif
  
  #ifdef MSWIN
! EXTERN char_u	toupper_tab[256];	// table for toupper()
! EXTERN char_u	tolower_tab[256];	// table for tolower()
  #endif
  
  #ifdef FEAT_LINEBREAK
! EXTERN char	breakat_flags[256];	// which characters are in 'breakat'
  #endif
  
! // These are in version.c, call init_longVersion() before use.
  extern char *Version;
  #if defined(HAVE_DATE_TIME) && defined(VMS) && defined(VAXC)
  extern char longVersion[];
***************
*** 1182,1193 ****
  extern char_u *compiled_sys;
  #endif
  
! /* When a window has a local directory, the absolute path of the global
!  * current directory is stored here (in allocated memory).  If the current
!  * directory is not a local directory, globaldir is NULL. */
  EXTERN char_u	*globaldir INIT(= NULL);
  
! /* Characters from 'listchars' option */
  EXTERN int	lcs_eol INIT(= '$');
  EXTERN int	lcs_ext INIT(= NUL);
  EXTERN int	lcs_prec INIT(= NUL);
--- 1183,1194 ----
  extern char_u *compiled_sys;
  #endif
  
! // When a window has a local directory, the absolute path of the global
! // current directory is stored here (in allocated memory).  If the current
! // directory is not a local directory, globaldir is NULL.
  EXTERN char_u	*globaldir INIT(= NULL);
  
! // Characters from 'listchars' option
  EXTERN int	lcs_eol INIT(= '$');
  EXTERN int	lcs_ext INIT(= NUL);
  EXTERN int	lcs_prec INIT(= NUL);
***************
*** 1201,1207 ****
  EXTERN int	lcs_conceal INIT(= ' ');
  #endif
  
! /* Characters from 'fillchars' option */
  EXTERN int	fill_stl INIT(= ' ');
  EXTERN int	fill_stlnc INIT(= ' ');
  EXTERN int	fill_vert INIT(= ' ');
--- 1202,1208 ----
  EXTERN int	lcs_conceal INIT(= ' ');
  #endif
  
! // Characters from 'fillchars' option
  EXTERN int	fill_stl INIT(= ' ');
  EXTERN int	fill_stlnc INIT(= ' ');
  EXTERN int	fill_vert INIT(= ' ');
***************
*** 1212,1225 ****
  EXTERN int	disable_fold_update INIT(= 0);
  #endif
  
! /* Whether 'keymodel' contains "stopsel" and "startsel". */
  EXTERN int	km_stopsel INIT(= FALSE);
  EXTERN int	km_startsel INIT(= FALSE);
  
  #ifdef FEAT_CMDWIN
! EXTERN int	cedit_key INIT(= -1);	/* key value of 'cedit' option */
! EXTERN int	cmdwin_type INIT(= 0);	/* type of cmdline window or 0 */
! EXTERN int	cmdwin_result INIT(= 0); /* result of cmdline window or 0 */
  #endif
  
  EXTERN char_u no_lines_msg[]	INIT(= N_("--No lines in buffer--"));
--- 1213,1226 ----
  EXTERN int	disable_fold_update INIT(= 0);
  #endif
  
! // Whether 'keymodel' contains "stopsel" and "startsel".
  EXTERN int	km_stopsel INIT(= FALSE);
  EXTERN int	km_startsel INIT(= FALSE);
  
  #ifdef FEAT_CMDWIN
! EXTERN int	cedit_key INIT(= -1);	// key value of 'cedit' option
! EXTERN int	cmdwin_type INIT(= 0);	// type of cmdline window or 0
! EXTERN int	cmdwin_result INIT(= 0); // result of cmdline window or 0
  #endif
  
  EXTERN char_u no_lines_msg[]	INIT(= N_("--No lines in buffer--"));
***************
*** 1229,1249 ****
   * accumulated until it's finished.
   * Also used for ":spellrepall".
   */
! EXTERN long	sub_nsubs;	/* total number of substitutions */
! EXTERN linenr_T	sub_nlines;	/* total number of lines changed */
  
! /* table to store parsed 'wildmode' */
  EXTERN char_u	wim_flags[4];
  
  #if defined(FEAT_TITLE) && defined(FEAT_STL_OPT)
! /* whether titlestring and iconstring contains statusline syntax */
  # define STL_IN_ICON	1
  # define STL_IN_TITLE	2
  EXTERN int      stl_syntax INIT(= 0);
  #endif
  
  #ifdef FEAT_SEARCH_EXTRA
! /* don't use 'hlsearch' temporarily */
  EXTERN int	no_hlsearch INIT(= FALSE);
  #endif
  
--- 1230,1250 ----
   * accumulated until it's finished.
   * Also used for ":spellrepall".
   */
! EXTERN long	sub_nsubs;	// total number of substitutions
! EXTERN linenr_T	sub_nlines;	// total number of lines changed
  
! // table to store parsed 'wildmode'
  EXTERN char_u	wim_flags[4];
  
  #if defined(FEAT_TITLE) && defined(FEAT_STL_OPT)
! // whether titlestring and iconstring contains statusline syntax
  # define STL_IN_ICON	1
  # define STL_IN_TITLE	2
  EXTERN int      stl_syntax INIT(= 0);
  #endif
  
  #ifdef FEAT_SEARCH_EXTRA
! // don't use 'hlsearch' temporarily
  EXTERN int	no_hlsearch INIT(= FALSE);
  #endif
  
***************
*** 1257,1263 ****
  #endif
  
  #ifdef CURSOR_SHAPE
! /* the table is in misc2.c, because of initializations */
  extern cursorentry_T shape_table[SHAPE_IDX_COUNT];
  #endif
  
--- 1258,1264 ----
  #endif
  
  #ifdef CURSOR_SHAPE
! // the table is in misc2.c, because of initializations
  extern cursorentry_T shape_table[SHAPE_IDX_COUNT];
  #endif
  
***************
*** 1304,1310 ****
  # endif
  ;
  
! /* For prt_get_unit(). */
  # define PRT_UNIT_NONE	-1
  # define PRT_UNIT_PERC	0
  # define PRT_UNIT_INCH	1
--- 1305,1311 ----
  # endif
  ;
  
! // For prt_get_unit().
  # define PRT_UNIT_NONE	-1
  # define PRT_UNIT_PERC	0
  # define PRT_UNIT_INCH	1
***************
*** 1315,1321 ****
  
  #if (defined(FEAT_PRINTER) && defined(FEAT_STL_OPT)) \
  	    || defined(FEAT_GUI_TABLINE)
! /* Page number used for %N in 'pageheader' and 'guitablabel'. */
  EXTERN linenr_T printer_page_num;
  #endif
  
--- 1316,1322 ----
  
  #if (defined(FEAT_PRINTER) && defined(FEAT_STL_OPT)) \
  	    || defined(FEAT_GUI_TABLINE)
! // Page number used for %N in 'pageheader' and 'guitablabel'.
  EXTERN linenr_T printer_page_num;
  #endif
  
***************
*** 1335,1341 ****
  
  #ifdef FEAT_GUI_GTK
  EXTERN guint32	gtk_socket_id INIT(= 0);
! EXTERN int	echo_wid_arg INIT(= FALSE);	/* --echo-wid argument */
  #endif
  
  #ifdef FEAT_GUI_MSWIN
--- 1336,1342 ----
  
  #ifdef FEAT_GUI_GTK
  EXTERN guint32	gtk_socket_id INIT(= 0);
! EXTERN int	echo_wid_arg INIT(= FALSE);	// --echo-wid argument
  #endif
  
  #ifdef FEAT_GUI_MSWIN
***************
*** 1347,1358 ****
  #endif
  
  #if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)
! EXTERN int	typebuf_was_filled INIT(= FALSE); /* received text from client
! 						     or from feedkeys() */
  #endif
  
  #ifdef FEAT_CLIENTSERVER
! EXTERN char_u	*serverName INIT(= NULL);	/* name of the server */
  # ifdef FEAT_X11
  EXTERN Window	commWindow INIT(= None);
  EXTERN Window	clientWindow INIT(= None);
--- 1348,1359 ----
  #endif
  
  #if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)
! EXTERN int	typebuf_was_filled INIT(= FALSE); // received text from client
! 						  // or from feedkeys()
  #endif
  
  #ifdef FEAT_CLIENTSERVER
! EXTERN char_u	*serverName INIT(= NULL);	// name of the server
  # ifdef FEAT_X11
  EXTERN Window	commWindow INIT(= None);
  EXTERN Window	clientWindow INIT(= None);
***************
*** 1367,1404 ****
  #endif
  
  #if defined(UNIX) || defined(VMS)
! EXTERN int	term_is_xterm INIT(= FALSE);	/* xterm-like 'term' */
  #endif
  
  #ifdef BACKSLASH_IN_FILENAME
! EXTERN char	psepc INIT(= '\\');	/* normal path separator character */
! EXTERN char	psepcN INIT(= '/');	/* abnormal path separator character */
  /* normal path separator string */
  EXTERN char	pseps[2] INIT(= {'\\' COMMA 0});
  #endif
  
! /* Set to TRUE when an operator is being executed with virtual editing, MAYBE
!  * when no operator is being executed, FALSE otherwise. */
  EXTERN int	virtual_op INIT(= MAYBE);
  
  #ifdef FEAT_SYN_HL
! /* Display tick, incremented for each call to update_screen() */
  EXTERN disptick_T	display_tick INIT(= 0);
  #endif
  
  #ifdef FEAT_SPELL
! /* Line in which spell checking wasn't highlighted because it touched the
!  * cursor position in Insert mode. */
  EXTERN linenr_T		spell_redraw_lnum INIT(= 0);
  #endif
  
  #ifdef FEAT_CONCEAL
! /* Set when the cursor line needs to be redrawn. */
  EXTERN int		need_cursor_line_redraw INIT(= FALSE);
  #endif
  
  #ifdef USE_MCH_ERRMSG
! /* Grow array to collect error messages in until they can be displayed. */
  EXTERN garray_T error_ga
  # ifdef DO_INIT
  	= {0, 0, 0, 0, NULL}
--- 1368,1405 ----
  #endif
  
  #if defined(UNIX) || defined(VMS)
! EXTERN int	term_is_xterm INIT(= FALSE);	// xterm-like 'term'
  #endif
  
  #ifdef BACKSLASH_IN_FILENAME
! EXTERN char	psepc INIT(= '\\');	// normal path separator character
! EXTERN char	psepcN INIT(= '/');	// abnormal path separator character
  /* normal path separator string */
  EXTERN char	pseps[2] INIT(= {'\\' COMMA 0});
  #endif
  
! // Set to TRUE when an operator is being executed with virtual editing, MAYBE
! // when no operator is being executed, FALSE otherwise.
  EXTERN int	virtual_op INIT(= MAYBE);
  
  #ifdef FEAT_SYN_HL
! // Display tick, incremented for each call to update_screen()
  EXTERN disptick_T	display_tick INIT(= 0);
  #endif
  
  #ifdef FEAT_SPELL
! // Line in which spell checking wasn't highlighted because it touched the
! // cursor position in Insert mode.
  EXTERN linenr_T		spell_redraw_lnum INIT(= 0);
  #endif
  
  #ifdef FEAT_CONCEAL
! // Set when the cursor line needs to be redrawn.
  EXTERN int		need_cursor_line_redraw INIT(= FALSE);
  #endif
  
  #ifdef USE_MCH_ERRMSG
! // Grow array to collect error messages in until they can be displayed.
  EXTERN garray_T error_ga
  # ifdef DO_INIT
  	= {0, 0, 0, 0, NULL}
***************
*** 1407,1417 ****
  #endif
  
  #ifdef FEAT_NETBEANS_INTG
! EXTERN char *netbeansArg INIT(= NULL);	/* the -nb[:host:port:passwd] arg */
! EXTERN int netbeansFireChanges INIT(= 1); /* send buffer changes if != 0 */
! EXTERN int netbeansForcedQuit INIT(= 0);/* don't write modified files */
! EXTERN int netbeansReadFile INIT(= 1);	/* OK to read from disk if != 0 */
! EXTERN int netbeansSuppressNoLines INIT(= 0); /* skip "No lines in buffer" */
  #endif
  
  /*
--- 1408,1418 ----
  #endif
  
  #ifdef FEAT_NETBEANS_INTG
! EXTERN char *netbeansArg INIT(= NULL);	// the -nb[:host:port:passwd] arg
! EXTERN int netbeansFireChanges INIT(= 1); // send buffer changes if != 0
! EXTERN int netbeansForcedQuit INIT(= 0);// don't write modified files
! EXTERN int netbeansReadFile INIT(= 1);	// OK to read from disk if != 0
! EXTERN int netbeansSuppressNoLines INIT(= 0); // skip "No lines in buffer"
  #endif
  
  /*
***************
*** 1635,1648 ****
   * Comms. with the session manager (XSMP)
   */
  #ifdef USE_XSMP
! EXTERN int xsmp_icefd INIT(= -1);   /* The actual connection */
  #endif
  
! /* For undo we need to know the lowest time possible. */
  EXTERN time_T starttime;
  
  #ifdef STARTUPTIME
! EXTERN FILE *time_fd INIT(= NULL);  /* where to write startup timing */
  #endif
  
  /*
--- 1636,1649 ----
   * Comms. with the session manager (XSMP)
   */
  #ifdef USE_XSMP
! EXTERN int xsmp_icefd INIT(= -1);   // The actual connection
  #endif
  
! // For undo we need to know the lowest time possible.
  EXTERN time_T starttime;
  
  #ifdef STARTUPTIME
! EXTERN FILE *time_fd INIT(= NULL);  // where to write startup timing
  #endif
  
  /*
***************
*** 1654,1664 ****
  EXTERN char *vim_ignoredp;
  
  #ifdef FEAT_EVAL
! /* set by alloc_fail(): ID */
  EXTERN alloc_id_T  alloc_fail_id INIT(= aid_none);
! /* set by alloc_fail(), when zero alloc() returns NULL */
  EXTERN int  alloc_fail_countdown INIT(= -1);
! /* set by alloc_fail(), number of times alloc() returns NULL */
  EXTERN int  alloc_fail_repeat INIT(= 0);
  
  // flags set by test_override()
--- 1655,1665 ----
  EXTERN char *vim_ignoredp;
  
  #ifdef FEAT_EVAL
! // set by alloc_fail(): ID
  EXTERN alloc_id_T  alloc_fail_id INIT(= aid_none);
! // set by alloc_fail(), when zero alloc() returns NULL
  EXTERN int  alloc_fail_countdown INIT(= -1);
! // set by alloc_fail(), number of times alloc() returns NULL
  EXTERN int  alloc_fail_repeat INIT(= 0);
  
  // flags set by test_override()
***************
*** 1673,1679 ****
  
  #ifdef FEAT_TIMERS
  EXTERN int  did_add_timer INIT(= FALSE);
! EXTERN int  timer_busy INIT(= 0);   /* when timer is inside vgetc() then > 0 */
  #endif
  
  #ifdef FEAT_BEVAL_TERM
--- 1674,1680 ----
  
  #ifdef FEAT_TIMERS
  EXTERN int  did_add_timer INIT(= FALSE);
! EXTERN int  timer_busy INIT(= 0);   // when timer is inside vgetc() then > 0
  #endif
  
  #ifdef FEAT_BEVAL_TERM
***************
*** 1684,1693 ****
  #ifdef FEAT_EVAL
  EXTERN time_T time_for_testing INIT(= 0);
  
! /* Abort conversion to string after a recursion error. */
  EXTERN int  did_echo_string_emsg INIT(= FALSE);
  
! /* Used for checking if local variables or arguments used in a lambda. */
  EXTERN int *eval_lavars_used INIT(= NULL);
  #endif
  
--- 1685,1694 ----
  #ifdef FEAT_EVAL
  EXTERN time_T time_for_testing INIT(= 0);
  
! // Abort conversion to string after a recursion error.
  EXTERN int  did_echo_string_emsg INIT(= FALSE);
  
! // Used for checking if local variables or arguments used in a lambda.
  EXTERN int *eval_lavars_used INIT(= NULL);
  #endif
  
*** ../vim-8.1.1792/src/version.c	2019-08-02 21:35:29.880442605 +0200
--- src/version.c	2019-08-02 22:08:04.921426017 +0200
***************
*** 775,776 ****
--- 775,778 ----
  {   /* Add new patch number below this line */
+ /**/
+     1793,
  /**/

-- 
"How is your new girlfriend?"
"90-60-90 man!"
"What, pale purple?"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
