To: vim_dev@googlegroups.com
Subject: Patch 8.1.0763
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.1.0763
Problem:    Nobody is using the Sun Workshop support.
Solution:   Remove the Workshop support.
Files:	    runtime/doc/workshop.txt, runtime/doc/help.txt,
            runtime/doc/netbeans.txt, src/Makefile, src/auto/configure,
            src/beval.c, src/buffer.c, src/config.h.in, src/config.mk.in,
            src/configure.ac, src/evalfunc.c, src/ex_cmds.c, src/ex_cmds.h,
            src/ex_docmd.c, src/feature.h, src/fileio.c, src/globals.h,
            src/gui.c, src/gui_beval.c, src/gui_motif.c, src/gui_x11.c,
            src/integration.c, src/integration.h, src/main.c, src/misc2.c,
            src/nbdebug.c, src/netbeans.c, src/proto.h,
            src/proto/workshop.pro, src/ui.c, src/version.c, src/vim.h,
            src/workshop.c, src/workshop.h, src/wsdebug.c, src/wsdebug.h,
            src/ex_cmdidxs.h


*** ../vim-8.1.0762/runtime/doc/workshop.txt	2018-05-17 13:42:04.000000000 +0200
--- runtime/doc/workshop.txt	2019-01-17 14:47:16.643795105 +0100
***************
*** 1,4 ****
! *workshop.txt*  For Vim version 8.1.  Last change: 2013 Jul 06
  
  
  		  VIM REFERENCE MANUAL    by Gordon Prieur
--- 1,4 ----
! *workshop.txt*  For Vim version 8.1.  Last change: 2019 Jan 17
  
  
  		  VIM REFERENCE MANUAL    by Gordon Prieur
***************
*** 6,98 ****
  
  Sun Visual WorkShop Features			*workshop* *workshop-support*
  
! 1. Introduction						|workshop-intro|
! 2. Commands						|workshop-commands|
! 3. Compiling vim/gvim for WorkShop			|workshop-compiling|
! 4. Configuring gvim for a WorkShop release tree		|workshop-configure|
! 5. Obtaining the latest version of the XPM library	|workshop-xpm|
! 
! {Vi does not have any of these features}
! {only available when compiled with the |+sun_workshop| feature}
! 
! ==============================================================================
! 1. Introduction						*workshop-intro*
! 
! Sun Visual WorkShop has an "Editor of Choice" feature designed to let users
! debug using their favorite editors.  For the 6.0 release we have added support
! for gvim.  A workshop debug session will have a debugging window and an editor
! window (possibly others as well).  The user can do many debugging operations
! from the editor window, minimizing the need to switch from window to window.
! 
! The version of vim shipped with Sun Visual WorkShop 6 (also called Forte
! Developer 6) is vim 5.3.  The features in this release are much more reliable
! than the vim/gvim shipped with Visual WorkShop.  VWS users wishing to use vim
! as their editor should compile these sources and install them in their
! workshop release tree.
! 
! ==============================================================================
! 2. Commands						*workshop-commands*
! 
! 						*:ws* *:wsverb*
! :ws[verb] verb			Pass the verb to the verb executor
! 
! Pass the verb to a workshop function which gathers some arguments and
! sends the verb and data to workshop over an IPC connection.
! 
! ==============================================================================
! 3. Compiling vim/gvim for WorkShop			*workshop-compiling*
! 
! Compiling vim with FEAT_SUN_WORKSHOP turns on all compile time flags necessary
! for building a vim to work with Visual WorkShop.  The features required for VWS
! have been built and tested using the Sun compilers from the VWS release.  They
! have not been built or tested using Gnu compilers.  This does not mean the
! features won't build and run if compiled with gcc, just that nothing is
! guaranteed with gcc!
! 
! ==============================================================================
! 4. Configuring gvim for a WorkShop release tree		*workshop-configure*
! 
! There are several assumptions which must be met in order to compile a gvim for
! use with Sun Visual WorkShop 6.
! 
!     o You should use the compiler in VWS rather than gcc.  We have neither
!       built nor tested with gcc and cannot guarantee it will build properly.
! 
!     o You must supply your own XPM library.  See |workshop-xpm| below for
!       details on obtaining the latest version of XPM.
! 
!     o Edit the Makefile in the src directory and uncomment the lines for Sun
!       Visual WorkShop.  You can easily find these by searching for the string
!       FEAT_SUN_WORKSHOP
! 
!     o We also suggest you use Motif for your gui.  This will provide gvim with
!       the same look-and-feel as the rest of Sun Visual WorkShop.
! 
! The following configuration line can be used to configure vim to build for use
! with Sun Visual WorkShop:
! 
!     $ CC=cc configure --enable-workshop --enable-gui=motif \
! 	-prefix=<VWS-install-dir>/contrib/contrib6/<vim-version>
! 
! The VWS-install-dir should be the base directory where your Sun Visual WorkShop
! was installed.  By default this is /opt/SUNWspro.  It will normally require
! root permissions to install the vim release.  You will also need to change the
! symlink <VWS-install-dir>/bin/gvim to point to the vim in your newly installed
! directory.  The <vim-version> should be a unique version string.  I use "vim"
! concatenated with the equivalent of version.h's VIM_VERSION_SHORT.
! 
! ==============================================================================
! 5. Obtaining the latest version of the XPM library	*workshop-xpm*
! 
! The XPM library is required to show images within Vim with Motif or Athena.
! Without it the toolbar and signs will be disabled.
! 
! The XPM library is provided by Arnaud Le Hors of the French National Institute
! for Research in Computer Science and Control.  It can be downloaded from
! http://cgit.freedesktop.org/xorg/lib/libXpm.  The current release, as of this
! writing, is xpm-3.4k-solaris.tgz, which is a gzip'ed tar file.  If you create
! the directory /usr/local/xpm and untar the file there you can use the
! uncommented lines in the Makefile without changing them.  If you use another
! xpm directory you will need to change the XPM_DIR in src/Makefile.
  
!  vim:tw=78:ts=8:ft=help:norl:
--- 6,14 ----
  
  Sun Visual WorkShop Features			*workshop* *workshop-support*
  
! The support for WorkShop was removed in patch 8.1.0763 in January 2019.
! The product has not been available for a long time and has been replaced by
! |NetBeans|.
  
! 
!  vim:tw=78:ts=8:noet:ft=help:norl:
*** ../vim-8.1.0762/runtime/doc/help.txt	2018-05-17 13:41:40.000000000 +0200
--- runtime/doc/help.txt	2019-01-17 14:55:00.628054659 +0100
***************
*** 171,177 ****
  |if_ole.txt|	OLE automation interface for Win32
  |if_ruby.txt|	Ruby interface
  |debugger.txt|	Interface with a debugger
- |workshop.txt|	Sun Visual Workshop interface
  |netbeans.txt|	NetBeans External Editor interface
  |sign.txt|	debugging signs
  
--- 180,185 ----
*** ../vim-8.1.0762/runtime/doc/netbeans.txt	2018-05-17 13:41:41.000000000 +0200
--- runtime/doc/netbeans.txt	2019-01-17 14:53:47.956614503 +0100
***************
*** 1,10 ****
! *netbeans.txt*  For Vim version 8.1.  Last change: 2016 Jul 15
  
  
  		  VIM REFERENCE MANUAL    by Gordon Prieur et al.
  
  
! 					*netbeans* *netbeans-support*
  
  Vim NetBeans Protocol: a socket interface for Vim integration into an IDE.
  
--- 1,10 ----
! *netbeans.txt*  For Vim version 8.1.  Last change: 2019 Jan 17
  
  
  		  VIM REFERENCE MANUAL    by Gordon Prieur et al.
  
  
! 					*netbeans* *NetBeans* *netbeans-support*
  
  Vim NetBeans Protocol: a socket interface for Vim integration into an IDE.
  
***************
*** 123,130 ****
  by gvim when it is run with one of the following GUIs: GTK, GNOME, Windows,
  Athena and Motif.
  
! If Motif support is required the user must supply XPM libraries.  See
! |workshop-xpm| for details on obtaining the latest version of XPM.
  
  
  On MS-Windows:
--- 123,140 ----
  by gvim when it is run with one of the following GUIs: GTK, GNOME, Windows,
  Athena and Motif.
  
! 							*netbeans-xpm*
! If Motif support is required the user must supply XPM libraries.
! The XPM library is required to show images within Vim with Motif or Athena.
! Without it the toolbar and signs will be disabled.
! 
! The XPM library is provided by Arnaud Le Hors of the French National Institute
! for Research in Computer Science and Control.  It can be downloaded from
! http://cgit.freedesktop.org/xorg/lib/libXpm.  The current release, as of this
! writing, is xpm-3.4k-solaris.tgz, which is a gzip'ed tar file.  If you create
! the directory /usr/local/xpm and untar the file there you can use the
! uncommented lines in the Makefile without changing them.  If you use another
! xpm directory you will need to change the XPM_DIR in src/Makefile.
  
  
  On MS-Windows:
***************
*** 409,417 ****
  		Vim will define a sign for the annotation.
  		When color is a number, this is the "#rrggbb" Red, Green and
  		Blue values of the color (see |gui-colors|) and the
! 		highlighting is only defined for GVim.
  		When color is a name, this color is defined both for Vim
! 		running in a color terminal and for GVim.
  		When both "fg" and "bg" are "none" no line highlighting is
  		used (new in version 2.1).
  		When "glyphFile" is empty, no text sign is used (new in
--- 419,427 ----
  		Vim will define a sign for the annotation.
  		When color is a number, this is the "#rrggbb" Red, Green and
  		Blue values of the color (see |gui-colors|) and the
! 		highlighting is only defined for gVim.
  		When color is a name, this color is defined both for Vim
! 		running in a color terminal and for gVim.
  		When both "fg" and "bg" are "none" no line highlighting is
  		used (new in version 2.1).
  		When "glyphFile" is empty, no text sign is used (new in
*** ../vim-8.1.0762/src/Makefile	2019-01-12 22:47:01.256088105 +0100
--- src/Makefile	2019-01-17 15:04:39.151775617 +0100
***************
*** 317,323 ****
  # You can give a lot of options to configure.
  # Change this to your desire and do 'make config' afterwards
  
! # examples:
  #CONF_ARGS1 = --exec-prefix=/usr
  #CONF_ARGS2 = --with-vim-name=vim8 --with-ex-name=ex8 --with-view-name=view8
  #CONF_ARGS3 = --with-global-runtime=/etc/vim,/usr/share/vim
--- 317,323 ----
  # You can give a lot of options to configure.
  # Change this to your desire and do 'make config' afterwards
  
! # examples you can uncomment:
  #CONF_ARGS1 = --exec-prefix=/usr
  #CONF_ARGS2 = --with-vim-name=vim8 --with-ex-name=ex8 --with-view-name=view8
  #CONF_ARGS3 = --with-global-runtime=/etc/vim,/usr/share/vim
***************
*** 472,482 ****
  # Uncomment this when you want to include the Cscope interface.
  #CONF_OPT_CSCOPE = --enable-cscope
  
- # WORKSHOP - Sun Visual Workshop interface.  Only works with Motif!
- #CONF_OPT_WORKSHOP = --enable-workshop
- 
  # NETBEANS - NetBeans interface. Only works with Motif, GTK, and gnome.
! # Motif version must have XPM libraries (see |workshop-xpm|).
  # Uncomment this when you do not want the netbeans interface.
  #CONF_OPT_NETBEANS = --disable-netbeans
  
--- 472,479 ----
  # Uncomment this when you want to include the Cscope interface.
  #CONF_OPT_CSCOPE = --enable-cscope
  
  # NETBEANS - NetBeans interface. Only works with Motif, GTK, and gnome.
! # Motif version must have XPM libraries (see |netbeans-xpm|).
  # Uncomment this when you do not want the netbeans interface.
  #CONF_OPT_NETBEANS = --disable-netbeans
  
***************
*** 781,787 ****
  #CC	    = /usr/ucb/cc
  #EXTRA_LIBS = -R/usr/ucblib
  
! ### Solaris with Forte Developer and FEAT_SUN_WORKSHOP
  # The Xpm library is available from http://koala.ilog.fr/ftp/pub/xpm.
  #CC		= cc
  #XPM_DIR		= /usr/local/xpm/xpm-3.4k-solaris
--- 780,786 ----
  #CC	    = /usr/ucb/cc
  #EXTRA_LIBS = -R/usr/ucblib
  
! ### Solaris with Forte Developer and NetBeans.
  # The Xpm library is available from http://koala.ilog.fr/ftp/pub/xpm.
  #CC		= cc
  #XPM_DIR		= /usr/local/xpm/xpm-3.4k-solaris
***************
*** 791,800 ****
  #EXTRA_IPATHS	= $(XPM_IPATH)
  #EXTRA_DEFS	= -xCC -DHAVE_X11_XPM_H
  
- ### Solaris with workshop compilers: Vim is unstable when compiled with
- # "-fast".  Use this instead. (Shea Martin)
- #CFLAGS = -x02 -xtarget=ultra
- 
  ### (R) for Solaris 2.5 (or 2.5.1) with gcc > 2.5.6 you might need this:
  #LDFLAGS = -lw -ldl -lXmu
  #GUI_LIB_LOC = -L/usr/local/lib
--- 790,795 ----
***************
*** 1651,1664 ****
  	$(PERL_SRC) \
  	$(PYTHON_SRC) $(PYTHON3_SRC) \
  	$(TCL_SRC) \
! 	$(RUBY_SRC) \
! 	$(WORKSHOP_SRC) \
! 	$(WSDEBUG_SRC)
  
  EXTRA_SRC = hangulin.c if_lua.c if_mzsch.c auto/if_perl.c if_perlsfio.c \
  	    if_python.c if_python3.c if_tcl.c if_ruby.c \
! 	    gui_beval.c workshop.c wsdebug.c integration.c \
! 	    netbeans.c channel.c \
  	    $(GRESOURCE_SRC)
  
  # Unittest files
--- 1646,1656 ----
  	$(PERL_SRC) \
  	$(PYTHON_SRC) $(PYTHON3_SRC) \
  	$(TCL_SRC) \
! 	$(RUBY_SRC)
  
  EXTRA_SRC = hangulin.c if_lua.c if_mzsch.c auto/if_perl.c if_perlsfio.c \
  	    if_python.c if_python3.c if_tcl.c if_ruby.c \
! 	    gui_beval.c netbeans.c channel.c \
  	    $(GRESOURCE_SRC)
  
  # Unittest files
***************
*** 1684,1690 ****
  # The perl sources also don't work well with lint.
  LINT_SRC = $(BASIC_SRC) $(GUI_SRC) $(HANGULIN_SRC) \
  	   $(PYTHON_SRC) $(PYTHON3_SRC) $(TCL_SRC) \
- 	   $(WORKSHOP_SRC) $(WSDEBUG_SRC) \
  	   $(NETBEANS_SRC) $(CHANNEL_SRC) $(TERM_SRC)
  #LINT_SRC = $(SRC)
  #LINT_SRC = $(ALL_SRC)
--- 1676,1681 ----
***************
*** 1761,1771 ****
  	$(TCL_OBJ) \
  	$(RUBY_OBJ) \
  	$(OS_EXTRA_OBJ) \
- 	$(WORKSHOP_OBJ) \
  	$(NETBEANS_OBJ) \
  	$(CHANNEL_OBJ) \
! 	$(XDIFF_OBJS) \
! 	$(WSDEBUG_OBJ)
  
  # The files included by tests are not in OBJ_COMMON.
  OBJ_MAIN = \
--- 1752,1760 ----
  	$(TCL_OBJ) \
  	$(RUBY_OBJ) \
  	$(OS_EXTRA_OBJ) \
  	$(NETBEANS_OBJ) \
  	$(CHANNEL_OBJ) \
! 	$(XDIFF_OBJS)
  
  # The files included by tests are not in OBJ_COMMON.
  OBJ_MAIN = \
***************
*** 1889,1895 ****
  	window.pro \
  	beval.pro \
  	gui_beval.pro \
- 	workshop.pro \
  	netbeans.pro \
  	channel.pro \
  	$(ALL_GUI_PRO) \
--- 1878,1883 ----
***************
*** 1932,1938 ****
  		$(CONF_OPT_PERL) $(CONF_OPT_PYTHON) $(CONF_OPT_PYTHON3) \
  		$(CONF_OPT_TCL) $(CONF_OPT_RUBY) $(CONF_OPT_NLS) \
  		$(CONF_OPT_CSCOPE) $(CONF_OPT_MULTIBYTE) $(CONF_OPT_INPUT) \
! 		$(CONF_OPT_OUTPUT) $(CONF_OPT_GPM) $(CONF_OPT_WORKSHOP) \
  		$(CONF_OPT_FEAT) $(CONF_TERM_LIB) \
  		$(CONF_OPT_COMPBY) $(CONF_OPT_ACL) $(CONF_OPT_NETBEANS) \
  		$(CONF_OPT_CHANNEL) $(CONF_OPT_TERMINAL) \
--- 1920,1926 ----
  		$(CONF_OPT_PERL) $(CONF_OPT_PYTHON) $(CONF_OPT_PYTHON3) \
  		$(CONF_OPT_TCL) $(CONF_OPT_RUBY) $(CONF_OPT_NLS) \
  		$(CONF_OPT_CSCOPE) $(CONF_OPT_MULTIBYTE) $(CONF_OPT_INPUT) \
! 		$(CONF_OPT_OUTPUT) $(CONF_OPT_GPM) \
  		$(CONF_OPT_FEAT) $(CONF_TERM_LIB) \
  		$(CONF_OPT_COMPBY) $(CONF_OPT_ACL) $(CONF_OPT_NETBEANS) \
  		$(CONF_OPT_CHANNEL) $(CONF_OPT_TERMINAL) \
***************
*** 3098,3106 ****
  objects/if_tcl.o: if_tcl.c
  	$(CCC_NF) $(TCL_CFLAGS) $(ALL_CFLAGS) -o $@ if_tcl.c
  
- objects/integration.o: integration.c
- 	$(CCC) -o $@ integration.c
- 
  objects/json.o: json.c
  	$(CCC) -o $@ json.c
  
--- 3086,3091 ----
***************
*** 3239,3250 ****
  objects/window.o: window.c
  	$(CCC) -o $@ window.c
  
- objects/workshop.o: workshop.c
- 	$(CCC) -o $@ workshop.c
- 
- objects/wsdebug.o: wsdebug.c
- 	$(CCC) -o $@ wsdebug.c
- 
  objects/netbeans.o: netbeans.c
  	$(CCC) -o $@ netbeans.c
  
--- 3224,3229 ----
***************
*** 3784,3799 ****
   os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h
- objects/workshop.o: workshop.c protodef.h auto/config.h integration.h vim.h \
-  feature.h os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h \
-  option.h beval.h proto/gui_beval.pro structs.h regexp.h gui.h alloc.h \
-  ex_cmds.h spell.h proto.h globals.h farsi.h arabic.h version.h \
-  workshop.h
- objects/wsdebug.o: wsdebug.c
- objects/integration.o: integration.c vim.h protodef.h auto/config.h feature.h \
-  os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
-  proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
-  proto.h globals.h farsi.h arabic.h integration.h
  objects/netbeans.o: netbeans.c vim.h protodef.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h beval.h \
   proto/gui_beval.pro structs.h regexp.h gui.h alloc.h ex_cmds.h spell.h \
--- 3763,3768 ----
*** ../vim-8.1.0762/src/auto/configure	2019-01-12 16:10:47.415360504 +0100
--- src/auto/configure	2019-01-17 14:58:28.142489864 +0100
***************
*** 661,668 ****
  CHANNEL_SRC
  NETBEANS_OBJ
  NETBEANS_SRC
- WORKSHOP_OBJ
- WORKSHOP_SRC
  RUBY_LIBS
  RUBY_CFLAGS
  RUBY_PRO
--- 661,666 ----
***************
*** 812,818 ****
  enable_rubyinterp
  with_ruby_command
  enable_cscope
- enable_workshop
  enable_netbeans
  enable_channel
  enable_terminal
--- 810,815 ----
***************
*** 1494,1500 ****
    --enable-tclinterp=OPTS      Include Tcl interpreter. default=no OPTS=no/yes/dynamic
    --enable-rubyinterp=OPTS     Include Ruby interpreter.  default=no OPTS=no/yes/dynamic
    --enable-cscope         Include cscope interface.
-   --enable-workshop       Include Sun Visual Workshop support.
    --disable-netbeans      Disable NetBeans integration support.
    --disable-channel       Disable process communication support.
    --enable-terminal       Enable terminal emulation support.
--- 1491,1496 ----
***************
*** 7665,7693 ****
  
  fi
  
- { $as_echo "$as_me:${as_lineno-$LINENO}: checking --enable-workshop argument" >&5
- $as_echo_n "checking --enable-workshop argument... " >&6; }
- # Check whether --enable-workshop was given.
- if test "${enable_workshop+set}" = set; then :
-   enableval=$enable_workshop;
- else
-   enable_workshop="no"
- fi
- 
- { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_workshop" >&5
- $as_echo "$enable_workshop" >&6; }
- if test "$enable_workshop" = "yes"; then
-   $as_echo "#define FEAT_SUN_WORKSHOP 1" >>confdefs.h
- 
-   WORKSHOP_SRC="workshop.c integration.c"
- 
-   WORKSHOP_OBJ="objects/workshop.o objects/integration.o"
- 
-   if test "${enable_gui-xxx}" = xxx; then
-     enable_gui=motif
-   fi
- fi
- 
  { $as_echo "$as_me:${as_lineno-$LINENO}: checking --disable-netbeans argument" >&5
  $as_echo_n "checking --disable-netbeans argument... " >&6; }
  # Check whether --enable-netbeans was given.
--- 7661,7666 ----
*** ../vim-8.1.0762/src/beval.c	2018-10-02 14:15:08.991376909 +0200
--- src/beval.c	2019-01-17 15:16:25.906741669 +0100
***************
*** 273,282 ****
      if (bevalServers & BEVAL_NETBEANS)
  	netbeans_beval_cb(beval, state);
  #endif
- #ifdef FEAT_SUN_WORKSHOP
-     if (bevalServers & BEVAL_WORKSHOP)
- 	workshop_beval_cb(beval, state);
- #endif
  
      recursive = FALSE;
  }
--- 273,278 ----
*** ../vim-8.1.0762/src/buffer.c	2019-01-15 20:19:36.739904461 +0100
--- src/buffer.c	2019-01-17 15:19:25.237997004 +0100
***************
*** 658,668 ****
       */
      if (wipe_buf)
      {
- #ifdef FEAT_SUN_WORKSHOP
- 	if (usingSunWorkShop)
- 	    workshop_file_closed_lineno((char *)buf->b_ffname,
- 			(int)buf->b_last_cursor.lnum);
- #endif
  	if (buf->b_sfname != buf->b_ffname)
  	    VIM_CLEAR(buf->b_sfname);
  	else
--- 658,663 ----
*** ../vim-8.1.0762/src/config.h.in	2018-12-21 11:48:48.320680492 +0100
--- src/config.h.in	2019-01-17 14:58:51.046319671 +0100
***************
*** 441,449 ****
  /* Define if we have shl_load() */
  #undef HAVE_SHL_LOAD
  
- /* Define if you want to include Sun Visual Workshop support. */
- #undef FEAT_SUN_WORKSHOP
- 
  /* Define if you want to include NetBeans integration. */
  #undef FEAT_NETBEANS_INTG
  
--- 441,446 ----
*** ../vim-8.1.0762/src/config.mk.in	2018-04-11 22:14:38.000000000 +0200
--- src/config.mk.in	2019-01-17 14:59:00.314250926 +0100
***************
*** 81,89 ****
  HANGULIN_SRC	= @HANGULIN_SRC@
  HANGULIN_OBJ	= @HANGULIN_OBJ@
  
- WORKSHOP_SRC	= @WORKSHOP_SRC@
- WORKSHOP_OBJ	= @WORKSHOP_OBJ@
- 
  NETBEANS_SRC	= @NETBEANS_SRC@
  NETBEANS_OBJ	= @NETBEANS_OBJ@
  CHANNEL_SRC	= @CHANNEL_SRC@
--- 81,86 ----
*** ../vim-8.1.0762/src/configure.ac	2019-01-12 16:10:47.411360533 +0100
--- src/configure.ac	2019-01-17 14:58:24.194519245 +0100
***************
*** 1996,2017 ****
    AC_DEFINE(FEAT_CSCOPE)
  fi
  
- AC_MSG_CHECKING(--enable-workshop argument)
- AC_ARG_ENABLE(workshop,
- 	[  --enable-workshop       Include Sun Visual Workshop support.], ,
- 	[enable_workshop="no"])
- AC_MSG_RESULT($enable_workshop)
- if test "$enable_workshop" = "yes"; then
-   AC_DEFINE(FEAT_SUN_WORKSHOP)
-   WORKSHOP_SRC="workshop.c integration.c"
-   AC_SUBST(WORKSHOP_SRC)
-   WORKSHOP_OBJ="objects/workshop.o objects/integration.o"
-   AC_SUBST(WORKSHOP_OBJ)
-   if test "${enable_gui-xxx}" = xxx; then
-     enable_gui=motif
-   fi
- fi
- 
  AC_MSG_CHECKING(--disable-netbeans argument)
  AC_ARG_ENABLE(netbeans,
  	[  --disable-netbeans      Disable NetBeans integration support.],
--- 1996,2001 ----
*** ../vim-8.1.0762/src/evalfunc.c	2019-01-15 22:16:37.414340200 +0100
--- src/evalfunc.c	2019-01-17 14:50:04.854386619 +0100
***************
*** 6512,6520 ****
  #ifdef FEAT_STL_OPT
  	"statusline",
  #endif
- #ifdef FEAT_SUN_WORKSHOP
- 	"sun_workshop",
- #endif
  #ifdef FEAT_NETBEANS_INTG
  	"netbeans_intg",
  #endif
--- 6512,6517 ----
*** ../vim-8.1.0762/src/ex_cmds.c	2019-01-13 23:38:33.387773334 +0100
--- src/ex_cmds.c	2019-01-17 15:20:04.497831990 +0100
***************
*** 3805,3813 ****
      int		newcol = -1;
      int		solcol = -1;
      pos_T	*pos;
- #ifdef FEAT_SUN_WORKSHOP
-     char_u	*cp;
- #endif
      char_u	*command = NULL;
  #ifdef FEAT_SPELL
      int		did_get_winopts = FALSE;
--- 3805,3810 ----
***************
*** 3881,3891 ****
  	    if (free_fname != NULL)
  		ffname = free_fname;
  	    other_file = otherfile(ffname);
- #ifdef FEAT_SUN_WORKSHOP
- 	    if (usingSunWorkShop && p_acd
- 				   && (cp = vim_strrchr(sfname, '/')) != NULL)
- 		sfname = ++cp;
- #endif
  	}
      }
  
--- 3878,3883 ----
***************
*** 4457,4469 ****
      }
  #endif
  
! #if defined(FEAT_SUN_WORKSHOP) || defined(FEAT_NETBEANS_INTG)
      if (curbuf->b_ffname != NULL)
      {
- # ifdef FEAT_SUN_WORKSHOP
- 	if (gui.in_use && usingSunWorkShop)
- 	    workshop_file_opened((char *)curbuf->b_ffname, curbuf->b_p_ro);
- # endif
  # ifdef FEAT_NETBEANS_INTG
  	if ((flags & ECMD_SET_HELP) != ECMD_SET_HELP)
  	    netbeans_file_opened(curbuf);
--- 4449,4457 ----
      }
  #endif
  
! #if defined(FEAT_NETBEANS_INTG)
      if (curbuf->b_ffname != NULL)
      {
  # ifdef FEAT_NETBEANS_INTG
  	if ((flags & ECMD_SET_HELP) != ECMD_SET_HELP)
  	    netbeans_file_opened(curbuf);
*** ../vim-8.1.0762/src/ex_cmds.h	2019-01-13 23:38:33.387773334 +0100
--- src/ex_cmds.h	2019-01-17 14:56:18.839459572 +0100
***************
*** 1670,1678 ****
  EX(CMD_wqall,		"wqall",	do_wqall,
  			BANG|FILE1|ARGOPT|DFLALL|TRLBAR,
  			ADDR_LINES),
- EX(CMD_wsverb,		"wsverb",	ex_wsverb,
- 			EXTRA|NOTADR|NEEDARG,
- 			ADDR_LINES),
  EX(CMD_wundo,		"wundo",	ex_wundo,
  			BANG|NEEDARG|FILE1,
  			ADDR_LINES),
--- 1670,1675 ----
*** ../vim-8.1.0762/src/ex_docmd.c	2019-01-15 20:19:36.743904434 +0100
--- src/ex_docmd.c	2019-01-17 15:20:26.561736397 +0100
***************
*** 411,419 ****
  #ifndef FEAT_SIGNS
  # define ex_sign		ex_ni
  #endif
- #ifndef FEAT_SUN_WORKSHOP
- # define ex_wsverb		ex_ni
- #endif
  #ifndef FEAT_NETBEANS_INTG
  # define ex_nbclose		ex_ni
  # define ex_nbkey		ex_ni
--- 411,416 ----
*** ../vim-8.1.0762/src/feature.h	2019-01-12 16:10:47.415360504 +0100
--- src/feature.h	2019-01-17 15:11:32.124821752 +0100
***************
*** 1232,1238 ****
   * +perl		Perl interface: "--enable-perlinterp"
   * +python		Python interface: "--enable-pythoninterp"
   * +tcl			TCL interface: "--enable-tclinterp"
-  * +sun_workshop	Sun Workshop integration
   * +netbeans_intg	Netbeans integration
   * +channel		Inter process communication
   */
--- 1232,1237 ----
***************
*** 1244,1256 ****
   */
  
  /*
-  * The Sun Workshop features currently only work with Motif.
-  */
- #if !defined(FEAT_GUI_MOTIF) && defined(FEAT_SUN_WORKSHOP)
- # undef FEAT_SUN_WORKSHOP
- #endif
- 
- /*
   * The Netbeans feature requires +eval.
   */
  #if !defined(FEAT_EVAL) && defined(FEAT_NETBEANS_INTG)
--- 1243,1248 ----
***************
*** 1279,1286 ****
   * +signs		Allow signs to be displayed to the left of text lines.
   *			Adds the ":sign" command.
   */
! #if defined(FEAT_BIG) || defined(FEAT_SUN_WORKSHOP) \
! 	    || defined(FEAT_NETBEANS_INTG)
  # define FEAT_SIGNS
  # if ((defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)) \
  		&& defined(HAVE_X11_XPM_H)) \
--- 1271,1277 ----
   * +signs		Allow signs to be displayed to the left of text lines.
   *			Adds the ":sign" command.
   */
! #if defined(FEAT_BIG) || defined(FEAT_NETBEANS_INTG)
  # define FEAT_SIGNS
  # if ((defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_ATHENA)) \
  		&& defined(HAVE_X11_XPM_H)) \
***************
*** 1299,1305 ****
  	|| defined(FEAT_GUI_GTK) || defined(FEAT_GUI_W32)) \
  	&& (   ((defined(FEAT_TOOLBAR) || defined(FEAT_GUI_TABLINE)) \
  		&& !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_W32)) \
- 	    || defined(FEAT_SUN_WORKSHOP) \
  	    || defined(FEAT_NETBEANS_INTG) || defined(FEAT_EVAL))
  # define FEAT_BEVAL_GUI
  # if !defined(FEAT_XFONTSET) && !defined(FEAT_GUI_GTK) \
--- 1290,1295 ----
***************
*** 1329,1365 ****
  # define FEAT_GUI_X11
  #endif
  
! #if defined(FEAT_SUN_WORKSHOP) || defined(FEAT_NETBEANS_INTG)
! /*
!  * The following features are (currently) only used by Sun Visual WorkShop 6
!  * and NetBeans. These features could be used with other integrations with
!  * debuggers so I've used separate feature defines.
!  */
  # if !defined(FEAT_MENU)
  #  define FEAT_MENU
  # endif
  #endif
  
! #if defined(FEAT_SUN_WORKSHOP)
! /*
!  *			Use an alternative method of X input for a secondary
!  *			command input.
!  */
! # define ALT_X_INPUT
! 
  /*
   * +footer		Motif only: Add a message area at the bottom of the
   *			main window area.
   */
  # define FEAT_FOOTER
- 
  #endif
  
  /*
   * +autochdir		'autochdir' option.
   */
! #if defined(FEAT_SUN_WORKSHOP) || defined(FEAT_NETBEANS_INTG) \
! 	    || defined(FEAT_BIG)
  # define FEAT_AUTOCHDIR
  #endif
  
--- 1319,1343 ----
  # define FEAT_GUI_X11
  #endif
  
! #if defined(FEAT_NETBEANS_INTG)
! // NetBeans uses menus.
  # if !defined(FEAT_MENU)
  #  define FEAT_MENU
  # endif
  #endif
  
! #if 0
  /*
   * +footer		Motif only: Add a message area at the bottom of the
   *			main window area.
   */
  # define FEAT_FOOTER
  #endif
  
  /*
   * +autochdir		'autochdir' option.
   */
! #if defined(FEAT_NETBEANS_INTG) || defined(FEAT_BIG)
  # define FEAT_AUTOCHDIR
  #endif
  
*** ../vim-8.1.0762/src/fileio.c	2019-01-13 23:38:33.391773303 +0100
--- src/fileio.c	2019-01-17 15:20:35.345697789 +0100
***************
*** 5094,5104 ****
      if (!p_bk && backup != NULL && mch_remove(backup) != 0)
  	emsg(_("E207: Can't delete backup file"));
  
- #ifdef FEAT_SUN_WORKSHOP
-     if (usingSunWorkShop)
- 	workshop_file_saved((char *) ffname);
- #endif
- 
      goto nofail;
  
      /*
--- 5094,5099 ----
*** ../vim-8.1.0762/src/globals.h	2019-01-16 22:41:50.091917818 +0100
--- src/globals.h	2019-01-17 15:26:00.420093561 +0100
***************
*** 1218,1227 ****
  #if defined(FEAT_BEVAL) && !defined(NO_X11_INCLUDES)
  EXTERN BalloonEval	*balloonEval INIT(= NULL);
  EXTERN int		balloonEvalForTerm INIT(= FALSE);
! # if defined(FEAT_NETBEANS_INTG) || defined(FEAT_SUN_WORKSHOP)
  EXTERN int bevalServers INIT(= 0);
  #  define BEVAL_NETBEANS		0x01
- #  define BEVAL_WORKSHOP		0x02
  # endif
  #endif
  
--- 1218,1226 ----
  #if defined(FEAT_BEVAL) && !defined(NO_X11_INCLUDES)
  EXTERN BalloonEval	*balloonEval INIT(= NULL);
  EXTERN int		balloonEvalForTerm INIT(= FALSE);
! # if defined(FEAT_NETBEANS_INTG)
  EXTERN int bevalServers INIT(= 0);
  #  define BEVAL_NETBEANS		0x01
  # endif
  #endif
  
***************
*** 1363,1376 ****
  EXTERN int		need_cursor_line_redraw INIT(= FALSE);
  #endif
  
- #ifdef ALT_X_INPUT
- /* we need to be able to go into the dispatch loop while processing a command
-  * received via alternate input. However, we don't want to process another
-  * command until the first is completed.
-  */
- EXTERN int	suppress_alternate_input INIT(= FALSE);
- #endif
- 
  #ifdef USE_MCH_ERRMSG
  /* Grow array to collect error messages in until they can be displayed. */
  EXTERN garray_T error_ga
--- 1362,1367 ----
*** ../vim-8.1.0762/src/gui.c	2019-01-13 23:38:33.391773303 +0100
--- src/gui.c	2019-01-17 15:21:11.121537479 +0100
***************
*** 672,681 ****
  #ifdef FEAT_MENU
      gui_create_initial_menus(root_menu);
  #endif
- #ifdef FEAT_SUN_WORKSHOP
-     if (usingSunWorkShop)
- 	workshop_init();
- #endif
  #ifdef FEAT_SIGN_ICONS
      sign_gui_started();
  #endif
--- 672,677 ----
***************
*** 1604,1622 ****
  	/* Remember the original window position. */
  	(void)gui_mch_get_winpos(&x, &y);
  
! #ifdef USE_SUN_WORKSHOP
!     if (!mustset && usingSunWorkShop
! 				&& workshop_get_width_height(&width, &height))
!     {
! 	Columns = (width - base_width + gui.char_width - 1) / gui.char_width;
! 	Rows = (height - base_height + gui.char_height - 1) / gui.char_height;
!     }
!     else
! #endif
!     {
! 	width = Columns * gui.char_width + base_width;
! 	height = Rows * gui.char_height + base_height;
!     }
  
      if (fit_to_display)
      {
--- 1600,1607 ----
  	/* Remember the original window position. */
  	(void)gui_mch_get_winpos(&x, &y);
  
!     width = Columns * gui.char_width + base_width;
!     height = Rows * gui.char_height + base_height;
  
      if (fit_to_display)
      {
***************
*** 5128,5134 ****
  }
  #endif
  
! #if defined(FIND_REPLACE_DIALOG) || defined(FEAT_SUN_WORKSHOP) \
  	|| defined(NEED_GUI_UPDATE_SCREEN) \
  	|| defined(PROTO)
  /*
--- 5113,5119 ----
  }
  #endif
  
! #if defined(FIND_REPLACE_DIALOG) \
  	|| defined(NEED_GUI_UPDATE_SCREEN) \
  	|| defined(PROTO)
  /*
*** ../vim-8.1.0762/src/gui_beval.c	2019-01-13 23:38:33.391773303 +0100
--- src/gui_beval.c	2019-01-17 15:21:35.733424452 +0100
***************
*** 199,206 ****
  #endif
  #endif /* !FEAT_GUI_W32 */
  
! #if defined(FEAT_SUN_WORKSHOP) || defined(FEAT_NETBEANS_INTG) \
!     || defined(FEAT_EVAL) || defined(PROTO)
  # if !defined(FEAT_GUI_W32) || defined(PROTO)
  
  /*
--- 199,205 ----
  #endif
  #endif /* !FEAT_GUI_W32 */
  
! #if defined(FEAT_NETBEANS_INTG) || defined(FEAT_EVAL) || defined(PROTO)
  # if !defined(FEAT_GUI_W32) || defined(PROTO)
  
  /*
***************
*** 216,222 ****
  	undrawBalloon(beval);
  }
  # endif /* !FEAT_GUI_W32 */
! #endif /* FEAT_SUN_WORKSHOP || FEAT_NETBEANS_INTG || PROTO */
  
  #if !defined(FEAT_GUI_W32) || defined(PROTO)
  #if defined(FEAT_BEVAL_TIP) || defined(PROTO)
--- 215,221 ----
  	undrawBalloon(beval);
  }
  # endif /* !FEAT_GUI_W32 */
! #endif /* FEAT_NETBEANS_INTG || PROTO */
  
  #if !defined(FEAT_GUI_W32) || defined(PROTO)
  #if defined(FEAT_BEVAL_TIP) || defined(PROTO)
*** ../vim-8.1.0762/src/gui_motif.c	2018-12-11 20:39:15.442937076 +0100
--- src/gui_motif.c	2019-01-17 15:21:49.653359579 +0100
***************
*** 698,705 ****
      XtVaSetValues(shell, XmNmappedWhenManaged, mappedWhenManaged, NULL);
  }
  
! #if defined(FEAT_MENU) || defined(FEAT_SUN_WORKSHOP) \
! 	|| defined(FEAT_GUI_DIALOG) || defined(PROTO)
  
  /*
   * Encapsulate the way an XmFontList is created.
--- 698,704 ----
      XtVaSetValues(shell, XmNmappedWhenManaged, mappedWhenManaged, NULL);
  }
  
! #if defined(FEAT_MENU) || defined(FEAT_GUI_DIALOG) || defined(PROTO)
  
  /*
   * Encapsulate the way an XmFontList is created.
*** ../vim-8.1.0762/src/gui_x11.c	2019-01-16 22:15:07.872962363 +0100
--- src/gui_x11.c	2019-01-17 15:23:32.516860907 +0100
***************
*** 22,32 ****
  #include <X11/cursorfont.h>
  
  /*
!  * For Workshop XpmP.h is preferred, because it makes the signs drawn with a
!  * transparent background instead of black.
   */
  #if defined(HAVE_XM_XPMP_H) && defined(FEAT_GUI_MOTIF) \
! 	&& (!defined(HAVE_X11_XPM_H) || defined(FEAT_SUN_WORKSHOP))
  # include <Xm/XpmP.h>
  #else
  # ifdef HAVE_X11_XPM_H
--- 22,32 ----
  #include <X11/cursorfont.h>
  
  /*
!  * XpmP.h is preferred, because it makes the signs drawn with a transparent
!  * background instead of black.
   */
  #if defined(HAVE_XM_XPMP_H) && defined(FEAT_GUI_MOTIF) \
! 	&& !defined(HAVE_X11_XPM_H)
  # include <Xm/XpmP.h>
  #else
  # ifdef HAVE_X11_XPM_H
***************
*** 469,475 ****
  	XtRString,
  	DFLT_TOOLTIP_FONT
      },
!     /* This one isn't really needed, keep for Sun Workshop? */
      {
  	"balloonEvalFontSet",
  	XtCFontSet,
--- 469,475 ----
  	XtRString,
  	DFLT_TOOLTIP_FONT
      },
!     /* This one may not be really needed? */
      {
  	"balloonEvalFontSet",
  	XtCFontSet,
***************
*** 636,643 ****
      gui_mch_update();
  }
  
! #if ((defined(FEAT_NETBEANS_INTG) || defined(FEAT_SUN_WORKSHOP)) \
! 	&& defined(FEAT_GUI_MOTIF)) || defined(PROTO)
  /*
   * This function fills in the XRectangle object with the current x,y
   * coordinates and height, width so that an XtVaSetValues to the same shell of
--- 636,642 ----
      gui_mch_update();
  }
  
! #if (defined(FEAT_NETBEANS_INTG) && defined(FEAT_GUI_MOTIF)) || defined(PROTO)
  /*
   * This function fills in the XRectangle object with the current x,y
   * coordinates and height, width so that an XtVaSetValues to the same shell of
***************
*** 701,715 ****
  #endif
  		     );
      }
- #ifdef FEAT_SUN_WORKSHOP
-     if (usingSunWorkShop)
-     {
- 	XRectangle  rec;
- 
- 	shellRectangle(w, &rec);
- 	workshop_frame_moved(rec.x, rec.y, rec.width, rec.height);
-     }
- #endif
  #if defined(FEAT_NETBEANS_INTG) && defined(FEAT_GUI_MOTIF)
      if (netbeans_active())
      {
--- 700,705 ----
***************
*** 1224,1245 ****
  	    argv[*argc] = NULL;
  	}
  	else
- #ifdef FEAT_SUN_WORKSHOP
- 	    if (strcmp("-ws", argv[arg]) == 0)
- 	{
- 	    usingSunWorkShop++;
- 	    p_acd = TRUE;
- 	    gui.dofork = FALSE;	/* don't fork() when starting GUI */
- 	    mch_memmove(&argv[arg], &argv[arg + 1],
- 					    (--*argc - arg) * sizeof(char *));
- 	    argv[*argc] = NULL;
- # ifdef WSDEBUG
- 	    wsdebug_wait(WT_ENV | WT_WAIT | WT_STOP, "SPRO_GVIM_WAIT", 20);
- 	    wsdebug_log_init("SPRO_GVIM_DEBUG", "SPRO_GVIM_DLEVEL");
- # endif
- 	}
- 	else
- #endif
  #ifdef FEAT_NETBEANS_INTG
  	    if (strncmp("-nb", argv[arg], 3) == 0)
  	{
--- 1214,1219 ----
***************
*** 1543,1553 ****
      if (gui.color_approx)
  	emsg(_("Vim E458: Cannot allocate colormap entry, some colors may be incorrect"));
  
- #ifdef FEAT_SUN_WORKSHOP
-     if (usingSunWorkShop)
- 	workshop_connect(app_context);
- #endif
- 
  #ifdef FEAT_BEVAL_GUI
      gui_init_tooltip_font();
  #endif
--- 1517,1522 ----
***************
*** 1681,1689 ****
  #ifdef FEAT_XIM
      xim_init();
  #endif
- #ifdef FEAT_SUN_WORKSHOP
-     workshop_postinit();
- #endif
  
      return OK;
  }
--- 1650,1655 ----
***************
*** 2748,2759 ****
  #endif
  
      focus = gui.in_focus;
! #ifdef ALT_X_INPUT
!     if (suppress_alternate_input)
! 	desired = (XtIMXEvent | XtIMTimer);
!     else
! #endif
! 	desired = (XtIMAll);
      while (!timed_out)
      {
  	/* Stop or start blinking when focus changes */
--- 2714,2720 ----
  #endif
  
      focus = gui.in_focus;
!     desired = (XtIMAll);
      while (!timed_out)
      {
  	/* Stop or start blinking when focus changes */
*** ../vim-8.1.0762/src/integration.c	2019-01-13 23:50:56.358162250 +0100
--- src/integration.c	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,1112 ****
- /* vi:set ts=8 sw=8 noet:
-  *
-  * VIM - Vi IMproved	by Bram Moolenaar
-  *			Visual Workshop integration by Gordon Prieur
-  *
-  * Do ":help uganda"  in Vim to read copying and usage conditions.
-  * Do ":help credits" in Vim to see a list of people who contributed.
-  * See README.txt for an overview of the Vim source code.
-  */
- 
- /*
-  * Integration with Sun Workshop.
-  *
-  * This file should not change much, it's also used by other editors that
-  * connect to Workshop.  Consider changing workshop.c instead.
-  */
- /*
- -> consider using MakeSelectionVisible instead of gotoLine hacks
-    to show the line properly
-      -> consider using glue instead of our own message wrapping functions
- 	(but can only use glue if we don't have to distribute source)
- */
- 
- #include "vim.h"
- 
- #include <stdio.h>
- #include <stdlib.h>
- 
- #ifdef INET_SOCKETS
- #include <netdb.h>
- #include <netinet/in.h>
- #else
- #include <sys/un.h>
- #endif
- 
- #include <sys/types.h>
- #include <sys/socket.h>
- #include <sys/param.h>
- #ifdef HAVE_LIBGEN_H
- # include <libgen.h>
- #endif
- #include <unistd.h>
- #include <string.h>
- 
- #include <X11/Intrinsic.h>
- #include <Xm/Xm.h>
- #include <Xm/AtomMgr.h>
- #include <Xm/PushB.h>
- 
- #ifdef HAVE_X11_XPM_H
- # include <X11/xpm.h>
- #else
- # ifdef HAVE_XM_XPMP_H
- #  include <Xm/XpmP.h>
- # endif
- #endif
- 
- #ifdef HAVE_UTIL_DEBUG_H
- # include <util/debug.h>
- #endif
- #ifdef HAVE_UTIL_MSGI18N_H
- # include <util/msgi18n.h>
- #endif
- 
- #include "integration.h"	/* <EditPlugin/integration.h> */
- #ifdef HAVE_FRAME_H
- # include <frame.h>
- #endif
- 
- #ifndef MAX
- # define MAX(a, b)    (a) > (b) ? (a) : (b)
- #endif
- 
- #ifndef NOCATGETS
- # define NOCATGETS(x) x
- #endif
- 
- /* Functions private to this file */
- static void workshop_disconnect(void);
- static void workshop_sensitivity(int num, char *table);
- static void adjust_sign_name(char *filename);
- static void process_menuItem(char *);
- static void process_toolbarButton(char *);
- static void workshop_set_option_first(char *name, char *value);
- 
- static size_t dummy;  /* to ignore return value of write() */
- 
- #define CMDBUFSIZ	2048
- 
- #ifdef DEBUG
- static FILE *dfd;
- static void pldebug(char *, ...);
- static void unrecognised_message(char *);
- 
- #define HANDLE_ERRORS(cmd)	else unrecognised_message(cmd);
- #else
- #define HANDLE_ERRORS(cmd)
- #endif
- 
- /*
-  * Version number of the protocol between an editor and eserve.
-  * This number should be incremented when the protocol
-  * is changed.
-  */
- #define	PROTOCOL_VERSION	"4.0.0"
- 
- static int sd = -1;
- static XtInputId inputHandler;		/* Cookie for input */
- 
- Boolean save_files = True;		/* When true, save all files before build actions */
- 
- 	static void
- workshop_connection_closed(void)
- {
- 	/*
- 	 * socket closed on other end
- 	 */
- 	XtRemoveInput(inputHandler);
- 	inputHandler = 0;
- 	sd = -1;
- }
- 
- 	static char *
- getCommand(void)
- {
- 	int	 len;		/* length of this command */
- 	char	 lenbuf[7];	/* get the length string here */
- 	char	*newcb;		/* used to realloc cmdbuf */
- 	static char	*cmdbuf;/* get the command string here */
- 	static int	 cbsize;/* size of cmdbuf */
- 
- 	if ((len = read(sd, &lenbuf, 6)) == 6) {
- 		lenbuf[6] = 0; /* Terminate buffer such that atoi() works right */
- 		len = atoi(lenbuf);
- 		if (cbsize < (len + 1)) {
- 			newcb = (char *) realloc(cmdbuf,
- 			    MAX((len + 256), CMDBUFSIZ));
- 			if (newcb != NULL) {
- 				cmdbuf = newcb;
- 				cbsize = MAX((len + 256), CMDBUFSIZ);
- 			}
- 		}
- 		if (cbsize >= len && (len = read(sd, cmdbuf, len)) > 0) {
- 			cmdbuf[len] = 0;
- 			return cmdbuf;
- 		} else {
- 			return NULL;
- 		}
- 	} else {
- 		if (len == 0) { /* EOF */
- 			workshop_connection_closed();
- 		}
- 		return NULL;
- 	}
- 
- }
- 
- 	static void
- messageFromEserve(XtPointer clientData UNUSED,
- 		  int *dum1 UNUSED,
- 		  XtInputId *dum2 UNUSED)
- {
- 	char	*cmd;		/* the 1st word of the command */
- 
- 	cmd = getCommand();
- 	if (cmd == NULL) {
- 		/* We're being shut down by eserve and the "quit" message
- 		 * didn't arrive before the socket connection got closed */
- 		return;
- 	}
- #ifdef DEBUG
- 	pldebug("%s\n", cmd);
- #endif
- 	switch (*cmd) {
- 	case 'a':
- 		if (cmd[1] == 'c' &&
- 		    strncmp(cmd, NOCATGETS("ack "), 4) == 0) {
- 			int ackNum;
- 			char buf[20];
- 
- 			ackNum = atoi(&cmd[4]);
- 			vim_snprintf(buf, sizeof(buf),
- 					       NOCATGETS("ack %d\n"), ackNum);
- 			dummy = write(sd, buf, strlen(buf));
- 		} else if (strncmp(cmd,
- 		    NOCATGETS("addMarkType "), 12) == 0) {
- 			int idx;
- 			char *color;
- 			char *sign;
- 
- 			idx = atoi(strtok(&cmd[12], " "));
- 			color  = strtok(NULL, NOCATGETS("\001"));
- 			sign  = strtok(NULL, NOCATGETS("\001"));
- 			/* Skip space that separates names */
- 			if (color) {
- 				color++;
- 			}
- 			if (sign) {
- 				sign++;
- 			}
- 			/* Change sign name to accommodate a different size? */
- 			adjust_sign_name(sign);
- 			workshop_add_mark_type(idx, color, sign);
- 		}
- 		HANDLE_ERRORS(cmd);
- 		break;
- 
- 	case 'b':
- 		if (strncmp(cmd,
- 		    NOCATGETS("balloon "), 8) == 0) {
- 			char *tip;
- 
- 			tip  = strtok(&cmd[8], NOCATGETS("\001"));
- 			workshop_show_balloon_tip(tip);
- 		}
- 		HANDLE_ERRORS(cmd);
- 		break;
- 
- 	case 'c':
- 		if (strncmp(cmd,
- 		    NOCATGETS("changeMarkType "), 15) == 0) {
- 			char *file;
- 			int markId;
- 			int type;
- 
- 			file  = strtok(&cmd[15], " ");
- 			markId = atoi(strtok(NULL, " "));
- 			type = atoi(strtok(NULL, " "));
- 			workshop_change_mark_type(file, markId, type);
- 		}
- 		HANDLE_ERRORS(cmd);
- 		break;
- 
- 	case 'd':
- 		if (strncmp(cmd, NOCATGETS("deleteMark "), 11) == 0) {
- 			char *file;
- 			int markId;
- 
- 			file  = strtok(&cmd[11], " ");
- 			markId = atoi(strtok(NULL, " "));
- 			workshop_delete_mark(file, markId);
- 		}
- 		HANDLE_ERRORS(cmd);
- 		break;
- 
- 	case 'f':
- 		if (cmd[1] == 'o' &&
- 		    strncmp(cmd, NOCATGETS("footerMsg "), 10) == 0) {
- 			int severity;
- 			char *message;
- 
- 			severity =
- 			    atoi(strtok(&cmd[10], " "));
- 			message = strtok(NULL, NOCATGETS("\001"));
- 
- 			workshop_footer_message(message, severity);
- 		} else if (strncmp(cmd,
- 		    NOCATGETS("frontFile "), 10) == 0) {
- 			char *file;
- 
- 			file  = strtok(&cmd[10], " ");
- 			workshop_front_file(file);
- 		}
- 		HANDLE_ERRORS(cmd);
- 		break;
- 
- 	case 'g':
- 		if (cmd[1] == 'e' &&
- 		    strncmp(cmd, NOCATGETS("getMarkLine "), 12) == 0) {
- 			char *file;
- 			int markid;
- 			int line;
- 			char buf[100];
- 
- 			file  = strtok(&cmd[12], " ");
- 			markid = atoi(strtok(NULL, " "));
- 			line = workshop_get_mark_lineno(file, markid);
- 			vim_snprintf(buf, sizeof(buf),
- 					     NOCATGETS("markLine %s %d %d\n"),
- 			    file, markid, line);
- 			dummy = write(sd, buf, strlen(buf));
- 		} else if (cmd[1] == 'o' && cmd[4] == 'L' &&
- 		    strncmp(cmd, NOCATGETS("gotoLine "), 9) == 0) {
- 			char *file;
- 			int lineno;
- 
- 			file  = strtok(&cmd[9], " ");
- 			lineno = atoi(strtok(NULL, " "));
- 			workshop_goto_line(file, lineno);
- 		} else if (strncmp(cmd,
- 		    NOCATGETS("gotoMark "), 9) == 0) {
- 			char *file;
- 			int markId;
- 			char *message;
- 
- 			file  = strtok(&cmd[9], " ");
- 			markId = atoi(strtok(NULL, " "));
- 			message = strtok(NULL, NOCATGETS("\001"));
- 			workshop_goto_mark(file, markId, message);
- #ifdef NOHANDS_SUPPORT_FUNCTIONS
- 		} else if (strcmp(cmd, NOCATGETS("getCurrentFile")) == 0) {
- 			char *f = workshop_test_getcurrentfile();
- 			char buffer[2*MAXPATHLEN];
- 			vim_snprintf(buffer, sizeof(buffer),
- 					NOCATGETS("currentFile %d %s"),
- 				f ? (int)strlen(f) : 0, f ? f : "");
- 			workshop_send_message(buffer);
- 		} else if (strcmp(cmd, NOCATGETS("getCursorRow")) == 0) {
- 			int row = workshop_test_getcursorrow();
- 			char buffer[2*MAXPATHLEN];
- 			vim_snprintf(buffer, sizeof(buffer),
- 					NOCATGETS("cursorRow %d"), row);
- 			workshop_send_message(buffer);
- 		} else if (strcmp(cmd, NOCATGETS("getCursorCol")) == 0) {
- 			int col = workshop_test_getcursorcol();
- 			char buffer[2*MAXPATHLEN];
- 			vim_snprintf(buffer, sizeof(buffer),
- 					NOCATGETS("cursorCol %d"), col);
- 			workshop_send_message(buffer);
- 		} else if (strcmp(cmd, NOCATGETS("getCursorRowText")) == 0) {
- 			char *t = workshop_test_getcursorrowtext();
- 			char buffer[2*MAXPATHLEN];
- 			vim_snprintf(buffer, sizeof(buffer),
- 					NOCATGETS("cursorRowText %d %s"),
- 				t ? (int)strlen(t) : 0, t ? t : "");
- 			workshop_send_message(buffer);
- 		} else if (strcmp(cmd, NOCATGETS("getSelectedText")) == 0) {
- 			char *t = workshop_test_getselectedtext();
- 			char buffer[2*MAXPATHLEN];
- 			vim_snprintf(buffer, sizeof(buffer),
- 					NOCATGETS("selectedText %d %s"),
- 				t ? (int)strlen(t) : 0, t ? t : "");
- 			workshop_send_message(buffer);
- #endif
- 		}
- 		HANDLE_ERRORS(cmd);
- 		break;
- 
- 	case 'l':
- 		if (strncmp(cmd, NOCATGETS("loadFile "), 9) == 0) {
- 			char *file;
- 			int line;
- 			char *frameid;
- 
- 			file  = strtok(&cmd[9], " ");
- 			line = atoi(strtok(NULL, " "));
- 			frameid = strtok(NULL, " ");
- 			workshop_load_file(file, line, frameid);
- 		}
- 		HANDLE_ERRORS(cmd);
- 		break;
- 
- 	case 'm':			/* Menu, minimize, maximize */
- 		if (cmd[1] == 'e' && cmd[4] == 'B' &&
- 		    strncmp(cmd, NOCATGETS("menuBegin "), 10) == 0) {
- 			workshop_menu_begin(&cmd[10]);
- 		} else if (cmd[1] == 'e' && cmd[4] == 'I' &&
- 		    strncmp(cmd, NOCATGETS("menuItem "), 9) == 0) {
- 			process_menuItem(cmd);
- 		} else if (cmd[1] == 'e' && cmd[4] == 'E' &&
- 		    strcmp(cmd, NOCATGETS("menuEnd")) == 0) {
- 			workshop_menu_end();
- 		} else if (cmd[1] == 'a' &&
- 		    strcmp(cmd, NOCATGETS("maximize")) == 0) {
- 			workshop_maximize();
- 		} else if (strcmp(cmd, NOCATGETS("minimize")) == 0) {
- 			workshop_minimize();
- 		}
- 		HANDLE_ERRORS(cmd);
- 		break;
- 
- 	case 'o':
- 		if (cmd[1] == 'p' &&
- 		    strcmp(cmd, NOCATGETS("option"))) {
- 			char *name;
- 			char *value;
- 
- 			name  = strtok(&cmd[7], " ");
- 			value = strtok(NULL, " ");
- 			workshop_set_option_first(name, value);
- 		}
- 		HANDLE_ERRORS(cmd);
- 		break;
- 
- 	case 'p':
- 		if (strcmp(cmd, NOCATGETS("ping")) == 0) {
- #if 0
- 			int pingNum;
- 
- 			pingNum = atoi(&cmd[5]);
- 			workshop_send_ack(ackNum);
- 			/* WHAT DO I DO HERE? */
- #endif
- 		}
- 		HANDLE_ERRORS(cmd);
- 		break;
- 
- 	case 'q':
- 		if (strncmp(cmd, NOCATGETS("quit"), 4) == 0) {
- 
- 			/* Close the connection. It's important to do
- 			 * that now, since workshop_quit might be
- 			 * looking at open files.  For example, if you
- 			 * have modified one of the files without
- 			 * saving, NEdit will ask you what you want to
- 			 * do, and spin loop by calling
- 			 * XtAppProcessEvent while waiting for your
- 			 * reply. In this case, if we still have an
- 			 * input handler and the socket has been
- 			 * closed on the other side when eserve
- 			 * expired, we will hang in IoWait.
- 			 */
- 			workshop_disconnect();
- 
- 			workshop_quit();
- 		}
- 		HANDLE_ERRORS(cmd);
- 		break;
- 
- 	case 'r':
- 		if (cmd[1] == 'e' &&
- 		    strncmp(cmd, NOCATGETS("reloadFile "), 11) == 0) {
- 			char *file;
- 			int line;
- 
- 			file  = strtok(&cmd[11], " ");
- 			line = atoi(strtok(NULL, " "));
- 			workshop_reload_file(file, line);
- 		}
- 		HANDLE_ERRORS(cmd);
- 		break;
- 
- 	case 's':
- 		if (cmd[1] == 'e' && cmd[2] == 't' &&
- 		    strncmp(cmd, NOCATGETS("setMark "), 8) == 0) {
- 			char *file;
- 			int line;
- 			int markId;
- 			int type;
- 
- 			file  = strtok(&cmd[8], " ");
- 			line = atoi(strtok(NULL, " "));
- 			markId = atoi(strtok(NULL, " "));
- 			type = atoi(strtok(NULL, " "));
- 			workshop_set_mark(file, line, markId, type);
- 		} else if (cmd[1] == 'h' &&
- 		    strncmp(cmd, NOCATGETS("showFile "), 9) == 0) {
- 			workshop_show_file(&cmd[9]);
- 		} else if (cmd[1] == 'u' &&
- 		    strncmp(cmd, NOCATGETS("subMenu "), 8) == 0) {
- 			char *label;
- 
- 			label  = strtok(&cmd[8], NOCATGETS("\001"));
- 			workshop_submenu_begin(label);
- 		} else if (cmd[1] == 'u' &&
- 		    strcmp(cmd, NOCATGETS("subMenuEnd")) == 0) {
- 			workshop_submenu_end();
- 		} else if (cmd[1] == 'e' && cmd[2] == 'n' &&
- 		    strncmp(cmd, NOCATGETS("sensitivity "), 12) == 0) {
- 			int num;
- 			char *bracket;
- 			char *table;
- 
- 			num = atoi(strtok(&cmd[12], " "));
- 			bracket = strtok(NULL, " ");
- 			if (*bracket != '[') {
- 				fprintf(stderr, NOCATGETS("Parsing "
- 				    "error for sensitivity\n"));
- 			} else {
- 				table = strtok(NULL, NOCATGETS("]"));
- 				workshop_sensitivity(num, table);
- 			}
- 		} else if (cmd[1] == 'e' && cmd[2] == 'n' && cmd[3] == 'd' &&
- 			   strncmp(cmd, NOCATGETS("sendVerb "), 9) == 0) {
- 			/* Send the given verb back (used for the
- 			 * debug.lineno callback (such that other tools
- 			 * can obtain the position coordinates or the
- 			 * selection) */
- 			char *verb;
- 
- 			verb = strtok(&cmd[9], " ");
- 			workshop_perform_verb(verb, NULL);
- 		} else if (cmd[1] == 'a' &&
- 		    strncmp(cmd, NOCATGETS("saveFile "), 9) == 0) {
- 			workshop_save_file(&cmd[9]);
- #ifdef NOHANDS_SUPPORT_FUNCTIONS
- 		} else if (strncmp(cmd, NOCATGETS("saveSensitivity "), 16) == 0) {
- 			char *file;
- 
- 			file  = strtok(&cmd[16], " ");
- 			workshop_save_sensitivity(file);
- #endif
- 		}
- 		HANDLE_ERRORS(cmd);
- 		break;
- 
- 	case 't':			/* Toolbar */
- 		if (cmd[8] == 'e' &&
- 		    strncmp(cmd, NOCATGETS("toolbarBegin"), 12) == 0) {
- 			workshop_toolbar_begin();
- 		} else if (cmd[8] == 'u' &&
- 		    strncmp(cmd, NOCATGETS("toolbarButton"), 13) == 0) {
- 			process_toolbarButton(cmd);
- 		} else if (cmd[7] == 'E' &&
- 		    strcmp(cmd, NOCATGETS("toolbarEnd")) == 0) {
- 			workshop_toolbar_end();
- 		}
- 		HANDLE_ERRORS(cmd);
- 		break;
- 
- #ifdef DEBUG
- 	default:
- 		unrecognised_message(cmd);
- 		break;
- #endif
- 	}
- }
- 
- 	static void
- process_menuItem(
- 	char	*cmd)
- {
- 	char *label  = strtok(&cmd[9], NOCATGETS("\001"));
- 	char *verb  = strtok(NULL, NOCATGETS("\001"));
- 	char *acc = strtok(NULL, NOCATGETS("\001"));
- 	char *accText  = strtok(NULL, NOCATGETS("\001"));
- 	char *name  = strtok(NULL, NOCATGETS("\001"));
- 	char *sense  = strtok(NULL, NOCATGETS("\n"));
- 	char *filepos  = strtok(NULL, NOCATGETS("\n"));
- 	if (*acc == '-') {
- 		acc = NULL;
- 	}
- 	if (*accText == '-') {
- 		accText = NULL;
- 	}
- 	workshop_menu_item(label, verb, acc, accText, name, filepos, sense);
- 
- }
- 
- 
- 	static void
- process_toolbarButton(
- 	char	*cmd)			/* button definition */
- {
- 	char *label  = strtok(&cmd[14], NOCATGETS("\001"));
- 	char *verb  = strtok(NULL, NOCATGETS("\001"));
- 	char *senseVerb  = strtok(NULL, NOCATGETS("\001"));
- 	char *filepos  = strtok(NULL, NOCATGETS("\001"));
- 	char *help  = strtok(NULL, NOCATGETS("\001"));
- 	char *sense  = strtok(NULL, NOCATGETS("\001"));
- 	char *file  = strtok(NULL, NOCATGETS("\001"));
- 	char *left  = strtok(NULL, NOCATGETS("\n"));
- 
- 	if (!strcmp(label, NOCATGETS("-"))) {
- 		label = NULL;
- 	}
- 	if (!strcmp(help, NOCATGETS("-"))) {
- 		help = NULL;
- 	}
- 	if (!strcmp(file, NOCATGETS("-"))) {
- 		file = NULL;
- 	}
- 	if (!strcmp(senseVerb, NOCATGETS("-"))) {
- 		senseVerb = NULL;
- 	}
- 	workshop_toolbar_button(label, verb, senseVerb, filepos, help,
- 				sense, file, left);
- }
- 
- 
- #ifdef DEBUG
- 	static void
- unrecognised_message(
- 	char	*cmd)
- {
- 	pldebug("Unrecognised eserve message:\n\t%s\n", cmd);
- 	/* abort(); */
- }
- #endif
- 
- 
- /* Change sign name to accommodate a different size:
-  * Create the filename based on the height. The filename format
-  * of multisize icons are:
-  *    x.xpm   : largest icon
-  *    x1.xpm  : smaller icon
-  *    x2.xpm  : smallest icon */
- 	static void
- adjust_sign_name(char *filename)
- {
- 	char *s;
- 	static int fontSize = -1;
- 
- 	if (fontSize == -1)
- 		fontSize = workshop_get_font_height();
- 	if (fontSize == 0)
- 		return;
- 	if (filename[0] == '-')
- 		return;
- 
- 	/* This is ugly: later we should instead pass the fontheight over
- 	 * to eserve on startup and let eserve just send the right filenames
- 	 * to us in the first place
- 
- 	 * I know that the filename will end with 1.xpm (see
- 	 * GuiEditor.cc`LispPrintSign if you wonder why) */
- 	s = filename+strlen(filename)-5;
- 	if (fontSize <= 11)
- 		strcpy(s, "2.xpm");
- 	else if (fontSize <= 15)
- 		strcpy(s, "1.xpm");
- 	else
- 		strcpy(s, ".xpm");
- }
- 
- #if 0
- /* Were we invoked by WorkShop? This function can be used early during startup
-    if you want to do things differently if the editor is started standalone
-    or in WorkShop mode. For example, in standalone mode you may not want to
-    add a footer/message area or a sign gutter. */
- 	int
- workshop_invoked(void)
- {
- 	static int result = -1;
- 	if (result == -1) {
- 		result = (getenv(NOCATGETS("SPRO_EDITOR_SOCKET")) != NULL);
- 	}
- 	return result;
- }
- #endif
- 
- /* Connect back to eserve */
- void	workshop_connect(XtAppContext context)
- {
- #ifdef INET_SOCKETS
- 	struct sockaddr_in	server;
- 	struct hostent *	host;
- 	int			port;
- #else
- 	struct sockaddr_un	server;
- #endif
- 	char			buf[32];
- 	char *			address;
- #ifdef DEBUG
- 	char			*file;
- #endif
- 
- 	address = getenv(NOCATGETS("SPRO_EDITOR_SOCKET"));
- 	if (address == NULL) {
- 		return;
- 	}
- 
- #ifdef INET_SOCKETS
- 	port = atoi(address);
- 
- 	if ((sd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
- 		PERROR(NOCATGETS("workshop_connect"));
- 		return;
- 	}
- 
- 	/* Get the server internet address and put into addr structure */
- 	/* fill in the socket address structure and connect to server */
- 	vim_memset((char *)&server, '\0', sizeof(server));
- 	server.sin_family = AF_INET;
- 	server.sin_port = port;
- 	if ((host = gethostbyname(NOCATGETS("localhost"))) == NULL) {
- 		PERROR(NOCATGETS("gethostbyname"));
- 		sd = -1;
- 		return;
- 	}
- 	memcpy((char *)&server.sin_addr, host->h_addr, host->h_length);
- #else
- 	if ((sd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
- 		PERROR(NOCATGETS("workshop_connect"));
- 		return;
- 	}
- 
- 	server.sun_family = AF_UNIX;
- 	strcpy(server.sun_path, address);
- #endif
- 	/* Connect to server */
- 	if (connect(sd, (struct sockaddr *)&server, sizeof(server))) {
- 		if (errno == ECONNREFUSED) {
- 			close(sd);
- #ifdef INET_SOCKETS
- 			if ((sd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
- 				PERROR(NOCATGETS("workshop_connect"));
- 				return;
- 			}
- #else
- 			if ((sd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
- 				PERROR(NOCATGETS("workshop_connect"));
- 				return;
- 			}
- #endif
- 			if (connect(sd, (struct sockaddr *)&server,
- 						sizeof(server))) {
- 				PERROR(NOCATGETS("workshop_connect"));
- 				return;
- 			}
- 
- 		} else {
- 			PERROR(NOCATGETS("workshop_connect"));
- 			return;
- 		}
- 	}
- 
- 	/* tell notifier we are interested in being called
- 	 * when there is input on the editor connection socket
- 	 */
- 	inputHandler = XtAppAddInput(context, sd, (XtPointer) XtInputReadMask,
- 				     messageFromEserve, NULL);
- #ifdef DEBUG
- 	if ((file = getenv(NOCATGETS("SPRO_PLUGIN_DEBUG"))) != NULL) {
- 		char buf[BUFSIZ];
- 
- 		unlink(file);
- 		vim_snprintf(buf, sizeof(buf), "date > %s", file);
- 		system(buf);
- 		dfd = fopen(file, "a");
- 	} else {
- 		dfd = NULL;
- 	}
- #endif
- 
- 	vim_snprintf(buf, sizeof(buf), NOCATGETS("connected %s %s %s\n"),
- 		workshop_get_editor_name(),
- 		PROTOCOL_VERSION,
- 		workshop_get_editor_version());
- 	dummy = write(sd, buf, strlen(buf));
- 
- 	vim_snprintf(buf, sizeof(buf), NOCATGETS("ack 1\n"));
- 	dummy = write(sd, buf, strlen(buf));
- }
- 
- 	static void
- workshop_disconnect(void)
- {
- 	/* Probably need to send some message here */
- 
- 	/*
- 	 * socket closed on other end
- 	 */
- 	XtRemoveInput(inputHandler);
- 	close(sd);
- 	inputHandler = 0;
- 	sd = -1;
- 
- }
- 
- /*
-  * Utility functions
-  */
- 
- 
- /* Minimize and maximize shells. From libutil's shell.cc. */
- 
- /* utility functions from libutil's shell.cc */
- static Boolean
- isWindowMapped(Display *display, Window win)
- {
- 	XWindowAttributes winAttrs;
- 	XGetWindowAttributes(display,
- 			     win,
- 			     &winAttrs);
- 	if (winAttrs.map_state == IsViewable) {
- 		return(True);
- 	} else {
- 		return(False);
- 	}
- }
- 
- static Boolean
- isMapped(Widget widget)
- {
- 	if (widget == NULL) {
- 		return(False);
- 	}
- 
- 	if (XtIsRealized(widget) == False) {
- 		return(False);
- 	}
- 
- 	return(isWindowMapped(XtDisplay(widget), XtWindow(widget)));
- }
- 
- static Boolean
- widgetIsIconified(
- 	Widget		 w)
- {
- 	Atom		 wm_state;
- 	Atom		 act_type;		/* actual Atom type returned */
- 	int		 act_fmt;		/* actual format returned */
- 	u_long		 nitems_ret;		/* number of items returned */
- 	u_long		 bytes_after;		/* number of bytes remaining */
- 	u_long		*property;		/* actual property returned */
- 
- 	/*
- 	 * If a window is iconified its WM_STATE is set to IconicState. See
- 	 * ICCCM Version 2.0, section 4.1.3.1 for more details.
- 	 */
- 
- 	wm_state = XmInternAtom(XtDisplay(w), NOCATGETS("WM_STATE"), False);
- 	if (XtWindow(w) != 0) {			/* only check if window exists! */
- 		XGetWindowProperty(XtDisplay(w), XtWindow(w), wm_state, 0L, 2L,
- 		    False, AnyPropertyType, &act_type, &act_fmt, &nitems_ret,
- 		    &bytes_after, (char_u **) &property);
- 		if (nitems_ret == 2 && property[0] == IconicState) {
- 			return True;
- 		}
- 	}
- 
- 	return False;
- 
- }    /* end widgetIsIconified */
- 
- void
- workshop_minimize_shell(Widget shell)
- {
- 	if (shell != NULL &&
- 	    XtIsObject(shell) &&
- 	    XtIsRealized(shell) == True) {
- 		if (isMapped(shell) == True) {
- 			XIconifyWindow(XtDisplay(shell), XtWindow(shell),
- 			       XScreenNumberOfScreen(XtScreen(shell)));
- 		}
- 		XtVaSetValues(shell,
- 			      XmNiconic, True,
- 			      NULL);
- 	}
- }
- 
- void workshop_maximize_shell(Widget shell)
- {
- 	if (shell != NULL &&
- 	    XtIsRealized(shell) == True &&
- 	    widgetIsIconified(shell) == True &&
- 	    isMapped(shell) == False) {
- 		XtMapWidget(shell);
- 		/* This used to be
- 		     XtPopdown(shell);
- 		     XtPopup(shell, XtGrabNone);
- 		   However, I found that that would drop any transient
- 		   windows that had been iconified with the window.
- 		   According to the ICCCM, XtMapWidget should be used
- 		   to bring a window from Iconic to Normal state.
- 		   However, Rich Mauri did a lot of work on this during
- 		   Bart, and found that XtPopDown,XtPopup was required
- 		   to fix several bugs involving multiple CDE workspaces.
- 		   I've tested it now and things seem to work fine but
- 		   I'm leaving this note for history in case this needs
- 		   to be revisited.
- 		*/
- 	}
- }
- 
- 
- Boolean workshop_get_width_height(int *width, int *height)
- {
- 	static int	wid = 0;
- 	static int	hgt = 0;
- 	static Boolean	firstTime = True;
- 	static Boolean	success = False;
- 
- 	if (firstTime) {
- 		char	*settings;
- 
- 		settings = getenv(NOCATGETS("SPRO_GUI_WIDTH_HEIGHT"));
- 		if (settings != NULL) {
- 			wid = atoi(settings);
- 			settings = strrchr(settings, ':');
- 			if (settings++ != NULL) {
- 				hgt = atoi(settings);
- 			}
- 			if (wid > 0 && hgt > 0) {
- 				success = True;
- 			}
- 			firstTime = False;
- 		}
- 	}
- 
- 	if (success) {
- 		*width = wid;
- 		*height = hgt;
- 	}
- 	return success;
- }
- 
- /*
-  * Toolbar code
-  */
- 
- 	static void
- workshop_sensitivity(int num, char *table)
- {
- 	/* build up a verb table */
- 	VerbSense *vs;
- 	int i;
- 	char *s;
- 	if ((num < 1) || (num > 500)) {
- 		return;
- 	}
- 
- 	vs = (VerbSense *)malloc((num+1)*sizeof(VerbSense));
- 
- 	/* Point to the individual names (destroys the table string, but
- 	 * that's okay -- this is more efficient than duplicating strings) */
- 	s = table;
- 	for (i = 0; i < num; i++) {
- 		while (*s == ' ') {
- 			s++;
- 		}
- 		vs[i].verb = s;
- 		while (*s && (*s != ' ') && (*s != '\001')) {
- 			s++;
- 		}
- 		if (*s == 0) {
- 			vs[i].verb = NULL;
- 			break;
- 		}
- 		if (*s == '\001') {
- 			*s = 0;
- 			s++;
- 		}
- 		*s = 0;
- 		s++;
- 		while (*s == ' ') {
- 			s++;
- 		}
- 		if (*s == '1') {
- 			vs[i].sense = 1;
- 		} else {
- 			vs[i].sense = 0;
- 		}
- 		s++;
- 	}
- 	vs[i].verb = NULL;
- 
- 	workshop_frame_sensitivities(vs);
- 
- 	free(vs);
- }
- 
- /*
-  * Options code
-  */
- /* Set an editor option.
-  * IGNORE an option if you do not recognize it.
-  */
- 	static void
- workshop_set_option_first(char *name, char *value)
- {
- 	/* Currently value can only be on/off. This may change later (for
- 	 * example to set an option like "balloon evaluate delay", but
- 	 * for now just convert it into a boolean */
- 	Boolean on = !strcmp(value, "on");
- 
- 	if (!strcmp(name, "workshopkeys")) {
- 		workshop_hotkeys(on);
- 	} else if (!strcmp(name, "savefiles")) {
- 		save_files = on;
- 	} else if (!strcmp(name, "balloon")) {
- 		workshop_balloon_mode(on);
- 	} else if (!strcmp(name, "balloondelay")) {
- 		int delay = atoi(value);
- 		/* Should I validate the number here?? */
- 		workshop_balloon_delay(delay);
- 	} else {
- 		/* Let editor interpret it */
- 		workshop_set_option(name, value);
- 	}
- }
- 
- 
- void workshop_file_closed_lineno(char *filename, int lineno)
- {
- 	char buffer[2*MAXPATHLEN];
- 	vim_snprintf(buffer, sizeof(buffer),
- 			NOCATGETS("deletedFile %s %d\n"), filename, lineno);
- 	dummy = write(sd, buffer, strlen(buffer));
- }
- 
- void workshop_file_opened(char *filename, int readOnly)
- {
- 	char buffer[2*MAXPATHLEN];
- 	vim_snprintf(buffer, sizeof(buffer),
- 			NOCATGETS("loadedFile %s %d\n"), filename, readOnly);
- 	dummy = write(sd, buffer, strlen(buffer));
- }
- 
- 
- void workshop_file_saved(char *filename)
- {
- 	char buffer[2*MAXPATHLEN];
- 	vim_snprintf(buffer, sizeof(buffer),
- 			NOCATGETS("savedFile %s\n"), filename);
- 	dummy = write(sd, buffer, strlen(buffer));
- 
- 	/* Let editor report any moved marks that the eserve client
- 	 * should deal with (for example, moving location-based breakpoints) */
- 	workshop_moved_marks(filename);
- }
- 
- void workshop_frame_moved(int new_x, int new_y, int new_w, int new_h)
- {
- 	char buffer[200];
- 
- 	if (sd >= 0)
- 	{
- 		vim_snprintf(buffer, sizeof(buffer),
- 				NOCATGETS("frameAt %d %d %d %d\n"),
- 				new_x, new_y, new_w, new_h);
- 		dummy = write(sd, buffer, strlen(buffer));
- 	}
- }
- 
- /* A button in the toolbar has been pushed.
-  * Clientdata is a pointer used by the editor code to figure out the
-  * positions for this toolbar (probably by storing a window pointer,
-  * and then fetching the current buffer for that window and looking up
-  * cursor and selection positions etc.) */
- void workshop_perform_verb(char *verb, void *clientData)
- {
- 	char *filename;
- 	int curLine;
- 	int curCol;
- 	int selStartLine;
- 	int selStartCol;
- 	int selEndLine;
- 	int selEndCol;
- 	int selLength;
- 	char *selection;
- 
- 	char buf[2*MAXPATHLEN];
- /* Later: needsFilePos indicates whether or not we need to fetch all this
-  * info for this verb... for now, however, it looks as if
-  * eserve parsing routines depend on it always being present */
- 
- 	if (workshop_get_positions(clientData,
- 				   &filename,
- 				   &curLine,
- 				   &curCol,
- 				   &selStartLine,
- 				   &selStartCol,
- 				   &selEndLine,
- 				   &selEndCol,
- 				   &selLength,
- 				   &selection)) {
- 		if (selection == NULL) {
- 			selection = NOCATGETS("");
- 		}
- 
- 		/* Should I save the files??? This is currently done by checking
- 		   if the verb is one of a few recognized ones. Later we can pass
- 		   this list from eserve to the editor (it's currently hardcoded in
- 		   vi and emacs as well). */
- 		if (save_files) {
- 			if (!strcmp(verb, "build.build") || !strcmp(verb, "build.build-file") ||
- 			    !strcmp(verb, "debug.fix") || !strcmp(verb, "debug.fix-all")) {
- 				workshop_save_files();
- 			}
- 		}
- 
- 		vim_snprintf(buf, sizeof(buf),
- 			NOCATGETS("toolVerb %s %s %d,%d %d,%d %d,%d %d %s\n"),
- 			verb,
- 			filename,
- 			curLine, curCol,
- 			selStartLine, selStartCol,
- 			selEndLine, selEndCol,
- 			selLength,
- 			selection);
- 		dummy = write(sd, buf, strlen(buf));
- 		if (*selection) {
- 			free(selection);
- 		}
- 	}
- }
- 
- /* Send a message to eserve */
- #if defined(NOHANDS_SUPPORT_FUNCTIONS) || defined(FEAT_BEVAL_GUI)
- void workshop_send_message(char *buf)
- {
- 	dummy = write(sd, buf, strlen(buf));
- }
- #endif
- 
- /* Some methods, like currentFile, cursorPos, etc. are missing here.
-  * But it looks like these are used for NoHands testing only so we
-  * won't bother requiring editors to implement these
-  */
- 
- 
- #ifdef DEBUG
- 
- 	static void
- pldebug(
- 	char		*fmt,	/* a printf style format line */
- 	...)
- {
- 	va_list		 ap;
- 
- 	if (dfd != NULL) {
- 		va_start(ap, fmt);
- 		vfprintf(dfd, fmt, ap);
- 		va_end(ap);
- 		fflush(dfd);
- 	}
- 
- }    /* end pldebug */
- 
- #endif
--- 0 ----
*** ../vim-8.1.0762/src/integration.h	2016-08-29 22:42:20.000000000 +0200
--- src/integration.h	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,452 ****
- /* vi:set ts=8 sts=4 sw=4 noet:
-  *
-  * VIM - Vi IMproved	by Bram Moolenaar
-  *			Visual Workshop integration by Gordon Prieur
-  *
-  * Do ":help uganda"  in Vim to read copying and usage conditions.
-  * Do ":help credits" in Vim to see a list of people who contributed.
-  */
- /*
-   THIS IS AN UNSTABLE INTERFACE! It is unsupported and will likely
-   change in future releases, possibly breaking compatibility!
- */
- 
- #ifndef _INTEGRATION_H
- #define _INTEGRATION_H
- 
- #include <X11/Intrinsic.h>
- #include <Xm/Xm.h>
- 
- #ifdef  __cplusplus
- extern "C" {
- #endif
- 
- /* Enable NoHands test support functions. Define this only if you want to
-    compile in support in the editor such that it can be run under
-    the WorkShop test suite. */
- #ifndef NOHANDS_SUPPORT_FUNCTIONS
- #define NOHANDS_SUPPORT_FUNCTIONS
- #endif
- 
- 
- /* This header file has three parts.
-  * 1. Functions you need to implement; these are called by the integration
-  *    library
-  * 2. Functions you need to call when certain events happen in the editor;
-  *    these are implemented by the integration library
-  * 3. Utility functions provided by the integration library; these make
-  *	  task 1 a bit easier.
-  */
- 
- /*
-  * The following functions need to be implemented by the editor
-  * integration code (and will be editor-specific). Please see the
-  * sample workshop.c file for comments explaining what each functions
-  * needs to do, what the arguments mean, etc.
-  */
- 
- /*
-  * This string is recognized by eserve and should be all lower case.
-  * This is how the editor detects that it is talking to NEdit instead
-  * of Vim, for example, when the connection is initiated from the editor.
-  * Examples: "nedit", "gvim"
-  */
- char *workshop_get_editor_name();
- 
- /*
-  * Version number of the editor.
-  * This number is communicated along with the protocol
-  * version to the application.
-  * Examples: "5.0.2", "19.3"
-  */
- char *workshop_get_editor_version();
- 
- 
- /* Goto a given line in a given file */
- void workshop_goto_line(char *filename, int lineno);
- 
- 
- /* Set mark in a given file */
- void workshop_set_mark(char *filename, int lineno, int markId, int type);
- 
- 
- /* Change mark type (for example from current-pc to pc-and-breakpoint) */
- void workshop_change_mark_type(char *filename, int markId, int type);
- 
- /*
-  * Goto the given mark in a file (e.g. show it).
-  * If message is not null, display it in the footer.
-  */
- 
- void workshop_goto_mark(char *filename, int markId, char *message);
- 
- 
- /* Delete mark */
- void workshop_delete_mark(char *filename, int markId);
- 
- /* Begin/end pair of messages indicating that a series of _set_mark and
-  * _delete_mark messages will be sent. This can/should be used to suppress gui
-  * redraws between the begin and end messages. For example, if you switch
-  * to a headerfile that has a class breakpoint set, there may be hundreds
-  * of marks that need to be added. You don't want to refresh the gui for each
-  * added sign, you want to wait until the final end message.
-  */
- void workshop_mark_batch_begin();
- void workshop_mark_batch_end();
- 
- 
- /* Load a given file into the WorkShop buffer. "frameid" is a token string
-  * that identifies which frame the file would like to be loaded into. This
-  * will usually be null, in which case you should use the default frame.
-  * However, if frameid is not null, you need to find a frame that has this
-  * frameid, and replace the file in that frame. Finally, if the frameid is
-  * one you haven't seen before, you should create a new frame for this file.
-  * Note that "frameid" is a string value, not just an opaque pointer, so
-  * you should use strcmp rather than == when testing for equality.
-  */
- void workshop_load_file(char *filename, int line, char *frameid);
- 
- 
- /* Reload the WorkShop buffer */
- void workshop_reload_file(char *filename, int line);
- 
- 
- /* Show the given file */
- void workshop_show_file(char *filename);
- 
- 
- /* Front the given file */
- void workshop_front_file(char *filename);
- 
- 
- /* Save the given file  */
- void workshop_save_file(char *filename);
- 
- /* Save all WorkShop edited files. You can ask user about modified files
-  * and skip saving any files the user doesn't want to save.
-  * This function is typically called when the user issues a build, a fix,
-  * etc. (and also if you select "Save All" from the File menu :-)
-  */
- void workshop_save_files();
- 
- /* Show a message in all footers.
-    Severity currently is not defined. */
- void workshop_footer_message(char *message, int severity);
- 
- /* Minimize all windows */
- void workshop_minimize();
- 
- 
- /* Maximize all windows */
- void workshop_maximize();
- 
- 
- /*
-  * Create a new mark type, assign it a given index, a given textbackground
-  * color, and a given left-margin sign (where sign is a filename to an
-  * .xpm file)
-  */
- void workshop_add_mark_type(int idx, char *colorspec, char *sign);
- 
- 
- /* Get mark line number */
- int workshop_get_mark_lineno(char *filename, int markId);
- 
- 
- /* Exit editor; save confirmation dialogs are okay */
- void workshop_quit();
- 
- /* Set an editor option.
-  * For example, name="syntax",value="on" would enable syntax highlighting.
-  * The currently defined options are:
-  *    lineno		{on,off}	show line numbers
-  *    syntax		{on,off}	highlight syntax
-  *    parentheses	{on,off}	show matching parentheses
-  * The following options are interpreted by the library for you (so you
-  * will never see the message. However, the implementation requires you
-  * to provide certain callbacks, like restore hotkeys or save all files.
-  * These are documented separately).
-  *    workshopkeys	{on,off}	set workshop hotkeys
-  *    savefiles		{on,off}	save all files before issuing a build
-  *    balloon		{on,off}	enable/disable balloon evaluate
-  *
-  * IGNORE an option if you do not recognize it.
-  */
- void workshop_set_option(char *name, char *value);
- 
- /*
-  * (See workshop_add_frame first.) This function notifies the editor
-  * that the frame for the given window (indicated by "frame", which
-  * was supplied by the editor in workshop_add_frame) has been created.
-  * This can happen much later than the workshop_add_frame message, since
-  * often a window is created on editor startup, while the frame description
-  * is passed over from eserve much later, when the connection is complete.
-  * This gives the editor a chance to kick its GUI to show the frame
-  * properly; typically you'll unmanage and remanage the parent widget to
-  * force a geometry recalculation.
-  */
- 
- void workshop_reconfigure_frame(void *frame);
- 
- 
- /* Are there any moved marks? If so, call workshop_move_mark on
-  * each of them now. This is how eserve can find out if for example
-  * breakpoints have moved when a program has been recompiled and
-  * reloaded into dbx.
-  */
- void workshop_moved_marks(char *filename);
- 
- 
- /* A button in the toolbar has been pushed. "frame" is provided
-  * which should let you determine which toolbar had a button pushed
-  * (you supplied this clientData when you created a toolbar). From
-  * this you should be able to figure out which file the operation
-  * applies to, and for that window the cursor line and column,
-  * selection begin line and column, selection end line and column,
-  * selection text and selection text length. The column numbers are
-  * currently unused but implement it anyway in case we decide to use
-  * them in the future.
-  * Note that frame can be NULL. In this case, you should pick
-  * a default window to translate coordinates for (ideally, the
-  * last window the user has operated on.) This will be the case when
-  * the user clicks on a Custom Button programmed to take the current
-  * line number as an argument. Here it's ambiguous which buffer
-  * to use, so you need to pick one.
-  * (Interface consideration: Perhaps we instead should add smarts
-  * into the library such that we remember which frame pointer
-  * we last noticed (e.g. last call to get_positions, or perhaps
-  * last add_frame) and then pass that instead? For example, we could
-  * have all workshop operations return the clientData when passed
-  * the filename (or add a filename-to-clientData converter?) and then
-  * remember the last filename/clientData used.
-  */
- int workshop_get_positions(void *frame,
- 			   char **filename,
- 			   int *curLine,
- 			   int *curCol,
- 			   int *selStartLine,
- 			   int *selStartCol,
- 			   int *selEndLine,
- 			   int *selEndCol,
- 			   int *selLength,
- 			   char **selection);
- 
- /* The following function should return the height of a character
-  * in the text display. This is used to pick out a suitable size
-  * for the signs to match the text (currently available in three
-  * sizes). If you just return 0, WorkShop will use the default
-  * sign size. (Use XmStringExtent on character "A" to get the height.)
-  */
- 
- int workshop_get_font_height(void);
- 
- /* The following function requests that you register the given
-  * hotkey as a keyboard accelerator for all frames. Whenever the
-  * hotkey is pressed, you should invoke  workshop_hotkey_pressed
-  * and pass the current frame pointer as an argument as well as
-  * the clientData pointer passed in to this function.
-  * The remove function unregisters the hotkey.
-  */
- void workshop_register_hotkey(Modifiers modifiers, KeySym keysym,
- 			      void *clientData);
- void workshop_unregister_hotkey(Modifiers modifiers, KeySym keysym,
- 				void *clientData);
- 
- 
- 
- 
- /*
-  *
-  * The following functions notify eserve of important editor events,
-  * such as files being modified, files being saved, etc. You must
-  * sprinkle your editor code with calls to these. For example, whenever
-  * a file is modified (well, when its read-only status changes to modified),
-  * call workshop_file_modified().
-  *
-  */
- 
- 
- 
- /* Connect with eserve. Add this call after you editor initialization
-  * is done, right before entering the event loop or blocking on input.
-  * This will set up a socket connection with eserve.
-  */
- void workshop_connect(XtAppContext context);
- 
- /* A file has been opened. */
- void workshop_file_opened(char *filename, int readOnly);
- 
- 
- /* A file has been saved. Despite its name, eserve also uses this
-  * message to mean a file has been reverted or unmodified.
-  */
- void workshop_file_saved(char *filename);
- 
- 
- #if 0
- /* A file has been closed */
- void workshop_file_closed(char *filename);
- #endif
- 
- /* Like workshop_file_closed, but also inform eserve what line the
-    cursor was on when you left the file. That way eserve can put you
-    back where you left off when you return to this file. */
- void workshop_file_closed_lineno(char *filename, int line);
- 
- #if 0
- /* A file has been modified */
- void workshop_file_modified(char *filename);
- 
- /*
-  * A mark has been moved. Only call this as a response to
-  * a workshop_moved_marks request call.
-  */
- void workshop_move_mark(char *filename, int markId, int newLineno);
- #endif
- 
- /* Tell the integration library about a new frame being added.
-  * Supply a form for the toolbar, a label for the footer, and an
-  * XmPulldown menu for the WorkShop menu to attach to. Top and bottom
-  * are the widgets above and below the toolbar form widget, if
-  * any. Call this function when you create a new window. It returns a
-  * void *, a handle which you should keep and return when you delete
-  * the window with workshop_delete_toolbar.  The "footer" argument
-  * points to a Label widget that is going to be used as a status
-  * message area, and "menu" (if any) points to an Menu widget that
-  * should contain a WorkShop menu.  Clientdata is a pointer which is
-  * only used by the editor. It will typically be a pointer to the
-  * window object that the toolbar is placed in. If you have multiple
-  * windows, you need to use this pointer to figure out which window
-  * (and thus corresponding buffer) the user has clicked on to respond
-  * to the workshop_get_positions message.
-  * Each frame's clientData ("frame") should be unique.
-  */
- void *workshop_add_frame(void *frame, Widget form,
- 			   Widget top, Widget bottom, Widget footer,
- 			   Widget menu);
- 
- /* Delete a window/frame. Call this when an editor window is being deleted. */
- void workshop_delete_frame(void *handle);
- 
- /* Add a balloon evaluate text area. "frame" is used the same way
-  * as in workshop_add_frame. This call is not part of workshop_add_frame because
-  * a frame can have multiple tooltip areas (typically, an editor frame that
-  * is split showing multiple buffers will have a separate tooltip area for
-  * each text widget. Each such area is called a "window" (consistent with
-  * XEmacs terminology). Separate these by the window argument if necessary.
-  * You will need to implement workshop_get_balloon_text such that it uses
-  * these two arguments to derive the file, line etc. for the tip.
-  * Call the remove function if you delete this area such that the integration
-  * library can update itself. You must call workshop_add_frame before you
-  * call add_balloon_eval_area, and you must pass the same frame pointer.
-  */
- void workshop_add_balloon_eval_area(void *frame, void *window, Widget widget);
- void workshop_remove_balloon_eval_area(void *frame, void *window, Widget widget);
- 
- 
- /* For a given mouse position inside the balloon area (passed as x,y),
-  * return the balloon text to be evaluated. There are two scenarios:
-  * If the position is inside the selection, return the selection
-  * string.  Else, return the full line (or possibly the full line up
-  * to the last semicolon (that's TBD), along with an index pointing to
-  * where which character the mouse is over.
-  * If we have the selection-scenario, set mouseIndex to -1 to indicate
-  * that no autoexpansion should occur but that the selection should
-  * be evaluated as is.
-  *
-  * XXX Does dbx need more information here, like the filename and line
-  * number in order to determine the correct language and scope to be
-  * used during evaluation?? Or should it just work like the p= button
-  * (where the current scope and language is used, even if you are
-  * pointing at a different file with a different scope) ?
-  */
- int workshop_get_balloon_text(Position x, Position y,
- 			      void *frame,
- 			      void *window,
- 			      char **filename,
- 			      int *line,
- 			      char **text,
- 			      int *mouseIndex);
- 
- 
- /* Window size and location
-  * WorkShop will attempt to restore the size and location of a single
-  * editor frame. For vi, this window is designated as the "reusable" one.
-  * You can implement your own scheme for determining which window you
-  * want to associate with WorkShop. Whenever the size and location of
-  * this window is changed, call the following function to notify eserve.
-  * Like workshop_invoked, this can be called before the workshop_connect()
-  * call.
-  */
- void workshop_frame_moved(int new_x, int new_y, int new_w, int new_h);
- Boolean workshop_get_width_height(int *, int *);
- #if 0
- Boolean workshop_get_rows_cols(int *, int *);
- #endif
- 
- /* This function should be invoked when you press a hotkey
-  * set up by workshop_register_hotkey. Pass the clientData
-  * to it that was given to you with workshop_register_hotkey.
- */
- void workshop_hotkey_pressed(void *frame, void *clientData);
- 
- 
- 
- 
- 
- /*
-  * Utility functions
-  * These provide convenience functions to simplify implementing some
-  * of the above functions.
-  *
-  */
- 
- #if 0
- /* Were we invoked by WorkShop? This function can be used early during startup
-  * if you want to do things differently if the editor is started standalone
-  * or in WorkShop mode. For example, in standalone mode you may not want to
-  * add a footer/message area or a sign gutter.
-  */
- int workshop_invoked(void);
- #endif
- 
- 
- /* Minimize (iconify) the given shell */
- void workshop_minimize_shell(Widget shell);
- 
- /* Maximize (deiconify) the given shell */
- void workshop_maximize_shell(Widget shell);
- 
- /* Called by frame.cc -- editor shouldn't call this directly.
-  * Perhaps we need an integrationP.h file ? */
- void workshop_perform_verb(char *verb, void *clientData);
- void workshop_send_message(char *buf);
- 
- 
- #ifdef NOHANDS_SUPPORT_FUNCTIONS
- /* The following functions are needed to run the WorkShop testsuite
-  * with this editor. You don't need to implement these unless you
-  * intend for your editor to be run by Workshop's testsuite.
-  * getcursorrow should return the number of lines from the top of
-  * the window the cursor is; similarly for getcursorcol.
-  */
- char *workshop_test_getcurrentfile();
- int workshop_test_getcursorrow();
- int workshop_test_getcursorcol();
- char *workshop_test_getcursorrowtext();
- char *workshop_test_getselectedtext();
- #endif
- 
- /*
-  * Struct used to set/unset the sensitivity of verbs.
-  */
- typedef struct {
- 	char		*verb;
- 	Boolean		sense;
- } VerbSense;
- 
- #ifdef  __cplusplus
- }
- #endif
- 
- #endif /* _INTEGRATION_H */
--- 0 ----
*** ../vim-8.1.0762/src/main.c	2019-01-14 21:51:17.987461933 +0100
--- src/main.c	2019-01-17 15:23:50.756769234 +0100
***************
*** 628,637 ****
       */
      if (gui.in_use)
      {
! # ifdef FEAT_SUN_WORKSHOP
! 	if (!usingSunWorkShop)
! # endif
! 	    gui_wait_for_chars(50L, typebuf.tb_change_cnt);
  	TIME_MSG("GUI delay");
      }
  #endif
--- 628,634 ----
       */
      if (gui.in_use)
      {
! 	gui_wait_for_chars(50L, typebuf.tb_change_cnt);
  	TIME_MSG("GUI delay");
      }
  #endif
***************
*** 983,991 ****
       */
      early_arg_scan(paramp);
  
- #ifdef FEAT_SUN_WORKSHOP
-     findYourself(paramp->argv[0]);
- #endif
  #if defined(FEAT_GUI)
      /* Prepare for possibly starting GUI sometime */
      gui_prepare(&paramp->argc, paramp->argv);
--- 980,985 ----
*** ../vim-8.1.0762/src/misc2.c	2019-01-13 23:38:33.403773217 +0100
--- src/misc2.c	2019-01-17 15:24:05.616693884 +0100
***************
*** 3411,3417 ****
  
  #if defined(FEAT_SESSION) || defined(FEAT_AUTOCHDIR) \
  	|| defined(MSWIN) || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_GTK) \
! 	|| defined(FEAT_SUN_WORKSHOP) || defined(FEAT_NETBEANS_INTG) \
  	|| defined(PROTO)
  /*
   * Change to a file's directory.
--- 3411,3417 ----
  
  #if defined(FEAT_SESSION) || defined(FEAT_AUTOCHDIR) \
  	|| defined(MSWIN) || defined(FEAT_GUI_MAC) || defined(FEAT_GUI_GTK) \
! 	|| defined(FEAT_NETBEANS_INTG) \
  	|| defined(PROTO)
  /*
   * Change to a file's directory.
*** ../vim-8.1.0762/src/nbdebug.c	2016-09-25 21:41:24.000000000 +0200
--- src/nbdebug.c	2019-01-17 15:24:41.628508930 +0100
***************
*** 42,48 ****
  /*
   * nbdebug_wait	-   This function can be used to delay or stop execution of vim.
   *		    It's normally used to delay startup while attaching a
!  *		    debugger to a running process. Since workshop starts gvim
   *		    from a background process this is the only way to debug
   *		    startup problems.
   */
--- 42,48 ----
  /*
   * nbdebug_wait	-   This function can be used to delay or stop execution of vim.
   *		    It's normally used to delay startup while attaching a
!  *		    debugger to a running process. Since NetBeans starts gvim
   *		    from a background process this is the only way to debug
   *		    startup problems.
   */
*** ../vim-8.1.0762/src/netbeans.c	2019-01-15 20:19:36.743904434 +0100
--- src/netbeans.c	2019-01-17 15:09:18.877769920 +0100
***************
*** 2273,2281 ****
  
      nbdebug(("    COLONCMD %s\n", buf));
  
- /*     ALT_INPUT_LOCK_ON; */
      do_cmdline((char_u *)buf, NULL, NULL, DOCMD_NOWAIT | DOCMD_KEYTYPED);
- /*     ALT_INPUT_LOCK_OFF; */
  
      setcursor();		/* restore the cursor position */
      out_flush_cursor(TRUE, FALSE);
--- 2273,2279 ----
*** ../vim-8.1.0762/src/proto.h	2019-01-15 20:19:36.743904434 +0100
--- src/proto.h	2019-01-17 15:26:51.439817568 +0100
***************
*** 295,303 ****
  #  ifdef FEAT_GUI_PHOTON
  #   include "gui_photon.pro"
  #  endif
- #  ifdef FEAT_SUN_WORKSHOP
- #   include "workshop.pro"
- #  endif
  # endif	/* FEAT_GUI */
  
  # ifdef FEAT_OLE
--- 295,300 ----
*** ../vim-8.1.0762/src/proto/workshop.pro	2018-05-17 13:52:57.000000000 +0200
--- src/proto/workshop.pro	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,49 ****
- /* workshop.c */
- void workshop_init(void);
- void workshop_postinit(void);
- void ex_wsverb(exarg_T *eap);
- char *workshop_get_editor_name(void);
- char *workshop_get_editor_version(void);
- void workshop_load_file(char *filename, int line, char *frameid);
- void workshop_reload_file(char *filename, int line);
- void workshop_show_file(char *filename);
- void workshop_goto_line(char *filename, int lineno);
- void workshop_front_file(char *filename);
- void workshop_save_file(char *filename);
- void workshop_save_files(void);
- void workshop_quit(void);
- void workshop_minimize(void);
- void workshop_maximize(void);
- void workshop_add_mark_type(int idx, char *colorspec, char *sign);
- void workshop_set_mark(char *filename, int lineno, int markId, int idx);
- void workshop_change_mark_type(char *filename, int markId, int idx);
- void workshop_goto_mark(char *filename, int markId, char *message);
- void workshop_delete_mark(char *filename, int markId);
- int workshop_get_mark_lineno(char *filename, int markId);
- void workshop_moved_marks(char *filename);
- int workshop_get_font_height(void);
- void workshop_footer_message(char *message, int severity);
- void workshop_menu_begin(char *label);
- void workshop_submenu_begin(char *label);
- void workshop_submenu_end(void);
- void workshop_menu_item(char *label, char *verb, char *accelerator, char *acceleratorText, char *name, char *filepos, char *sensitive);
- void workshop_menu_end(void);
- void workshop_toolbar_begin(void);
- void workshop_toolbar_end(void);
- void workshop_toolbar_button(char *label, char *verb, char *senseVerb, char *filepos, char *help, char *sense, char *file, char *left);
- void workshop_frame_sensitivities(VerbSense *vs);
- void workshop_set_option(char *option, char *value);
- void workshop_balloon_mode(Boolean on);
- void workshop_balloon_delay(int delay);
- void workshop_show_balloon_tip(char *tip);
- void workshop_hotkeys(Boolean on);
- int workshop_get_positions(void *clientData, char **filename, int *curLine, int *curCol, int *selStartLine, int *selStartCol, int *selEndLine, int *selEndCol, int *selLength, char **selection);
- char *workshop_test_getcurrentfile(void);
- int workshop_test_getcursorrow(void);
- int workshop_test_getcursorcol(void);
- char *workshop_test_getcursorrowtext(void);
- char *workshop_test_getselectedtext(void);
- void workshop_save_sensitivity(char *filename);
- void workshop_beval_cb(BalloonEval *beval, int state);
- void findYourself(char *argv0);
- /* vim: set ft=c : */
--- 0 ----
*** ../vim-8.1.0762/src/ui.c	2019-01-17 14:11:56.434600704 +0100
--- src/ui.c	2019-01-17 15:25:20.972303268 +0100
***************
*** 1625,1634 ****
   * descriptions which would otherwise overflow.  The buffer is considered full
   * when only this extra space (or part of it) remains.
   */
! #if defined(FEAT_SUN_WORKSHOP) || defined(FEAT_JOB_CHANNEL) \
! 	|| defined(FEAT_CLIENTSERVER)
     /*
!     * Sun WorkShop and NetBeans stuff debugger commands into the input buffer.
      * This requires a larger buffer...
      * (Madsen) Go with this for remote input as well ...
      */
--- 1625,1633 ----
   * descriptions which would otherwise overflow.  The buffer is considered full
   * when only this extra space (or part of it) remains.
   */
! #if defined(FEAT_JOB_CHANNEL) || defined(FEAT_CLIENTSERVER)
     /*
!     * NetBeans stuffs debugger commands into the input buffer.
      * This requires a larger buffer...
      * (Madsen) Go with this for remote input as well ...
      */
*** ../vim-8.1.0762/src/version.c	2019-01-17 14:31:10.190919265 +0100
--- src/version.c	2019-01-17 15:39:12.143436999 +0100
***************
*** 598,608 ****
  #else
  	"-statusline",
  #endif
- #ifdef FEAT_SUN_WORKSHOP
- 	"+sun_workshop",
- #else
  	"-sun_workshop",
- #endif
  #ifdef FEAT_SYN_HL
  	"+syntax",
  #else
--- 598,604 ----
*** ../vim-8.1.0762/src/vim.h	2019-01-13 23:38:33.415773131 +0100
--- src/vim.h	2019-01-17 15:27:00.275769256 +0100
***************
*** 288,297 ****
  # include "os_qnx.h"
  #endif
  
- #ifdef FEAT_SUN_WORKSHOP
- # include "workshop.h"
- #endif
- 
  #ifdef X_LOCALE
  # include <X11/Xlocale.h>
  #else
--- 288,293 ----
***************
*** 2236,2249 ****
  # define vim_realloc(ptr, size)  realloc((ptr), (size))
  #endif
  
- /*
-  * The following macros stop display/event loop nesting at the wrong time.
-  */
- #ifdef ALT_X_INPUT
- # define ALT_INPUT_LOCK_OFF	suppress_alternate_input = FALSE
- # define ALT_INPUT_LOCK_ON	suppress_alternate_input = TRUE
- #endif
- 
  #ifdef FEAT_MBYTE
  /*
   * Return byte length of character that starts with byte "b".
--- 2232,2237 ----
*** ../vim-8.1.0762/src/workshop.c	2018-12-21 15:16:57.483579762 +0100
--- src/workshop.c	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,1830 ****
- /* vi:set ts=8 sts=4 sw=4 noet:
-  *
-  * VIM - Vi IMproved	by Bram Moolenaar
-  *			Visual Workshop integration by Gordon Prieur
-  *
-  * Do ":help uganda"  in Vim to read copying and usage conditions.
-  * Do ":help credits" in Vim to see a list of people who contributed.
-  * See README.txt for an overview of the Vim source code.
-  */
- 
- #include "protodef.h"
- #ifdef HAVE_CONFIG_H
- # include "auto/config.h"
- #endif
- #include <stdio.h>
- #include <stdlib.h>
- #include <sys/types.h>
- #include <netdb.h>
- #include <netinet/in.h>
- #include <sys/socket.h>
- #ifdef HAVE_LIBGEN_H
- # include <libgen.h>
- #endif
- #include <unistd.h>
- #include <string.h>
- #include <stdlib.h>
- #include <ctype.h>
- 
- #include <X11/Intrinsic.h>
- #include <Xm/Xm.h>
- #include <Xm/PushB.h>
- 
- #include "integration.h"	/* <EditPlugin/integration.h> */
- 
- #include "vim.h"
- #include "version.h"
- #include "workshop.h"
- 
- void		 workshop_hotkeys(Boolean);
- 
- static Boolean	 isShowing(int);
- static win_T	*get_window(buf_T *);
- static void	 updatePriority(Boolean);
- static char	*addUniqueMnemonic(char *, char *);
- static char	*fixup(char *);
- static char	*get_selection(buf_T *);
- static char	*append_selection(int, char *, int *, int *);
- static void	 load_window(char *, int lnum);
- static void	 warp_to_pc(int);
- #ifdef FEAT_BEVAL_GUI
- void		 workshop_beval_cb(BalloonEval *, int);
- # ifdef FEAT_VARTABS
- static int	 computeIndex(int, char_u *, int, int *);
- # else
- static int	 computeIndex(int, char_u *, int);
- # endif
- #endif
- static char	*fixAccelText(char *);
- static void	 addMenu(char *, char *, char *);
- static char	*lookupVerb(char *, int);
- static void	 coloncmd(char *, Boolean);
- 
- extern Widget	 vimShell;
- extern Widget	 textArea;
- extern XtAppContext app_context;
- 
- static int	 tbpri;			/* ToolBar priority */
- int		 usingSunWorkShop = 0;	/* set if -ws flag is used */
- char		 curMenuName[BUFSIZ];
- char		 curMenuPriority[BUFSIZ];
- 
- static Boolean	 workshopInitDone = False;
- static Boolean	 workshopHotKeysEnabled = False;
- 
- /*
-  * The following enum is from <gp_dbx/gp_dbx_common.h>. We can't include it
-  * here because it's C++.
-  */
- enum
- {
-     GPLineEval_EVALUATE,		/* evaluate expression */
-     GPLineEval_INDIRECT,		/* evaluate *<expression> */
-     GPLineEval_TYPE			/* type of expression */
- };
- 
- /*
-  * Store each verb in the MenuMap. This lets us map from a verb to a menu.
-  * There may be multiple matches for a single verb in this table.
-  */
- #define MENU_INC	50		/* menuMap incremental size increases */
- typedef struct
- {
-     char	*name;			/* name of the menu */
-     char	*accel;			/* optional accelerator key */
-     char	*verb;			/* menu verb */
- } MenuMap;
- static MenuMap	*menuMap;		/* list of verb/menu mappings */
- static int	 menuMapSize;		/* current size of menuMap */
- static int	 menuMapMax;		/* allocated size of menuMap */
- static char	*initialFileCmd;	/* save command but defer doing it */
- 
- 
-     void
- workshop_init(void)
- {
-     char_u	 buf[64];
-     int		 is_dirty = FALSE;
-     int		 width, height;
-     XtInputMask	 mask;
- 
-     /*
-      * Turn on MenuBar, ToolBar, and Footer.
-      */
-     STRCPY(buf, p_go);
-     if (vim_strchr(p_go, GO_MENUS) == NULL)
-     {
- 	STRCAT(buf, "m");
- 	is_dirty = TRUE;
-     }
-     if (vim_strchr(p_go, GO_TOOLBAR) == NULL)
-     {
- 	STRCAT(buf, "T");
- 	is_dirty = TRUE;
-     }
-     if (vim_strchr(p_go, GO_FOOTER) == NULL)
-     {
- 	STRCAT(buf, "F");
- 	is_dirty = TRUE;
-     }
-     if (is_dirty)
- 	set_option_value((char_u *)"go", 0L, buf, 0);
- 
-     /*
-      * Set size from workshop_get_width_height().
-      */
-     width = height = 0;
-     if (workshop_get_width_height(&width, &height))
-     {
- 	XtVaSetValues(vimShell,
- 		XmNwidth, width,
- 		XmNheight, height,
- 		NULL);
-     }
- 
-     /*
-      * Now read in the initial messages from eserve.
-      */
-     while ((mask = XtAppPending(app_context))
- 	    && (mask & XtIMAlternateInput) && !workshopInitDone)
- 	XtAppProcessEvent(app_context, (XtInputMask)XtIMAlternateInput);
- }
- 
-     void
- workshop_postinit(void)
- {
-     do_cmdline_cmd((char_u *)initialFileCmd);
-     ALT_INPUT_LOCK_OFF;
-     free(initialFileCmd);
-     initialFileCmd = NULL;
- }
- 
-     void
- ex_wsverb(exarg_T *eap)
- {
-     msg_clr_cmdline();
-     workshop_perform_verb((char *) eap->arg, NULL);
- }
- 
- /*
-  * Editor name
-  * This string is recognized by eserve and should be all lower case.
-  * This is how the editor detects that it is talking to gvim instead
-  * of NEdit, for example, when the connection is initiated from the editor.
-  */
-     char *
- workshop_get_editor_name(void)
- {
-     return "gvim";
- }
- 
- /*
-  * Version number of the editor.
-  * This number is communicated along with the protocol
-  * version to the application.
-  */
-     char *
- workshop_get_editor_version(void)
- {
-     return Version;
- }
- 
- /*
-  * Answer functions: called by eserve
-  */
- 
- /*
-  * Name:
-  *	workshop_load_file
-  *
-  * Function:
-  *	Load a given file into the WorkShop buffer.
-  */
-     void
- workshop_load_file(
- 	char	*filename,		/* the file to load */
- 	int	 line,			/* an optional line number (or 0) */
- 	char	*frameid UNUSED)	/* used for multi-frame support */
- {
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_load_file(%s, %d)\n", filename, line);
- #endif
- 
- #ifdef FEAT_BEVAL_GUI
-     bevalServers |= BEVAL_WORKSHOP;
- #endif
- 
-     load_window(filename, line);
- }
- 
- /*
-  * Reload the WorkShop buffer
-  */
-     void
- workshop_reload_file(
- 	char	*filename,
- 	int	 line)
- {
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_reload_file(%s, %d)\n", filename, line);
- #endif
-     load_window(filename, line);
- }
- 
-     void
- workshop_show_file(
-     char	*filename)
- {
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_show_file(%s)\n", filename);
- #endif
- 
-     load_window(filename, 0);
- }
- 
-     void
- workshop_goto_line(
-     char	*filename,
-     int		 lineno)
- {
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_goto_line(%s, %d)\n", filename, lineno);
- #endif
- 
-     load_window(filename, lineno);
- }
- 
-     void
- workshop_front_file(
- 	char	*filename UNUSED)
- {
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_front_file()\n");
- #endif
-     /*
-      * Assumption: This function will always be called after a call to
-      * workshop_show_file(), so the file is always showing.
-      */
-     if (vimShell != NULL)
- 	XRaiseWindow(gui.dpy, XtWindow(vimShell));
- }
- 
-     void
- workshop_save_file(
- 	    char	*filename)
- {
-     char	 cbuf[BUFSIZ];		/* build vim command here */
- 
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_save_file(%s)\n", filename);
- #endif
- 
-     /* Save the given file */
-     vim_snprintf(cbuf, sizeof(cbuf), "w %s", filename);
-     coloncmd(cbuf, TRUE);
- }
- 
-     void
- workshop_save_files(void)
- {
-     /* Save the given file */
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_save_files()\n");
- #endif
- 
-     add_to_input_buf((char_u *) ":wall\n", 6);
- }
- 
-     void
- workshop_quit(void)
- {
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_quit()\n");
- #endif
- 
-     add_to_input_buf((char_u *) ":qall\n", 6);
- }
- 
-     void
- workshop_minimize(void)
- {
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_minimize()\n");
- #endif
-     workshop_minimize_shell(vimShell);
- }
-     void
- workshop_maximize(void)
- {
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_maximize()\n");
- #endif
- 
-     workshop_maximize_shell(vimShell);
- }
- 
-     void
- workshop_add_mark_type(
- 	int		 idx,
- 	char		*colorspec,
- 	char		*sign)
- {
-     char	 gbuf[BUFSIZ];	/* buffer for sign name */
-     char	 cibuf[BUFSIZ];	/* color information */
-     char	 cbuf[BUFSIZ];	/* command buffer */
-     char	*bp;
- 
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
-     {
- 	char *cp;
- 
- 	cp = strrchr(sign, '/');
- 	if (cp == NULL)
- 	    cp = sign;
- 	else
- 	    cp++;		/* skip '/' character */
- 	wstrace("workshop_add_mark_type(%d, \"%s\", \"%s\")\n", idx,
- 		colorspec && *colorspec ? colorspec : "<None>", cp);
-     }
- #endif
- 
-     /*
-      * Isolate the basename of sign in gbuf. We will use this for the
-      * GroupName in the highlight command sent to vim.
-      */
-     STRCPY(gbuf, gettail((char_u *)sign));
-     bp = strrchr(gbuf, '.');
-     if (bp != NULL)
- 	*bp = NUL;
- 
-     if (gbuf[0] != '-' && gbuf[1] != NUL)
-     {
- 	if (colorspec != NULL && *colorspec)
- 	{
- 	    vim_snprintf(cbuf, sizeof(cbuf),
- 				  "highlight WS%s guibg=%s", gbuf, colorspec);
- 	    coloncmd(cbuf, FALSE);
- 	    vim_snprintf(cibuf, sizeof(cibuf), "linehl=WS%s", gbuf);
- 	}
- 	else
- 	    cibuf[0] = NUL;
- 
- 	vim_snprintf(cbuf, sizeof(cbuf),
- 			       "sign define %d %s icon=%s", idx, cibuf, sign);
- 	coloncmd(cbuf, TRUE);
-     }
- }
- 
-     void
- workshop_set_mark(
- 	char		*filename,	/* filename which gets the mark */
- 	int		 lineno,	/* line number which gets the mark */
- 	int		 markId,	/* unique mark identifier */
- 	int		 idx)		/* which mark to use */
- {
-     char	cbuf[BUFSIZ];	/* command buffer */
- 
-     /* Set mark in a given file */
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_set_mark(%s, %d (ln), %d (id), %d (idx))\n",
- 		filename, lineno, markId, idx);
- #endif
- 
-     vim_snprintf(cbuf, sizeof(cbuf), "sign place %d line=%d name=%d file=%s",
- 					       markId, lineno, idx, filename);
-     coloncmd(cbuf, TRUE);
- }
- 
-     void
- workshop_change_mark_type(
- 	char		*filename,	/* filename which gets the mark */
- 	int		 markId,	/* unique mark identifier */
- 	int		 idx)		/* which mark to use */
- {
-     char	cbuf[BUFSIZ];	/* command buffer */
- 
-     /* Change mark type */
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_change_mark_type(%s, %d, %d)\n",
- 		filename, markId, idx);
- #endif
- 
-     vim_snprintf(cbuf, sizeof(cbuf),
- 		      "sign place %d name=%d file=%s", markId, idx, filename);
-     coloncmd(cbuf, TRUE);
- }
- 
- /*
-  * Goto the given mark in a file (e.g. show it).
-  * If message is not null, display it in the footer.
-  */
-     void
- workshop_goto_mark(
- 	char		*filename,
- 	int		 markId,
- 	char		*message)
- {
-     char	cbuf[BUFSIZ];	/* command buffer */
- 
-     /* Goto mark */
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_goto_mark(%s, %d (id), %s)\n",
- 		filename, markId, message && *message &&
- 		!(*message == ' ' && message[1] == NULL) ?
- 		message : "<None>");
- #endif
- 
-     vim_snprintf(cbuf, sizeof(cbuf), "sign jump %d file=%s", markId, filename);
-     coloncmd(cbuf, TRUE);
-     if (message != NULL && *message != NUL)
- 	gui_mch_set_footer((char_u *)message);
- }
- 
-     void
- workshop_delete_mark(
- 	char		*filename,
- 	int		 markId)
- {
-     char	cbuf[BUFSIZ];	/* command buffer */
- 
-     /* Delete mark */
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_delete_mark(%s, %d (id))\n",
- 		filename, markId);
- #endif
- 
-     vim_snprintf(cbuf, sizeof(cbuf),
- 				 "sign unplace %d file=%s", markId, filename);
-     coloncmd(cbuf, TRUE);
- }
- 
-     int
- workshop_get_mark_lineno(
- 	char	*filename,
- 	int	 markId)
- {
-     buf_T	*buf;		/* buffer containing filename */
-     int		lineno;		/* line number of filename in buf */
- 
-     /* Get mark line number */
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_get_mark_lineno(%s, %d)\n",
- 		filename, markId);
- #endif
- 
-     lineno = 0;
-     buf = buflist_findname((char_u *)filename);
-     if (buf != NULL)
- 	lineno = buf_findsign(buf, markId, NULL);
- 
-     return lineno;
- }
- 
- 
- /*
-  * Are there any moved marks? If so, call workshop_move_mark on
-  * each of them now. This is how eserve can find out if for example
-  * breakpoints have moved when a program has been recompiled and
-  * reloaded into dbx.
-  */
-     void
- workshop_moved_marks(char *filename UNUSED)
- {
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("XXXworkshop_moved_marks(%s)\n", filename);
- #endif
- }
- 
-     int
- workshop_get_font_height(void)
- {
-     XmFontList	 fontList;	/* fontList made from gui.norm_font */
-     XmString	 str;
-     Dimension	 w;
-     Dimension	 h;
- 
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_get_font_height()\n");
- #endif
- 
-     /* Pick the proper signs for this font size */
-     fontList = gui_motif_create_fontlist((XFontStruct *)gui.norm_font);
-     h = 0;
-     if (fontList != NULL)
-     {
- 	str = XmStringCreateLocalized("A");
- 	XmStringExtent(fontList, str, &w, &h);
- 	XmStringFree(str);
- 	XmFontListFree(fontList);
-     }
- 
-     return (int)h;
- }
- 
-     void
- workshop_footer_message(
- 	char	*message,
- 	int	severity UNUSED)	/* severity is currently unused */
- {
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_footer_message(%s, %d)\n", message, severity);
- #endif
- 
-     gui_mch_set_footer((char_u *) message);
- }
- 
- /*
-  * workshop_menu_begin() is passed the menu name. We determine its mnemonic
-  * here and store its name and priority.
-  */
-     void
- workshop_menu_begin(
- 	char		*label)
- {
-     vimmenu_T	*menu;			/* pointer to last menu */
-     int		menuPriority = 0;	/* priority of new menu */
-     char	mnembuf[64];		/* store menubar mnemonics here */
-     char	*name;			/* label with a mnemonic */
-     char	*p;			/* used to find mnemonics */
-     int		idx;			/* index into mnembuf */
- 
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_menu_begin()\n");
- #endif
- 
-     /*
-      * Look through all existing (non-PopUp and non-Toolbar) menus
-      * and gather their mnemonics. Use this list to decide what
-      * mnemonic should be used for label.
-      */
- 
-     idx = 0;
-     mnembuf[idx++] = 'H';		/* H is mnemonic for Help */
-     for (menu = root_menu; menu != NULL; menu = menu->next)
-     {
- 	if (menu_is_menubar(menu->name))
- 	{
- 	    p = strchr((char *)menu->name, '&');
- 	    if (p != NULL)
- 		mnembuf[idx++] = *++p;
- 	}
- 	if (menu->next != NULL
- 		&& strcmp((char *) menu->next->dname, "Help") == 0)
- 	{
- 	    menuPriority = menu->priority + 10;
- 	    break;
- 	}
-     }
-     mnembuf[idx++] = NUL;
-     name = addUniqueMnemonic(mnembuf, label);
- 
-     vim_snprintf(curMenuName, sizeof(curMenuName), "%s", name);
-     sprintf(curMenuPriority, "%d.0", menuPriority);
- }
- 
- /*
-  * Append the name and priority to strings to be used in vim menu commands.
-  */
-     void
- workshop_submenu_begin(
- 	char		*label)
- {
- #ifdef WSDEBUG_TRACE
-     if (ws_debug  && ws_dlevel & WS_TRACE
- 	    && strncmp(curMenuName, "ToolBar", 7) != 0)
- 	wstrace("workshop_submenu_begin(%s)\n", label);
- #endif
- 
-     strcat(curMenuName, ".");
-     strcat(curMenuName, fixup(label));
- 
-     updatePriority(True);
- }
- 
- /*
-  * Remove the submenu name and priority from curMenu*.
-  */
- 
-     void
- workshop_submenu_end(void)
- {
-     char		*p;
- 
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE)
- 	    && strncmp(curMenuName, "ToolBar", 7) != 0)
- 	wstrace("workshop_submenu_end()\n");
- #endif
- 
-     p = strrchr(curMenuPriority, '.');
-     ASSERT(p != NULL);
-     *p = NUL;
- 
-     p = strrchr(curMenuName, '.');
-     ASSERT(p != NULL);
-     *p = NUL;
- }
- 
- /*
-  * This is where menus are really made. Each item will generate an amenu vim
-  * command. The globals curMenuName and curMenuPriority contain the name and
-  * priority of the parent menu tree.
-  */
-     void
- workshop_menu_item(
- 	char		*label,
- 	char		*verb,
- 	char		*accelerator UNUSED,
- 	char		*acceleratorText,
- 	char		*name UNUSED,
- 	char		*filepos UNUSED,
- 	char		*sensitive)
- {
-     char		 cbuf[BUFSIZ];
-     char		 namebuf[BUFSIZ];
-     char		 accText[BUFSIZ];
- 
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE)
- 	    && strncmp(curMenuName, "ToolBar", 7) != 0)
-     {
- 	if (ws_dlevel & WS_TRACE_VERBOSE)
- 	    wsdebug("workshop_menu_item(\n"
- 		    "\tlabel = \"%s\",\n"
- 		    "\tverb = %s,\n"
- 		    "\taccelerator = %s,\n"
- 		    "\tacceleratorText = \"%s\",\n"
- 		    "\tname = %s,\n"
- 		    "\tfilepos = %s,\n"
- 		    "\tsensitive = %s)\n",
- 		    label && *label ? label : "<None>",
- 		    verb && *verb ? verb : "<None>",
- 		    accelerator && *accelerator ?
- 		    accelerator : "<None>",
- 		    acceleratorText && *acceleratorText ?
- 		    acceleratorText : "<None>",
- 		    name && *name ? name : "<None>",
- 		    filepos && *filepos ? filepos : "<None>",
- 		    sensitive);
- 	else if (ws_dlevel & WS_TRACE)
- 	    wstrace("workshop_menu_item(\"%s\", %s)\n",
- 		    label && *label ? label : "<None>",
- 		    verb && *verb ? verb : "<None>", sensitive);
-     }
- #endif
- #ifdef WSDEBUG_SENSE
-     if (ws_debug)
- 	wstrace("menu:   %-21.20s%-21.20s(%s)\n", label, verb,
- 		*sensitive == '1' ? "Sensitive" : "Insensitive");
- #endif
- 
-     if (acceleratorText != NULL)
- 	vim_snprintf(accText, sizeof(accText), "<Tab>%s", acceleratorText);
-     else
- 	accText[0] = NUL;
-     updatePriority(False);
-     vim_snprintf(namebuf, sizeof(namebuf), "%s.%s", curMenuName, fixup(label));
-     vim_snprintf(cbuf, sizeof(cbuf), "amenu %s %s%s\t:wsverb %s<CR>",
- 	    curMenuPriority, namebuf, accText, verb);
- 
-     coloncmd(cbuf, TRUE);
-     addMenu(namebuf, fixAccelText(acceleratorText), verb);
- 
-     if (*sensitive == '0')
-     {
- 	vim_snprintf(cbuf, sizeof(cbuf), "amenu disable %s", namebuf);
- 	coloncmd(cbuf, TRUE);
-     }
- }
- 
- /*
-  * This function is called when a complete WorkShop menu description has been
-  * sent over from eserve. We do some menu cleanup.
-  */
- 
-     void
- workshop_menu_end(void)
- {
-     Boolean		 using_tearoff;	/* set per current option setting */
- 
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_menu_end()\n");
- #endif
- 
-     using_tearoff = vim_strchr(p_go, GO_TEAROFF) != NULL;
-     gui_mch_toggle_tearoffs(using_tearoff);
- }
- 
-     void
- workshop_toolbar_begin(void)
- {
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_toolbar_begin()\n");
- #endif
- 
-     coloncmd("aunmenu ToolBar", True);
-     tbpri = 10;
- }
- 
-     void
- workshop_toolbar_end(void)
- {
-     char_u	buf[64];
- 
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
-     {
- 	wstrace("workshop_toolbar_end()\n");
-     }
- #endif
- 
-     /*
-      * Turn on ToolBar.
-      */
-     STRCPY(buf, p_go);
-     if (vim_strchr(p_go, 'T') == NULL)
-     {
- 	STRCAT(buf, "T");
- 	set_option_value((char_u *)"go", 0L, buf, 0);
-     }
-     workshopInitDone = True;
- }
- 
-     void
- workshop_toolbar_button(
- 	char	*label,
- 	char	*verb,
- 	char	*senseVerb UNUSED,
- 	char	*filepos UNUSED,
- 	char	*help,
- 	char	*sense,
- 	char	*file,
- 	char	*left)
- {
-     char	cbuf[BUFSIZ + MAXPATHLEN];
-     char	namebuf[BUFSIZ];
-     static int	tbid = 1;
-     char_u	*p;
- 
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE))
- 	wsdebug("workshop_toolbar_button(\"%s\", %s, %s,\n"
- 		"\t%s, \"%s\", %s,\n\t\"%s\",\n\t<%s>)\n",
- 		label   && *label   ? label   : "<None>",
- 		verb    && *verb    ? verb    : "<None>",
- 		senseVerb && *senseVerb    ? senseVerb    : "<None>",
- 		filepos && *filepos ? filepos : "<None>",
- 		help    && *help    ? help    : "<None>",
- 		sense   && *sense   ? sense   : "<None>",
- 		file    && *file    ? file    : "<None>",
- 		left    && *left    ? left    : "<None>");
-     else if (WSDLEVEL(WS_TRACE))
- 	wstrace("workshop_toolbar_button(\"%s\", %s)\n",
- 		label   && *label   ? label   : "<None>",
- 		verb    && *verb    ? verb    : "<None>");
- #endif
- #ifdef WSDEBUG_SENSE
-     if (ws_debug)
- 	wsdebug("button: %-21.20s%-21.20s(%s)\n", label, verb,
- 		*sense == '1' ? "Sensitive" : "Insensitive");
- #endif
- 
-     if (left && *left && atoi(left) > 0)
-     {
- 	/* Add a separator (but pass the width passed after the ':') */
- 	sprintf(cbuf, "amenu 1.%d ToolBar.-sep%d:%s- <nul>",
- 		tbpri - 5, tbid++, left);
- 
- 	coloncmd(cbuf, True);
-     }
- 
-     p = vim_strsave_escaped((char_u *)label, (char_u *)"\\. ");
-     vim_snprintf(namebuf, sizeof(namebuf), "ToolBar.%s", p);
-     vim_free(p);
-     STRCPY(cbuf, "amenu <silent> ");
-     if (file != NULL && *file != NUL)
-     {
- 	p = vim_strsave_escaped((char_u *)file, (char_u *)" ");
- 	vim_snprintf_add(cbuf, sizeof(cbuf), "icon=%s ", p);
- 	vim_free(p);
-     }
-     vim_snprintf_add(cbuf, sizeof(cbuf),"1.%d %s :wsverb %s<CR>",
- 							tbpri, namebuf, verb);
- 
-     /* Define the menu item */
-     coloncmd(cbuf, True);
- 
-     if (*sense == '0')
-     {
- 	/* If menu isn't sensitive at startup... */
- 	vim_snprintf(cbuf, sizeof(cbuf), "amenu disable %s", namebuf);
- 	coloncmd(cbuf, True);
-     }
- 
-     if (help && *help)
-     {
- 	/* Do the tooltip */
- 	vim_snprintf(cbuf, sizeof(cbuf), "tmenu %s %s", namebuf, help);
- 	coloncmd(cbuf, True);
-     }
- 
-     addMenu(namebuf, NULL, verb);
-     tbpri += 10;
- }
- 
-     void
- workshop_frame_sensitivities(
- 	VerbSense	*vs)		/* list of verbs to (de)sensitize */
- {
-     VerbSense	*vp;		/* iterate through vs */
-     char	*menu_name;	/* used in menu lookup */
-     int		 cnt;		/* count of verbs to skip */
-     int		 len;		/* length of nonvariant part of command */
-     char	 cbuf[4096];
- 
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE) || WSDLEVEL(4))
-     {
- 	wsdebug("workshop_frame_sensitivities(\n");
- 	for (vp = vs; vp->verb != NULL; vp++)
- 	    wsdebug("\t%-25s%d\n", vp->verb, vp->sense);
- 	wsdebug(")\n");
-     }
-     else if (WSDLEVEL(WS_TRACE))
- 	wstrace("workshop_frame_sensitivities()\n");
- #endif
- #ifdef WSDEBUG_SENSE
-     if (ws_debug)
- 	for (vp = vs; vp->verb != NULL; vp++)
- 	    wsdebug("change: %-21.20s%-21.20s(%s)\n",
- 		    "", vp->verb, vp->sense == 1 ?
- 		    "Sensitive" : "Insensitive");
- #endif
- 
-     /*
-      * Look for all matching menu entries for the verb. There may be more
-      * than one if the verb has both a menu and toolbar entry.
-      */
-     for (vp = vs; vp->verb != NULL; vp++)
-     {
- 	cnt = 0;
- 	strcpy(cbuf, "amenu");
- 	strcat(cbuf, " ");
- 	strcat(cbuf, vp->sense ? "enable" : "disable");
- 	strcat(cbuf, " ");
- 	len = strlen(cbuf);
- 	while ((menu_name = lookupVerb(vp->verb, cnt++)) != NULL)
- 	{
- 	    strcpy(&cbuf[len], menu_name);
- 	    coloncmd(cbuf, FALSE);
- 	}
-     }
-     gui_update_menus(0);
-     gui_mch_flush();
- }
- 
-     void
- workshop_set_option(
- 	char	*option,		/* name of a supported option */
- 	char	*value)			/* value to set option to */
- {
-     char	 cbuf[BUFSIZ];		/* command buffer */
- 
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
-     {
- 	wstrace("workshop_set_option(%s, %s)\n", option, value);
-     }
- #endif
- 
-     cbuf[0] = NUL;
-     switch (*option)		/* switch on 1st letter */
-     {
- 	case 's':
- 	    if (strcmp(option, "syntax") == 0)
- 		vim_snprintf(cbuf, sizeof(cbuf), "syntax %s", value);
- 	    else if (strcmp(option, "savefiles") == 0)
- 	    {
- 		/* XXX - Not yet implemented */
- 	    }
- 	    break;
- 
- 	case 'l':
- 	    if (strcmp(option, "lineno") == 0)
- 		sprintf(cbuf, "set %snu",
- 			(strcmp(value, "on") == 0) ? "" : "no");
- 	    break;
- 
- 	case 'p':
- 	    if (strcmp(option, "parentheses") == 0)
- 		sprintf(cbuf, "set %ssm",
- 			(strcmp(value, "on") == 0) ? "" : "no");
- 	    break;
- 
- 	case 'w':
- 	    /* this option is set by a direct call */
- #ifdef WSDEBUG
- 	    wsdebug("workshop_set_option: "
- 		    "Got unexpected workshopkeys option");
- #endif
- 	    break;
- 
- 	case 'b':	/* these options are set from direct calls */
- 	    if (option[7] == NUL && strcmp(option, "balloon") == 0)
- 	    {
- #ifdef WSDEBUG
- 		/* set by direct call to workshop_balloon_mode */
- 		wsdebug("workshop_set_option: "
- 			"Got unexpected ballooneval option");
- #endif
- 	    }
- 	    else if (strcmp(option, "balloondelay") == 0)
- 	    {
- #ifdef WSDEBUG
- 		/* set by direct call to workshop_balloon_delay */
- 		wsdebug("workshop_set_option: "
- 			"Got unexpected balloondelay option");
- #endif
- 	    }
- 	    break;
-     }
-     if (cbuf[0] != NUL)
- 	coloncmd(cbuf, TRUE);
- }
- 
- 
-     void
- workshop_balloon_mode(
- 	Boolean	 on)
- {
-     char	 cbuf[BUFSIZ];		/* command buffer */
- 
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_balloon_mode(%s)\n", on ? "True" : "False");
- #endif
- 
-     sprintf(cbuf, "set %sbeval", on ? "" : "no");
-     coloncmd(cbuf, TRUE);
- }
- 
- 
-     void
- workshop_balloon_delay(
- 	int	 delay)
- {
-     char	 cbuf[BUFSIZ];		/* command buffer */
- 
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_balloon_delay(%d)\n", delay);
- #endif
- 
-     sprintf(cbuf, "set bdlay=%d", delay);
-     coloncmd(cbuf, TRUE);
- }
- 
- 
-     void
- workshop_show_balloon_tip(
- 	char	*tip)
- {
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_show_balloon_tip(%s)\n", tip);
- #endif
- 
-     if (balloonEval != NULL)
- 	gui_mch_post_balloon(balloonEval, (char_u *)tip);
- }
- 
- 
-     void
- workshop_hotkeys(
- 	Boolean	on)
- {
-     char	 cbuf[BUFSIZ];		/* command buffer */
-     MenuMap	*mp;			/* iterate over menuMap entries */
- 
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_hotkeys(%s)\n", on ? "True" : "False");
- #endif
- 
-     workshopHotKeysEnabled = on;
-     if (workshopHotKeysEnabled)
- 	for (mp = menuMap; mp < &menuMap[menuMapSize]; mp++)
- 	{
- 	    if (mp->accel != NULL)
- 	    {
- 		vim_snprintf(cbuf, sizeof(cbuf),
- 			"map %s :wsverb %s<CR>", mp->accel, mp->verb);
- 		coloncmd(cbuf, TRUE);
- 	    }
- 	}
-     else
- 	for (mp = menuMap; mp < &menuMap[menuMapSize]; mp++)
- 	{
- 	    if (mp->accel != NULL)
- 	    {
- 		vim_snprintf(cbuf, sizeof(cbuf), "unmap %s", mp->accel);
- 		coloncmd(cbuf, TRUE);
- 	    }
- 	}
- }
- 
- /*
-  * A button in the toolbar has been pushed.
-  */
-     int
- workshop_get_positions(
- 	void		*clientData UNUSED,
- 	char	       **filename,	/* output data */
- 	int		*curLine,	/* output data */
- 	int		*curCol,	/* output data */
- 	int		*selStartLine,	/* output data */
- 	int		*selStartCol,	/* output data */
- 	int		*selEndLine,	/* output data */
- 	int		*selEndCol,	/* output data */
- 	int		*selLength,	/* output data */
- 	char	       **selection)	/* output data */
- {
-     static char	 ffname[MAXPATHLEN];
- 
- #ifdef WSDEBUG_TRACE
-     if (WSDLEVEL(WS_TRACE_VERBOSE | WS_TRACE))
- 	wstrace("workshop_get_positions(%#x, \"%s\", ...)\n",
- 		clientData, (curbuf && curbuf->b_sfname != NULL)
- 				      ? (char *)curbuf->b_sfname : "<None>");
- #endif
- 
-     if (curbuf->b_ffname == NULL)
- 	ffname[0] = NUL;
-     else
- 	/* copy so nobody can change b_ffname */
- 	strcpy(ffname, (char *) curbuf->b_ffname);
-     *filename = ffname;
-     *curLine = curwin->w_cursor.lnum;
-     *curCol = curwin->w_cursor.col;
- 
-     if (curbuf->b_visual.vi_mode == 'v' &&
- 	    EQUAL_POS(curwin->w_cursor, curbuf->b_visual.vi_end))
-     {
- 	*selStartLine = curbuf->b_visual.vi_start.lnum;
- 	*selStartCol = curbuf->b_visual.vi_start.col;
- 	*selEndLine = curbuf->b_visual.vi_end.lnum;
- 	*selEndCol = curbuf->b_visual.vi_end.col;
- 	*selection = get_selection(curbuf);
- 	if (*selection)
- 	    *selLength = strlen(*selection);
- 	else
- 	    *selLength = 0;
-     }
-     else
-     {
- 	*selStartLine = *selEndLine = -1;
- 	*selStartCol = *selEndCol = -1;
- 	*selLength = 0;
- 	*selection = "";
-     }
- 
-     return True;
- }
- 
- 
- 
- /************************************************************************
-  * Utility functions
-  ************************************************************************/
- 
-     static char *
- get_selection(
- 	buf_T		*buf)		/* buffer whose selection we want */
- {
-     pos_T	*start;		/* start of the selection */
-     pos_T	*end;		/* end of the selection */
-     char	*lp;		/* pointer to actual line data */
-     int		 llen;		/* length of actual line data */
-     char	*sp;		/* pointer to selection  buffer */
-     int		 slen;		/* string length in selection buffer */
-     int		 size;		/* size of selection buffer */
-     char	*new_sp;	/* temp pointer to new sp */
-     int		 lnum;		/* line number we are appending */
- 
-     if (buf->b_visual.vi_mode == 'v')
-     {
- 	start = &buf->b_visual.vi_start;
- 	end = &buf->b_visual.vi_end;
- 	if (start->lnum == end->lnum)
- 	{
- 	    /* selection is all on one line */
- 	    lp = (char *) ml_get_pos(start);
- 	    llen = end->col - start->col + 1;
- 	    sp = (char *) malloc(llen + 1);
- 	    if (sp != NULL)
- 	    {
- 		strncpy(sp, lp, llen);
- 		sp[llen] = NUL;
- 	    }
- 	}
- 	else
- 	{
- 	    /* multi-line selection */
- 	    lp = (char *) ml_get_pos(start);
- 	    llen = strlen(lp);
- 	    sp = (char *) malloc(BUFSIZ + llen);
- 	    if (sp != NULL)
- 	    {
- 		size = BUFSIZ + llen;
- 		strcpy(sp, lp);
- 		sp[llen] = '\n';
- 		slen = llen + 1;
- 
- 		lnum = start->lnum + 1;
- 		while (lnum < end->lnum)
- 		    sp = append_selection(lnum++, sp, &size, &slen);
- 
- 		lp = (char *) ml_get(end->lnum);
- 		llen = end->col + 1;
- 		if ((slen + llen) >= size)
- 		{
- 		    new_sp = (char *)
- 			realloc(sp, slen + llen + 1);
- 		    if (new_sp != NULL)
- 		    {
- 			size += llen + 1;
- 			sp = new_sp;
- 		    }
- 		}
- 		if ((slen + llen) < size)
- 		{
- 		    strncpy(&sp[slen], lp, llen);
- 		    sp[slen + llen] = NUL;
- 		}
- 
- 	    }
- 	}
-     }
-     else
- 	sp = NULL;
- 
-     return sp;
- }
- 
-     static char *
- append_selection(
- 	int		 lnum,		/* line number to append */
- 	char		*sp,		/* pointer to selection buffer */
- 	int		*size,		/* ptr to size of sp */
- 	int		*slen)		/* ptr to length of selection string */
- {
-     char	*lp;		/* line of data from buffer */
-     int		 llen;		/* strlen of lp */
-     char	*new_sp;	/* temp pointer to new sp */
- 
-     lp = (char *)ml_get((linenr_T)lnum);
-     llen = strlen(lp);
- 
-     if ((*slen + llen) <= *size)
-     {
- 	new_sp = (char *) realloc((void *) sp, BUFSIZ + *slen + llen);
- 	if (*new_sp != NUL)
- 	{
- 	    *size = BUFSIZ + *slen + llen;
- 	    sp = new_sp;
- 	}
-     }
-     if ((*slen + llen) > *size)
-     {
- 	strcat(&sp[*slen], lp);
- 	*slen += llen;
- 	sp[*slen++] = '\n';
-     }
- 
-     return sp;
- }
- 
- 
-     static void
- load_buffer_by_name(
- 	char	*filename,		/* the file to load */
- 	int	 lnum)			/* an optional line number (or 0) */
- {
-     char	 lnumbuf[16];		/* make line number option for :e */
-     char	 cbuf[BUFSIZ];		/* command buffer */
- 
-     if (lnum > 0)
- 	sprintf(lnumbuf, "+%d", lnum);
-     else
- 	lnumbuf[0] = NUL;
- 
-     vim_snprintf(cbuf, sizeof(cbuf), "e %s %s", lnumbuf, filename);
-     coloncmd(cbuf, False);
- }
- 
- 
-     static void
- load_window(
- 	char	*filename,		/* filename to load */
- 	int	 lnum)			/* linenumber to go to */
- {
-     buf_T	*buf;		/* buffer filename is stored in */
-     win_T	*win;		/* window filenme is displayed in */
- 
-     /*
-      * Make sure filename is displayed and is the current window.
-      */
- 
-     buf = buflist_findname((char_u *)filename);
-     if (buf == NULL || (win = get_window(buf)) == NULL)
-     {
- 	/* No buffer or buffer is not in current window */
- 	/* wsdebug("load_window: load_buffer_by_name(\"%s\", %d)\n",
- 		filename, lnum); */
- 	load_buffer_by_name(filename, lnum);
-     }
-     else
-     {
- 	/* buf is in a window */
- 	if (win != curwin)
- 	{
- 	    win_enter(win, False);
- 	    /* wsdebug("load_window: window enter %s\n",
- 		    win->w_buffer->b_sfname); */
- 	}
- 	if (lnum > 0 && win->w_cursor.lnum != lnum)
- 	{
- 	    warp_to_pc(lnum);
- 	    /* wsdebug("load_window: warp to %s[%d]\n",
- 		    win->w_buffer->b_sfname, lnum); */
- 	}
-     }
-     out_flush();
- }
- 
- 
- 
-     static void
- warp_to_pc(
- 	int	 lnum)			/* line number to warp to */
- {
-     char	 lbuf[256];		/* build line command here */
- 
-     if (lnum > 0)
-     {
- 	if (State & INSERT)
- 	    add_to_input_buf((char_u *) "\033", 1);
- 	if (isShowing(lnum))
- 	    sprintf(lbuf, "%dG", lnum);
- 	else
- 	    sprintf(lbuf, "%dz.", lnum);
- 	add_to_input_buf((char_u *) lbuf, strlen(lbuf));
-     }
- }
- 
-     static Boolean
- isShowing(
- 	int	 lnum)			/* tell if line number is showing */
- {
-     return lnum >= curwin->w_topline && lnum < curwin->w_botline;
- }
- 
- 
- 
-     static win_T *
- get_window(
- 	buf_T	*buf)		/* buffer to find window for */
- {
-     win_T	*wp = NULL;	/* window filename is in */
- 
-     FOR_ALL_WINDOWS(wp)
- 	if (buf == wp->w_buffer)
- 	    break;
-     return wp;
- }
- 
- 
-     static void
- updatePriority(
- 	Boolean		 subMenu)	/* if True then start new submenu pri */
- {
-     int		 pri;		/* priority of this menu/item */
-     char	*p;
- 
-     p = strrchr(curMenuPriority, '.');
-     ASSERT(p != NULL);
-     *p++ = NUL;
- 
-     pri = atoi(p) + 10;		/* our new priority */
- 
-     if (subMenu)
- 	vim_snprintf(curMenuPriority, sizeof(curMenuPriority),
- 					     "%s.%d.0", curMenuPriority, pri);
-     else
- 	vim_snprintf(curMenuPriority, sizeof(curMenuPriority),
- 					       "%s.%d", curMenuPriority, pri);
- }
- 
-     static char *
- addUniqueMnemonic(
- 	char		*mnemonics,	/* currently used mnemonics */
- 	char		*label)		/* label of menu needing mnemonic */
- {
-     static char	 name[BUFSIZ];	/* buffer for the updated name */
-     char	*p;		/* pointer into label */
-     char	*found;		/* pointer to possible mnemonic */
- 
-     found = NULL;
-     for (p = label; *p != NUL; p++)
- 	if (strchr(mnemonics, *p) == 0)
- 	    if (found == NULL || (isupper((int)*p) && islower((int)*found)))
- 		found = p;
- 
-     if (found != NULL)
-     {
- 	strncpy(name, label, (found - label));
- 	strcat(name, "&");
- 	strcat(name, found);
-     }
-     else
- 	strcpy(name, label);
- 
-     return name;
- }
- 
- /*
-  * Some characters in a menu name must be escaped in vim. Since this is vim
-  * specific, it must be done on this side.
-  */
-     static char *
- fixup(
- 	char		*label)
- {
-     static char	 buf[BUFSIZ];
-     char		*bp;		/* pointer into buf */
-     char		*lp;		/* pointer into label */
- 
-     lp = label;
-     bp = buf;
-     while (*lp != NUL)
-     {
- 	if (*lp == ' ' || *lp == '.')
- 	    *bp++ = '\\';
- 	*bp++ = *lp++;
-     }
-     *bp = NUL;
- 
-     return buf;
- }
- 
- 
- #ifdef NOHANDS_SUPPORT_FUNCTIONS
- 
- /* For the NoHands test suite */
- 
-     char *
- workshop_test_getcurrentfile(void)
- {
-     char	*filename, *selection;
-     int		curLine, curCol, selStartLine, selStartCol, selEndLine;
-     int		selEndCol, selLength;
- 
-     if (workshop_get_positions(
- 		NULL, &filename, &curLine, &curCol, &selStartLine,
- 		&selStartCol, &selEndLine, &selEndCol, &selLength,
- 		&selection))
- 	return filename;
-     else
- 	return NULL;
- }
- 
-     int
- workshop_test_getcursorrow(void)
- {
-     return 0;
- }
- 
-     int
- workshop_test_getcursorcol(void)
- {
-     char	*filename, *selection;
-     int		curLine, curCol, selStartLine, selStartCol, selEndLine;
-     int		selEndCol, selLength;
- 
-     if (workshop_get_positions(
- 		NULL, &filename, &curLine, &curCol, &selStartLine,
- 		&selStartCol, &selEndLine, &selEndCol, &selLength,
- 		&selection))
- 	return curCol;
-     else
- 	return -1;
- }
- 
-     char *
- workshop_test_getcursorrowtext(void)
- {
-     return NULL;
- }
- 
-     char *
- workshop_test_getselectedtext(void)
- {
-     char	*filename, *selection;
-     int		curLine, curCol, selStartLine, selStartCol, selEndLine;
-     int		selEndCol, selLength;
- 
-     if (workshop_get_positions(
- 		NULL, &filename, &curLine, &curCol, &selStartLine,
- 		&selStartCol, &selEndLine, &selEndCol, &selLength,
- 		&selection))
- 	return selection;
-     else
- 	return NULL;
- }
- 
-     void
- workshop_save_sensitivity(char *filename UNUSED)
- {
- }
- 
- #endif
- 
-     static char *
- fixAccelText(
- 	char		*ap)		/* original acceleratorText */
- {
-     char	buf[256];	/* build in temp buffer */
-     char	*shift;		/* shift string of "" */
- 
-     if (ap == NULL)
- 	return NULL;
- 
-     /* If the accelerator is shifted use the vim form */
-     if (strncmp("Shift+", ap, 6) == 0)
-     {
- 	shift = "S-";
- 	ap += 6;
-     }
-     else
- 	shift = "";
- 
-     if (*ap == 'F' && atoi(&ap[1]) > 0)
-     {
- 	vim_snprintf(buf, sizeof(buf), "<%s%s>", shift, ap);
- 	return strdup(buf);
-     }
-     else
- 	return NULL;
- }
- 
- #ifdef FEAT_BEVAL_GUI
-     void
- workshop_beval_cb(
- 	BalloonEval	*beval,
- 	int		 state)
- {
-     win_T	*wp;
-     char_u	*text;
-     int		 type;
-     linenr_T	 lnum;
-     int		 col;
-     int		 idx;
-     char	 buf[MAXPATHLEN * 2];
-     static int	 serialNo = -1;
- 
-     if (!p_beval)
- 	return;
- 
-     if (get_beval_info(beval, FALSE, &wp, &lnum, &text, &col) == OK)
-     {
- 	if (text && text[0])
- 	{
- 	    /* Send debugger request */
- 	    if (strlen((char *) text) > (MAXPATHLEN/2))
- 	    {
- 		/*
- 		 * The user has probably selected the entire
- 		 * buffer or something like that - don't attempt
- 		 * to evaluate it
- 		 */
- 		return;
- 	    }
- 
- 	    /*
- 	     * WorkShop expects the col to be a character index, not
- 	     * a column number. Compute the index from col. Also set
- 	     * line to 0 because thats what dbx expects.
- 	     */
- #ifdef FEAT_VARTABS
- 	    idx = computeIndex(col, text, beval->ts, beval->vts);
- #else
- 	    idx = computeIndex(col, text, beval->ts, 0);
- #endif
- 	    if (idx > 0)
- 	    {
- 		lnum = 0;
- 
- 		/*
- 		 * If successful, it will respond with a balloon cmd.
- 		 */
- 		if (state & ControlMask)
- 		    /* Evaluate *(expression) */
- 		    type = (int)GPLineEval_INDIRECT;
- 		else if (state & ShiftMask)
- 		    /* Evaluate type(expression) */
- 		    type = (int)GPLineEval_TYPE;
- 		else
- 		    /* Evaluate value(expression) */
- 		    type = (int)GPLineEval_EVALUATE;
- 
- 		/* Send request to dbx */
- 		vim_snprintf(buf, sizeof(buf), "toolVerb debug.balloonEval "
- 			"%s %ld,0 %d,0 %d,%d %ld %s\n",
- 			(char *)wp->w_buffer->b_ffname,
- 			(long)lnum, idx, type, serialNo++,
- 			(long)strlen((char *)text), (char *)text);
- 		balloonEval = beval;
- 		workshop_send_message(buf);
- 	    }
- 	}
-     }
- }
- 
-     static int
- computeIndex(
- 	int		 wantedCol,
- 	char_u		*line,
- 	int		 ts,
- 	int		*vts UNUSED)
- {
-     int		 col = 0;
-     int		 idx = 0;
- 
-     while (line[idx])
-     {
- 	if (line[idx] == '\t')
- #ifdef FEAT_VARTABS
- 	    col += tabstop_padding(col, ts, vts);
- #else
- 	    col += ts - (col % ts);
- #endif
- 	else
- 	    col++;
- 	idx++;
- 	if (col >= wantedCol)
- 	    return idx;
-     }
- 
-     return -1;
- }
- #endif
- 
-     static void
- addMenu(
- 	char		*menu,		/* menu name */
- 	char		*accel,		/* accelerator text (optional) */
- 	char		*verb)		/* WorkShop action-verb */
- {
-     MenuMap		*newMap;
-     char		 cbuf[BUFSIZ];
- 
-     if (menuMapSize >= menuMapMax)
-     {
- 	newMap = realloc(menuMap,
- 		sizeof(MenuMap) * (menuMapMax + MENU_INC));
- 	if (newMap != NULL)
- 	{
- 	    menuMap = newMap;
- 	    menuMapMax += MENU_INC;
- 	}
-     }
-     if (menuMapSize < menuMapMax)
-     {
- 	menuMap[menuMapSize].name = strdup(menu);
- 	menuMap[menuMapSize].accel = accel && *accel ? strdup(accel) : NULL;
- 	menuMap[menuMapSize++].verb = strdup(verb);
- 	if (accel && workshopHotKeysEnabled)
- 	{
- 	    vim_snprintf(cbuf, sizeof(cbuf),
- 					"map %s :wsverb %s<CR>", accel, verb);
- 	    coloncmd(cbuf, TRUE);
- 	}
-     }
- }
- 
-     static char *
- nameStrip(
- 	char		*raw)		/* menu name, possibly with & chars */
- {
-     static char		buf[BUFSIZ];	/* build stripped name here */
-     char		*bp = buf;
- 
-     while (*raw)
-     {
- 	if (*raw != '&')
- 	    *bp++ = *raw;
- 	raw++;
-     }
-     *bp = NUL;
-     return buf;
- }
- 
- 
-     static char *
- lookupVerb(
- 	char	*verb,
- 	int	skip)		/* number of matches to skip */
- {
-     int		i;		/* loop iterator */
- 
-     for (i = 0; i < menuMapSize; i++)
- 	if (strcmp(menuMap[i].verb, verb) == 0 && skip-- == 0)
- 	    return nameStrip(menuMap[i].name);
- 
-     return NULL;
- }
- 
- 
-     static void
- coloncmd(
- 	char	*cmd,		/* the command to print */
- 	Boolean	force)		/* force cursor update */
- {
-     char_u	*cpo_save = p_cpo;
- 
- #ifdef WSDEBUG
-     if (WSDLEVEL(WS_TRACE_COLONCMD))
- 	wsdebug("Cmd: %s\n", cmd);
- #endif
- 
-     p_cpo = empty_option;
- 
-     ALT_INPUT_LOCK_ON;
-     do_cmdline_cmd((char_u *)cmd);
-     ALT_INPUT_LOCK_OFF;
- 
-     p_cpo = cpo_save;
- 
-     if (force)
- 	gui_update_screen();
- }
- 
- /*
-  * setDollarVim -	Given the run directory, search for the vim install
-  *			directory and set $VIM.
-  *
-  *			We can be running out of SUNWspro/bin or out of
-  *			SUNWspro/contrib/contrib6/vim5.6/bin so we check
-  *			relative to both of these directories.
-  */
-     static void
- setDollarVim(
- 	char	*rundir)
- {
-     char	 buf[MAXPATHLEN];
-     char	*cp;
- 
-     /*
-      * First case: Running from <install-dir>/SUNWspro/bin
-      */
-     strcpy(buf, rundir);
-     strcat(buf, "/../contrib/contrib6/vim" VIM_VERSION_SHORT "/share/vim/"
- 	    VIM_VERSION_NODOT "/syntax/syntax.vim");
-     if (access(buf, R_OK) == 0)
-     {
- 	strcpy(buf, "SPRO_WSDIR=");
- 	strcat(buf, rundir);
- 	cp = strrchr(buf, '/');
- 	if (cp != NULL)
- 	    strcpy(cp, "/WS6U2");
- 	putenv(strdup(buf));
- 
- 	strcpy(buf, "VIM=");
- 	strcat(buf, rundir);
- 	strcat(buf, "/../contrib/contrib6/vim" VIM_VERSION_SHORT "/share/vim/"
- 		VIM_VERSION_NODOT);
- 	putenv(strdup(buf));
- 	return;
-     }
- 
-     /*
-      * Second case: Probably running from
-      *		<install-dir>/SUNWspro/contrib/contrib6/vim5.6/bin
-      */
-     strcpy(buf, rundir);
-     strcat(buf, "/../../../contrib/contrib6/vim" VIM_VERSION_SHORT
- 	    "/share/vim/" VIM_VERSION_NODOT "/syntax/syntax.vim");
-     if (access(buf, R_OK) == 0)
-     {
- 	strcpy(buf, "SPRO_WSDIR=");
- 	strcat(buf, rundir);
- 	cp = strrchr(buf, '/');
- 	if (cp != NULL)
- 	    strcpy(cp, "../../../../WS6U2");
- 	putenv(strdup(buf));
- 
- 	strcpy(buf, "VIM=");
- 	strcat(buf, rundir);
- 	strcat(buf, "/../../../contrib/contrib6/vim" VIM_VERSION_SHORT
- 		"/share/vim/" VIM_VERSION_NODOT);
- 	putenv(strdup(buf));
- 	return;
-     }
- }
- 
- /*
-  * findYourself -	Find the directory we are running from. This is used to
-  *			set $VIM. We need to set this because users can install
-  *			the package in a different directory than the compiled
-  *			directory. This is a Sun Visual WorkShop requirement!
-  *
-  * Note:		We override a user's $VIM because it won't have the
-  *			WorkShop specific files. S/he may not like this but it's
-  *			better than getting the wrong files (especially as the
-  *			user is likely to have $VIM set to 5.4 or later).
-  */
-     void
- findYourself(
-     char	*argv0)
- {
-     char	*runpath = NULL;
-     char	*path;
-     char	*pathbuf;
- 
-     if (*argv0 == '/')
- 	runpath = strdup(argv0);
-     else if (*argv0 == '.' || strchr(argv0, '/'))
-     {
- 	runpath = (char *) malloc(MAXPATHLEN);
- 	if (getcwd(runpath, MAXPATHLEN) == NULL)
- 	    runpath[0] = NUL;
- 	strcat(runpath, "/");
- 	strcat(runpath, argv0);
-     }
-     else
-     {
- 	path = getenv("PATH");
- 	if (path != NULL)
- 	{
- 	    runpath = (char *) malloc(MAXPATHLEN);
- 	    pathbuf = strdup(path);
- 	    path = strtok(pathbuf, ":");
- 	    do
- 	    {
- 		strcpy(runpath, path);
- 		strcat(runpath, "/");
- 		strcat(runpath, argv0);
- 		if (access(runpath, X_OK) == 0)
- 		    break;
- 	    } while ((path = strtok(NULL, ":")) != NULL);
- 	    free(pathbuf);
- 	}
-     }
- 
-     if (runpath != NULL)
-     {
- 	char runbuf[MAXPATHLEN];
- 
- 	/*
- 	 * We found the run directory. Now find the install dir.
- 	 */
- 	(void)vim_FullName((char_u *)runpath, (char_u *)runbuf, MAXPATHLEN, 1);
- 	path = strrchr(runbuf, '/');
- 	if (path != NULL)
- 	    *path = NUL;		/* remove the vim/gvim name */
- 	path = strrchr(runbuf, '/');
- 	if (path != NULL)
- 	{
- 	    if (strncmp(path, "/bin", 4) == 0)
- 		setDollarVim(runbuf);
- 	    else if (strncmp(path, "/src", 4) == 0)
- 	    {
- 		*path = NUL;	/* development tree */
- 		setDollarVim(runbuf);
- 	    }
- 	}
- 	free(runpath);
-     }
- }
--- 0 ----
*** ../vim-8.1.0762/src/workshop.h	2016-08-29 22:42:21.000000000 +0200
--- src/workshop.h	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,28 ****
- /* vi:set ts=8 sts=4 sw=4 noet:
-  *
-  * VIM - Vi IMproved	by Bram Moolenaar
-  *			Visual Workshop integration by Gordon Prieur
-  *
-  * Do ":help uganda"  in Vim to read copying and usage conditions.
-  * Do ":help credits" in Vim to see a list of people who contributed.
-  */
- 
- #if !defined(WORKSHOP_H) && defined(FEAT_SUN_WORKSHOP)
- #define WORKSHOP_H
- 
- #include <X11/Intrinsic.h>
- #include <Xm/Xm.h>
- 
- #include "integration.h"
- 
- #ifdef WSDEBUG
- # include "wsdebug.h"
- #else
- # ifndef ASSERT
- #  define ASSERT(c)
- # endif
- #endif
- 
- extern int		usingSunWorkShop;	/* set if -ws flag is used */
- 
- #endif
--- 0 ----
*** ../vim-8.1.0762/src/wsdebug.c	2016-09-25 21:41:24.000000000 +0200
--- src/wsdebug.c	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,184 ****
- /* vi:set ts=8 sw=8 noet:
-  *
-  * VIM - Vi IMproved	by Bram Moolenaar
-  *			Visual Workshop integration by Gordon Prieur
-  *
-  * Do ":help uganda"  in Vim to read copying and usage conditions.
-  * Do ":help credits" in Vim to see a list of people who contributed.
-  * See README.txt for an overview of the Vim source code.
-  */
- 
- /*
-  * WorkShop Debugging Tools. What are these tools and why are they important?
-  * There are two main tools here. The first tool is a tool for delaying or
-  * stopping gvim during startup.  The second tool is a protocol log tool.
-  *
-  * The startup delay tool is called wsdebug_wait(). This is very important for
-  * debugging startup problems because gvim will be started automatically from
-  * workshop and cannot be run directly from a debugger. The only way to debug
-  * a gvim started by workshop is by attaching a debugger to it. Without this
-  * tool all starup code will have completed before you can get the pid and
-  * attach.
-  *
-  * The second tool is a protocol log tool. The workshop editor server and gvim
-  * pass information back and forth during a workshop session. Sometimes it is
-  * very important to peruse this conversation in order to understand what is
-  * happening. The wsdebug_log_init() call sets up this protocol log tool and
-  * wsdebug() and wstrace() calls output the information to the log.
-  *
-  * This code must have WSDEBUG defined for it to be compiled into vim/gvim.
-  */
- 
- #ifdef WSDEBUG
- 
- #include "vim.h"
- 
- FILE		*ws_debug = NULL;
- u_int		 ws_dlevel = 0;		/* ws_debug verbosity level */
- 
- void		 wsdebug(char *, ...);
- void		 wstrace(char *, ...);
- 
- static int	 lookup(char *);
- #ifdef USE_WS_ERRORHANDLER
- static int	 errorHandler(Display *, XErrorEvent *);
- #endif
- 
- 
- /*
-  * wsdebug_wait	-   This function can be used to delay or stop execution of vim.
-  *		    It's normally used to delay startup while attaching a
-  *		    debugger to a running process. Since workshop starts gvim
-  *		    from a background process this is the only way to debug
-  *		    startup problems.
-  */
- 
- void wsdebug_wait(
- 	u_int		 wait_flags,	/* tells what to do */
- 	char		*wait_var,	/* wait environment variable */
- 	u_int		 wait_secs)	/* how many seconds to wait */
- {
- 
- 	init_homedir();			/* not inited yet */
- #ifdef USE_WDDUMP
- 	WDDump(0, 0, 0);
- #endif
- 
- 	/* for debugging purposes only */
- 	if (wait_flags & WT_ENV && wait_var && getenv(wait_var) != NULL) {
- 		sleep(atoi(getenv(wait_var)));
- 	} else if (wait_flags & WT_WAIT && lookup("~/.gvimwait")) {
- 		sleep(wait_secs > 0 && wait_secs < 120 ? wait_secs : 20);
- 	} else if (wait_flags & WT_STOP && lookup("~/.gvimstop")) {
- 		int w = 1;
- 		while (w) {
- 			;
- 		}
- 	}
- }    /* end wsdebug_wait */
- 
- 
- void
- wsdebug_log_init(
- 	char		*log_var,	/* env var with log file */
- 	char		*level_var)	/* env var with ws_debug level */
- {
- 	char		*file;		/* possible ws_debug output file */
- 	char		*cp;		/* ws_dlevel pointer */
- 
- 	if (log_var && (file = getenv(log_var)) != NULL)
- 	{
- 		char buf[BUFSIZ];
- 
- 		vim_snprintf(buf, sizeof(buf), "date > %s", file);
- 		system(buf);
- 		ws_debug = fopen(file, "a");
- 		if (level_var && (cp = getenv(level_var)) != NULL) {
- 			ws_dlevel = strtoul(cp, NULL, 0);
- 		} else {
- 			ws_dlevel = WS_TRACE;	/* default level */
- 		}
- #ifdef USE_WS_ERRORHANDLER
- 		XSetErrorHandler(errorHandler);
- #endif
- 	}
- 
- }    /* end wsdebug_log_init */
- 
- 
- 
- 
- void
- wstrace(
- 	char		*fmt,
- 	...)
- {
- 	va_list		 ap;
- 
- 	if (ws_debug!= NULL && (ws_dlevel & (WS_TRACE | WS_TRACE_VERBOSE))) {
- 		va_start(ap, fmt);
- 		vfprintf(ws_debug, fmt, ap);
- 		va_end(ap);
- 		fflush(ws_debug);
- 	}
- 
- }    /* end wstrace */
- 
- 
- void
- wsdebug(
- 	char		*fmt,
- 	...)
- {
- 	va_list		 ap;
- 
- 	if (ws_debug != NULL) {
- 		va_start(ap, fmt);
- 		vfprintf(ws_debug, fmt, ap);
- 		va_end(ap);
- 		fflush(ws_debug);
- 	}
- 
- }    /* end wsdebug */
- 
- 
- static int
- lookup(
- 	char		*file)
- {
- 	char		 buf[BUFSIZ];
- 
- 	expand_env((char_u *) file, (char_u *) buf, BUFSIZ);
- 	return (access(buf, F_OK) == 0);
- 
- }    /* end lookup */
- 
- #ifdef USE_WS_ERRORHANDLER
- static int
- errorHandler(
- 	Display		*dpy,
- 	XErrorEvent	*err)
- {
- 	char		 msg[256];
- 	char		 buf[256];
- 
- 	XGetErrorText(dpy, err->error_code, msg, sizeof(msg));
- 	wsdebug("\n\nWSDEBUG Vim: X Error of failed request: %s\n", msg);
- 
- 	sprintf(buf, "%d", err->request_code);
- 	XGetErrorDatabaseText(dpy,
- 	    "XRequest", buf, "Unknown", msg, sizeof(msg));
- 	wsdebug("\tMajor opcode of failed request: %d (%s)\n",
- 	    err->request_code, msg);
- 	if (err->request_code > 128) {
- 		wsdebug("\tMinor opcode of failed request: %d\n",
- 		    err->minor_code);
- 	}
- 
- 	return 0;
- }
- #endif
- 
- 
- 
- #endif /* WSDEBUG */
--- 0 ----
*** ../vim-8.1.0762/src/wsdebug.h	2016-08-29 22:42:21.000000000 +0200
--- src/wsdebug.h	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,81 ****
- /* vi:set ts=8 sw=8 noet:
-  *
-  * VIM - Vi IMproved	by Bram Moolenaar
-  *			Visual Workshop integration by Gordon Prieur
-  *
-  * Do ":help uganda"  in Vim to read copying and usage conditions.
-  * Do ":help credits" in Vim to see a list of people who contributed.
-  */
- 
- 
- #ifndef WSDEBUG_H
- #define WSDEBUG_H
- 
- #ifdef WSDEBUG
- 
- #ifndef ASSERT
- #define ASSERT(c) \
-     if (!(c)) { \
- 	fprintf(stderr, "Assertion failed: line %d, file %s\n", \
- 		__LINE__, __FILE__); \
- 	fflush(stderr); \
- 	abort(); \
-     }
- #endif
- 
- #define WS_TRACE		0x00000001
- #define WS_TRACE_VERBOSE	0x00000002
- #define WS_TRACE_COLONCMD	0x00000004
- #define WS_DEBUG_ALL		0xffffffff
- 
- #define WSDLEVEL(flags)		(ws_debug != NULL && (ws_dlevel & (flags)))
- 
- #ifdef USE_WDDUMP
- #include "wdump.h"
- #endif
- 
- #define WSDEBUG_TRACE	1
- //#define WSDEBUG_SENSE	2
- 
- typedef enum {
- 		WT_ENV = 1,		/* look for env var if set */
- 		WT_WAIT,		/* look for ~/.gvimwait if set */
- 		WT_STOP			/* look for ~/.gvimstop if set */
- } WtWait;
- 
- 
- void		 wsdebug(char *, ...);
- void		 wstrace(char *, ...);
- 
- 
- extern FILE	*ws_debug;
- extern u_int	 ws_dlevel;		/* ws_debug verbosity level */
- 
- # else		/* not WSDEBUG */
- 
- #ifndef ASSERT
- # define ASSERT(c)
- #endif
- 
- /*
-  * The following 2 stubs are needed because a macro cannot be used because of
-  * the variable number of arguments.
-  */
- 
- void
- wsdebug(
- 	char		*fmt,
- 	...)
- {
- }
- 
- 
- void
- wstrace(
- 	char		*fmt,
- 	...)
- {
- }
- 
- #endif /* WSDEBUG */
- #endif /* WSDEBUG_H */
--- 0 ----
*** ../vim-8.1.0762/src/ex_cmdidxs.h	2019-01-08 22:02:36.044297306 +0100
--- src/ex_cmdidxs.h	2019-01-17 15:31:43.054158710 +0100
***************
*** 28,36 ****
    /* u */ 481,
    /* v */ 492,
    /* w */ 510,
!   /* x */ 525,
!   /* y */ 534,
!   /* z */ 535
  };
  
  /*
--- 28,36 ----
    /* u */ 481,
    /* v */ 492,
    /* w */ 510,
!   /* x */ 524,
!   /* y */ 533,
!   /* z */ 534
  };
  
  /*
***************
*** 63,72 ****
    /* t */ {  2,  0, 19,  0, 22, 24,  0, 25,  0, 26,  0, 27, 31, 34, 36, 37,  0, 38, 40,  0, 41,  0,  0,  0,  0,  0 },
    /* u */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    /* v */ {  0,  0,  0,  0,  1,  0,  0,  0,  4,  0,  0,  0,  9, 12,  0,  0,  0,  0, 15,  0, 16,  0,  0,  0,  0,  0 },
!   /* w */ {  2,  0,  0,  0,  0,  0,  0,  3,  4,  0,  0,  0,  0,  8,  0,  9, 10,  0, 12,  0, 13, 14,  0,  0,  0,  0 },
    /* x */ {  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  5,  0,  0,  0,  0,  0,  0,  7,  0,  0,  0,  0,  0 },
    /* y */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    /* z */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }
  };
  
! static const int command_count = 548;
--- 63,72 ----
    /* t */ {  2,  0, 19,  0, 22, 24,  0, 25,  0, 26,  0, 27, 31, 34, 36, 37,  0, 38, 40,  0, 41,  0,  0,  0,  0,  0 },
    /* u */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    /* v */ {  0,  0,  0,  0,  1,  0,  0,  0,  4,  0,  0,  0,  9, 12,  0,  0,  0,  0, 15,  0, 16,  0,  0,  0,  0,  0 },
!   /* w */ {  2,  0,  0,  0,  0,  0,  0,  3,  4,  0,  0,  0,  0,  8,  0,  9, 10,  0,  0,  0, 12, 13,  0,  0,  0,  0 },
    /* x */ {  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  5,  0,  0,  0,  0,  0,  0,  7,  0,  0,  0,  0,  0 },
    /* y */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    /* z */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }
  };
  
! static const int command_count = 547;
*** ../vim-8.1.0762/src/version.c	2019-01-17 14:31:10.190919265 +0100
--- src/version.c	2019-01-17 15:39:12.143436999 +0100
***************
*** 797,798 ****
--- 793,796 ----
  {   /* Add new patch number below this line */
+ /**/
+     763,
  /**/

-- 
You are Dead.  Do you wish to restart, load, or quit?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
