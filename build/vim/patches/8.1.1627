To: vim_dev@googlegroups.com
Subject: Patch 8.1.1627
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.1.1627
Problem:    Header file contains mixed comment style.
Solution:   Use // style comments.
Files:	    src/structs.h


*** ../vim-8.1.1626/src/structs.h	2019-07-02 23:13:20.156427779 +0200
--- src/structs.h	2019-07-04 16:02:42.130798940 +0200
***************
*** 47,57 ****
   */
  typedef struct growarray
  {
!     int	    ga_len;		    /* current number of items used */
!     int	    ga_maxlen;		    /* maximum number of items possible */
!     int	    ga_itemsize;	    /* sizeof(item) */
!     int	    ga_growsize;	    /* number of items to grow each time */
!     void    *ga_data;		    /* pointer to the first item */
  } garray_T;
  
  #define GA_EMPTY    {0, 0, 0, 0, NULL}
--- 47,57 ----
   */
  typedef struct growarray
  {
!     int	    ga_len;		    // current number of items used
!     int	    ga_maxlen;		    // maximum number of items possible
!     int	    ga_itemsize;	    // sizeof(item)
!     int	    ga_growsize;	    // number of items to grow each time
!     void    *ga_data;		    // pointer to the first item
  } garray_T;
  
  #define GA_EMPTY    {0, 0, 0, 0, NULL}
***************
*** 59,66 ****
  typedef struct window_S		win_T;
  typedef struct wininfo_S	wininfo_T;
  typedef struct frame_S		frame_T;
! typedef int			scid_T;		/* script ID */
! typedef struct file_buffer	buf_T;  /* forward declaration */
  typedef struct terminal_S	term_T;
  
  #ifdef FEAT_MENU
--- 59,66 ----
  typedef struct window_S		win_T;
  typedef struct wininfo_S	wininfo_T;
  typedef struct frame_S		frame_T;
! typedef int			scid_T;		// script ID
! typedef struct file_buffer	buf_T;		// forward declaration
  typedef struct terminal_S	term_T;
  
  #ifdef FEAT_MENU
***************
*** 109,115 ****
  # endif
  # define guicolor_T long
  # define INVALCOLOR ((guicolor_T)0x1ffffff)
!     /* only used for cterm.bg_rgb and cterm.fg_rgb: use cterm color */
  # define CTERMCOLOR ((guicolor_T)0x1fffffe)
  #endif
  #define COLOR_INVALID(x) ((x) == INVALCOLOR || (x) == CTERMCOLOR)
--- 109,115 ----
  # endif
  # define guicolor_T long
  # define INVALCOLOR ((guicolor_T)0x1ffffff)
!     // only used for cterm.bg_rgb and cterm.fg_rgb: use cterm color
  # define CTERMCOLOR ((guicolor_T)0x1fffffe)
  #endif
  #define COLOR_INVALID(x) ((x) == INVALCOLOR || (x) == CTERMCOLOR)
***************
*** 119,142 ****
   * (a normal mark is a lnum/col pair, the same as a file position)
   */
  
! /* (Note: for EBCDIC there are more than 26, because there are gaps in the
!  * alphabet coding.  To minimize changes to the code, I decided to just
!  * increase the number of possible marks. */
! #define NMARKS		('z' - 'a' + 1)	/* max. # of named marks */
! #define JUMPLISTSIZE	100		/* max. # of marks in jump list */
! #define TAGSTACKSIZE	20		/* max. # of tags in tag stack */
  
  typedef struct filemark
  {
!     pos_T	mark;		/* cursor position */
!     int		fnum;		/* file number */
  } fmark_T;
  
! /* Xtended file mark: also has a file name */
  typedef struct xfilemark
  {
      fmark_T	fmark;
!     char_u	*fname;		/* file name, used when fnum == 0 */
  #ifdef FEAT_VIMINFO
      time_T	time_set;
  #endif
--- 119,142 ----
   * (a normal mark is a lnum/col pair, the same as a file position)
   */
  
! // (Note: for EBCDIC there are more than 26, because there are gaps in the
! // alphabet coding.  To minimize changes to the code, I decided to just
! // increase the number of possible marks.
! #define NMARKS		('z' - 'a' + 1)	// max. # of named marks
! #define JUMPLISTSIZE	100		// max. # of marks in jump list
! #define TAGSTACKSIZE	20		// max. # of tags in tag stack
  
  typedef struct filemark
  {
!     pos_T	mark;		// cursor position
!     int		fnum;		// file number
  } fmark_T;
  
! // Xtended file mark: also has a file name
  typedef struct xfilemark
  {
      fmark_T	fmark;
!     char_u	*fname;		// file name, used when fnum == 0
  #ifdef FEAT_VIMINFO
      time_T	time_set;
  #endif
***************
*** 179,295 ****
  #endif
  #ifdef FEAT_FOLDING
      long	wo_fdc;
! # define w_p_fdc w_onebuf_opt.wo_fdc	/* 'foldcolumn' */
      int		wo_fdc_save;
! # define w_p_fdc_save w_onebuf_opt.wo_fdc_save	/* 'foldenable' saved for diff mode */
      int		wo_fen;
! # define w_p_fen w_onebuf_opt.wo_fen	/* 'foldenable' */
      int		wo_fen_save;
! # define w_p_fen_save w_onebuf_opt.wo_fen_save	/* 'foldenable' saved for diff mode */
      char_u	*wo_fdi;
! # define w_p_fdi w_onebuf_opt.wo_fdi	/* 'foldignore' */
      long	wo_fdl;
! # define w_p_fdl w_onebuf_opt.wo_fdl	/* 'foldlevel' */
      int		wo_fdl_save;
! # define w_p_fdl_save w_onebuf_opt.wo_fdl_save	/* 'foldlevel' state saved for diff mode */
      char_u	*wo_fdm;
! # define w_p_fdm w_onebuf_opt.wo_fdm	/* 'foldmethod' */
      char_u	*wo_fdm_save;
! # define w_p_fdm_save w_onebuf_opt.wo_fdm_save	/* 'fdm' saved for diff mode */
      long	wo_fml;
! # define w_p_fml w_onebuf_opt.wo_fml	/* 'foldminlines' */
      long	wo_fdn;
! # define w_p_fdn w_onebuf_opt.wo_fdn	/* 'foldnestmax' */
  # ifdef FEAT_EVAL
      char_u	*wo_fde;
! # define w_p_fde w_onebuf_opt.wo_fde	/* 'foldexpr' */
      char_u	*wo_fdt;
! #  define w_p_fdt w_onebuf_opt.wo_fdt	/* 'foldtext' */
  # endif
      char_u	*wo_fmr;
! # define w_p_fmr w_onebuf_opt.wo_fmr	/* 'foldmarker' */
  #endif
  #ifdef FEAT_LINEBREAK
      int		wo_lbr;
! # define w_p_lbr w_onebuf_opt.wo_lbr	/* 'linebreak' */
  #endif
      int		wo_list;
! #define w_p_list w_onebuf_opt.wo_list	/* 'list' */
      int		wo_nu;
! #define w_p_nu w_onebuf_opt.wo_nu	/* 'number' */
      int		wo_rnu;
! #define w_p_rnu w_onebuf_opt.wo_rnu	/* 'relativenumber' */
  #ifdef FEAT_LINEBREAK
      long	wo_nuw;
! # define w_p_nuw w_onebuf_opt.wo_nuw	/* 'numberwidth' */
  #endif
      int		wo_wfh;
! # define w_p_wfh w_onebuf_opt.wo_wfh	/* 'winfixheight' */
      int		wo_wfw;
! # define w_p_wfw w_onebuf_opt.wo_wfw	/* 'winfixwidth' */
  #if defined(FEAT_QUICKFIX)
      int		wo_pvw;
! # define w_p_pvw w_onebuf_opt.wo_pvw	/* 'previewwindow' */
  #endif
  #ifdef FEAT_RIGHTLEFT
      int		wo_rl;
! # define w_p_rl w_onebuf_opt.wo_rl	/* 'rightleft' */
      char_u	*wo_rlc;
! # define w_p_rlc w_onebuf_opt.wo_rlc	/* 'rightleftcmd' */
  #endif
      long	wo_scr;
! #define w_p_scr w_onebuf_opt.wo_scr	/* 'scroll' */
  #ifdef FEAT_SPELL
      int		wo_spell;
! # define w_p_spell w_onebuf_opt.wo_spell /* 'spell' */
  #endif
  #ifdef FEAT_SYN_HL
      int		wo_cuc;
! # define w_p_cuc w_onebuf_opt.wo_cuc	/* 'cursorcolumn' */
      int		wo_cul;
! # define w_p_cul w_onebuf_opt.wo_cul	/* 'cursorline' */
      char_u	*wo_cc;
! # define w_p_cc w_onebuf_opt.wo_cc	/* 'colorcolumn' */
  #endif
  #ifdef FEAT_STL_OPT
      char_u	*wo_stl;
! #define w_p_stl w_onebuf_opt.wo_stl	/* 'statusline' */
  #endif
      int		wo_scb;
! #define w_p_scb w_onebuf_opt.wo_scb	/* 'scrollbind' */
!     int		wo_diff_saved; /* options were saved for starting diff mode */
  #define w_p_diff_saved w_onebuf_opt.wo_diff_saved
!     int		wo_scb_save;	/* 'scrollbind' saved for diff mode*/
  #define w_p_scb_save w_onebuf_opt.wo_scb_save
      int		wo_wrap;
! #define w_p_wrap w_onebuf_opt.wo_wrap	/* 'wrap' */
  #ifdef FEAT_DIFF
!     int		wo_wrap_save;	/* 'wrap' state saved for diff mode*/
  # define w_p_wrap_save w_onebuf_opt.wo_wrap_save
  #endif
  #ifdef FEAT_CONCEAL
!     char_u	*wo_cocu;		/* 'concealcursor' */
  # define w_p_cocu w_onebuf_opt.wo_cocu
!     long	wo_cole;		/* 'conceallevel' */
  # define w_p_cole w_onebuf_opt.wo_cole
  #endif
      int		wo_crb;
! #define w_p_crb w_onebuf_opt.wo_crb	/* 'cursorbind' */
!     int		wo_crb_save;	/* 'cursorbind' state saved for diff mode*/
  #define w_p_crb_save w_onebuf_opt.wo_crb_save
  #ifdef FEAT_SIGNS
      char_u	*wo_scl;
! # define w_p_scl w_onebuf_opt.wo_scl	/* 'signcolumn' */
  #endif
  #ifdef FEAT_TERMINAL
      char_u	*wo_twk;
! # define w_p_twk w_onebuf_opt.wo_twk	/* 'termwinkey' */
      char_u	*wo_tws;
! # define w_p_tws w_onebuf_opt.wo_tws	/* 'termwinsize' */
  #endif
  
  #ifdef FEAT_EVAL
!     sctx_T	wo_script_ctx[WV_COUNT];	/* SCTXs for window-local options */
  # define w_p_script_ctx w_onebuf_opt.wo_script_ctx
  #endif
  } winopt_T;
--- 179,295 ----
  #endif
  #ifdef FEAT_FOLDING
      long	wo_fdc;
! # define w_p_fdc w_onebuf_opt.wo_fdc	// 'foldcolumn'
      int		wo_fdc_save;
! # define w_p_fdc_save w_onebuf_opt.wo_fdc_save	// 'foldenable' saved for diff mode
      int		wo_fen;
! # define w_p_fen w_onebuf_opt.wo_fen	// 'foldenable'
      int		wo_fen_save;
! # define w_p_fen_save w_onebuf_opt.wo_fen_save	// 'foldenable' saved for diff mode
      char_u	*wo_fdi;
! # define w_p_fdi w_onebuf_opt.wo_fdi	// 'foldignore'
      long	wo_fdl;
! # define w_p_fdl w_onebuf_opt.wo_fdl	// 'foldlevel'
      int		wo_fdl_save;
! # define w_p_fdl_save w_onebuf_opt.wo_fdl_save	// 'foldlevel' state saved for diff mode
      char_u	*wo_fdm;
! # define w_p_fdm w_onebuf_opt.wo_fdm	// 'foldmethod'
      char_u	*wo_fdm_save;
! # define w_p_fdm_save w_onebuf_opt.wo_fdm_save	// 'fdm' saved for diff mode
      long	wo_fml;
! # define w_p_fml w_onebuf_opt.wo_fml	// 'foldminlines'
      long	wo_fdn;
! # define w_p_fdn w_onebuf_opt.wo_fdn	// 'foldnestmax'
  # ifdef FEAT_EVAL
      char_u	*wo_fde;
! # define w_p_fde w_onebuf_opt.wo_fde	// 'foldexpr'
      char_u	*wo_fdt;
! #  define w_p_fdt w_onebuf_opt.wo_fdt	// 'foldtext'
  # endif
      char_u	*wo_fmr;
! # define w_p_fmr w_onebuf_opt.wo_fmr	// 'foldmarker'
  #endif
  #ifdef FEAT_LINEBREAK
      int		wo_lbr;
! # define w_p_lbr w_onebuf_opt.wo_lbr	// 'linebreak'
  #endif
      int		wo_list;
! #define w_p_list w_onebuf_opt.wo_list	// 'list'
      int		wo_nu;
! #define w_p_nu w_onebuf_opt.wo_nu	// 'number'
      int		wo_rnu;
! #define w_p_rnu w_onebuf_opt.wo_rnu	// 'relativenumber'
  #ifdef FEAT_LINEBREAK
      long	wo_nuw;
! # define w_p_nuw w_onebuf_opt.wo_nuw	// 'numberwidth'
  #endif
      int		wo_wfh;
! # define w_p_wfh w_onebuf_opt.wo_wfh	// 'winfixheight'
      int		wo_wfw;
! # define w_p_wfw w_onebuf_opt.wo_wfw	// 'winfixwidth'
  #if defined(FEAT_QUICKFIX)
      int		wo_pvw;
! # define w_p_pvw w_onebuf_opt.wo_pvw	// 'previewwindow'
  #endif
  #ifdef FEAT_RIGHTLEFT
      int		wo_rl;
! # define w_p_rl w_onebuf_opt.wo_rl	// 'rightleft'
      char_u	*wo_rlc;
! # define w_p_rlc w_onebuf_opt.wo_rlc	// 'rightleftcmd'
  #endif
      long	wo_scr;
! #define w_p_scr w_onebuf_opt.wo_scr	// 'scroll'
  #ifdef FEAT_SPELL
      int		wo_spell;
! # define w_p_spell w_onebuf_opt.wo_spell // 'spell'
  #endif
  #ifdef FEAT_SYN_HL
      int		wo_cuc;
! # define w_p_cuc w_onebuf_opt.wo_cuc	// 'cursorcolumn'
      int		wo_cul;
! # define w_p_cul w_onebuf_opt.wo_cul	// 'cursorline'
      char_u	*wo_cc;
! # define w_p_cc w_onebuf_opt.wo_cc	// 'colorcolumn'
  #endif
  #ifdef FEAT_STL_OPT
      char_u	*wo_stl;
! #define w_p_stl w_onebuf_opt.wo_stl	// 'statusline'
  #endif
      int		wo_scb;
! #define w_p_scb w_onebuf_opt.wo_scb	// 'scrollbind'
!     int		wo_diff_saved; // options were saved for starting diff mode
  #define w_p_diff_saved w_onebuf_opt.wo_diff_saved
!     int		wo_scb_save;	// 'scrollbind' saved for diff mode
  #define w_p_scb_save w_onebuf_opt.wo_scb_save
      int		wo_wrap;
! #define w_p_wrap w_onebuf_opt.wo_wrap	// 'wrap'
  #ifdef FEAT_DIFF
!     int		wo_wrap_save;	// 'wrap' state saved for diff mode
  # define w_p_wrap_save w_onebuf_opt.wo_wrap_save
  #endif
  #ifdef FEAT_CONCEAL
!     char_u	*wo_cocu;		// 'concealcursor'
  # define w_p_cocu w_onebuf_opt.wo_cocu
!     long	wo_cole;		// 'conceallevel'
  # define w_p_cole w_onebuf_opt.wo_cole
  #endif
      int		wo_crb;
! #define w_p_crb w_onebuf_opt.wo_crb	// 'cursorbind'
!     int		wo_crb_save;	// 'cursorbind' state saved for diff mode
  #define w_p_crb_save w_onebuf_opt.wo_crb_save
  #ifdef FEAT_SIGNS
      char_u	*wo_scl;
! # define w_p_scl w_onebuf_opt.wo_scl	// 'signcolumn'
  #endif
  #ifdef FEAT_TERMINAL
      char_u	*wo_twk;
! # define w_p_twk w_onebuf_opt.wo_twk	// 'termwinkey'
      char_u	*wo_tws;
! # define w_p_tws w_onebuf_opt.wo_tws	// 'termwinsize'
  #endif
  
  #ifdef FEAT_EVAL
!     sctx_T	wo_script_ctx[WV_COUNT];	// SCTXs for window-local options
  # define w_p_script_ctx w_onebuf_opt.wo_script_ctx
  #endif
  } winopt_T;
***************
*** 306,320 ****
   */
  struct wininfo_S
  {
!     wininfo_T	*wi_next;	/* next entry or NULL for last entry */
!     wininfo_T	*wi_prev;	/* previous entry or NULL for first entry */
!     win_T	*wi_win;	/* pointer to window that did set wi_fpos */
!     pos_T	wi_fpos;	/* last cursor position in the file */
!     int		wi_optset;	/* TRUE when wi_opt has useful values */
!     winopt_T	wi_opt;		/* local window options */
  #ifdef FEAT_FOLDING
!     int		wi_fold_manual;	/* copy of w_fold_manual */
!     garray_T	wi_folds;	/* clone of w_folds */
  #endif
  };
  
--- 306,320 ----
   */
  struct wininfo_S
  {
!     wininfo_T	*wi_next;	// next entry or NULL for last entry
!     wininfo_T	*wi_prev;	// previous entry or NULL for first entry
!     win_T	*wi_win;	// pointer to window that did set wi_fpos
!     pos_T	wi_fpos;	// last cursor position in the file
!     int		wi_optset;	// TRUE when wi_opt has useful values
!     winopt_T	wi_opt;		// local window options
  #ifdef FEAT_FOLDING
!     int		wi_fold_manual;	// copy of w_fold_manual
!     garray_T	wi_folds;	// clone of w_folds
  #endif
  };
  
***************
*** 324,343 ****
   */
  typedef struct foldinfo
  {
!     int		fi_level;	/* level of the fold; when this is zero the
! 				   other fields are invalid */
!     int		fi_lnum;	/* line number where fold starts */
!     int		fi_low_level;	/* lowest fold level that starts in the same
! 				   line */
  } foldinfo_T;
  
! /* Structure to store info about the Visual area. */
  typedef struct
  {
!     pos_T	vi_start;	/* start pos of last VIsual */
!     pos_T	vi_end;		/* end position of last VIsual */
!     int		vi_mode;	/* VIsual_mode of last VIsual */
!     colnr_T	vi_curswant;	/* MAXCOL from w_curswant */
  } visualinfo_T;
  
  /*
--- 324,345 ----
   */
  typedef struct foldinfo
  {
!     int		fi_level;	// level of the fold; when this is zero the
! 				// other fields are invalid
!     int		fi_lnum;	// line number where fold starts
!     int		fi_low_level;	// lowest fold level that starts in the same
! 				// line
  } foldinfo_T;
  
! /*
!  * Structure to store info about the Visual area.
!  */
  typedef struct
  {
!     pos_T	vi_start;	// start pos of last VIsual
!     pos_T	vi_end;		// end position of last VIsual
!     int		vi_mode;	// VIsual_mode of last VIsual
!     colnr_T	vi_curswant;	// MAXCOL from w_curswant
  } visualinfo_T;
  
  /*
***************
*** 356,417 ****
  typedef struct u_header u_header_T;
  struct u_entry
  {
!     u_entry_T	*ue_next;	/* pointer to next entry in list */
!     linenr_T	ue_top;		/* number of line above undo block */
!     linenr_T	ue_bot;		/* number of line below undo block */
!     linenr_T	ue_lcount;	/* linecount when u_save called */
!     undoline_T	*ue_array;	/* array of lines in undo block */
!     long	ue_size;	/* number of lines in ue_array */
  #ifdef U_DEBUG
!     int		ue_magic;	/* magic number to check allocation */
  #endif
  };
  
  struct u_header
  {
!     /* The following have a pointer and a number. The number is used when
!      * reading the undo file in u_read_undo() */
      union {
! 	u_header_T *ptr;	/* pointer to next undo header in list */
  	long	   seq;
      } uh_next;
      union {
! 	u_header_T *ptr;	/* pointer to previous header in list */
  	long	   seq;
      } uh_prev;
      union {
! 	u_header_T *ptr;	/* pointer to next header for alt. redo */
  	long	   seq;
      } uh_alt_next;
      union {
! 	u_header_T *ptr;	/* pointer to previous header for alt. redo */
  	long	   seq;
      } uh_alt_prev;
!     long	uh_seq;		/* sequence number, higher == newer undo */
!     int		uh_walk;	/* used by undo_time() */
!     u_entry_T	*uh_entry;	/* pointer to first entry */
!     u_entry_T	*uh_getbot_entry; /* pointer to where ue_bot must be set */
!     pos_T	uh_cursor;	/* cursor position before saving */
      long	uh_cursor_vcol;
!     int		uh_flags;	/* see below */
!     pos_T	uh_namedm[NMARKS];	/* marks before undo/after redo */
!     visualinfo_T uh_visual;	/* Visual areas before undo/after redo */
!     time_T	uh_time;	/* timestamp when the change was made */
!     long	uh_save_nr;	/* set when the file was saved after the
! 				   changes in this block */
  #ifdef U_DEBUG
!     int		uh_magic;	/* magic number to check allocation */
  #endif
  };
  
! /* values for uh_flags */
! #define UH_CHANGED  0x01	/* b_changed flag before undo/after redo */
! #define UH_EMPTYBUF 0x02	/* buffer was empty */
  
  /*
   * structures used in undo.c
   */
! #define ALIGN_LONG	/* longword alignment and use filler byte */
  #define ALIGN_SIZE (sizeof(long))
  
  #define ALIGN_MASK (ALIGN_SIZE - 1)
--- 358,419 ----
  typedef struct u_header u_header_T;
  struct u_entry
  {
!     u_entry_T	*ue_next;	// pointer to next entry in list
!     linenr_T	ue_top;		// number of line above undo block
!     linenr_T	ue_bot;		// number of line below undo block
!     linenr_T	ue_lcount;	// linecount when u_save called
!     undoline_T	*ue_array;	// array of lines in undo block
!     long	ue_size;	// number of lines in ue_array
  #ifdef U_DEBUG
!     int		ue_magic;	// magic number to check allocation
  #endif
  };
  
  struct u_header
  {
!     // The following have a pointer and a number. The number is used when
!     // reading the undo file in u_read_undo()
      union {
! 	u_header_T *ptr;	// pointer to next undo header in list
  	long	   seq;
      } uh_next;
      union {
! 	u_header_T *ptr;	// pointer to previous header in list
  	long	   seq;
      } uh_prev;
      union {
! 	u_header_T *ptr;	// pointer to next header for alt. redo
  	long	   seq;
      } uh_alt_next;
      union {
! 	u_header_T *ptr;	// pointer to previous header for alt. redo
  	long	   seq;
      } uh_alt_prev;
!     long	uh_seq;		// sequence number, higher == newer undo
!     int		uh_walk;	// used by undo_time()
!     u_entry_T	*uh_entry;	// pointer to first entry
!     u_entry_T	*uh_getbot_entry; // pointer to where ue_bot must be set
!     pos_T	uh_cursor;	// cursor position before saving
      long	uh_cursor_vcol;
!     int		uh_flags;	// see below
!     pos_T	uh_namedm[NMARKS];	// marks before undo/after redo
!     visualinfo_T uh_visual;	// Visual areas before undo/after redo
!     time_T	uh_time;	// timestamp when the change was made
!     long	uh_save_nr;	// set when the file was saved after the
! 				// changes in this block
  #ifdef U_DEBUG
!     int		uh_magic;	// magic number to check allocation
  #endif
  };
  
! // values for uh_flags
! #define UH_CHANGED  0x01	// b_changed flag before undo/after redo
! #define UH_EMPTYBUF 0x02	// buffer was empty
  
  /*
   * structures used in undo.c
   */
! #define ALIGN_LONG	// longword alignment and use filler byte
  #define ALIGN_SIZE (sizeof(long))
  
  #define ALIGN_MASK (ALIGN_SIZE - 1)
***************
*** 424,434 ****
  struct m_info
  {
  #ifdef ALIGN_LONG
!     long_u	m_size;		/* size of the chunk (including m_info) */
  #else
!     short_u	m_size;		/* size of the chunk (including m_info) */
  #endif
!     minfo_T	*m_next;	/* pointer to next free chunk in the list */
  };
  
  /*
--- 426,436 ----
  struct m_info
  {
  #ifdef ALIGN_LONG
!     long_u	m_size;		// size of the chunk (including m_info)
  #else
!     short_u	m_size;		// size of the chunk (including m_info)
  #endif
!     minfo_T	*m_next;	// pointer to next free chunk in the list
  };
  
  /*
***************
*** 459,471 ****
  
  typedef struct mf_hashtab_S
  {
!     long_u	    mht_mask;	    /* mask used for hash value (nr of items
! 				     * in array is "mht_mask" + 1) */
!     long_u	    mht_count;	    /* nr of items inserted into hashtable */
!     mf_hashitem_T   **mht_buckets;  /* points to mht_small_buckets or
! 				     *dynamically allocated array */
!     mf_hashitem_T   *mht_small_buckets[MHT_INIT_SIZE];   /* initial buckets */
!     char	    mht_fixed;	    /* non-zero value forbids growth */
  } mf_hashtab_T;
  
  /*
--- 461,473 ----
  
  typedef struct mf_hashtab_S
  {
!     long_u	    mht_mask;	    // mask used for hash value (nr of items
! 				    // in array is "mht_mask" + 1)
!     long_u	    mht_count;	    // nr of items inserted into hashtable
!     mf_hashitem_T   **mht_buckets;  // points to mht_small_buckets or
! 				    //dynamically allocated array
!     mf_hashitem_T   *mht_small_buckets[MHT_INIT_SIZE];   // initial buckets
!     char	    mht_fixed;	    // non-zero value forbids growth
  } mf_hashtab_T;
  
  /*
***************
*** 485,501 ****
  
  struct block_hdr
  {
!     mf_hashitem_T bh_hashitem;      /* header for hash table and key */
! #define bh_bnum bh_hashitem.mhi_key /* block number, part of bh_hashitem */
  
!     bhdr_T	*bh_next;	    /* next block_hdr in free or used list */
!     bhdr_T	*bh_prev;	    /* previous block_hdr in used list */
!     char_u	*bh_data;	    /* pointer to memory (for used block) */
!     int		bh_page_count;	    /* number of pages in this block */
  
  #define BH_DIRTY    1
  #define BH_LOCKED   2
!     char	bh_flags;	    /* BH_DIRTY or BH_LOCKED */
  };
  
  /*
--- 487,503 ----
  
  struct block_hdr
  {
!     mf_hashitem_T bh_hashitem;      // header for hash table and key
! #define bh_bnum bh_hashitem.mhi_key // block number, part of bh_hashitem
  
!     bhdr_T	*bh_next;	    // next block_hdr in free or used list
!     bhdr_T	*bh_prev;	    // previous block_hdr in used list
!     char_u	*bh_data;	    // pointer to memory (for used block)
!     int		bh_page_count;	    // number of pages in this block
  
  #define BH_DIRTY    1
  #define BH_LOCKED   2
!     char	bh_flags;	    // BH_DIRTY or BH_LOCKED
  };
  
  /*
***************
*** 508,517 ****
  
  struct nr_trans
  {
!     mf_hashitem_T nt_hashitem;		/* header for hash table and key */
! #define nt_old_bnum nt_hashitem.mhi_key	/* old, negative, number */
  
!     blocknr_T	nt_new_bnum;		/* new, positive, number */
  };
  
  
--- 510,519 ----
  
  struct nr_trans
  {
!     mf_hashitem_T nt_hashitem;		// header for hash table and key
! #define nt_old_bnum nt_hashitem.mhi_key	// old, negative, number
  
!     blocknr_T	nt_new_bnum;		// new, positive, number
  };
  
  
***************
*** 523,530 ****
   */
  struct buffblock
  {
!     buffblock_T	*b_next;	/* pointer to next buffblock */
!     char_u	b_str[1];	/* contents (actually longer) */
  };
  
  /*
--- 525,532 ----
   */
  struct buffblock
  {
!     buffblock_T	*b_next;	// pointer to next buffblock
!     char_u	b_str[1];	// contents (actually longer)
  };
  
  /*
***************
*** 532,541 ****
   */
  struct buffheader
  {
!     buffblock_T	bh_first;	/* first (dummy) block of list */
!     buffblock_T	*bh_curr;	/* buffblock for appending */
!     int		bh_index;	/* index for reading */
!     int		bh_space;	/* space in bh_curr for appending */
  };
  
  typedef struct
--- 534,543 ----
   */
  struct buffheader
  {
!     buffblock_T	bh_first;	// first (dummy) block of list
!     buffblock_T	*bh_curr;	// buffblock for appending
!     int		bh_index;	// index for reading
!     int		bh_space;	// space in bh_curr for appending
  };
  
  typedef struct
***************
*** 549,577 ****
   */
  typedef struct expand
  {
!     int		xp_context;		/* type of expansion */
!     char_u	*xp_pattern;		/* start of item to expand */
!     int		xp_pattern_len;		/* bytes in xp_pattern before cursor */
  #if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
!     char_u	*xp_arg;		/* completion function */
!     sctx_T	xp_script_ctx;		/* SCTX for completion function */
  #endif
!     int		xp_backslash;		/* one of the XP_BS_ values */
  #ifndef BACKSLASH_IN_FILENAME
!     int		xp_shell;		/* TRUE for a shell command, more
! 					   characters need to be escaped */
  #endif
!     int		xp_numfiles;		/* number of files found by
! 						    file name completion */
!     char_u	**xp_files;		/* list of files */
!     char_u	*xp_line;		/* text being completed */
!     int		xp_col;			/* cursor position in line */
  } expand_T;
  
! /* values for xp_backslash */
! #define XP_BS_NONE	0	/* nothing special for backslashes */
! #define XP_BS_ONE	1	/* uses one backslash before a space */
! #define XP_BS_THREE	2	/* uses three backslashes before a space */
  
  /*
   * Command modifiers ":vertical", ":browse", ":confirm" and ":hide" set a flag.
--- 551,581 ----
   */
  typedef struct expand
  {
!     int		xp_context;		// type of expansion
!     char_u	*xp_pattern;		// start of item to expand
!     int		xp_pattern_len;		// bytes in xp_pattern before cursor
  #if defined(FEAT_EVAL) && defined(FEAT_CMDL_COMPL)
!     char_u	*xp_arg;		// completion function
!     sctx_T	xp_script_ctx;		// SCTX for completion function
  #endif
!     int		xp_backslash;		// one of the XP_BS_ values
  #ifndef BACKSLASH_IN_FILENAME
!     int		xp_shell;		// TRUE for a shell command, more
! 					// characters need to be escaped
  #endif
!     int		xp_numfiles;		// number of files found by
! 					// file name completion
!     char_u	**xp_files;		// list of files
!     char_u	*xp_line;		// text being completed
!     int		xp_col;			// cursor position in line
  } expand_T;
  
! /*
!  * values for xp_backslash
!  */
! #define XP_BS_NONE	0	// nothing special for backslashes
! #define XP_BS_ONE	1	// uses one backslash before a space
! #define XP_BS_THREE	2	// uses three backslashes before a space
  
  /*
   * Command modifiers ":vertical", ":browse", ":confirm" and ":hide" set a flag.
***************
*** 580,603 ****
   */
  typedef struct
  {
!     int		hide;			/* TRUE when ":hide" was used */
  # ifdef FEAT_BROWSE_CMD
!     int		browse;			/* TRUE to invoke file dialog */
  # endif
!     int		split;			/* flags for win_split() */
!     int		tab;			/* > 0 when ":tab" was used */
  # if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
!     int		confirm;		/* TRUE to invoke yes/no dialog */
  # endif
!     int		keepalt;		/* TRUE when ":keepalt" was used */
!     int		keepmarks;		/* TRUE when ":keepmarks" was used */
!     int		keepjumps;		/* TRUE when ":keepjumps" was used */
!     int		lockmarks;		/* TRUE when ":lockmarks" was used */
!     int		keeppatterns;		/* TRUE when ":keeppatterns" was used */
!     int		noswapfile;		/* TRUE when ":noswapfile" was used */
!     char_u	*save_ei;		/* saved value of 'eventignore' */
!     regmatch_T	filter_regmatch;	/* set by :filter /pat/ */
!     int		filter_force;		/* set for :filter! */
  } cmdmod_T;
  
  #define MF_SEED_LEN	8
--- 584,607 ----
   */
  typedef struct
  {
!     int		hide;			// TRUE when ":hide" was used
  # ifdef FEAT_BROWSE_CMD
!     int		browse;			// TRUE to invoke file dialog
  # endif
!     int		split;			// flags for win_split()
!     int		tab;			// > 0 when ":tab" was used
  # if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
!     int		confirm;		// TRUE to invoke yes/no dialog
  # endif
!     int		keepalt;		// TRUE when ":keepalt" was used
!     int		keepmarks;		// TRUE when ":keepmarks" was used
!     int		keepjumps;		// TRUE when ":keepjumps" was used
!     int		lockmarks;		// TRUE when ":lockmarks" was used
!     int		keeppatterns;		// TRUE when ":keeppatterns" was used
!     int		noswapfile;		// TRUE when ":noswapfile" was used
!     char_u	*save_ei;		// saved value of 'eventignore'
!     regmatch_T	filter_regmatch;	// set by :filter /pat/
!     int		filter_force;		// set for :filter!
  } cmdmod_T;
  
  #define MF_SEED_LEN	8
***************
*** 644,654 ****
   */
  typedef struct info_pointer
  {
!     blocknr_T	ip_bnum;	/* block number */
!     linenr_T	ip_low;		/* lowest lnum in this block */
!     linenr_T	ip_high;	/* highest lnum in this block */
!     int		ip_index;	/* index for block with current lnum */
! } infoptr_T;	/* block/index pair */
  
  #ifdef FEAT_BYTEOFF
  typedef struct ml_chunksize
--- 648,658 ----
   */
  typedef struct info_pointer
  {
!     blocknr_T	ip_bnum;	// block number
!     linenr_T	ip_low;		// lowest lnum in this block
!     linenr_T	ip_high;	// highest lnum in this block
!     int		ip_index;	// index for block with current lnum
! } infoptr_T;	// block/index pair
  
  #ifdef FEAT_BYTEOFF
  typedef struct ml_chunksize
***************
*** 657,667 ****
      long	mlcs_totalsize;
  } chunksize_T;
  
!  /* Flags when calling ml_updatechunk() */
! 
! #define ML_CHNK_ADDLINE 1
! #define ML_CHNK_DELLINE 2
! #define ML_CHNK_UPDLINE 3
  #endif
  
  /*
--- 661,672 ----
      long	mlcs_totalsize;
  } chunksize_T;
  
! /*
!  * Flags when calling ml_updatechunk()
!  */
! # define ML_CHNK_ADDLINE 1
! # define ML_CHNK_DELLINE 2
! # define ML_CHNK_UPDLINE 3
  #endif
  
  /*
***************
*** 669,696 ****
   */
  typedef struct memline
  {
!     linenr_T	ml_line_count;	/* number of lines in the buffer */
  
!     memfile_T	*ml_mfp;	/* pointer to associated memfile */
  
! #define ML_EMPTY	1	/* empty buffer */
! #define ML_LINE_DIRTY	2	/* cached line was changed and allocated */
! #define ML_LOCKED_DIRTY	4	/* ml_locked was changed */
! #define ML_LOCKED_POS	8	/* ml_locked needs positive block number */
      int		ml_flags;
  
!     infoptr_T	*ml_stack;	/* stack of pointer blocks (array of IPTRs) */
!     int		ml_stack_top;	/* current top of ml_stack */
!     int		ml_stack_size;	/* total number of entries in ml_stack */
! 
!     linenr_T	ml_line_lnum;	/* line number of cached line, 0 if not valid */
!     char_u	*ml_line_ptr;	/* pointer to cached line */
!     colnr_T	ml_line_len;	/* length of the cached line, including NUL */
! 
!     bhdr_T	*ml_locked;	/* block used by last ml_get */
!     linenr_T	ml_locked_low;	/* first line in ml_locked */
!     linenr_T	ml_locked_high;	/* last line in ml_locked */
!     int		ml_locked_lineadd;  /* number of lines inserted in ml_locked */
  #ifdef FEAT_BYTEOFF
      chunksize_T *ml_chunksize;
      int		ml_numchunks;
--- 674,701 ----
   */
  typedef struct memline
  {
!     linenr_T	ml_line_count;	// number of lines in the buffer
  
!     memfile_T	*ml_mfp;	// pointer to associated memfile
  
! #define ML_EMPTY	1	// empty buffer
! #define ML_LINE_DIRTY	2	// cached line was changed and allocated
! #define ML_LOCKED_DIRTY	4	// ml_locked was changed
! #define ML_LOCKED_POS	8	// ml_locked needs positive block number
      int		ml_flags;
  
!     infoptr_T	*ml_stack;	// stack of pointer blocks (array of IPTRs)
!     int		ml_stack_top;	// current top of ml_stack
!     int		ml_stack_size;	// total number of entries in ml_stack
! 
!     linenr_T	ml_line_lnum;	// line number of cached line, 0 if not valid
!     char_u	*ml_line_ptr;	// pointer to cached line
!     colnr_T	ml_line_len;	// length of the cached line, including NUL
! 
!     bhdr_T	*ml_locked;	// block used by last ml_get
!     linenr_T	ml_locked_low;	// first line in ml_locked
!     linenr_T	ml_locked_high;	// last line in ml_locked
!     int		ml_locked_lineadd;  // number of lines inserted in ml_locked
  #ifdef FEAT_BYTEOFF
      chunksize_T *ml_chunksize;
      int		ml_numchunks;
***************
*** 745,757 ****
  
  struct signlist
  {
!     int		id;		/* unique identifier for each placed sign */
!     linenr_T	lnum;		/* line number which has this sign */
!     int		typenr;		/* typenr of sign */
!     signgroup_T	*group;		/* sign group */
!     int		priority;	/* priority for highlighting */
!     signlist_T	*next;		/* next signlist entry */
!     signlist_T  *prev;		/* previous entry -- for easy reordering */
  };
  
  #if defined(FEAT_SIGNS) || defined(PROTO)
--- 750,762 ----
  
  struct signlist
  {
!     int		id;		// unique identifier for each placed sign
!     linenr_T	lnum;		// line number which has this sign
!     int		typenr;		// typenr of sign
!     signgroup_T	*group;		// sign group
!     int		priority;	// priority for highlighting
!     signlist_T	*next;		// next signlist entry
!     signlist_T  *prev;		// previous entry -- for easy reordering
  };
  
  #if defined(FEAT_SIGNS) || defined(PROTO)
***************
*** 775,783 ****
   */
  typedef struct arglist
  {
!     garray_T	al_ga;		/* growarray with the array of file names */
!     int		al_refcount;	/* number of windows using this arglist */
!     int		id;		/* id of this arglist */
  } alist_T;
  
  /*
--- 780,788 ----
   */
  typedef struct arglist
  {
!     garray_T	al_ga;		// growarray with the array of file names
!     int		al_refcount;	// number of windows using this arglist
!     int		id;		// id of this arglist
  } alist_T;
  
  /*
***************
*** 787,794 ****
   */
  typedef struct argentry
  {
!     char_u	*ae_fname;	/* file name as specified */
!     int		ae_fnum;	/* buffer number with expanded file name */
  } aentry_T;
  
  #define ALIST(win)	(win)->w_alist
--- 792,799 ----
   */
  typedef struct argentry
  {
!     char_u	*ae_fname;	// file name as specified
!     int		ae_fnum;	// buffer number with expanded file name
  } aentry_T;
  
  #define ALIST(win)	(win)->w_alist
***************
*** 809,816 ****
  typedef struct eslist_elem eslist_T;
  struct eslist_elem
  {
!     int		saved_emsg_silent;	/* saved value of "emsg_silent" */
!     eslist_T	*next;			/* next element on the list */
  };
  
  /*
--- 814,821 ----
  typedef struct eslist_elem eslist_T;
  struct eslist_elem
  {
!     int		saved_emsg_silent;	// saved value of "emsg_silent"
!     eslist_T	*next;			// next element on the list
  };
  
  /*
***************
*** 821,879 ****
  
  struct condstack
  {
!     short	cs_flags[CSTACK_LEN];	/* CSF_ flags */
!     char	cs_pending[CSTACK_LEN];	/* CSTP_: what's pending in ":finally"*/
      union {
! 	void	*csp_rv[CSTACK_LEN];	/* return typeval for pending return */
! 	void	*csp_ex[CSTACK_LEN];	/* exception for pending throw */
      }		cs_pend;
!     void	*cs_forinfo[CSTACK_LEN]; /* info used by ":for" */
!     int		cs_line[CSTACK_LEN];	/* line nr of ":while"/":for" line */
!     int		cs_idx;			/* current entry, or -1 if none */
!     int		cs_looplevel;		/* nr of nested ":while"s and ":for"s */
!     int		cs_trylevel;		/* nr of nested ":try"s */
!     eslist_T	*cs_emsg_silent_list;	/* saved values of "emsg_silent" */
!     char	cs_lflags;		/* loop flags: CSL_ flags */
  };
  # define cs_rettv	cs_pend.csp_rv
  # define cs_exception	cs_pend.csp_ex
  
! /* There is no CSF_IF, the lack of CSF_WHILE, CSF_FOR and CSF_TRY means ":if"
!  * was used. */
! # define CSF_TRUE	0x0001	/* condition was TRUE */
! # define CSF_ACTIVE	0x0002	/* current state is active */
! # define CSF_ELSE	0x0004	/* ":else" has been passed */
! # define CSF_WHILE	0x0008	/* is a ":while" */
! # define CSF_FOR	0x0010	/* is a ":for" */
! 
! # define CSF_TRY	0x0100	/* is a ":try" */
! # define CSF_FINALLY	0x0200	/* ":finally" has been passed */
! # define CSF_THROWN	0x0400	/* exception thrown to this try conditional */
! # define CSF_CAUGHT	0x0800  /* exception caught by this try conditional */
! # define CSF_SILENT	0x1000	/* "emsg_silent" reset by ":try" */
! /* Note that CSF_ELSE is only used when CSF_TRY and CSF_WHILE are unset
!  * (an ":if"), and CSF_SILENT is only used when CSF_TRY is set. */
  
  /*
   * What's pending for being reactivated at the ":endtry" of this try
   * conditional:
   */
! # define CSTP_NONE	0	/* nothing pending in ":finally" clause */
! # define CSTP_ERROR	1	/* an error is pending */
! # define CSTP_INTERRUPT	2	/* an interrupt is pending */
! # define CSTP_THROW	4	/* a throw is pending */
! # define CSTP_BREAK	8	/* ":break" is pending */
! # define CSTP_CONTINUE	16	/* ":continue" is pending */
! # define CSTP_RETURN	24	/* ":return" is pending */
! # define CSTP_FINISH	32	/* ":finish" is pending */
  
  /*
   * Flags for the cs_lflags item in struct condstack.
   */
! # define CSL_HAD_LOOP	 1	/* just found ":while" or ":for" */
! # define CSL_HAD_ENDLOOP 2	/* just found ":endwhile" or ":endfor" */
! # define CSL_HAD_CONT	 4	/* just found ":continue" */
! # define CSL_HAD_FINA	 8	/* just found ":finally" */
  
  /*
   * A list of error messages that can be converted to an exception.  "throw_msg"
--- 826,884 ----
  
  struct condstack
  {
!     short	cs_flags[CSTACK_LEN];	// CSF_ flags
!     char	cs_pending[CSTACK_LEN];	// CSTP_: what's pending in ":finally"
      union {
! 	void	*csp_rv[CSTACK_LEN];	// return typeval for pending return
! 	void	*csp_ex[CSTACK_LEN];	// exception for pending throw
      }		cs_pend;
!     void	*cs_forinfo[CSTACK_LEN]; // info used by ":for"
!     int		cs_line[CSTACK_LEN];	// line nr of ":while"/":for" line
!     int		cs_idx;			// current entry, or -1 if none
!     int		cs_looplevel;		// nr of nested ":while"s and ":for"s
!     int		cs_trylevel;		// nr of nested ":try"s
!     eslist_T	*cs_emsg_silent_list;	// saved values of "emsg_silent"
!     char	cs_lflags;		// loop flags: CSL_ flags
  };
  # define cs_rettv	cs_pend.csp_rv
  # define cs_exception	cs_pend.csp_ex
  
! // There is no CSF_IF, the lack of CSF_WHILE, CSF_FOR and CSF_TRY means ":if"
! // was used.
! # define CSF_TRUE	0x0001	// condition was TRUE
! # define CSF_ACTIVE	0x0002	// current state is active
! # define CSF_ELSE	0x0004	// ":else" has been passed
! # define CSF_WHILE	0x0008	// is a ":while"
! # define CSF_FOR	0x0010	// is a ":for"
! 
! # define CSF_TRY	0x0100	// is a ":try"
! # define CSF_FINALLY	0x0200	// ":finally" has been passed
! # define CSF_THROWN	0x0400	// exception thrown to this try conditional
! # define CSF_CAUGHT	0x0800  // exception caught by this try conditional
! # define CSF_SILENT	0x1000	// "emsg_silent" reset by ":try"
! // Note that CSF_ELSE is only used when CSF_TRY and CSF_WHILE are unset
! // (an ":if"), and CSF_SILENT is only used when CSF_TRY is set.
  
  /*
   * What's pending for being reactivated at the ":endtry" of this try
   * conditional:
   */
! # define CSTP_NONE	0	// nothing pending in ":finally" clause
! # define CSTP_ERROR	1	// an error is pending
! # define CSTP_INTERRUPT	2	// an interrupt is pending
! # define CSTP_THROW	4	// a throw is pending
! # define CSTP_BREAK	8	// ":break" is pending
! # define CSTP_CONTINUE	16	// ":continue" is pending
! # define CSTP_RETURN	24	// ":return" is pending
! # define CSTP_FINISH	32	// ":finish" is pending
  
  /*
   * Flags for the cs_lflags item in struct condstack.
   */
! # define CSL_HAD_LOOP	 1	// just found ":while" or ":for"
! # define CSL_HAD_ENDLOOP 2	// just found ":endwhile" or ":endfor"
! # define CSL_HAD_CONT	 4	// just found ":continue"
! # define CSL_HAD_FINA	 8	// just found ":finally"
  
  /*
   * A list of error messages that can be converted to an exception.  "throw_msg"
***************
*** 883,891 ****
   */
  struct msglist
  {
!     char		*msg;		/* original message */
!     char		*throw_msg;	/* msg to throw: usually original one */
!     struct msglist	*next;		/* next of several messages in a row */
  };
  
  /*
--- 888,896 ----
   */
  struct msglist
  {
!     char		*msg;		// original message
!     char		*throw_msg;	// msg to throw: usually original one
!     struct msglist	*next;		// next of several messages in a row
  };
  
  /*
***************
*** 905,916 ****
  typedef struct vim_exception except_T;
  struct vim_exception
  {
!     except_type_T	type;		/* exception type */
!     char		*value;		/* exception value */
!     struct msglist	*messages;	/* message(s) causing error exception */
!     char_u		*throw_name;	/* name of the throw point */
!     linenr_T		throw_lnum;	/* line number of the throw point */
!     except_T		*caught;	/* next exception on the caught stack */
  };
  
  /*
--- 910,921 ----
  typedef struct vim_exception except_T;
  struct vim_exception
  {
!     except_type_T	type;		// exception type
!     char		*value;		// exception value
!     struct msglist	*messages;	// message(s) causing error exception
!     char_u		*throw_name;	// name of the throw point
!     linenr_T		throw_lnum;	// line number of the throw point
!     except_T		*caught;	// next exception on the caught stack
  };
  
  /*
***************
*** 921,937 ****
  typedef struct cleanup_stuff cleanup_T;
  struct cleanup_stuff
  {
!     int pending;		/* error/interrupt/exception state */
!     except_T *exception;	/* exception value */
  };
  
  #ifdef FEAT_SYN_HL
! /* struct passed to in_id_list() */
  struct sp_syn
  {
!     int		inc_tag;	/* ":syn include" unique tag */
!     short	id;		/* highlight group ID of item */
!     short	*cont_in_list;	/* cont.in group IDs, if non-zero */
  };
  
  /*
--- 926,942 ----
  typedef struct cleanup_stuff cleanup_T;
  struct cleanup_stuff
  {
!     int pending;		// error/interrupt/exception state
!     except_T *exception;	// exception value
  };
  
  #ifdef FEAT_SYN_HL
! // struct passed to in_id_list()
  struct sp_syn
  {
!     int		inc_tag;	// ":syn include" unique tag
!     short	id;		// highlight group ID of item
!     short	*cont_in_list;	// cont.in group IDs, if non-zero
  };
  
  /*
***************
*** 941,952 ****
  
  struct keyentry
  {
!     keyentry_T	*ke_next;	/* next entry with identical "keyword[]" */
!     struct sp_syn k_syn;	/* struct passed to in_id_list() */
!     short	*next_list;	/* ID list for next match (if non-zero) */
      int		flags;
!     int		k_char;		/* conceal substitute character */
!     char_u	keyword[1];	/* actually longer */
  };
  
  /*
--- 946,957 ----
  
  struct keyentry
  {
!     keyentry_T	*ke_next;	// next entry with identical "keyword[]"
!     struct sp_syn k_syn;	// struct passed to in_id_list()
!     short	*next_list;	// ID list for next match (if non-zero)
      int		flags;
!     int		k_char;		// conceal substitute character
!     char_u	keyword[1];	// actually longer
  };
  
  /*
***************
*** 954,966 ****
   */
  typedef struct buf_state
  {
!     int		    bs_idx;	 /* index of pattern */
!     int		    bs_flags;	 /* flags for pattern */
  #ifdef FEAT_CONCEAL
!     int		    bs_seqnr;	 /* stores si_seqnr */
!     int		    bs_cchar;	 /* stores si_cchar */
  #endif
!     reg_extmatch_T *bs_extmatch; /* external matches from start pattern */
  } bufstate_T;
  
  /*
--- 959,971 ----
   */
  typedef struct buf_state
  {
!     int		    bs_idx;	 // index of pattern
!     int		    bs_flags;	 // flags for pattern
  #ifdef FEAT_CONCEAL
!     int		    bs_seqnr;	 // stores si_seqnr
!     int		    bs_cchar;	 // stores si_cchar
  #endif
!     reg_extmatch_T *bs_extmatch; // external matches from start pattern
  } bufstate_T;
  
  /*
***************
*** 971,1025 ****
  
  struct syn_state
  {
!     synstate_T	*sst_next;	/* next entry in used or free list */
!     linenr_T	sst_lnum;	/* line number for this state */
      union
      {
! 	bufstate_T	sst_stack[SST_FIX_STATES]; /* short state stack */
! 	garray_T	sst_ga;	/* growarray for long state stack */
      } sst_union;
!     int		sst_next_flags;	/* flags for sst_next_list */
!     int		sst_stacksize;	/* number of states on the stack */
!     short	*sst_next_list;	/* "nextgroup" list in this state
! 				 * (this is a copy, don't free it! */
!     disptick_T	sst_tick;	/* tick when last displayed */
!     linenr_T	sst_change_lnum;/* when non-zero, change in this line
! 				 * may have made the state invalid */
  };
! #endif /* FEAT_SYN_HL */
  
  /*
   * Structure shared between syntax.c, screen.c and gui_x11.c.
   */
  typedef struct attr_entry
  {
!     short	    ae_attr;		/* HL_BOLD, etc. */
      union
      {
  	struct
  	{
! 	    char_u	    *start;	/* start escape sequence */
! 	    char_u	    *stop;	/* stop escape sequence */
  	} term;
  	struct
  	{
! 	    /* These colors need to be > 8 bits to hold 256. */
! 	    short_u	    fg_color;	/* foreground color number */
! 	    short_u	    bg_color;	/* background color number */
  # ifdef FEAT_TERMGUICOLORS
! 	    guicolor_T	    fg_rgb;	/* foreground color RGB */
! 	    guicolor_T	    bg_rgb;	/* background color RGB */
  # endif
  	} cterm;
  # ifdef FEAT_GUI
  	struct
  	{
! 	    guicolor_T	    fg_color;	/* foreground color handle */
! 	    guicolor_T	    bg_color;	/* background color handle */
! 	    guicolor_T	    sp_color;	/* special color handle */
! 	    GuiFont	    font;	/* font handle */
  #  ifdef FEAT_XFONTSET
! 	    GuiFontset	    fontset;	/* fontset handle */
  #  endif
  	} gui;
  # endif
--- 976,1030 ----
  
  struct syn_state
  {
!     synstate_T	*sst_next;	// next entry in used or free list
!     linenr_T	sst_lnum;	// line number for this state
      union
      {
! 	bufstate_T	sst_stack[SST_FIX_STATES]; // short state stack
! 	garray_T	sst_ga;	// growarray for long state stack
      } sst_union;
!     int		sst_next_flags;	// flags for sst_next_list
!     int		sst_stacksize;	// number of states on the stack
!     short	*sst_next_list;	// "nextgroup" list in this state
! 				// (this is a copy, don't free it!
!     disptick_T	sst_tick;	// tick when last displayed
!     linenr_T	sst_change_lnum;// when non-zero, change in this line
! 				// may have made the state invalid
  };
! #endif // FEAT_SYN_HL
  
  /*
   * Structure shared between syntax.c, screen.c and gui_x11.c.
   */
  typedef struct attr_entry
  {
!     short	    ae_attr;		// HL_BOLD, etc.
      union
      {
  	struct
  	{
! 	    char_u	    *start;	// start escape sequence
! 	    char_u	    *stop;	// stop escape sequence
  	} term;
  	struct
  	{
! 	    // These colors need to be > 8 bits to hold 256.
! 	    short_u	    fg_color;	// foreground color number
! 	    short_u	    bg_color;	// background color number
  # ifdef FEAT_TERMGUICOLORS
! 	    guicolor_T	    fg_rgb;	// foreground color RGB
! 	    guicolor_T	    bg_rgb;	// background color RGB
  # endif
  	} cterm;
  # ifdef FEAT_GUI
  	struct
  	{
! 	    guicolor_T	    fg_color;	// foreground color handle
! 	    guicolor_T	    bg_color;	// background color handle
! 	    guicolor_T	    sp_color;	// special color handle
! 	    GuiFont	    font;	// font handle
  #  ifdef FEAT_XFONTSET
! 	    GuiFontset	    fontset;	// fontset handle
  #  endif
  	} gui;
  # endif
***************
*** 1033,1039 ****
  #  if defined(MACOS_X)
  #   include <sys/errno.h>
  #   ifndef EILSEQ
! #    define EILSEQ ENOENT /* Early MacOS X does not have EILSEQ */
  #   endif
  typedef struct _iconv_t *iconv_t;
  #  else
--- 1038,1044 ----
  #  if defined(MACOS_X)
  #   include <sys/errno.h>
  #   ifndef EILSEQ
! #    define EILSEQ ENOENT // Early MacOS X does not have EILSEQ
  #   endif
  typedef struct _iconv_t *iconv_t;
  #  else
***************
*** 1048,1069 ****
   */
  typedef struct
  {
!     char_u	*tb_buf;	/* buffer for typed characters */
!     char_u	*tb_noremap;	/* mapping flags for characters in tb_buf[] */
!     int		tb_buflen;	/* size of tb_buf[] */
!     int		tb_off;		/* current position in tb_buf[] */
!     int		tb_len;		/* number of valid bytes in tb_buf[] */
!     int		tb_maplen;	/* nr of mapped bytes in tb_buf[] */
!     int		tb_silent;	/* nr of silently mapped bytes in tb_buf[] */
!     int		tb_no_abbr_cnt; /* nr of bytes without abbrev. in tb_buf[] */
!     int		tb_change_cnt;	/* nr of time tb_buf was changed; never zero */
  } typebuf_T;
  
  /* Struct to hold the saved typeahead for save_typeahead(). */
  typedef struct
  {
      typebuf_T		save_typebuf;
!     int			typebuf_valid;	    /* TRUE when save_typebuf valid */
      int			old_char;
      int			old_mod_mask;
      buffheader_T	save_readbuf1;
--- 1053,1074 ----
   */
  typedef struct
  {
!     char_u	*tb_buf;	// buffer for typed characters
!     char_u	*tb_noremap;	// mapping flags for characters in tb_buf[]
!     int		tb_buflen;	// size of tb_buf[]
!     int		tb_off;		// current position in tb_buf[]
!     int		tb_len;		// number of valid bytes in tb_buf[]
!     int		tb_maplen;	// nr of mapped bytes in tb_buf[]
!     int		tb_silent;	// nr of silently mapped bytes in tb_buf[]
!     int		tb_no_abbr_cnt; // nr of bytes without abbrev. in tb_buf[]
!     int		tb_change_cnt;	// nr of time tb_buf was changed; never zero
  } typebuf_T;
  
  /* Struct to hold the saved typeahead for save_typeahead(). */
  typedef struct
  {
      typebuf_T		save_typebuf;
!     int			typebuf_valid;	    // TRUE when save_typebuf valid
      int			old_char;
      int			old_mod_mask;
      buffheader_T	save_readbuf1;
***************
*** 1078,1093 ****
   */
  typedef struct
  {
!     int		vc_type;	/* zero or one of the CONV_ values */
!     int		vc_factor;	/* max. expansion factor */
  # ifdef MSWIN
!     int		vc_cpfrom;	/* codepage to convert from (CONV_CODEPAGE) */
!     int		vc_cpto;	/* codepage to convert to (CONV_CODEPAGE) */
  # endif
  # ifdef USE_ICONV
!     iconv_t	vc_fd;		/* for CONV_ICONV */
  # endif
!     int		vc_fail;	/* fail for invalid char, don't use '?' */
  } vimconv_T;
  
  /*
--- 1083,1098 ----
   */
  typedef struct
  {
!     int		vc_type;	// zero or one of the CONV_ values
!     int		vc_factor;	// max. expansion factor
  # ifdef MSWIN
!     int		vc_cpfrom;	// codepage to convert from (CONV_CODEPAGE)
!     int		vc_cpto;	// codepage to convert to (CONV_CODEPAGE)
  # endif
  # ifdef USE_ICONV
!     iconv_t	vc_fd;		// for CONV_ICONV
  # endif
!     int		vc_fail;	// fail for invalid char, don't use '?'
  } vimconv_T;
  
  /*
***************
*** 1095,1105 ****
   */
  typedef struct
  {
!     char_u	*vir_line;	/* text of the current line */
!     FILE	*vir_fd;	/* file descriptor */
!     vimconv_T	vir_conv;	/* encoding conversion */
!     int		vir_version;	/* viminfo version detected or -1 */
!     garray_T	vir_barlines;	/* lines starting with | */
  } vir_T;
  
  #define CONV_NONE		0
--- 1100,1110 ----
   */
  typedef struct
  {
!     char_u	*vir_line;	// text of the current line
!     FILE	*vir_fd;	// file descriptor
!     vimconv_T	vir_conv;	// encoding conversion
!     int		vir_version;	// viminfo version detected or -1
!     garray_T	vir_barlines;	// lines starting with |
  } vir_T;
  
  #define CONV_NONE		0
***************
*** 1109,1115 ****
  #define CONV_TO_LATIN9		4
  #define CONV_ICONV		5
  #ifdef MSWIN
! # define CONV_CODEPAGE		10	/* codepage -> codepage */
  #endif
  #ifdef MACOS_X
  # define CONV_MAC_LATIN1	20
--- 1114,1120 ----
  #define CONV_TO_LATIN9		4
  #define CONV_ICONV		5
  #ifdef MSWIN
! # define CONV_CODEPAGE		10	// codepage -> codepage
  #endif
  #ifdef MACOS_X
  # define CONV_MAC_LATIN1	20
***************
*** 1124,1141 ****
  typedef struct mapblock mapblock_T;
  struct mapblock
  {
!     mapblock_T	*m_next;	/* next mapblock in list */
!     char_u	*m_keys;	/* mapped from, lhs */
!     char_u	*m_str;		/* mapped to, rhs */
!     char_u	*m_orig_str;	/* rhs as entered by the user */
!     int		m_keylen;	/* strlen(m_keys) */
!     int		m_mode;		/* valid mode */
!     int		m_noremap;	/* if non-zero no re-mapping for m_str */
!     char	m_silent;	/* <silent> used, don't echo commands */
!     char	m_nowait;	/* <nowait> used */
  #ifdef FEAT_EVAL
!     char	m_expr;		/* <expr> used, m_str is an expression */
!     sctx_T	m_script_ctx;		/* SCTX where map was defined */
  #endif
  };
  
--- 1129,1146 ----
  typedef struct mapblock mapblock_T;
  struct mapblock
  {
!     mapblock_T	*m_next;	// next mapblock in list
!     char_u	*m_keys;	// mapped from, lhs
!     char_u	*m_str;		// mapped to, rhs
!     char_u	*m_orig_str;	// rhs as entered by the user
!     int		m_keylen;	// strlen(m_keys)
!     int		m_mode;		// valid mode
!     int		m_noremap;	// if non-zero no re-mapping for m_str
!     char	m_silent;	// <silent> used, don't echo commands
!     char	m_nowait;	// <nowait> used
  #ifdef FEAT_EVAL
!     char	m_expr;		// <expr> used, m_str is an expression
!     sctx_T	m_script_ctx;	// SCTX where map was defined
  #endif
  };
  
***************
*** 1145,1151 ****
  struct stl_hlrec
  {
      char_u	*start;
!     int		userhl;		/* 0: no HL, 1-9: User HL, < 0 for syn ID */
  };
  
  
--- 1150,1156 ----
  struct stl_hlrec
  {
      char_u	*start;
!     int		userhl;		// 0: no HL, 1-9: User HL, < 0 for syn ID
  };
  
  
***************
*** 1162,1199 ****
   */
  typedef struct hashitem_S
  {
!     long_u	hi_hash;	/* cached hash number of hi_key */
      char_u	*hi_key;
  } hashitem_T;
  
! /* The address of "hash_removed" is used as a magic number for hi_key to
!  * indicate a removed item. */
  #define HI_KEY_REMOVED &hash_removed
  #define HASHITEM_EMPTY(hi) ((hi)->hi_key == NULL || (hi)->hi_key == &hash_removed)
  
! /* Initial size for a hashtable.  Our items are relatively small and growing
!  * is expensive, thus use 16 as a start.  Must be a power of 2. */
  #define HT_INIT_SIZE 16
  
  typedef struct hashtable_S
  {
!     long_u	ht_mask;	/* mask used for hash value (nr of items in
! 				 * array is "ht_mask" + 1) */
!     long_u	ht_used;	/* number of items used */
!     long_u	ht_filled;	/* number of items used + removed */
!     int		ht_locked;	/* counter for hash_lock() */
!     int		ht_error;	/* when set growing failed, can't add more
! 				   items before growing works */
!     hashitem_T	*ht_array;	/* points to the array, allocated when it's
! 				   not "ht_smallarray" */
!     hashitem_T	ht_smallarray[HT_INIT_SIZE];   /* initial array */
  } hashtab_T;
  
! typedef long_u hash_T;		/* Type for hi_hash */
  
  
  #ifdef FEAT_NUM64
! /* Use 64-bit Number. */
  # ifdef MSWIN
  #  ifdef PROTO
  typedef long		    varnumber_T;
--- 1167,1204 ----
   */
  typedef struct hashitem_S
  {
!     long_u	hi_hash;	// cached hash number of hi_key
      char_u	*hi_key;
  } hashitem_T;
  
! // The address of "hash_removed" is used as a magic number for hi_key to
! // indicate a removed item.
  #define HI_KEY_REMOVED &hash_removed
  #define HASHITEM_EMPTY(hi) ((hi)->hi_key == NULL || (hi)->hi_key == &hash_removed)
  
! // Initial size for a hashtable.  Our items are relatively small and growing
! // is expensive, thus use 16 as a start.  Must be a power of 2.
  #define HT_INIT_SIZE 16
  
  typedef struct hashtable_S
  {
!     long_u	ht_mask;	// mask used for hash value (nr of items in
! 				// array is "ht_mask" + 1)
!     long_u	ht_used;	// number of items used
!     long_u	ht_filled;	// number of items used + removed
!     int		ht_locked;	// counter for hash_lock()
!     int		ht_error;	// when set growing failed, can't add more
! 				// items before growing works
!     hashitem_T	*ht_array;	// points to the array, allocated when it's
! 				// not "ht_smallarray"
!     hashitem_T	ht_smallarray[HT_INIT_SIZE];   // initial array
  } hashtab_T;
  
! typedef long_u hash_T;		// Type for hi_hash
  
  
  #ifdef FEAT_NUM64
! // Use 64-bit Number.
  # ifdef MSWIN
  #  ifdef PROTO
  typedef long		    varnumber_T;
***************
*** 1222,1228 ****
  #  define UVARNUM_MAX	    ULONG_MAX
  # endif
  #else
! /* Use 32-bit Number. */
  typedef int		    varnumber_T;
  typedef unsigned int	    uvarnumber_T;
  # define VARNUM_MIN	    INT_MIN
--- 1227,1233 ----
  #  define UVARNUM_MAX	    ULONG_MAX
  # endif
  #else
! // Use 32-bit Number.
  typedef int		    varnumber_T;
  typedef unsigned int	    uvarnumber_T;
  # define VARNUM_MIN	    INT_MIN
***************
*** 1277,1309 ****
  typedef struct
  {
      vartype_T	v_type;
!     char	v_lock;	    /* see below: VAR_LOCKED, VAR_FIXED */
      union
      {
! 	varnumber_T	v_number;	/* number value */
  #ifdef FEAT_FLOAT
! 	float_T		v_float;	/* floating number value */
  #endif
! 	char_u		*v_string;	/* string value (can be NULL!) */
! 	list_T		*v_list;	/* list value (can be NULL!) */
! 	dict_T		*v_dict;	/* dict value (can be NULL!) */
! 	partial_T	*v_partial;	/* closure: function with args */
  #ifdef FEAT_JOB_CHANNEL
! 	job_T		*v_job;		/* job value (can be NULL!) */
! 	channel_T	*v_channel;	/* channel value (can be NULL!) */
  #endif
! 	blob_T		*v_blob;	/* blob value (can be NULL!) */
      }		vval;
  } typval_T;
  
! /* Values for "dv_scope". */
! #define VAR_SCOPE     1	/* a:, v:, s:, etc. scope dictionaries */
! #define VAR_DEF_SCOPE 2	/* l:, g: scope dictionaries: here funcrefs are not
! 			   allowed to mask existing functions */
! 
! /* Values for "v_lock". */
! #define VAR_LOCKED  1	/* locked with lock(), can use unlock() */
! #define VAR_FIXED   2	/* locked forever */
  
  /*
   * Structure to hold an item of a list: an internal variable without a name.
--- 1282,1314 ----
  typedef struct
  {
      vartype_T	v_type;
!     char	v_lock;	    // see below: VAR_LOCKED, VAR_FIXED
      union
      {
! 	varnumber_T	v_number;	// number value
  #ifdef FEAT_FLOAT
! 	float_T		v_float;	// floating number value
  #endif
! 	char_u		*v_string;	// string value (can be NULL!)
! 	list_T		*v_list;	// list value (can be NULL!)
! 	dict_T		*v_dict;	// dict value (can be NULL!)
! 	partial_T	*v_partial;	// closure: function with args
  #ifdef FEAT_JOB_CHANNEL
! 	job_T		*v_job;		// job value (can be NULL!)
! 	channel_T	*v_channel;	// channel value (can be NULL!)
  #endif
! 	blob_T		*v_blob;	// blob value (can be NULL!)
      }		vval;
  } typval_T;
  
! // Values for "dv_scope".
! #define VAR_SCOPE     1	// a:, v:, s:, etc. scope dictionaries
! #define VAR_DEF_SCOPE 2	// l:, g: scope dictionaries: here funcrefs are not
! 			// allowed to mask existing functions
! 
! // Values for "v_lock".
! #define VAR_LOCKED  1	// locked with lock(), can use unlock()
! #define VAR_FIXED   2	// locked forever
  
  /*
   * Structure to hold an item of a list: an internal variable without a name.
***************
*** 1312,1331 ****
  
  struct listitem_S
  {
!     listitem_T	*li_next;	/* next item in list */
!     listitem_T	*li_prev;	/* previous item in list */
!     typval_T	li_tv;		/* type and value of the variable */
  };
  
! /*
!  * Struct used by those that are using an item in a list.
!  */
  typedef struct listwatch_S listwatch_T;
  
  struct listwatch_S
  {
!     listitem_T		*lw_item;	/* item being watched */
!     listwatch_T		*lw_next;	/* next watcher */
  };
  
  /*
--- 1317,1334 ----
  
  struct listitem_S
  {
!     listitem_T	*li_next;	// next item in list
!     listitem_T	*li_prev;	// previous item in list
!     typval_T	li_tv;		// type and value of the variable
  };
  
! // Struct used by those that are using an item in a list.
  typedef struct listwatch_S listwatch_T;
  
  struct listwatch_S
  {
!     listitem_T		*lw_item;	// item being watched
!     listwatch_T		*lw_next;	// next watcher
  };
  
  /*
***************
*** 1334,1358 ****
   */
  struct listvar_S
  {
!     listitem_T	*lv_first;	/* first item, NULL if none */
!     listitem_T	*lv_last;	/* last item, NULL if none */
!     listwatch_T	*lv_watch;	/* first watcher, NULL if none */
!     listitem_T	*lv_idx_item;	/* when not NULL item at index "lv_idx" */
!     list_T	*lv_copylist;	/* copied list used by deepcopy() */
!     list_T	*lv_used_next;	/* next list in used lists list */
!     list_T	*lv_used_prev;	/* previous list in used lists list */
!     int		lv_refcount;	/* reference count */
!     int		lv_len;		/* number of items */
!     int		lv_idx;		/* cached index of an item */
!     int		lv_copyID;	/* ID used by deepcopy() */
!     char	lv_lock;	/* zero, VAR_LOCKED, VAR_FIXED */
  };
  
  /*
   * Static list with 10 items.  Use init_static_list() to initialize.
   */
  typedef struct {
!     list_T	sl_list;	/* must be first */
      listitem_T	sl_items[10];
  } staticList10_T;
  
--- 1337,1361 ----
   */
  struct listvar_S
  {
!     listitem_T	*lv_first;	// first item, NULL if none
!     listitem_T	*lv_last;	// last item, NULL if none
!     listwatch_T	*lv_watch;	// first watcher, NULL if none
!     listitem_T	*lv_idx_item;	// when not NULL item at index "lv_idx"
!     list_T	*lv_copylist;	// copied list used by deepcopy()
!     list_T	*lv_used_next;	// next list in used lists list
!     list_T	*lv_used_prev;	// previous list in used lists list
!     int		lv_refcount;	// reference count
!     int		lv_len;		// number of items
!     int		lv_idx;		// cached index of an item
!     int		lv_copyID;	// ID used by deepcopy()
!     char	lv_lock;	// zero, VAR_LOCKED, VAR_FIXED
  };
  
  /*
   * Static list with 10 items.  Use init_static_list() to initialize.
   */
  typedef struct {
!     list_T	sl_list;	// must be first
      listitem_T	sl_items[10];
  } staticList10_T;
  
***************
*** 1363,1371 ****
   */
  struct dictitem_S
  {
!     typval_T	di_tv;		/* type and value of the variable */
!     char_u	di_flags;	/* flags (only used for variable) */
!     char_u	di_key[1];	/* key (actually longer!) */
  };
  typedef struct dictitem_S dictitem_T;
  
--- 1366,1374 ----
   */
  struct dictitem_S
  {
!     typval_T	di_tv;		// type and value of the variable
!     char_u	di_flags;	// flags (only used for variable)
!     char_u	di_key[1];	// key (actually longer!)
  };
  typedef struct dictitem_S dictitem_T;
  
***************
*** 1376,1406 ****
  #define DICTITEM16_KEY_LEN 16
  struct dictitem16_S
  {
!     typval_T	di_tv;		/* type and value of the variable */
!     char_u	di_flags;	/* flags (only used for variable) */
!     char_u	di_key[DICTITEM16_KEY_LEN + 1];	/* key */
  };
  typedef struct dictitem16_S dictitem16_T;
  
! #define DI_FLAGS_RO	1  /* "di_flags" value: read-only variable */
! #define DI_FLAGS_RO_SBX 2  /* "di_flags" value: read-only in the sandbox */
! #define DI_FLAGS_FIX	4  /* "di_flags" value: fixed: no :unlet or remove() */
! #define DI_FLAGS_LOCK	8  /* "di_flags" value: locked variable */
! #define DI_FLAGS_ALLOC	16 /* "di_flags" value: separately allocated */
  
  /*
   * Structure to hold info about a Dictionary.
   */
  struct dictvar_S
  {
!     char	dv_lock;	/* zero, VAR_LOCKED, VAR_FIXED */
!     char	dv_scope;	/* zero, VAR_SCOPE, VAR_DEF_SCOPE */
!     int		dv_refcount;	/* reference count */
!     int		dv_copyID;	/* ID used by deepcopy() */
!     hashtab_T	dv_hashtab;	/* hashtab that refers to the items */
!     dict_T	*dv_copydict;	/* copied dict used by deepcopy() */
!     dict_T	*dv_used_next;	/* next dict in used dicts list */
!     dict_T	*dv_used_prev;	/* previous dict in used dicts list */
  };
  
  /*
--- 1379,1409 ----
  #define DICTITEM16_KEY_LEN 16
  struct dictitem16_S
  {
!     typval_T	di_tv;		// type and value of the variable
!     char_u	di_flags;	// flags (only used for variable)
!     char_u	di_key[DICTITEM16_KEY_LEN + 1];	// key
  };
  typedef struct dictitem16_S dictitem16_T;
  
! #define DI_FLAGS_RO	1  // "di_flags" value: read-only variable
! #define DI_FLAGS_RO_SBX 2  // "di_flags" value: read-only in the sandbox
! #define DI_FLAGS_FIX	4  // "di_flags" value: fixed: no :unlet or remove()
! #define DI_FLAGS_LOCK	8  // "di_flags" value: locked variable
! #define DI_FLAGS_ALLOC	16 // "di_flags" value: separately allocated
  
  /*
   * Structure to hold info about a Dictionary.
   */
  struct dictvar_S
  {
!     char	dv_lock;	// zero, VAR_LOCKED, VAR_FIXED
!     char	dv_scope;	// zero, VAR_SCOPE, VAR_DEF_SCOPE
!     int		dv_refcount;	// reference count
!     int		dv_copyID;	// ID used by deepcopy()
!     hashtab_T	dv_hashtab;	// hashtab that refers to the items
!     dict_T	*dv_copydict;	// copied dict used by deepcopy()
!     dict_T	*dv_used_next;	// next dict in used dicts list
!     dict_T	*dv_used_prev;	// previous dict in used dicts list
  };
  
  /*
***************
*** 1462,1496 ****
  /* structure to hold info for a function that is currently being executed. */
  struct funccall_S
  {
!     ufunc_T	*func;		/* function being called */
!     int		linenr;		/* next line to be executed */
!     int		returned;	/* ":return" used */
!     struct			/* fixed variables for arguments */
      {
! 	dictitem_T	var;		/* variable (without room for name) */
! 	char_u	room[VAR_SHORT_LEN];	/* room for the name */
      } fixvar[FIXVAR_CNT];
!     dict_T	l_vars;		/* l: local function variables */
!     dictitem_T	l_vars_var;	/* variable for l: scope */
!     dict_T	l_avars;	/* a: argument variables */
!     dictitem_T	l_avars_var;	/* variable for a: scope */
!     list_T	l_varlist;	/* list for a:000 */
!     listitem_T	l_listitems[MAX_FUNC_ARGS];	/* listitems for a:000 */
!     typval_T	*rettv;		/* return value */
!     linenr_T	breakpoint;	/* next line with breakpoint or zero */
!     int		dbg_tick;	/* debug_tick when breakpoint was set */
!     int		level;		/* top nesting level of executed function */
  #ifdef FEAT_PROFILE
!     proftime_T	prof_child;	/* time spent in a child */
  #endif
!     funccall_T	*caller;	/* calling function or NULL */
  
!     /* for closure */
!     int		fc_refcount;	/* number of user functions that reference this
! 				 * funccal */
!     int		fc_copyID;	/* for garbage collection */
!     garray_T	fc_funcs;	/* list of ufunc_T* which keep a reference to
! 				 * "func" */
  };
  
  /*
--- 1465,1499 ----
  /* structure to hold info for a function that is currently being executed. */
  struct funccall_S
  {
!     ufunc_T	*func;		// function being called
!     int		linenr;		// next line to be executed
!     int		returned;	// ":return" used
!     struct			// fixed variables for arguments
      {
! 	dictitem_T	var;		// variable (without room for name)
! 	char_u	room[VAR_SHORT_LEN];	// room for the name
      } fixvar[FIXVAR_CNT];
!     dict_T	l_vars;		// l: local function variables
!     dictitem_T	l_vars_var;	// variable for l: scope
!     dict_T	l_avars;	// a: argument variables
!     dictitem_T	l_avars_var;	// variable for a: scope
!     list_T	l_varlist;	// list for a:000
!     listitem_T	l_listitems[MAX_FUNC_ARGS];	// listitems for a:000
!     typval_T	*rettv;		// return value
!     linenr_T	breakpoint;	// next line with breakpoint or zero
!     int		dbg_tick;	// debug_tick when breakpoint was set
!     int		level;		// top nesting level of executed function
  #ifdef FEAT_PROFILE
!     proftime_T	prof_child;	// time spent in a child
  #endif
!     funccall_T	*caller;	// calling function or NULL
  
!     // for closure
!     int		fc_refcount;	// number of user functions that reference this
! 				// funccal
!     int		fc_copyID;	// for garbage collection
!     garray_T	fc_funcs;	// list of ufunc_T* which keep a reference to
! 				// "func"
  };
  
  /*
***************
*** 1498,1506 ****
   */
  typedef struct
  {
!     dict_T	*fd_dict;	/* Dictionary used */
!     char_u	*fd_newkey;	/* new key in "dict" in allocated memory */
!     dictitem_T	*fd_di;		/* Dictionary item used */
  } funcdict_T;
  
  typedef struct funccal_entry funccal_entry_T;
--- 1501,1509 ----
   */
  typedef struct
  {
!     dict_T	*fd_dict;	// Dictionary used
!     char_u	*fd_newkey;	// new key in "dict" in allocated memory
!     dictitem_T	*fd_di;		// Dictionary item used
  } funcdict_T;
  
  typedef struct funccal_entry funccal_entry_T;
***************
*** 1510,1516 ****
  };
  
  #else
! /* dummy typedefs for function prototypes */
  typedef struct
  {
      int	    dummy;
--- 1513,1519 ----
  };
  
  #else
! // dummy typedefs for use in function prototypes
  typedef struct
  {
      int	    dummy;
***************
*** 1527,1553 ****
  
  struct partial_S
  {
!     int		pt_refcount;	/* reference count */
!     char_u	*pt_name;	/* function name; when NULL use
! 				 * pt_func->uf_name */
!     ufunc_T	*pt_func;	/* function pointer; when NULL lookup function
! 				 * with pt_name */
!     int		pt_auto;	/* when TRUE the partial was created for using
! 				   dict.member in handle_subscript() */
!     int		pt_argc;	/* number of arguments */
!     typval_T	*pt_argv;	/* arguments in allocated array */
!     dict_T	*pt_dict;	/* dict for "self" */
  };
  
! /* Information returned by get_tty_info(). */
  typedef struct {
!     int backspace;	/* what the Backspace key produces */
!     int enter;		/* what the Enter key produces */
!     int interrupt;	/* interrupt character */
!     int nl_does_cr;	/* TRUE when a NL is expanded to CR-NL on output */
  } ttyinfo_T;
  
! /* Status of a job.  Order matters! */
  typedef enum
  {
      JOB_FAILED,
--- 1530,1556 ----
  
  struct partial_S
  {
!     int		pt_refcount;	// reference count
!     char_u	*pt_name;	// function name; when NULL use
! 				// pt_func->uf_name
!     ufunc_T	*pt_func;	// function pointer; when NULL lookup function
! 				// with pt_name
!     int		pt_auto;	// when TRUE the partial was created for using
! 				// dict.member in handle_subscript()
!     int		pt_argc;	// number of arguments
!     typval_T	*pt_argv;	// arguments in allocated array
!     dict_T	*pt_dict;	// dict for "self"
  };
  
! // Information returned by get_tty_info().
  typedef struct {
!     int backspace;	// what the Backspace key produces
!     int enter;		// what the Enter key produces
!     int interrupt;	// interrupt character
!     int nl_does_cr;	// TRUE when a NL is expanded to CR-NL on output
  } ttyinfo_T;
  
! // Status of a job.  Order matters!
  typedef enum
  {
      JOB_FAILED,
***************
*** 1570,1581 ****
      PROCESS_INFORMATION	jv_proc_info;
      HANDLE		jv_job_object;
  #endif
!     char_u	*jv_tty_in;	/* controlling tty input, allocated */
!     char_u	*jv_tty_out;	/* controlling tty output, allocated */
      jobstatus_T	jv_status;
!     char_u	*jv_stoponexit;	/* allocated */
  #ifdef UNIX
!     char_u	*jv_termsig;	/* allocated */
  #endif
  #ifdef MSWIN
      char_u	*jv_tty_type;	// allocated
--- 1573,1584 ----
      PROCESS_INFORMATION	jv_proc_info;
      HANDLE		jv_job_object;
  #endif
!     char_u	*jv_tty_in;	// controlling tty input, allocated
!     char_u	*jv_tty_out;	// controlling tty output, allocated
      jobstatus_T	jv_status;
!     char_u	*jv_stoponexit;	// allocated
  #ifdef UNIX
!     char_u	*jv_termsig;	// allocated
  #endif
  #ifdef MSWIN
      char_u	*jv_tty_type;	// allocated
***************
*** 1583,1595 ****
      int		jv_exitval;
      callback_T	jv_exit_cb;
  
!     buf_T	*jv_in_buf;	/* buffer from "in-name" */
  
!     int		jv_refcount;	/* reference count */
      int		jv_copyID;
  
!     channel_T	*jv_channel;	/* channel for I/O, reference counted */
!     char	**jv_argv;	/* command line used to start the job */
  };
  
  /*
--- 1586,1598 ----
      int		jv_exitval;
      callback_T	jv_exit_cb;
  
!     buf_T	*jv_in_buf;	// buffer from "in-name"
  
!     int		jv_refcount;	// reference count
      int		jv_copyID;
  
!     channel_T	*jv_channel;	// channel for I/O, reference counted
!     char	**jv_argv;	// command line used to start the job
  };
  
  /*
***************
*** 1615,1621 ****
      typval_T	*jq_value;
      jsonq_T	*jq_next;
      jsonq_T	*jq_prev;
!     int		jq_no_callback; /* TRUE when no callback was found */
  };
  
  struct cbq_S
--- 1618,1624 ----
      typval_T	*jq_value;
      jsonq_T	*jq_next;
      jsonq_T	*jq_prev;
!     int		jq_no_callback; // TRUE when no callback was found
  };
  
  struct cbq_S
***************
*** 1626,1632 ****
      cbq_T	*cq_prev;
  };
  
! /* mode for a channel */
  typedef enum
  {
      MODE_NL = 0,
--- 1629,1635 ----
      cbq_T	*cq_prev;
  };
  
! // mode for a channel
  typedef enum
  {
      MODE_NL = 0,
***************
*** 1645,1652 ****
  
  #define CH_PART_FD(part)	ch_part[part].ch_fd
  
! /* Ordering matters, it is used in for loops: IN is last, only SOCK/OUT/ERR
!  * are polled. */
  typedef enum {
      PART_SOCK = 0,
  #define CH_SOCK_FD	CH_PART_FD(PART_SOCK)
--- 1648,1655 ----
  
  #define CH_PART_FD(part)	ch_part[part].ch_fd
  
! // Ordering matters, it is used in for loops: IN is last, only SOCK/OUT/ERR
! // are polled.
  typedef enum {
      PART_SOCK = 0,
  #define CH_SOCK_FD	CH_PART_FD(PART_SOCK)
***************
*** 1663,1752 ****
  
  #define INVALID_FD	(-1)
  
! /* The per-fd info for a channel. */
  typedef struct {
!     sock_T	ch_fd;	    /* socket/stdin/stdout/stderr, -1 if not used */
  
  # if defined(UNIX) && !defined(HAVE_SELECT)
!     int		ch_poll_idx;	/* used by channel_poll_setup() */
  # endif
  
  #ifdef FEAT_GUI_X11
!     XtInputId	ch_inputHandler; /* Cookie for input */
  #endif
  #ifdef FEAT_GUI_GTK
!     gint	ch_inputHandler; /* Cookie for input */
  #endif
  
      ch_mode_T	ch_mode;
      job_io_T	ch_io;
!     int		ch_timeout;	/* request timeout in msec */
  
!     readq_T	ch_head;	/* header for circular raw read queue */
!     jsonq_T	ch_json_head;	/* header for circular json read queue */
!     garray_T	ch_block_ids;	/* list of IDs that channel_read_json_block()
! 				   is waiting for */
!     /* When ch_wait_len is non-zero use ch_deadline to wait for incomplete
!      * message to be complete. The value is the length of the incomplete
!      * message when the deadline was set.  If it gets longer (something was
!      * received) the deadline is reset. */
      size_t	ch_wait_len;
  #ifdef MSWIN
      DWORD	ch_deadline;
  #else
      struct timeval ch_deadline;
  #endif
!     int		ch_block_write;	/* for testing: 0 when not used, -1 when write
! 				 * does not block, 1 simulate blocking */
!     int		ch_nonblocking;	/* write() is non-blocking */
!     writeq_T	ch_writeque;	/* header for write queue */
! 
!     cbq_T	ch_cb_head;	/* dummy node for per-request callbacks */
!     callback_T	ch_callback;	/* call when a msg is not handled */
! 
!     bufref_T	ch_bufref;	/* buffer to read from or write to */
!     int		ch_nomodifiable; /* TRUE when buffer can be 'nomodifiable' */
!     int		ch_nomod_error;	/* TRUE when e_modifiable was given */
!     int		ch_buf_append;	/* write appended lines instead top-bot */
!     linenr_T	ch_buf_top;	/* next line to send */
!     linenr_T	ch_buf_bot;	/* last line to send */
  } chanpart_T;
  
  struct channel_S {
      channel_T	*ch_next;
      channel_T	*ch_prev;
  
!     int		ch_id;		/* ID of the channel */
!     int		ch_last_msg_id;	/* ID of the last message */
  
!     chanpart_T	ch_part[PART_COUNT]; /* info for socket, out, err and in */
!     int		ch_write_text_mode; /* write buffer lines with CR, not NL */
  
!     char	*ch_hostname;	/* only for socket, allocated */
!     int		ch_port;	/* only for socket */
  
!     int		ch_to_be_closed; /* bitset of readable fds to be closed.
! 				  * When all readable fds have been closed,
! 				  * set to (1 << PART_COUNT). */
!     int		ch_to_be_freed; /* When TRUE channel must be freed when it's
! 				 * safe to invoke callbacks. */
!     int		ch_error;	/* When TRUE an error was reported.  Avoids
! 				 * giving pages full of error messages when
! 				 * the other side has exited, only mention the
! 				 * first error until the connection works
! 				 * again. */
  
      void	(*ch_nb_close_cb)(void);
! 				/* callback for Netbeans when channel is
! 				 * closed */
  
  #ifdef MSWIN
!     int		ch_named_pipe;	/* using named pipe instead of pty */
  #endif
!     callback_T	ch_callback;	/* call when any msg is not handled */
!     callback_T	ch_close_cb;	/* call when channel is closed */
      int		ch_drop_never;
!     int		ch_keep_open;	/* do not close on read error */
      int		ch_nonblock;
  
      job_T	*ch_job;	// Job that uses this channel; this does not
--- 1666,1755 ----
  
  #define INVALID_FD	(-1)
  
! // The per-fd info for a channel.
  typedef struct {
!     sock_T	ch_fd;	    // socket/stdin/stdout/stderr, -1 if not used
  
  # if defined(UNIX) && !defined(HAVE_SELECT)
!     int		ch_poll_idx;	// used by channel_poll_setup()
  # endif
  
  #ifdef FEAT_GUI_X11
!     XtInputId	ch_inputHandler; // Cookie for input
  #endif
  #ifdef FEAT_GUI_GTK
!     gint	ch_inputHandler; // Cookie for input
  #endif
  
      ch_mode_T	ch_mode;
      job_io_T	ch_io;
!     int		ch_timeout;	// request timeout in msec
  
!     readq_T	ch_head;	// header for circular raw read queue
!     jsonq_T	ch_json_head;	// header for circular json read queue
!     garray_T	ch_block_ids;	// list of IDs that channel_read_json_block()
! 				// is waiting for
!     // When ch_wait_len is non-zero use ch_deadline to wait for incomplete
!     // message to be complete. The value is the length of the incomplete
!     // message when the deadline was set.  If it gets longer (something was
!     // received) the deadline is reset.
      size_t	ch_wait_len;
  #ifdef MSWIN
      DWORD	ch_deadline;
  #else
      struct timeval ch_deadline;
  #endif
!     int		ch_block_write;	// for testing: 0 when not used, -1 when write
! 				// does not block, 1 simulate blocking
!     int		ch_nonblocking;	// write() is non-blocking
!     writeq_T	ch_writeque;	// header for write queue
! 
!     cbq_T	ch_cb_head;	// dummy node for per-request callbacks
!     callback_T	ch_callback;	// call when a msg is not handled
! 
!     bufref_T	ch_bufref;	// buffer to read from or write to
!     int		ch_nomodifiable; // TRUE when buffer can be 'nomodifiable'
!     int		ch_nomod_error;	// TRUE when e_modifiable was given
!     int		ch_buf_append;	// write appended lines instead top-bot
!     linenr_T	ch_buf_top;	// next line to send
!     linenr_T	ch_buf_bot;	// last line to send
  } chanpart_T;
  
  struct channel_S {
      channel_T	*ch_next;
      channel_T	*ch_prev;
  
!     int		ch_id;		// ID of the channel
!     int		ch_last_msg_id;	// ID of the last message
  
!     chanpart_T	ch_part[PART_COUNT]; // info for socket, out, err and in
!     int		ch_write_text_mode; // write buffer lines with CR, not NL
  
!     char	*ch_hostname;	// only for socket, allocated
!     int		ch_port;	// only for socket
  
!     int		ch_to_be_closed; // bitset of readable fds to be closed.
! 				 // When all readable fds have been closed,
! 				 // set to (1 << PART_COUNT).
!     int		ch_to_be_freed; // When TRUE channel must be freed when it's
! 				// safe to invoke callbacks.
!     int		ch_error;	// When TRUE an error was reported.  Avoids
! 				// giving pages full of error messages when
! 				// the other side has exited, only mention the
! 				// first error until the connection works
! 				// again.
  
      void	(*ch_nb_close_cb)(void);
! 				// callback for Netbeans when channel is
! 				// closed
  
  #ifdef MSWIN
!     int		ch_named_pipe;	// using named pipe instead of pty
  #endif
!     callback_T	ch_callback;	// call when any msg is not handled
!     callback_T	ch_close_cb;	// call when channel is closed
      int		ch_drop_never;
!     int		ch_keep_open;	// do not close on read error
      int		ch_nonblock;
  
      job_T	*ch_job;	// Job that uses this channel; this does not
***************
*** 1761,1817 ****
      int		ch_copyID;
  };
  
! #define JO_MODE		    0x0001	/* channel mode */
! #define JO_IN_MODE	    0x0002	/* stdin mode */
! #define JO_OUT_MODE	    0x0004	/* stdout mode */
! #define JO_ERR_MODE	    0x0008	/* stderr mode */
! #define JO_CALLBACK	    0x0010	/* channel callback */
! #define JO_OUT_CALLBACK	    0x0020	/* stdout callback */
! #define JO_ERR_CALLBACK	    0x0040	/* stderr callback */
! #define JO_CLOSE_CALLBACK   0x0080	/* "close_cb" */
! #define JO_WAITTIME	    0x0100	/* only for ch_open() */
! #define JO_TIMEOUT	    0x0200	/* all timeouts */
! #define JO_OUT_TIMEOUT	    0x0400	/* stdout timeouts */
! #define JO_ERR_TIMEOUT	    0x0800	/* stderr timeouts */
! #define JO_PART		    0x1000	/* "part" */
! #define JO_ID		    0x2000	/* "id" */
! #define JO_STOPONEXIT	    0x4000	/* "stoponexit" */
! #define JO_EXIT_CB	    0x8000	/* "exit_cb" */
! #define JO_OUT_IO	    0x10000	/* "out_io" */
! #define JO_ERR_IO	    0x20000	/* "err_io" (JO_OUT_IO << 1) */
! #define JO_IN_IO	    0x40000	/* "in_io" (JO_OUT_IO << 2) */
! #define JO_OUT_NAME	    0x80000	/* "out_name" */
! #define JO_ERR_NAME	    0x100000	/* "err_name" (JO_OUT_NAME << 1) */
! #define JO_IN_NAME	    0x200000	/* "in_name" (JO_OUT_NAME << 2) */
! #define JO_IN_TOP	    0x400000	/* "in_top" */
! #define JO_IN_BOT	    0x800000	/* "in_bot" */
! #define JO_OUT_BUF	    0x1000000	/* "out_buf" */
! #define JO_ERR_BUF	    0x2000000	/* "err_buf" (JO_OUT_BUF << 1) */
! #define JO_IN_BUF	    0x4000000	/* "in_buf" (JO_OUT_BUF << 2) */
! #define JO_CHANNEL	    0x8000000	/* "channel" */
! #define JO_BLOCK_WRITE	    0x10000000	/* "block_write" */
! #define JO_OUT_MODIFIABLE   0x20000000	/* "out_modifiable" */
! #define JO_ERR_MODIFIABLE   0x40000000	/* "err_modifiable" (JO_OUT_ << 1) */
  #define JO_ALL		    0x7fffffff
  
! #define JO2_OUT_MSG	    0x0001	/* "out_msg" */
! #define JO2_ERR_MSG	    0x0002	/* "err_msg" (JO_OUT_ << 1) */
! #define JO2_TERM_NAME	    0x0004	/* "term_name" */
! #define JO2_TERM_FINISH	    0x0008	/* "term_finish" */
! #define JO2_ENV		    0x0010	/* "env" */
! #define JO2_CWD		    0x0020	/* "cwd" */
! #define JO2_TERM_ROWS	    0x0040	/* "term_rows" */
! #define JO2_TERM_COLS	    0x0080	/* "term_cols" */
! #define JO2_VERTICAL	    0x0100	/* "vertical" */
! #define JO2_CURWIN	    0x0200	/* "curwin" */
! #define JO2_HIDDEN	    0x0400	/* "hidden" */
! #define JO2_TERM_OPENCMD    0x0800	/* "term_opencmd" */
! #define JO2_EOF_CHARS	    0x1000	/* "eof_chars" */
! #define JO2_NORESTORE	    0x2000	/* "norestore" */
! #define JO2_TERM_KILL	    0x4000	/* "term_kill" */
! #define JO2_ANSI_COLORS	    0x8000	/* "ansi_colors" */
! #define JO2_TTY_TYPE	    0x10000	/* "tty_type" */
! #define JO2_BUFNR	    0x20000	/* "bufnr" */
  
  #define JO_MODE_ALL	(JO_MODE + JO_IN_MODE + JO_OUT_MODE + JO_ERR_MODE)
  #define JO_CB_ALL \
--- 1764,1820 ----
      int		ch_copyID;
  };
  
! #define JO_MODE		    0x0001	// channel mode
! #define JO_IN_MODE	    0x0002	// stdin mode
! #define JO_OUT_MODE	    0x0004	// stdout mode
! #define JO_ERR_MODE	    0x0008	// stderr mode
! #define JO_CALLBACK	    0x0010	// channel callback
! #define JO_OUT_CALLBACK	    0x0020	// stdout callback
! #define JO_ERR_CALLBACK	    0x0040	// stderr callback
! #define JO_CLOSE_CALLBACK   0x0080	// "close_cb"
! #define JO_WAITTIME	    0x0100	// only for ch_open()
! #define JO_TIMEOUT	    0x0200	// all timeouts
! #define JO_OUT_TIMEOUT	    0x0400	// stdout timeouts
! #define JO_ERR_TIMEOUT	    0x0800	// stderr timeouts
! #define JO_PART		    0x1000	// "part"
! #define JO_ID		    0x2000	// "id"
! #define JO_STOPONEXIT	    0x4000	// "stoponexit"
! #define JO_EXIT_CB	    0x8000	// "exit_cb"
! #define JO_OUT_IO	    0x10000	// "out_io"
! #define JO_ERR_IO	    0x20000	// "err_io" (JO_OUT_IO << 1)
! #define JO_IN_IO	    0x40000	// "in_io" (JO_OUT_IO << 2)
! #define JO_OUT_NAME	    0x80000	// "out_name"
! #define JO_ERR_NAME	    0x100000	// "err_name" (JO_OUT_NAME << 1)
! #define JO_IN_NAME	    0x200000	// "in_name" (JO_OUT_NAME << 2)
! #define JO_IN_TOP	    0x400000	// "in_top"
! #define JO_IN_BOT	    0x800000	// "in_bot"
! #define JO_OUT_BUF	    0x1000000	// "out_buf"
! #define JO_ERR_BUF	    0x2000000	// "err_buf" (JO_OUT_BUF << 1)
! #define JO_IN_BUF	    0x4000000	// "in_buf" (JO_OUT_BUF << 2)
! #define JO_CHANNEL	    0x8000000	// "channel"
! #define JO_BLOCK_WRITE	    0x10000000	// "block_write"
! #define JO_OUT_MODIFIABLE   0x20000000	// "out_modifiable"
! #define JO_ERR_MODIFIABLE   0x40000000	// "err_modifiable" (JO_OUT_ << 1)
  #define JO_ALL		    0x7fffffff
  
! #define JO2_OUT_MSG	    0x0001	// "out_msg"
! #define JO2_ERR_MSG	    0x0002	// "err_msg" (JO_OUT_ << 1)
! #define JO2_TERM_NAME	    0x0004	// "term_name"
! #define JO2_TERM_FINISH	    0x0008	// "term_finish"
! #define JO2_ENV		    0x0010	// "env"
! #define JO2_CWD		    0x0020	// "cwd"
! #define JO2_TERM_ROWS	    0x0040	// "term_rows"
! #define JO2_TERM_COLS	    0x0080	// "term_cols"
! #define JO2_VERTICAL	    0x0100	// "vertical"
! #define JO2_CURWIN	    0x0200	// "curwin"
! #define JO2_HIDDEN	    0x0400	// "hidden"
! #define JO2_TERM_OPENCMD    0x0800	// "term_opencmd"
! #define JO2_EOF_CHARS	    0x1000	// "eof_chars"
! #define JO2_NORESTORE	    0x2000	// "norestore"
! #define JO2_TERM_KILL	    0x4000	// "term_kill"
! #define JO2_ANSI_COLORS	    0x8000	// "ansi_colors"
! #define JO2_TTY_TYPE	    0x10000	// "tty_type"
! #define JO2_BUFNR	    0x20000	// "bufnr"
  
  #define JO_MODE_ALL	(JO_MODE + JO_IN_MODE + JO_OUT_MODE + JO_ERR_MODE)
  #define JO_CB_ALL \
***************
*** 1823,1830 ****
   */
  typedef struct
  {
!     int		jo_set;		/* JO_ bits for values that were set */
!     int		jo_set2;	/* JO2_ bits for values that were set */
  
      ch_mode_T	jo_mode;
      ch_mode_T	jo_in_mode;
--- 1826,1833 ----
   */
  typedef struct
  {
!     int		jo_set;		// JO_ bits for values that were set
!     int		jo_set2;	// JO2_ bits for values that were set
  
      ch_mode_T	jo_mode;
      ch_mode_T	jo_in_mode;
***************
*** 1832,1840 ****
      ch_mode_T	jo_err_mode;
      int		jo_noblock;
  
!     job_io_T	jo_io[4];	/* PART_OUT, PART_ERR, PART_IN */
      char_u	jo_io_name_buf[4][NUMBUFLEN];
!     char_u	*jo_io_name[4];	/* not allocated! */
      int		jo_io_buf[4];
      int		jo_pty;
      int		jo_modifiable[4];
--- 1835,1843 ----
      ch_mode_T	jo_err_mode;
      int		jo_noblock;
  
!     job_io_T	jo_io[4];	// PART_OUT, PART_ERR, PART_IN
      char_u	jo_io_name_buf[4][NUMBUFLEN];
!     char_u	*jo_io_name[4];	// not allocated!
      int		jo_io_buf[4];
      int		jo_pty;
      int		jo_modifiable[4];
***************
*** 1854,1870 ****
      int		jo_timeout;
      int		jo_out_timeout;
      int		jo_err_timeout;
!     int		jo_block_write;	/* for testing only */
      int		jo_part;
      int		jo_id;
      char_u	jo_soe_buf[NUMBUFLEN];
      char_u	*jo_stoponexit;
!     dict_T	*jo_env;	/* environment variables */
      char_u	jo_cwd_buf[NUMBUFLEN];
      char_u	*jo_cwd;
  
  #ifdef FEAT_TERMINAL
!     /* when non-zero run the job in a terminal window of this size */
      int		jo_term_rows;
      int		jo_term_cols;
      int		jo_vertical;
--- 1857,1873 ----
      int		jo_timeout;
      int		jo_out_timeout;
      int		jo_err_timeout;
!     int		jo_block_write;	// for testing only
      int		jo_part;
      int		jo_id;
      char_u	jo_soe_buf[NUMBUFLEN];
      char_u	*jo_stoponexit;
!     dict_T	*jo_env;	// environment variables
      char_u	jo_cwd_buf[NUMBUFLEN];
      char_u	*jo_cwd;
  
  #ifdef FEAT_TERMINAL
!     // when non-zero run the job in a terminal window of this size
      int		jo_term_rows;
      int		jo_term_cols;
      int		jo_vertical;
***************
*** 1897,1910 ****
  };
  #endif
  
! /* structure used for explicit stack while garbage collecting hash tables */
  typedef struct ht_stack_S
  {
      hashtab_T		*ht;
      struct ht_stack_S	*prev;
  } ht_stack_T;
  
! /* structure used for explicit stack while garbage collecting lists */
  typedef struct list_stack_S
  {
      list_T		*list;
--- 1900,1917 ----
  };
  #endif
  
! /*
!  * structure used for explicit stack while garbage collecting hash tables
!  */
  typedef struct ht_stack_S
  {
      hashtab_T		*ht;
      struct ht_stack_S	*prev;
  } ht_stack_T;
  
! /*
!  * structure used for explicit stack while garbage collecting lists
!  */
  typedef struct list_stack_S
  {
      list_T		*list;
***************
*** 1921,1932 ****
      hashitem_T	*dit_hi;
  } dict_iterator_T;
  
! /* values for b_syn_spell: what to do with toplevel text */
! #define SYNSPL_DEFAULT	0	/* spell check if @Spell not defined */
! #define SYNSPL_TOP	1	/* spell check toplevel text */
! #define SYNSPL_NOTOP	2	/* don't spell check toplevel text */
  
! /* avoid #ifdefs for when b_spell is not available */
  #ifdef FEAT_SPELL
  # define B_SPELL(buf)  ((buf)->b_spell)
  #else
--- 1928,1939 ----
      hashitem_T	*dit_hi;
  } dict_iterator_T;
  
! // values for b_syn_spell: what to do with toplevel text
! #define SYNSPL_DEFAULT	0	// spell check if @Spell not defined
! #define SYNSPL_TOP	1	// spell check toplevel text
! #define SYNSPL_NOTOP	2	// don't spell check toplevel text
  
! // avoid #ifdefs for when b_spell is not available
  #ifdef FEAT_SPELL
  # define B_SPELL(buf)  ((buf)->b_spell)
  #else
***************
*** 1942,1951 ****
   * Used for :syntime: timing of executing a syntax pattern.
   */
  typedef struct {
!     proftime_T	total;		/* total time used */
!     proftime_T	slowest;	/* time of slowest call */
!     long	count;		/* nr of times used */
!     long	match;		/* nr of times matched */
  } syn_time_T;
  #endif
  
--- 1949,1958 ----
   * Used for :syntime: timing of executing a syntax pattern.
   */
  typedef struct {
!     proftime_T	total;		// total time used
!     proftime_T	slowest;	// time of slowest call
!     long	count;		// nr of times used
!     long	match;		// nr of times matched
  } syn_time_T;
  #endif
  
***************
*** 1973,1986 ****
   */
  typedef struct {
      int	    method_nr;
!     void    *method_state;  /* method-specific state information */
  } cryptstate_T;
  
! /* values for method_nr */
  # define CRYPT_M_ZIP	0
  # define CRYPT_M_BF	1
  # define CRYPT_M_BF2	2
! # define CRYPT_M_COUNT	3 /* number of crypt methods */
  
  // Currently all crypt methods work inplace.  If one is added that isn't then
  // define this.
--- 1980,1993 ----
   */
  typedef struct {
      int	    method_nr;
!     void    *method_state;  // method-specific state information
  } cryptstate_T;
  
! // values for method_nr
  # define CRYPT_M_ZIP	0
  # define CRYPT_M_BF	1
  # define CRYPT_M_BF2	2
! # define CRYPT_M_COUNT	3 // number of crypt methods
  
  // Currently all crypt methods work inplace.  If one is added that isn't then
  // define this.
***************
*** 2014,2051 ****
   */
  typedef struct {
  #ifdef FEAT_SYN_HL
!     hashtab_T	b_keywtab;		/* syntax keywords hash table */
!     hashtab_T	b_keywtab_ic;		/* idem, ignore case */
!     int		b_syn_error;		/* TRUE when error occurred in HL */
  # ifdef FEAT_RELTIME
!     int		b_syn_slow;		/* TRUE when 'redrawtime' reached */
  # endif
!     int		b_syn_ic;		/* ignore case for :syn cmds */
!     int		b_syn_spell;		/* SYNSPL_ values */
!     garray_T	b_syn_patterns;		/* table for syntax patterns */
!     garray_T	b_syn_clusters;		/* table for syntax clusters */
!     int		b_spell_cluster_id;	/* @Spell cluster ID or 0 */
!     int		b_nospell_cluster_id;	/* @NoSpell cluster ID or 0 */
!     int		b_syn_containedin;	/* TRUE when there is an item with a
! 					   "containedin" argument */
!     int		b_syn_sync_flags;	/* flags about how to sync */
!     short	b_syn_sync_id;		/* group to sync on */
!     long	b_syn_sync_minlines;	/* minimal sync lines offset */
!     long	b_syn_sync_maxlines;	/* maximal sync lines offset */
!     long	b_syn_sync_linebreaks;	/* offset for multi-line pattern */
!     char_u	*b_syn_linecont_pat;	/* line continuation pattern */
!     regprog_T	*b_syn_linecont_prog;	/* line continuation program */
  #ifdef FEAT_PROFILE
      syn_time_T  b_syn_linecont_time;
  #endif
!     int		b_syn_linecont_ic;	/* ignore-case flag for above */
!     int		b_syn_topgrp;		/* for ":syntax include" */
  # ifdef FEAT_CONCEAL
!     int		b_syn_conceal;		/* auto-conceal for :syn cmds */
  # endif
  # ifdef FEAT_FOLDING
!     int		b_syn_folditems;	/* number of patterns with the HL_FOLD
! 					   flag set */
  # endif
      /*
       * b_sst_array[] contains the state stack for a number of lines, for the
--- 2021,2058 ----
   */
  typedef struct {
  #ifdef FEAT_SYN_HL
!     hashtab_T	b_keywtab;		// syntax keywords hash table
!     hashtab_T	b_keywtab_ic;		// idem, ignore case
!     int		b_syn_error;		// TRUE when error occurred in HL
  # ifdef FEAT_RELTIME
!     int		b_syn_slow;		// TRUE when 'redrawtime' reached
  # endif
!     int		b_syn_ic;		// ignore case for :syn cmds
!     int		b_syn_spell;		// SYNSPL_ values
!     garray_T	b_syn_patterns;		// table for syntax patterns
!     garray_T	b_syn_clusters;		// table for syntax clusters
!     int		b_spell_cluster_id;	// @Spell cluster ID or 0
!     int		b_nospell_cluster_id;	// @NoSpell cluster ID or 0
!     int		b_syn_containedin;	// TRUE when there is an item with a
! 					// "containedin" argument
!     int		b_syn_sync_flags;	// flags about how to sync
!     short	b_syn_sync_id;		// group to sync on
!     long	b_syn_sync_minlines;	// minimal sync lines offset
!     long	b_syn_sync_maxlines;	// maximal sync lines offset
!     long	b_syn_sync_linebreaks;	// offset for multi-line pattern
!     char_u	*b_syn_linecont_pat;	// line continuation pattern
!     regprog_T	*b_syn_linecont_prog;	// line continuation program
  #ifdef FEAT_PROFILE
      syn_time_T  b_syn_linecont_time;
  #endif
!     int		b_syn_linecont_ic;	// ignore-case flag for above
!     int		b_syn_topgrp;		// for ":syntax include"
  # ifdef FEAT_CONCEAL
!     int		b_syn_conceal;		// auto-conceal for :syn cmds
  # endif
  # ifdef FEAT_FOLDING
!     int		b_syn_folditems;	// number of patterns with the HL_FOLD
! 					// flag set
  # endif
      /*
       * b_sst_array[] contains the state stack for a number of lines, for the
***************
*** 2067,2091 ****
      synstate_T	*b_sst_firstfree;
      int		b_sst_freecount;
      linenr_T	b_sst_check_lnum;
!     short_u	b_sst_lasttick;	/* last display tick */
! #endif /* FEAT_SYN_HL */
  
  #ifdef FEAT_SPELL
!     /* for spell checking */
!     garray_T	b_langp;	/* list of pointers to slang_T, see spell.c */
!     char_u	b_spell_ismw[256];/* flags: is midword char */
!     char_u	*b_spell_ismw_mb; /* multi-byte midword chars */
!     char_u	*b_p_spc;	/* 'spellcapcheck' */
!     regprog_T	*b_cap_prog;	/* program for 'spellcapcheck' */
!     char_u	*b_p_spf;	/* 'spellfile' */
!     char_u	*b_p_spl;	/* 'spelllang' */
!     int		b_cjk;		/* all CJK letters as OK */
  #endif
  #if !defined(FEAT_SYN_HL) && !defined(FEAT_SPELL)
      int		dummy;
  #endif
!     char_u	b_syn_chartab[32];	/* syntax iskeyword option */
!     char_u	*b_syn_isk;		/* iskeyword option */
  } synblock_T;
  
  
--- 2074,2098 ----
      synstate_T	*b_sst_firstfree;
      int		b_sst_freecount;
      linenr_T	b_sst_check_lnum;
!     short_u	b_sst_lasttick;	// last display tick
! #endif // FEAT_SYN_HL
  
  #ifdef FEAT_SPELL
!     // for spell checking
!     garray_T	b_langp;	    // list of pointers to slang_T, see spell.c
!     char_u	b_spell_ismw[256];  // flags: is midword char
!     char_u	*b_spell_ismw_mb;   // multi-byte midword chars
!     char_u	*b_p_spc;	    // 'spellcapcheck'
!     regprog_T	*b_cap_prog;	    // program for 'spellcapcheck'
!     char_u	*b_p_spf;	    // 'spellfile'
!     char_u	*b_p_spl;	    // 'spelllang'
!     int		b_cjk;		    // all CJK letters as OK
  #endif
  #if !defined(FEAT_SYN_HL) && !defined(FEAT_SPELL)
      int		dummy;
  #endif
!     char_u	b_syn_chartab[32];  // syntax iskeyword option
!     char_u	*b_syn_isk;	    // iskeyword option
  } synblock_T;
  
  
***************
*** 2099,2115 ****
  
  struct file_buffer
  {
!     memline_T	b_ml;		/* associated memline (also contains line
! 				   count) */
  
!     buf_T	*b_next;	/* links in list of buffers */
      buf_T	*b_prev;
  
!     int		b_nwindows;	/* nr of windows open on this buffer */
  
!     int		b_flags;	/* various BF_ flags */
!     int		b_locked;	/* Buffer is being closed or referenced, don't
! 				   let autocommands wipe it out. */
  
      /*
       * b_ffname has the full path of the file (NULL for no name).
--- 2106,2122 ----
  
  struct file_buffer
  {
!     memline_T	b_ml;		// associated memline (also contains line
! 				// count)
  
!     buf_T	*b_next;	// links in list of buffers
      buf_T	*b_prev;
  
!     int		b_nwindows;	// nr of windows open on this buffer
  
!     int		b_flags;	// various BF_ flags
!     int		b_locked;	// Buffer is being closed or referenced, don't
! 				// let autocommands wipe it out.
  
      /*
       * b_ffname has the full path of the file (NULL for no name).
***************
*** 2124,2206 ****
  				// b_sfname
  
  #ifdef UNIX
!     int		b_dev_valid;	/* TRUE when b_dev has a valid number */
!     dev_t	b_dev;		/* device number */
!     ino_t	b_ino;		/* inode number */
  #endif
  #ifdef FEAT_CW_EDITOR
!     FSSpec	b_FSSpec;	/* MacOS File Identification */
  #endif
  #ifdef VMS
!     char	 b_fab_rfm;	/* Record format    */
!     char	 b_fab_rat;	/* Record attribute */
!     unsigned int b_fab_mrs;	/* Max record size  */
  #endif
!     int		b_fnum;		/* buffer number for this file. */
      char_u	b_key[VIM_SIZEOF_INT * 2 + 1];
! 				/* key used for buf_hashtab, holds b_fnum as
! 				   hex string */
  
!     int		b_changed;	/* 'modified': Set to TRUE if something in the
! 				   file has been changed and not written out. */
!     dictitem16_T b_ct_di;	/* holds the b:changedtick value in
! 				   b_ct_di.di_tv.vval.v_number;
! 				   incremented for each change, also for undo */
  #define CHANGEDTICK(buf) ((buf)->b_ct_di.di_tv.vval.v_number)
  
!     varnumber_T	b_last_changedtick; /* b:changedtick when TextChanged or
! 				       TextChangedI was last triggered. */
  #ifdef FEAT_INS_EXPAND
!     varnumber_T	b_last_changedtick_pum; /* b:changedtick when TextChangedP was
! 					   last triggered. */
  #endif
  
!     int		b_saving;	/* Set to TRUE if we are in the middle of
! 				   saving the buffer. */
  
      /*
       * Changes to a buffer require updating of the display.  To minimize the
       * work, remember changes made and update everything at once.
       */
!     int		b_mod_set;	/* TRUE when there are changes since the last
! 				   time the display was updated */
!     linenr_T	b_mod_top;	/* topmost lnum that was changed */
!     linenr_T	b_mod_bot;	/* lnum below last changed line, AFTER the
! 				   change */
!     long	b_mod_xlines;	/* number of extra buffer lines inserted;
! 				   negative when lines were deleted */
! 
!     wininfo_T	*b_wininfo;	/* list of last used info for each window */
! 
!     long	b_mtime;	/* last change time of original file */
!     long	b_mtime_read;	/* last change time when reading */
!     off_T	b_orig_size;	/* size of original file in bytes */
!     int		b_orig_mode;	/* mode of original file */
  #ifdef FEAT_VIMINFO
!     time_T	b_last_used;	/* time when the buffer was last used; used
! 				 * for viminfo */
  #endif
  
!     pos_T	b_namedm[NMARKS]; /* current named marks (mark.c) */
  
!     /* These variables are set when VIsual_active becomes FALSE */
      visualinfo_T b_visual;
  #ifdef FEAT_EVAL
!     int		b_visual_mode_eval;  /* b_visual.vi_mode for visualmode() */
  #endif
  
!     pos_T	b_last_cursor;	/* cursor position when last unloading this
! 				   buffer */
!     pos_T	b_last_insert;	/* where Insert mode was left */
!     pos_T	b_last_change;	/* position of last change: '. mark */
  
  #ifdef FEAT_JUMPLIST
      /*
       * the changelist contains old change positions
       */
      pos_T	b_changelist[JUMPLISTSIZE];
!     int		b_changelistlen;	/* number of active entries */
!     int		b_new_change;		/* set by u_savecommon() */
  #endif
  
      /*
--- 2131,2213 ----
  				// b_sfname
  
  #ifdef UNIX
!     int		b_dev_valid;	// TRUE when b_dev has a valid number
!     dev_t	b_dev;		// device number
!     ino_t	b_ino;		// inode number
  #endif
  #ifdef FEAT_CW_EDITOR
!     FSSpec	b_FSSpec;	// MacOS File Identification
  #endif
  #ifdef VMS
!     char	 b_fab_rfm;	// Record format
!     char	 b_fab_rat;	// Record attribute
!     unsigned int b_fab_mrs;	// Max record size
  #endif
!     int		b_fnum;		// buffer number for this file.
      char_u	b_key[VIM_SIZEOF_INT * 2 + 1];
! 				// key used for buf_hashtab, holds b_fnum as
! 				// hex string
  
!     int		b_changed;	// 'modified': Set to TRUE if something in the
! 				// file has been changed and not written out.
!     dictitem16_T b_ct_di;	// holds the b:changedtick value in
! 				// b_ct_di.di_tv.vval.v_number;
! 				// incremented for each change, also for undo
  #define CHANGEDTICK(buf) ((buf)->b_ct_di.di_tv.vval.v_number)
  
!     varnumber_T	b_last_changedtick; // b:changedtick when TextChanged or
! 				    // TextChangedI was last triggered.
  #ifdef FEAT_INS_EXPAND
!     varnumber_T	b_last_changedtick_pum; // b:changedtick when TextChangedP was
! 					// last triggered.
  #endif
  
!     int		b_saving;	// Set to TRUE if we are in the middle of
! 				// saving the buffer.
  
      /*
       * Changes to a buffer require updating of the display.  To minimize the
       * work, remember changes made and update everything at once.
       */
!     int		b_mod_set;	// TRUE when there are changes since the last
! 				// time the display was updated
!     linenr_T	b_mod_top;	// topmost lnum that was changed
!     linenr_T	b_mod_bot;	// lnum below last changed line, AFTER the
! 				// change
!     long	b_mod_xlines;	// number of extra buffer lines inserted;
! 				// negative when lines were deleted
! 
!     wininfo_T	*b_wininfo;	// list of last used info for each window
! 
!     long	b_mtime;	// last change time of original file
!     long	b_mtime_read;	// last change time when reading
!     off_T	b_orig_size;	// size of original file in bytes
!     int		b_orig_mode;	// mode of original file
  #ifdef FEAT_VIMINFO
!     time_T	b_last_used;	// time when the buffer was last used; used
! 				// for viminfo
  #endif
  
!     pos_T	b_namedm[NMARKS]; // current named marks (mark.c)
  
!     // These variables are set when VIsual_active becomes FALSE
      visualinfo_T b_visual;
  #ifdef FEAT_EVAL
!     int		b_visual_mode_eval;  // b_visual.vi_mode for visualmode()
  #endif
  
!     pos_T	b_last_cursor;	// cursor position when last unloading this
! 				// buffer
!     pos_T	b_last_insert;	// where Insert mode was left
!     pos_T	b_last_change;	// position of last change: '. mark
  
  #ifdef FEAT_JUMPLIST
      /*
       * the changelist contains old change positions
       */
      pos_T	b_changelist[JUMPLISTSIZE];
!     int		b_changelistlen;	// number of active entries
!     int		b_new_change;		// set by u_savecommon()
  #endif
  
      /*
***************
*** 2210,2274 ****
      char_u	b_chartab[32];
  
  #ifdef FEAT_LOCALMAP
!     /* Table used for mappings local to a buffer. */
      mapblock_T	*(b_maphash[256]);
  
!     /* First abbreviation local to a buffer. */
      mapblock_T	*b_first_abbr;
  #endif
      // User commands local to the buffer.
      garray_T	b_ucmds;
!     /*
!      * start and end of an operator, also used for '[ and ']
!      */
      pos_T	b_op_start;
      pos_T	b_op_start_orig;  /* used for Insstart_orig */
      pos_T	b_op_end;
  
  #ifdef FEAT_VIMINFO
!     int		b_marks_read;	/* Have we read viminfo marks yet? */
  #endif
  
      /*
       * The following only used in undo.c.
       */
!     u_header_T	*b_u_oldhead;	/* pointer to oldest header */
!     u_header_T	*b_u_newhead;	/* pointer to newest header; may not be valid
! 				   if b_u_curhead is not NULL */
!     u_header_T	*b_u_curhead;	/* pointer to current header */
!     int		b_u_numhead;	/* current number of headers */
!     int		b_u_synced;	/* entry lists are synced */
!     long	b_u_seq_last;	/* last used undo sequence number */
!     long	b_u_save_nr_last; /* counter for last file write */
!     long	b_u_seq_cur;	/* hu_seq of header below which we are now */
!     time_T	b_u_time_cur;	/* uh_time of header below which we are now */
!     long	b_u_save_nr_cur; /* file write nr after which we are now */
  
      /*
       * variables for "U" command in undo.c
       */
!     undoline_T	b_u_line_ptr;	/* saved line for "U" command */
!     linenr_T	b_u_line_lnum;	/* line number of line in u_line */
!     colnr_T	b_u_line_colnr;	/* optional column number */
  
  #ifdef FEAT_INS_EXPAND
!     int		b_scanned;	/* ^N/^P have scanned this buffer */
  #endif
  
!     /* flags for use of ":lmap" and IM control */
!     long	b_p_iminsert;	/* input mode for insert */
!     long	b_p_imsearch;	/* input mode for search */
! #define B_IMODE_USE_INSERT -1	/*	Use b_p_iminsert value for search */
! #define B_IMODE_NONE 0		/*	Input via none */
! #define B_IMODE_LMAP 1		/*	Input via langmap */
! #define B_IMODE_IM 2		/*	Input via input method */
  #define B_IMODE_LAST 2
  
  #ifdef FEAT_KEYMAP
!     short	b_kmap_state;	/* using "lmap" mappings */
! # define KEYMAP_INIT	1	/* 'keymap' was set, call keymap_init() */
! # define KEYMAP_LOADED	2	/* 'keymap' mappings have been loaded */
!     garray_T	b_kmap_ga;	/* the keymap table */
  #endif
  
      /*
--- 2217,2279 ----
      char_u	b_chartab[32];
  
  #ifdef FEAT_LOCALMAP
!     // Table used for mappings local to a buffer.
      mapblock_T	*(b_maphash[256]);
  
!     // First abbreviation local to a buffer.
      mapblock_T	*b_first_abbr;
  #endif
      // User commands local to the buffer.
      garray_T	b_ucmds;
!     // start and end of an operator, also used for '[ and ']
      pos_T	b_op_start;
      pos_T	b_op_start_orig;  /* used for Insstart_orig */
      pos_T	b_op_end;
  
  #ifdef FEAT_VIMINFO
!     int		b_marks_read;	// Have we read viminfo marks yet?
  #endif
  
      /*
       * The following only used in undo.c.
       */
!     u_header_T	*b_u_oldhead;	// pointer to oldest header
!     u_header_T	*b_u_newhead;	// pointer to newest header; may not be valid
! 				// if b_u_curhead is not NULL
!     u_header_T	*b_u_curhead;	// pointer to current header
!     int		b_u_numhead;	// current number of headers
!     int		b_u_synced;	// entry lists are synced
!     long	b_u_seq_last;	// last used undo sequence number
!     long	b_u_save_nr_last; // counter for last file write
!     long	b_u_seq_cur;	// hu_seq of header below which we are now
!     time_T	b_u_time_cur;	// uh_time of header below which we are now
!     long	b_u_save_nr_cur; // file write nr after which we are now
  
      /*
       * variables for "U" command in undo.c
       */
!     undoline_T	b_u_line_ptr;	// saved line for "U" command
!     linenr_T	b_u_line_lnum;	// line number of line in u_line
!     colnr_T	b_u_line_colnr;	// optional column number
  
  #ifdef FEAT_INS_EXPAND
!     int		b_scanned;	// ^N/^P have scanned this buffer
  #endif
  
!     // flags for use of ":lmap" and IM control
!     long	b_p_iminsert;	// input mode for insert
!     long	b_p_imsearch;	// input mode for search
! #define B_IMODE_USE_INSERT -1	//	Use b_p_iminsert value for search
! #define B_IMODE_NONE 0		//	Input via none
! #define B_IMODE_LMAP 1		//	Input via langmap
! #define B_IMODE_IM 2		//	Input via input method
  #define B_IMODE_LAST 2
  
  #ifdef FEAT_KEYMAP
!     short	b_kmap_state;	// using "lmap" mappings
! # define KEYMAP_INIT	1	// 'keymap' was set, call keymap_init()
! # define KEYMAP_LOADED	2	// 'keymap' mappings have been loaded
!     garray_T	b_kmap_ga;	// the keymap table
  #endif
  
      /*
***************
*** 2276,2439 ****
       * They are here because their value depends on the type of file
       * or contents of the file being edited.
       */
!     int		b_p_initialized;	/* set when options initialized */
  
  #ifdef FEAT_EVAL
!     sctx_T	b_p_script_ctx[BV_COUNT];	/* SCTXs for buffer-local options */
  #endif
  
!     int		b_p_ai;		/* 'autoindent' */
!     int		b_p_ai_nopaste;	/* b_p_ai saved for paste mode */
!     char_u	*b_p_bkc;	/* 'backupcopy' */
!     unsigned	b_bkc_flags;    /* flags for 'backupcopy' */
!     int		b_p_ci;		/* 'copyindent' */
!     int		b_p_bin;	/* 'binary' */
!     int		b_p_bomb;	/* 'bomb' */
!     char_u	*b_p_bh;	/* 'bufhidden' */
!     char_u	*b_p_bt;	/* 'buftype' */
  #ifdef FEAT_QUICKFIX
  #define BUF_HAS_QF_ENTRY 1
  #define BUF_HAS_LL_ENTRY 2
      int		b_has_qf_entry;
  #endif
!     int		b_p_bl;		/* 'buflisted' */
  #ifdef FEAT_CINDENT
!     int		b_p_cin;	/* 'cindent' */
!     char_u	*b_p_cino;	/* 'cinoptions' */
!     char_u	*b_p_cink;	/* 'cinkeys' */
  #endif
  #if defined(FEAT_CINDENT) || defined(FEAT_SMARTINDENT)
!     char_u	*b_p_cinw;	/* 'cinwords' */
  #endif
  #ifdef FEAT_COMMENTS
!     char_u	*b_p_com;	/* 'comments' */
  #endif
  #ifdef FEAT_FOLDING
!     char_u	*b_p_cms;	/* 'commentstring' */
  #endif
  #ifdef FEAT_INS_EXPAND
!     char_u	*b_p_cpt;	/* 'complete' */
  #endif
  #ifdef FEAT_COMPL_FUNC
!     char_u	*b_p_cfu;	/* 'completefunc' */
!     char_u	*b_p_ofu;	/* 'omnifunc' */
  #endif
  #ifdef FEAT_EVAL
!     char_u	*b_p_tfu;	/* 'tagfunc' */
  #endif
!     int		b_p_eol;	/* 'endofline' */
!     int		b_p_fixeol;	/* 'fixendofline' */
!     int		b_p_et;		/* 'expandtab' */
!     int		b_p_et_nobin;	/* b_p_et saved for binary mode */
!     int		b_p_et_nopaste; /* b_p_et saved for paste mode */
!     char_u	*b_p_fenc;	/* 'fileencoding' */
!     char_u	*b_p_ff;	/* 'fileformat' */
!     char_u	*b_p_ft;	/* 'filetype' */
!     char_u	*b_p_fo;	/* 'formatoptions' */
!     char_u	*b_p_flp;	/* 'formatlistpat' */
!     int		b_p_inf;	/* 'infercase' */
!     char_u	*b_p_isk;	/* 'iskeyword' */
  #ifdef FEAT_FIND_ID
!     char_u	*b_p_def;	/* 'define' local value */
!     char_u	*b_p_inc;	/* 'include' */
  # ifdef FEAT_EVAL
!     char_u	*b_p_inex;	/* 'includeexpr' */
!     long_u	b_p_inex_flags;	/* flags for 'includeexpr' */
  # endif
  #endif
  #if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
!     char_u	*b_p_inde;	/* 'indentexpr' */
!     long_u	b_p_inde_flags;	/* flags for 'indentexpr' */
!     char_u	*b_p_indk;	/* 'indentkeys' */
  #endif
!     char_u	*b_p_fp;	/* 'formatprg' */
  #if defined(FEAT_EVAL)
!     char_u	*b_p_fex;	/* 'formatexpr' */
!     long_u	b_p_fex_flags;	/* flags for 'formatexpr' */
  #endif
  #ifdef FEAT_CRYPT
!     char_u	*b_p_key;	/* 'key' */
  #endif
!     char_u	*b_p_kp;	/* 'keywordprg' */
  #ifdef FEAT_LISP
!     int		b_p_lisp;	/* 'lisp' */
  #endif
!     char_u	*b_p_menc;	/* 'makeencoding' */
!     char_u	*b_p_mps;	/* 'matchpairs' */
!     int		b_p_ml;		/* 'modeline' */
!     int		b_p_ml_nobin;	/* b_p_ml saved for binary mode */
!     int		b_p_ma;		/* 'modifiable' */
!     char_u	*b_p_nf;	/* 'nrformats' */
!     int		b_p_pi;		/* 'preserveindent' */
  #ifdef FEAT_TEXTOBJ
!     char_u	*b_p_qe;	/* 'quoteescape' */
  #endif
!     int		b_p_ro;		/* 'readonly' */
!     long	b_p_sw;		/* 'shiftwidth' */
!     int		b_p_sn;		/* 'shortname' */
  #ifdef FEAT_SMARTINDENT
!     int		b_p_si;		/* 'smartindent' */
  #endif
!     long	b_p_sts;	/* 'softtabstop' */
!     long	b_p_sts_nopaste; /* b_p_sts saved for paste mode */
  #ifdef FEAT_SEARCHPATH
!     char_u	*b_p_sua;	/* 'suffixesadd' */
  #endif
!     int		b_p_swf;	/* 'swapfile' */
  #ifdef FEAT_SYN_HL
!     long	b_p_smc;	/* 'synmaxcol' */
!     char_u	*b_p_syn;	/* 'syntax' */
  #endif
!     long	b_p_ts;		/* 'tabstop' */
!     int		b_p_tx;		/* 'textmode' */
!     long	b_p_tw;		/* 'textwidth' */
!     long	b_p_tw_nobin;	/* b_p_tw saved for binary mode */
!     long	b_p_tw_nopaste;	/* b_p_tw saved for paste mode */
!     long	b_p_wm;		/* 'wrapmargin' */
!     long	b_p_wm_nobin;	/* b_p_wm saved for binary mode */
!     long	b_p_wm_nopaste;	/* b_p_wm saved for paste mode */
  #ifdef FEAT_VARTABS
!     char_u	*b_p_vsts;	/* 'varsofttabstop' */
!     int		*b_p_vsts_array;   /* 'varsofttabstop' in internal format */
!     char_u	*b_p_vsts_nopaste; /* b_p_vsts saved for paste mode */
!     char_u	*b_p_vts;	/* 'vartabstop' */
!     int		*b_p_vts_array;	/* 'vartabstop' in internal format */
  #endif
  #ifdef FEAT_KEYMAP
!     char_u	*b_p_keymap;	/* 'keymap' */
  #endif
  
!     /* local values for options which are normally global */
  #ifdef FEAT_QUICKFIX
!     char_u	*b_p_gp;	/* 'grepprg' local value */
!     char_u	*b_p_mp;	/* 'makeprg' local value */
!     char_u	*b_p_efm;	/* 'errorformat' local value */
! #endif
!     char_u	*b_p_ep;	/* 'equalprg' local value */
!     char_u	*b_p_path;	/* 'path' local value */
!     int		b_p_ar;		/* 'autoread' local value */
!     char_u	*b_p_tags;	/* 'tags' local value */
!     char_u	*b_p_tc;	/* 'tagcase' local value */
!     unsigned	b_tc_flags;     /* flags for 'tagcase' */
  #ifdef FEAT_INS_EXPAND
!     char_u	*b_p_dict;	/* 'dictionary' local value */
!     char_u	*b_p_tsr;	/* 'thesaurus' local value */
  #endif
!     long	b_p_ul;		/* 'undolevels' local value */
  #ifdef FEAT_PERSISTENT_UNDO
!     int		b_p_udf;	/* 'undofile' */
  #endif
  #ifdef FEAT_LISP
!     char_u	*b_p_lw;	/* 'lispwords' local value */
  #endif
  #ifdef FEAT_TERMINAL
!     long	b_p_twsl;	/* 'termwinscroll' */
  #endif
  
!     /* end of buffer options */
  
  #ifdef FEAT_CINDENT
!     /* values set from b_p_cino */
      int		b_ind_level;
      int		b_ind_open_imag;
      int		b_ind_no_brace;
--- 2281,2448 ----
       * They are here because their value depends on the type of file
       * or contents of the file being edited.
       */
!     int		b_p_initialized;	// set when options initialized
  
  #ifdef FEAT_EVAL
!     sctx_T	b_p_script_ctx[BV_COUNT]; // SCTXs for buffer-local options
  #endif
  
!     int		b_p_ai;		// 'autoindent'
!     int		b_p_ai_nopaste;	// b_p_ai saved for paste mode
!     char_u	*b_p_bkc;	// 'backupcopy'
!     unsigned	b_bkc_flags;    // flags for 'backupcopy'
!     int		b_p_ci;		// 'copyindent'
!     int		b_p_bin;	// 'binary'
!     int		b_p_bomb;	// 'bomb'
!     char_u	*b_p_bh;	// 'bufhidden'
!     char_u	*b_p_bt;	// 'buftype'
  #ifdef FEAT_QUICKFIX
  #define BUF_HAS_QF_ENTRY 1
  #define BUF_HAS_LL_ENTRY 2
      int		b_has_qf_entry;
  #endif
!     int		b_p_bl;		// 'buflisted'
  #ifdef FEAT_CINDENT
!     int		b_p_cin;	// 'cindent'
!     char_u	*b_p_cino;	// 'cinoptions'
!     char_u	*b_p_cink;	// 'cinkeys'
  #endif
  #if defined(FEAT_CINDENT) || defined(FEAT_SMARTINDENT)
!     char_u	*b_p_cinw;	// 'cinwords'
  #endif
  #ifdef FEAT_COMMENTS
!     char_u	*b_p_com;	// 'comments'
  #endif
  #ifdef FEAT_FOLDING
!     char_u	*b_p_cms;	// 'commentstring'
  #endif
  #ifdef FEAT_INS_EXPAND
!     char_u	*b_p_cpt;	// 'complete'
  #endif
  #ifdef FEAT_COMPL_FUNC
!     char_u	*b_p_cfu;	// 'completefunc'
!     char_u	*b_p_ofu;	// 'omnifunc'
  #endif
  #ifdef FEAT_EVAL
!     char_u	*b_p_tfu;	// 'tagfunc'
  #endif
!     int		b_p_eol;	// 'endofline'
!     int		b_p_fixeol;	// 'fixendofline'
!     int		b_p_et;		// 'expandtab'
!     int		b_p_et_nobin;	// b_p_et saved for binary mode
!     int		b_p_et_nopaste; // b_p_et saved for paste mode
!     char_u	*b_p_fenc;	// 'fileencoding'
!     char_u	*b_p_ff;	// 'fileformat'
!     char_u	*b_p_ft;	// 'filetype'
!     char_u	*b_p_fo;	// 'formatoptions'
!     char_u	*b_p_flp;	// 'formatlistpat'
!     int		b_p_inf;	// 'infercase'
!     char_u	*b_p_isk;	// 'iskeyword'
  #ifdef FEAT_FIND_ID
!     char_u	*b_p_def;	// 'define' local value
!     char_u	*b_p_inc;	// 'include'
  # ifdef FEAT_EVAL
!     char_u	*b_p_inex;	// 'includeexpr'
!     long_u	b_p_inex_flags;	// flags for 'includeexpr'
  # endif
  #endif
  #if defined(FEAT_CINDENT) && defined(FEAT_EVAL)
!     char_u	*b_p_inde;	// 'indentexpr'
!     long_u	b_p_inde_flags;	// flags for 'indentexpr'
!     char_u	*b_p_indk;	// 'indentkeys'
  #endif
!     char_u	*b_p_fp;	// 'formatprg'
  #if defined(FEAT_EVAL)
!     char_u	*b_p_fex;	// 'formatexpr'
!     long_u	b_p_fex_flags;	// flags for 'formatexpr'
  #endif
  #ifdef FEAT_CRYPT
!     char_u	*b_p_key;	// 'key'
  #endif
!     char_u	*b_p_kp;	// 'keywordprg'
  #ifdef FEAT_LISP
!     int		b_p_lisp;	// 'lisp'
  #endif
!     char_u	*b_p_menc;	// 'makeencoding'
!     char_u	*b_p_mps;	// 'matchpairs'
!     int		b_p_ml;		// 'modeline'
!     int		b_p_ml_nobin;	// b_p_ml saved for binary mode
!     int		b_p_ma;		// 'modifiable'
!     char_u	*b_p_nf;	// 'nrformats'
!     int		b_p_pi;		// 'preserveindent'
  #ifdef FEAT_TEXTOBJ
!     char_u	*b_p_qe;	// 'quoteescape'
  #endif
!     int		b_p_ro;		// 'readonly'
!     long	b_p_sw;		// 'shiftwidth'
!     int		b_p_sn;		// 'shortname'
  #ifdef FEAT_SMARTINDENT
!     int		b_p_si;		// 'smartindent'
  #endif
!     long	b_p_sts;	// 'softtabstop'
!     long	b_p_sts_nopaste; // b_p_sts saved for paste mode
  #ifdef FEAT_SEARCHPATH
!     char_u	*b_p_sua;	// 'suffixesadd'
  #endif
!     int		b_p_swf;	// 'swapfile'
  #ifdef FEAT_SYN_HL
!     long	b_p_smc;	// 'synmaxcol'
!     char_u	*b_p_syn;	// 'syntax'
  #endif
!     long	b_p_ts;		// 'tabstop'
!     int		b_p_tx;		// 'textmode'
!     long	b_p_tw;		// 'textwidth'
!     long	b_p_tw_nobin;	// b_p_tw saved for binary mode
!     long	b_p_tw_nopaste;	// b_p_tw saved for paste mode
!     long	b_p_wm;		// 'wrapmargin'
!     long	b_p_wm_nobin;	// b_p_wm saved for binary mode
!     long	b_p_wm_nopaste;	// b_p_wm saved for paste mode
  #ifdef FEAT_VARTABS
!     char_u	*b_p_vsts;	// 'varsofttabstop'
!     int		*b_p_vsts_array;   // 'varsofttabstop' in internal format
!     char_u	*b_p_vsts_nopaste; // b_p_vsts saved for paste mode
!     char_u	*b_p_vts;	// 'vartabstop'
!     int		*b_p_vts_array;	// 'vartabstop' in internal format
  #endif
  #ifdef FEAT_KEYMAP
!     char_u	*b_p_keymap;	// 'keymap'
  #endif
  
!     /*
!      * local values for options which are normally global
!      */
  #ifdef FEAT_QUICKFIX
!     char_u	*b_p_gp;	// 'grepprg' local value
!     char_u	*b_p_mp;	// 'makeprg' local value
!     char_u	*b_p_efm;	// 'errorformat' local value
! #endif
!     char_u	*b_p_ep;	// 'equalprg' local value
!     char_u	*b_p_path;	// 'path' local value
!     int		b_p_ar;		// 'autoread' local value
!     char_u	*b_p_tags;	// 'tags' local value
!     char_u	*b_p_tc;	// 'tagcase' local value
!     unsigned	b_tc_flags;     // flags for 'tagcase'
  #ifdef FEAT_INS_EXPAND
!     char_u	*b_p_dict;	// 'dictionary' local value
!     char_u	*b_p_tsr;	// 'thesaurus' local value
  #endif
!     long	b_p_ul;		// 'undolevels' local value
  #ifdef FEAT_PERSISTENT_UNDO
!     int		b_p_udf;	// 'undofile'
  #endif
  #ifdef FEAT_LISP
!     char_u	*b_p_lw;	// 'lispwords' local value
  #endif
  #ifdef FEAT_TERMINAL
!     long	b_p_twsl;	// 'termwinscroll'
  #endif
  
!     /*
!      * end of buffer options
!      */
  
  #ifdef FEAT_CINDENT
!     // values set from b_p_cino
      int		b_ind_level;
      int		b_ind_open_imag;
      int		b_ind_no_brace;
***************
*** 2472,2489 ****
      int		b_ind_cpp_extern_c;
  #endif
  
!     linenr_T	b_no_eol_lnum;	/* non-zero lnum when last line of next binary
! 				 * write should not have an end-of-line */
  
!     int		b_start_eol;	/* last line had eol when it was read */
!     int		b_start_ffc;	/* first char of 'ff' when edit started */
!     char_u	*b_start_fenc;	/* 'fileencoding' when edit started or NULL */
!     int		b_bad_char;	/* "++bad=" argument when edit started or 0 */
!     int		b_start_bomb;	/* 'bomb' when it was read */
  
  #ifdef FEAT_EVAL
!     dictitem_T	b_bufvar;	/* variable for "b:" Dictionary */
!     dict_T	*b_vars;	/* internal variables, local to buffer */
  
      listener_T	*b_listener;
      list_T	*b_recorded_changes;
--- 2481,2498 ----
      int		b_ind_cpp_extern_c;
  #endif
  
!     linenr_T	b_no_eol_lnum;	// non-zero lnum when last line of next binary
! 				// write should not have an end-of-line
  
!     int		b_start_eol;	// last line had eol when it was read
!     int		b_start_ffc;	// first char of 'ff' when edit started
!     char_u	*b_start_fenc;	// 'fileencoding' when edit started or NULL
!     int		b_bad_char;	// "++bad=" argument when edit started or 0
!     int		b_start_bomb;	// 'bomb' when it was read
  
  #ifdef FEAT_EVAL
!     dictitem_T	b_bufvar;	// variable for "b:" Dictionary
!     dict_T	*b_vars;	// internal variables, local to buffer
  
      listener_T	*b_listener;
      list_T	*b_recorded_changes;
***************
*** 2494,2528 ****
  #endif
  
  #if defined(FEAT_BEVAL) && defined(FEAT_EVAL)
!     char_u	*b_p_bexpr;	/* 'balloonexpr' local value */
!     long_u	b_p_bexpr_flags;/* flags for 'balloonexpr' */
  #endif
  #ifdef FEAT_CRYPT
!     char_u	*b_p_cm;	/* 'cryptmethod' */
  #endif
  
!     /* When a buffer is created, it starts without a swap file.  b_may_swap is
!      * then set to indicate that a swap file may be opened later.  It is reset
!      * if a swap file could not be opened.
!      */
      int		b_may_swap;
!     int		b_did_warn;	/* Set to 1 if user has been warned on first
! 				   change of a read-only file */
  
!     /* Two special kinds of buffers:
!      * help buffer  - used for help files, won't use a swap file.
!      * spell buffer - used for spell info, never displayed and doesn't have a
!      *		      file name.
!      */
!     int		b_help;		/* TRUE for help file buffer (when set b_p_bt
! 				   is "help") */
  #ifdef FEAT_SPELL
!     int		b_spell;	/* TRUE for a spell file buffer, most fields
! 				   are not used!  Use the B_SPELL macro to
! 				   access b_spell without #ifdef. */
  #endif
  
!     int		b_shortname;	/* this file has an 8.3 file name */
  
  #ifdef FEAT_JOB_CHANNEL
      char_u	*b_prompt_text;		// set by prompt_setprompt()
--- 2503,2535 ----
  #endif
  
  #if defined(FEAT_BEVAL) && defined(FEAT_EVAL)
!     char_u	*b_p_bexpr;	// 'balloonexpr' local value
!     long_u	b_p_bexpr_flags;// flags for 'balloonexpr'
  #endif
  #ifdef FEAT_CRYPT
!     char_u	*b_p_cm;	// 'cryptmethod'
  #endif
  
!     // When a buffer is created, it starts without a swap file.  b_may_swap is
!     // then set to indicate that a swap file may be opened later.  It is reset
!     // if a swap file could not be opened.
      int		b_may_swap;
!     int		b_did_warn;	// Set to 1 if user has been warned on first
! 				// change of a read-only file
  
!     // Two special kinds of buffers:
!     // help buffer  - used for help files, won't use a swap file.
!     // spell buffer - used for spell info, never displayed and doesn't have a
!     //		      file name.
!     int		b_help;		// TRUE for help file buffer (when set b_p_bt
! 				// is "help")
  #ifdef FEAT_SPELL
!     int		b_spell;	// TRUE for a spell file buffer, most fields
! 				// are not used!  Use the B_SPELL macro to
! 				// access b_spell without #ifdef.
  #endif
  
!     int		b_shortname;	// this file has an 8.3 file name
  
  #ifdef FEAT_JOB_CHANNEL
      char_u	*b_prompt_text;		// set by prompt_setprompt()
***************
*** 2532,2538 ****
  					// a prompt buffer window.
  #endif
  #ifdef FEAT_MZSCHEME
!     void	*b_mzscheme_ref; /* The MzScheme reference to this buffer */
  #endif
  
  #ifdef FEAT_PERL
--- 2539,2545 ----
  					// a prompt buffer window.
  #endif
  #ifdef FEAT_MZSCHEME
!     void	*b_mzscheme_ref; // The MzScheme reference to this buffer
  #endif
  
  #ifdef FEAT_PERL
***************
*** 2540,2550 ****
  #endif
  
  #ifdef FEAT_PYTHON
!     void	*b_python_ref;	/* The Python reference to this buffer */
  #endif
  
  #ifdef FEAT_PYTHON3
!     void	*b_python3_ref;	/* The Python3 reference to this buffer */
  #endif
  
  #ifdef FEAT_TCL
--- 2547,2557 ----
  #endif
  
  #ifdef FEAT_PYTHON
!     void	*b_python_ref;	// The Python reference to this buffer
  #endif
  
  #ifdef FEAT_PYTHON3
!     void	*b_python3_ref;	// The Python3 reference to this buffer
  #endif
  
  #ifdef FEAT_TCL
***************
*** 2556,2605 ****
  #endif
  
  #if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)
!     synblock_T	b_s;		/* Info related to syntax highlighting.  w_s
! 				 * normally points to this, but some windows
! 				 * may use a different synblock_T. */
  #endif
  
  #ifdef FEAT_SIGNS
!     signlist_T	*b_signlist;	/* list of signs to draw */
  # ifdef FEAT_NETBEANS_INTG
!     int		b_has_sign_column; /* Flag that is set when a first sign is
! 				    * added and remains set until the end of
! 				    * the netbeans session. */
  # endif
  #endif
  
  #ifdef FEAT_NETBEANS_INTG
!     int		b_netbeans_file;    /* TRUE when buffer is owned by NetBeans */
!     int		b_was_netbeans_file;/* TRUE if b_netbeans_file was once set */
  #endif
  #ifdef FEAT_JOB_CHANNEL
!     int		b_write_to_channel; /* TRUE when appended lines are written to
! 				     * a channel. */
  #endif
  
  #ifdef FEAT_CRYPT
!     cryptstate_T *b_cryptstate;	/* Encryption state while reading or writing
! 				 * the file. NULL when not using encryption. */
  #endif
!     int		b_mapped_ctrl_c; /* modes where CTRL-C is mapped */
  
  #ifdef FEAT_TERMINAL
!     term_T	*b_term;	/* When not NULL this buffer is for a terminal
! 				 * window. */
  #endif
  #ifdef FEAT_DIFF
      int		b_diff_failed;	// internal diff failed for this buffer
  #endif
! }; /* file_buffer */
  
  
  #ifdef FEAT_DIFF
  /*
   * Stuff for diff mode.
   */
! # define DB_COUNT 8	/* up to eight buffers can be diff'ed */
  
  /*
   * Each diffblock defines where a block of lines starts in each of the buffers
--- 2563,2612 ----
  #endif
  
  #if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)
!     synblock_T	b_s;		// Info related to syntax highlighting.  w_s
! 				// normally points to this, but some windows
! 				// may use a different synblock_T.
  #endif
  
  #ifdef FEAT_SIGNS
!     signlist_T	*b_signlist;	   // list of signs to draw
  # ifdef FEAT_NETBEANS_INTG
!     int		b_has_sign_column; // Flag that is set when a first sign is
! 				   // added and remains set until the end of
! 				   // the netbeans session.
  # endif
  #endif
  
  #ifdef FEAT_NETBEANS_INTG
!     int		b_netbeans_file;    // TRUE when buffer is owned by NetBeans
!     int		b_was_netbeans_file;// TRUE if b_netbeans_file was once set
  #endif
  #ifdef FEAT_JOB_CHANNEL
!     int		b_write_to_channel; // TRUE when appended lines are written to
! 				    // a channel.
  #endif
  
  #ifdef FEAT_CRYPT
!     cryptstate_T *b_cryptstate;	// Encryption state while reading or writing
! 				// the file. NULL when not using encryption.
  #endif
!     int		b_mapped_ctrl_c; // modes where CTRL-C is mapped
  
  #ifdef FEAT_TERMINAL
!     term_T	*b_term;	// When not NULL this buffer is for a terminal
! 				// window.
  #endif
  #ifdef FEAT_DIFF
      int		b_diff_failed;	// internal diff failed for this buffer
  #endif
! }; // file_buffer
  
  
  #ifdef FEAT_DIFF
  /*
   * Stuff for diff mode.
   */
! # define DB_COUNT 8	// up to eight buffers can be diff'ed
  
  /*
   * Each diffblock defines where a block of lines starts in each of the buffers
***************
*** 2619,2626 ****
  struct diffblock_S
  {
      diff_T	*df_next;
!     linenr_T	df_lnum[DB_COUNT];	/* line number in buffer */
!     linenr_T	df_count[DB_COUNT];	/* nr of inserted/changed lines */
  };
  #endif
  
--- 2626,2633 ----
  struct diffblock_S
  {
      diff_T	*df_next;
!     linenr_T	df_lnum[DB_COUNT];	// line number in buffer
!     linenr_T	df_count[DB_COUNT];	// nr of inserted/changed lines
  };
  #endif
  
***************
*** 2692,2703 ****
   */
  typedef struct w_line
  {
!     linenr_T	wl_lnum;	/* buffer line number for logical line */
!     short_u	wl_size;	/* height in screen lines */
!     char	wl_valid;	/* TRUE values are valid for text in buffer */
  #ifdef FEAT_FOLDING
!     char	wl_folded;	/* TRUE when this is a range of folded lines */
!     linenr_T	wl_lastlnum;	/* last buffer line number for logical line */
  #endif
  } wline_T;
  
--- 2699,2710 ----
   */
  typedef struct w_line
  {
!     linenr_T	wl_lnum;	// buffer line number for logical line
!     short_u	wl_size;	// height in screen lines
!     char	wl_valid;	// TRUE values are valid for text in buffer
  #ifdef FEAT_FOLDING
!     char	wl_folded;	// TRUE when this is a range of folded lines
!     linenr_T	wl_lastlnum;	// last buffer line number for logical line
  #endif
  } wline_T;
  
***************
*** 2722,2730 ****
      win_T	*fr_win;	// window that fills this frame
  };
  
! #define FR_LEAF	0	/* frame is a leaf */
! #define FR_ROW	1	/* frame with a row of windows */
! #define FR_COL	2	/* frame with a column of windows */
  
  /*
   * Struct used for highlighting 'hlsearch' matches, matches defined by
--- 2729,2737 ----
      win_T	*fr_win;	// window that fills this frame
  };
  
! #define FR_LEAF	0	// frame is a leaf
! #define FR_ROW	1	// frame with a row of windows
! #define FR_COL	2	// frame with a column of windows
  
  /*
   * Struct used for highlighting 'hlsearch' matches, matches defined by
***************
*** 2734,2756 ****
   */
  typedef struct
  {
!     regmmatch_T	rm;	/* points to the regexp program; contains last found
! 			   match (may continue in next line) */
!     buf_T	*buf;	/* the buffer to search for a match */
!     linenr_T	lnum;	/* the line to search for a match */
!     int		attr;	/* attributes to be used for a match */
!     int		attr_cur; /* attributes currently active in win_line() */
!     linenr_T	first_lnum;	/* first lnum to search for multi-line pat */
!     colnr_T	startcol; /* in win_line() points to char where HL starts */
!     colnr_T	endcol;	 /* in win_line() points to char where HL ends */
!     int		is_addpos;	/* position specified directly by
! 				   matchaddpos(). TRUE/FALSE */
  #ifdef FEAT_RELTIME
!     proftime_T	tm;	/* for a time limit */
  #endif
  } match_T;
  
! /* number of positions supported by matchaddpos() */
  #define MAXPOSMATCH 8
  
  /*
--- 2741,2763 ----
   */
  typedef struct
  {
!     regmmatch_T	rm;	    // points to the regexp program; contains last
! 			    // found match (may continue in next line)
!     buf_T	*buf;	    // the buffer to search for a match
!     linenr_T	lnum;	    // the line to search for a match
!     int		attr;	    // attributes to be used for a match
!     int		attr_cur;   // attributes currently active in win_line()
!     linenr_T	first_lnum; // first lnum to search for multi-line pat
!     colnr_T	startcol;   // in win_line() points to char where HL starts
!     colnr_T	endcol;	    // in win_line() points to char where HL ends
!     int		is_addpos;  // position specified directly by
! 			    // matchaddpos(). TRUE/FALSE
  #ifdef FEAT_RELTIME
!     proftime_T	tm;	    // for a time limit
  #endif
  } match_T;
  
! // number of positions supported by matchaddpos()
  #define MAXPOSMATCH 8
  
  /*
***************
*** 2758,2766 ****
   */
  typedef struct
  {
!     linenr_T	lnum;	/* line number */
!     colnr_T	col;	/* column number */
!     int		len;	/* length: 0 - to the end of line */
  } llpos_T;
  
  /*
--- 2765,2773 ----
   */
  typedef struct
  {
!     linenr_T	lnum;	// line number
!     colnr_T	col;	// column number
!     int		len;	// length: 0 - to the end of line
  } llpos_T;
  
  /*
***************
*** 2770,2779 ****
  typedef struct posmatch posmatch_T;
  struct posmatch
  {
!     llpos_T	pos[MAXPOSMATCH];	/* array of positions */
!     int		cur;			/* internal position counter */
!     linenr_T	toplnum;		/* top buffer line */
!     linenr_T	botlnum;		/* bottom buffer line */
  };
  
  /*
--- 2777,2786 ----
  typedef struct posmatch posmatch_T;
  struct posmatch
  {
!     llpos_T	pos[MAXPOSMATCH];	// array of positions
!     int		cur;			// internal position counter
!     linenr_T	toplnum;		// top buffer line
!     linenr_T	botlnum;		// bottom buffer line
  };
  
  /*
***************
*** 2784,2798 ****
  struct matchitem
  {
      matchitem_T	*next;
!     int		id;	    /* match ID */
!     int		priority;   /* match priority */
!     char_u	*pattern;   /* pattern to highlight */
!     int		hlg_id;	    /* highlight group ID */
!     regmmatch_T	match;	    /* regexp program for pattern */
!     posmatch_T	pos;	    /* position matches */
!     match_T	hl;	    /* struct for doing the actual highlighting */
  #ifdef FEAT_CONCEAL
!     int		conceal_char; /* cchar for Conceal highlighting */
  #endif
  };
  
--- 2791,2805 ----
  struct matchitem
  {
      matchitem_T	*next;
!     int		id;	    // match ID
!     int		priority;   // match priority
!     char_u	*pattern;   // pattern to highlight
!     int		hlg_id;	    // highlight group ID
!     regmmatch_T	match;	    // regexp program for pattern
!     posmatch_T	pos;	    // position matches
!     match_T	hl;	    // struct for doing the actual highlighting
  #ifdef FEAT_CONCEAL
!     int		conceal_char; // cchar for Conceal highlighting
  #endif
  };
  
***************
*** 2821,2900 ****
   */
  struct window_S
  {
!     int		w_id;		    /* unique window ID */
  
!     buf_T	*w_buffer;	    /* buffer we are a window into */
  
!     win_T	*w_prev;	    /* link to previous window */
!     win_T	*w_next;	    /* link to next window */
  
  #if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)
!     synblock_T	*w_s;		    /* for :ownsyntax */
  #endif
  
!     int		w_closing;	    /* window is being closed, don't let
! 				       autocommands close it too. */
  
!     frame_T	*w_frame;	    /* frame containing this window */
  
!     pos_T	w_cursor;	    /* cursor position in buffer */
  
!     colnr_T	w_curswant;	    /* The column we'd like to be at.  This is
! 				       used to try to stay in the same column
! 				       for up/down cursor motions. */
  
!     int		w_set_curswant;	    /* If set, then update w_curswant the next
! 				       time through cursupdate() to the
! 				       current virtual column */
  
  #ifdef FEAT_SYN_HL
      linenr_T	w_last_cursorline;  // where last time 'cursorline' was drawn
  #endif
  
      /*
!      * the next seven are used to update the visual part
       */
!     char	w_old_visual_mode;  /* last known VIsual_mode */
!     linenr_T	w_old_cursor_lnum;  /* last known end of visual part */
!     colnr_T	w_old_cursor_fcol;  /* first column for block visual part */
!     colnr_T	w_old_cursor_lcol;  /* last column for block visual part */
!     linenr_T	w_old_visual_lnum;  /* last known start of visual part */
!     colnr_T	w_old_visual_col;   /* last known start of visual part */
!     colnr_T	w_old_curswant;	    /* last known value of Curswant */
  
      /*
       * "w_topline", "w_leftcol" and "w_skipcol" specify the offsets for
       * displaying the buffer.
       */
!     linenr_T	w_topline;	    /* buffer line number of the line at the
! 				       top of the window */
!     char	w_topline_was_set;  /* flag set to TRUE when topline is set,
! 				       e.g. by winrestview() */
  #ifdef FEAT_DIFF
!     int		w_topfill;	    /* number of filler lines above w_topline */
!     int		w_old_topfill;	    /* w_topfill at last redraw */
!     int		w_botfill;	    /* TRUE when filler lines are actually
! 				       below w_topline (at end of file) */
!     int		w_old_botfill;	    /* w_botfill at last redraw */
! #endif
!     colnr_T	w_leftcol;	    /* window column number of the left most
! 				       character in the window; used when
! 				       'wrap' is off */
!     colnr_T	w_skipcol;	    /* starting column when a single line
! 				       doesn't fit in the window */
  
      /*
       * Layout of the window in the screen.
       * May need to add "msg_scrolled" to "w_winrow" in rare situations.
       */
!     int		w_winrow;	    /* first row of window in screen */
!     int		w_height;	    /* number of rows in window, excluding
! 				       status/command/winbar line(s) */
!     int		w_status_height;    /* number of status lines (0 or 1) */
!     int		w_wincol;	    /* Leftmost column of window in screen. */
!     int		w_width;	    /* Width of window, excluding separation. */
!     int		w_vsep_width;	    /* Number of separator columns (0 or 1). */
!     pos_save_T	w_save_cursor;	    /* backup of cursor pos and topline */
  #ifdef FEAT_TEXT_PROP
      int		w_popup_flags;	    // POPF_ values
      char_u	*w_popup_title;
--- 2828,2907 ----
   */
  struct window_S
  {
!     int		w_id;		    // unique window ID
  
!     buf_T	*w_buffer;	    // buffer we are a window into
  
!     win_T	*w_prev;	    // link to previous window
!     win_T	*w_next;	    // link to next window
  
  #if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)
!     synblock_T	*w_s;		    // for :ownsyntax
  #endif
  
!     int		w_closing;	    // window is being closed, don't let
! 				    // autocommands close it too.
  
!     frame_T	*w_frame;	    // frame containing this window
  
!     pos_T	w_cursor;	    // cursor position in buffer
  
!     colnr_T	w_curswant;	    // The column we'd like to be at.  This is
! 				    // used to try to stay in the same column
! 				    // for up/down cursor motions.
  
!     int		w_set_curswant;	    // If set, then update w_curswant the next
! 				    // time through cursupdate() to the
! 				    // current virtual column
  
  #ifdef FEAT_SYN_HL
      linenr_T	w_last_cursorline;  // where last time 'cursorline' was drawn
  #endif
  
      /*
!      * the next seven are used to update the Visual highlighting
       */
!     char	w_old_visual_mode;  // last known VIsual_mode
!     linenr_T	w_old_cursor_lnum;  // last known end of visual part
!     colnr_T	w_old_cursor_fcol;  // first column for block visual part
!     colnr_T	w_old_cursor_lcol;  // last column for block visual part
!     linenr_T	w_old_visual_lnum;  // last known start of visual part
!     colnr_T	w_old_visual_col;   // last known start of visual part
!     colnr_T	w_old_curswant;	    // last known value of Curswant
  
      /*
       * "w_topline", "w_leftcol" and "w_skipcol" specify the offsets for
       * displaying the buffer.
       */
!     linenr_T	w_topline;	    // buffer line number of the line at the
! 				    // top of the window
!     char	w_topline_was_set;  // flag set to TRUE when topline is set,
! 				    // e.g. by winrestview()
  #ifdef FEAT_DIFF
!     int		w_topfill;	    // number of filler lines above w_topline
!     int		w_old_topfill;	    // w_topfill at last redraw
!     int		w_botfill;	    // TRUE when filler lines are actually
! 				    // below w_topline (at end of file)
!     int		w_old_botfill;	    // w_botfill at last redraw
! #endif
!     colnr_T	w_leftcol;	    // window column number of the left most
! 				    // character in the window; used when
! 				    // 'wrap' is off
!     colnr_T	w_skipcol;	    // starting column when a single line
! 				    // doesn't fit in the window
  
      /*
       * Layout of the window in the screen.
       * May need to add "msg_scrolled" to "w_winrow" in rare situations.
       */
!     int		w_winrow;	    // first row of window in screen
!     int		w_height;	    // number of rows in window, excluding
! 				    // status/command/winbar line(s)
!     int		w_status_height;    // number of status lines (0 or 1)
!     int		w_wincol;	    // Leftmost column of window in screen.
!     int		w_width;	    // Width of window, excluding separation.
!     int		w_vsep_width;	    // Number of separator columns (0 or 1).
!     pos_save_T	w_save_cursor;	    // backup of cursor pos and topline
  #ifdef FEAT_TEXT_PROP
      int		w_popup_flags;	    // POPF_ values
      char_u	*w_popup_title;
***************
*** 2948,2988 ****
       * valid or need to be recomputed.	See screen.c for values.
       */
      int		w_valid;
!     pos_T	w_valid_cursor;	    /* last known position of w_cursor, used
! 				       to adjust w_valid */
!     colnr_T	w_valid_leftcol;    /* last known w_leftcol */
  
      /*
       * w_cline_height is the number of physical lines taken by the buffer line
       * that the cursor is on.  We use this to avoid extra calls to plines().
       */
!     int		w_cline_height;	    /* current size of cursor line */
  #ifdef FEAT_FOLDING
!     int		w_cline_folded;	    /* cursor line is folded */
  #endif
  
!     int		w_cline_row;	    /* starting row of the cursor line */
  
!     colnr_T	w_virtcol;	    /* column number of the cursor in the
! 				       buffer line, as opposed to the column
! 				       number we're at on the screen.  This
! 				       makes a difference on lines which span
! 				       more than one screen line or when
! 				       w_leftcol is non-zero */
  
      /*
       * w_wrow and w_wcol specify the cursor position in the window.
       * This is related to positions in the window, not in the display or
       * buffer, thus w_wrow is relative to w_winrow.
       */
!     int		w_wrow, w_wcol;	    /* cursor position in window */
  
!     linenr_T	w_botline;	    /* number of the line below the bottom of
! 				       the window */
!     int		w_empty_rows;	    /* number of ~ rows in window */
  #ifdef FEAT_DIFF
!     int		w_filler_rows;	    /* number of filler rows at the end of the
! 				       window */
  #endif
  
      /*
--- 2955,2995 ----
       * valid or need to be recomputed.	See screen.c for values.
       */
      int		w_valid;
!     pos_T	w_valid_cursor;	    // last known position of w_cursor, used
! 				    // to adjust w_valid
!     colnr_T	w_valid_leftcol;    // last known w_leftcol
  
      /*
       * w_cline_height is the number of physical lines taken by the buffer line
       * that the cursor is on.  We use this to avoid extra calls to plines().
       */
!     int		w_cline_height;	    // current size of cursor line
  #ifdef FEAT_FOLDING
!     int		w_cline_folded;	    // cursor line is folded
  #endif
  
!     int		w_cline_row;	    // starting row of the cursor line
  
!     colnr_T	w_virtcol;	    // column number of the cursor in the
! 				    // buffer line, as opposed to the column
! 				    // number we're at on the screen.  This
! 				    // makes a difference on lines which span
! 				    // more than one screen line or when
! 				    // w_leftcol is non-zero
  
      /*
       * w_wrow and w_wcol specify the cursor position in the window.
       * This is related to positions in the window, not in the display or
       * buffer, thus w_wrow is relative to w_winrow.
       */
!     int		w_wrow, w_wcol;	    // cursor position in window
  
!     linenr_T	w_botline;	    // number of the line below the bottom of
! 				    // the window
!     int		w_empty_rows;	    // number of ~ rows in window
  #ifdef FEAT_DIFF
!     int		w_filler_rows;	    // number of filler rows at the end of the
! 				    // window
  #endif
  
      /*
***************
*** 2995,3051 ****
       * what is currently displayed.  wl_valid is reset to indicated this.
       * This is used for efficient redrawing.
       */
!     int		w_lines_valid;	    /* number of valid entries */
      wline_T	*w_lines;
  
  #ifdef FEAT_FOLDING
!     garray_T	w_folds;	    /* array of nested folds */
!     char	w_fold_manual;	    /* when TRUE: some folds are opened/closed
! 				       manually */
!     char	w_foldinvalid;	    /* when TRUE: folding needs to be
! 				       recomputed */
  #endif
  #ifdef FEAT_LINEBREAK
!     int		w_nrwidth;	    /* width of 'number' and 'relativenumber'
! 				       column being used */
  #endif
  
      /*
       * === end of cached values ===
       */
  
!     int		w_redr_type;	    /* type of redraw to be performed on win */
!     int		w_upd_rows;	    /* number of window lines to update when
! 				       w_redr_type is REDRAW_TOP */
!     linenr_T	w_redraw_top;	    /* when != 0: first line needing redraw */
!     linenr_T	w_redraw_bot;	    /* when != 0: last line needing redraw */
!     int		w_redr_status;	    /* if TRUE status line must be redrawn */
  
  #ifdef FEAT_CMDL_INFO
!     /* remember what is shown in the ruler for this window (if 'ruler' set) */
!     pos_T	w_ru_cursor;	    /* cursor position shown in ruler */
!     colnr_T	w_ru_virtcol;	    /* virtcol shown in ruler */
!     linenr_T	w_ru_topline;	    /* topline shown in ruler */
!     linenr_T	w_ru_line_count;    /* line count used for ruler */
  # ifdef FEAT_DIFF
!     int		w_ru_topfill;	    /* topfill shown in ruler */
  # endif
!     char	w_ru_empty;	    /* TRUE if ruler shows 0-1 (empty line) */
  #endif
  
!     int		w_alt_fnum;	    /* alternate file (for # and CTRL-^) */
  
!     alist_T	*w_alist;	    /* pointer to arglist for this window */
!     int		w_arg_idx;	    /* current index in argument list (can be
! 				       out of range!) */
!     int		w_arg_idx_invalid;  /* editing another file than w_arg_idx */
  
!     char_u	*w_localdir;	    /* absolute path of local directory or
! 				       NULL */
  #ifdef FEAT_MENU
!     vimmenu_T	*w_winbar;	    /* The root of the WinBar menu hierarchy. */
!     winbar_item_T *w_winbar_items;  /* list of items in the WinBar */
!     int		w_winbar_height;    /* 1 if there is a window toolbar */
  #endif
  
      /*
--- 3002,3058 ----
       * what is currently displayed.  wl_valid is reset to indicated this.
       * This is used for efficient redrawing.
       */
!     int		w_lines_valid;	    // number of valid entries
      wline_T	*w_lines;
  
  #ifdef FEAT_FOLDING
!     garray_T	w_folds;	    // array of nested folds
!     char	w_fold_manual;	    // when TRUE: some folds are opened/closed
! 				    // manually
!     char	w_foldinvalid;	    // when TRUE: folding needs to be
! 				    // recomputed
  #endif
  #ifdef FEAT_LINEBREAK
!     int		w_nrwidth;	    // width of 'number' and 'relativenumber'
! 				    // column being used
  #endif
  
      /*
       * === end of cached values ===
       */
  
!     int		w_redr_type;	    // type of redraw to be performed on win
!     int		w_upd_rows;	    // number of window lines to update when
! 				    // w_redr_type is REDRAW_TOP
!     linenr_T	w_redraw_top;	    // when != 0: first line needing redraw
!     linenr_T	w_redraw_bot;	    // when != 0: last line needing redraw
!     int		w_redr_status;	    // if TRUE status line must be redrawn
  
  #ifdef FEAT_CMDL_INFO
!     // remember what is shown in the ruler for this window (if 'ruler' set)
!     pos_T	w_ru_cursor;	    // cursor position shown in ruler
!     colnr_T	w_ru_virtcol;	    // virtcol shown in ruler
!     linenr_T	w_ru_topline;	    // topline shown in ruler
!     linenr_T	w_ru_line_count;    // line count used for ruler
  # ifdef FEAT_DIFF
!     int		w_ru_topfill;	    // topfill shown in ruler
  # endif
!     char	w_ru_empty;	    // TRUE if ruler shows 0-1 (empty line)
  #endif
  
!     int		w_alt_fnum;	    // alternate file (for # and CTRL-^)
  
!     alist_T	*w_alist;	    // pointer to arglist for this window
!     int		w_arg_idx;	    // current index in argument list (can be
! 				    // out of range!)
!     int		w_arg_idx_invalid;  // editing another file than w_arg_idx
  
!     char_u	*w_localdir;	    // absolute path of local directory or
! 				    // NULL
  #ifdef FEAT_MENU
!     vimmenu_T	*w_winbar;	    // The root of the WinBar menu hierarchy.
!     winbar_item_T *w_winbar_items;  // list of items in the WinBar
!     int		w_winbar_height;    // 1 if there is a window toolbar
  #endif
  
      /*
***************
*** 3058,3083 ****
      winopt_T	w_onebuf_opt;
      winopt_T	w_allbuf_opt;
  
!     /* A few options have local flags for P_INSECURE. */
  #ifdef FEAT_STL_OPT
!     long_u	w_p_stl_flags;	    /* flags for 'statusline' */
  #endif
  #ifdef FEAT_EVAL
!     long_u	w_p_fde_flags;	    /* flags for 'foldexpr' */
!     long_u	w_p_fdt_flags;	    /* flags for 'foldtext' */
  #endif
  #ifdef FEAT_SYN_HL
!     int		*w_p_cc_cols;	    /* array of columns to highlight or NULL */
  #endif
  #ifdef FEAT_LINEBREAK
!     int		w_p_brimin;	    /* minimum width for breakindent */
!     int		w_p_brishift;	    /* additional shift for breakindent */
!     int		w_p_brisbr;	    /* sbr in 'briopt' */
  #endif
!     long	w_p_siso;	    /* 'sidescrolloff' local value */
!     long	w_p_so;		    /* 'scrolloff' local value */
  
!     /* transform a pointer to a "onebuf" option into a "allbuf" option */
  #define GLOBAL_WO(p)	((char *)p + sizeof(winopt_T))
  
      long	w_scbind_pos;
--- 3065,3090 ----
      winopt_T	w_onebuf_opt;
      winopt_T	w_allbuf_opt;
  
!     // A few options have local flags for P_INSECURE.
  #ifdef FEAT_STL_OPT
!     long_u	w_p_stl_flags;	    // flags for 'statusline'
  #endif
  #ifdef FEAT_EVAL
!     long_u	w_p_fde_flags;	    // flags for 'foldexpr'
!     long_u	w_p_fdt_flags;	    // flags for 'foldtext'
  #endif
  #ifdef FEAT_SYN_HL
!     int		*w_p_cc_cols;	    // array of columns to highlight or NULL
  #endif
  #ifdef FEAT_LINEBREAK
!     int		w_p_brimin;	    // minimum width for breakindent
!     int		w_p_brishift;	    // additional shift for breakindent
!     int		w_p_brisbr;	    // sbr in 'briopt'
  #endif
!     long	w_p_siso;	    // 'sidescrolloff' local value
!     long	w_p_so;		    // 'scrolloff' local value
  
!     // transform a pointer to a "onebuf" option into a "allbuf" option
  #define GLOBAL_WO(p)	((char *)p + sizeof(winopt_T))
  
      long	w_scbind_pos;
***************
*** 3092,3114 ****
       * a new line after setting the w_pcmark.  If not, then we revert to
       * using the previous w_pcmark.
       */
!     pos_T	w_pcmark;	/* previous context mark */
!     pos_T	w_prev_pcmark;	/* previous w_pcmark */
  
  #ifdef FEAT_JUMPLIST
      /*
       * the jumplist contains old cursor positions
       */
      xfmark_T	w_jumplist[JUMPLISTSIZE];
!     int		w_jumplistlen;		/* number of active entries */
!     int		w_jumplistidx;		/* current position */
  
!     int		w_changelistidx;	/* current position in b_changelist */
  #endif
  
  #ifdef FEAT_SEARCH_EXTRA
!     matchitem_T	*w_match_head;		/* head of match list */
!     int		w_next_match_id;	/* next match ID */
  #endif
  
      /*
--- 3099,3121 ----
       * a new line after setting the w_pcmark.  If not, then we revert to
       * using the previous w_pcmark.
       */
!     pos_T	w_pcmark;	// previous context mark
!     pos_T	w_prev_pcmark;	// previous w_pcmark
  
  #ifdef FEAT_JUMPLIST
      /*
       * the jumplist contains old cursor positions
       */
      xfmark_T	w_jumplist[JUMPLISTSIZE];
!     int		w_jumplistlen;		// number of active entries
!     int		w_jumplistidx;		// current position
  
!     int		w_changelistidx;	// current position in b_changelist
  #endif
  
  #ifdef FEAT_SEARCH_EXTRA
!     matchitem_T	*w_match_head;		// head of match list
!     int		w_next_match_id;	// next match ID
  #endif
  
      /*
***************
*** 3117,3125 ****
       * entry 1: newer
       * entry 2: newest
       */
!     taggy_T	w_tagstack[TAGSTACKSIZE];	/* the tag stack */
!     int		w_tagstackidx;		/* idx just below active entry */
!     int		w_tagstacklen;		/* number of tags on stack */
  
      /*
       * w_fraction is the fractional row of the cursor within the window, from
--- 3124,3132 ----
       * entry 1: newer
       * entry 2: newest
       */
!     taggy_T	w_tagstack[TAGSTACKSIZE];   // the tag stack
!     int		w_tagstackidx;		    // idx just below active entry
!     int		w_tagstacklen;		    // number of tags on stack
  
      /*
       * w_fraction is the fractional row of the cursor within the window, from
***************
*** 3131,3147 ****
      int		w_prev_fraction_row;
  
  #ifdef FEAT_GUI
!     scrollbar_T	w_scrollbars[2];	/* vert. Scrollbars for this window */
  #endif
  #ifdef FEAT_LINEBREAK
!     linenr_T	w_nrwidth_line_count;	/* line count when ml_nrwidth_width
! 					 * was computed. */
!     long	w_nuw_cached;		/* 'numberwidth' option cached */
!     int		w_nrwidth_width;	/* nr of chars to print line count. */
  #endif
  
  #ifdef FEAT_QUICKFIX
!     qf_info_T	*w_llist;		/* Location list for this window */
      /*
       * Location list reference used in the location list window.
       * In a non-location list window, w_llist_ref is NULL.
--- 3138,3154 ----
      int		w_prev_fraction_row;
  
  #ifdef FEAT_GUI
!     scrollbar_T	w_scrollbars[2];	// vert. Scrollbars for this window
  #endif
  #ifdef FEAT_LINEBREAK
!     linenr_T	w_nrwidth_line_count;	// line count when ml_nrwidth_width
! 					// was computed.
!     long	w_nuw_cached;		// 'numberwidth' option cached
!     int		w_nrwidth_width;	// nr of chars to print line count.
  #endif
  
  #ifdef FEAT_QUICKFIX
!     qf_info_T	*w_llist;		// Location list for this window
      /*
       * Location list reference used in the location list window.
       * In a non-location list window, w_llist_ref is NULL.
***************
*** 3151,3157 ****
  
  
  #ifdef FEAT_MZSCHEME
!     void	*w_mzscheme_ref;	/* The MzScheme value for this window */
  #endif
  
  #ifdef FEAT_PERL
--- 3158,3164 ----
  
  
  #ifdef FEAT_MZSCHEME
!     void	*w_mzscheme_ref;	// The MzScheme value for this window
  #endif
  
  #ifdef FEAT_PERL
***************
*** 3159,3169 ****
  #endif
  
  #ifdef FEAT_PYTHON
!     void	*w_python_ref;		/* The Python value for this window */
  #endif
  
  #ifdef FEAT_PYTHON3
!     void	*w_python3_ref;		/* The Python value for this window */
  #endif
  
  #ifdef FEAT_TCL
--- 3166,3176 ----
  #endif
  
  #ifdef FEAT_PYTHON
!     void	*w_python_ref;		// The Python value for this window
  #endif
  
  #ifdef FEAT_PYTHON3
!     void	*w_python3_ref;		// The Python value for this window
  #endif
  
  #ifdef FEAT_TCL
***************
*** 3180,3209 ****
   */
  typedef struct oparg_S
  {
!     int		op_type;	/* current pending operator type */
!     int		regname;	/* register to use for the operator */
!     int		motion_type;	/* type of the current cursor motion */
!     int		motion_force;	/* force motion type: 'v', 'V' or CTRL-V */
!     int		use_reg_one;	/* TRUE if delete uses reg 1 even when not
! 				   linewise */
!     int		inclusive;	/* TRUE if char motion is inclusive (only
! 				   valid when motion_type is MCHAR */
!     int		end_adjusted;	/* backuped b_op_end one char (only used by
! 				   do_format()) */
!     pos_T	start;		/* start of the operator */
!     pos_T	end;		/* end of the operator */
!     pos_T	cursor_start;	/* cursor position before motion for "gw" */
! 
!     long	line_count;	/* number of lines from op_start to op_end
! 				   (inclusive) */
!     int		empty;		/* op_start and op_end the same (only used by
! 				   do_change()) */
!     int		is_VIsual;	/* operator on Visual area */
!     int		block_mode;	/* current operator is Visual block mode */
!     colnr_T	start_vcol;	/* start col for block mode operator */
!     colnr_T	end_vcol;	/* end col for block mode operator */
!     long	prev_opcount;	/* ca.opcount saved for K_CURSORHOLD */
!     long	prev_count0;	/* ca.count0 saved for K_CURSORHOLD */
  } oparg_T;
  
  /*
--- 3187,3216 ----
   */
  typedef struct oparg_S
  {
!     int		op_type;	// current pending operator type
!     int		regname;	// register to use for the operator
!     int		motion_type;	// type of the current cursor motion
!     int		motion_force;	// force motion type: 'v', 'V' or CTRL-V
!     int		use_reg_one;	// TRUE if delete uses reg 1 even when not
! 				// linewise
!     int		inclusive;	// TRUE if char motion is inclusive (only
! 				// valid when motion_type is MCHAR
!     int		end_adjusted;	// backuped b_op_end one char (only used by
! 				// do_format())
!     pos_T	start;		// start of the operator
!     pos_T	end;		// end of the operator
!     pos_T	cursor_start;	// cursor position before motion for "gw"
! 
!     long	line_count;	// number of lines from op_start to op_end
! 				// (inclusive)
!     int		empty;		// op_start and op_end the same (only used by
! 				// do_change())
!     int		is_VIsual;	// operator on Visual area
!     int		block_mode;	// current operator is Visual block mode
!     colnr_T	start_vcol;	// start col for block mode operator
!     colnr_T	end_vcol;	// end col for block mode operator
!     long	prev_opcount;	// ca.opcount saved for K_CURSORHOLD
!     long	prev_count0;	// ca.count0 saved for K_CURSORHOLD
  } oparg_T;
  
  /*
***************
*** 3211,3287 ****
   */
  typedef struct cmdarg_S
  {
!     oparg_T	*oap;		/* Operator arguments */
!     int		prechar;	/* prefix character (optional, always 'g') */
!     int		cmdchar;	/* command character */
!     int		nchar;		/* next command character (optional) */
!     int		ncharC1;	/* first composing character (optional) */
!     int		ncharC2;	/* second composing character (optional) */
!     int		extra_char;	/* yet another character (optional) */
!     long	opcount;	/* count before an operator */
!     long	count0;		/* count before command, default 0 */
!     long	count1;		/* count before command, default 1 */
!     int		arg;		/* extra argument from nv_cmds[] */
!     int		retval;		/* return: CA_* values */
!     char_u	*searchbuf;	/* return: pointer to search pattern or NULL */
  } cmdarg_T;
  
! /* values for retval: */
! #define CA_COMMAND_BUSY	    1	/* skip restarting edit() once */
! #define CA_NO_ADJ_OP_END    2	/* don't adjust operator end */
  
  #ifdef CURSOR_SHAPE
  /*
   * struct to store values from 'guicursor' and 'mouseshape'
   */
  /* Indexes in shape_table[] */
! #define SHAPE_IDX_N	0	/* Normal mode */
! #define SHAPE_IDX_V	1	/* Visual mode */
! #define SHAPE_IDX_I	2	/* Insert mode */
! #define SHAPE_IDX_R	3	/* Replace mode */
! #define SHAPE_IDX_C	4	/* Command line Normal mode */
! #define SHAPE_IDX_CI	5	/* Command line Insert mode */
! #define SHAPE_IDX_CR	6	/* Command line Replace mode */
! #define SHAPE_IDX_O	7	/* Operator-pending mode */
! #define SHAPE_IDX_VE	8	/* Visual mode with 'selection' exclusive */
! #define SHAPE_IDX_CLINE	9	/* On command line */
! #define SHAPE_IDX_STATUS 10	/* A status line */
! #define SHAPE_IDX_SDRAG 11	/* dragging a status line */
! #define SHAPE_IDX_VSEP	12	/* A vertical separator line */
! #define SHAPE_IDX_VDRAG 13	/* dragging a vertical separator line */
! #define SHAPE_IDX_MORE	14	/* Hit-return or More */
! #define SHAPE_IDX_MOREL	15	/* Hit-return or More in last line */
! #define SHAPE_IDX_SM	16	/* showing matching paren */
  #define SHAPE_IDX_COUNT	17
  
! #define SHAPE_BLOCK	0	/* block cursor */
! #define SHAPE_HOR	1	/* horizontal bar cursor */
! #define SHAPE_VER	2	/* vertical bar cursor */
  
! #define MSHAPE_NUMBERED	1000	/* offset for shapes identified by number */
! #define MSHAPE_HIDE	1	/* hide mouse pointer */
  
! #define SHAPE_MOUSE	1	/* used for mouse pointer shape */
! #define SHAPE_CURSOR	2	/* used for text cursor shape */
  
  typedef struct cursor_entry
  {
!     int		shape;		/* one of the SHAPE_ defines */
!     int		mshape;		/* one of the MSHAPE defines */
!     int		percentage;	/* percentage of cell for bar */
!     long	blinkwait;	/* blinking, wait time before blinking starts */
!     long	blinkon;	/* blinking, on time */
!     long	blinkoff;	/* blinking, off time */
!     int		id;		/* highlight group ID */
!     int		id_lm;		/* highlight group ID for :lmap mode */
!     char	*name;		/* mode name (fixed) */
!     char	used_for;	/* SHAPE_MOUSE and/or SHAPE_CURSOR */
  } cursorentry_T;
! #endif /* CURSOR_SHAPE */
  
  #ifdef FEAT_MENU
  
! /* Indices into vimmenu_T->strings[] and vimmenu_T->noremap[] for each mode */
  #define MENU_INDEX_INVALID	-1
  #define MENU_INDEX_NORMAL	0
  #define MENU_INDEX_VISUAL	1
--- 3218,3294 ----
   */
  typedef struct cmdarg_S
  {
!     oparg_T	*oap;		// Operator arguments
!     int		prechar;	// prefix character (optional, always 'g')
!     int		cmdchar;	// command character
!     int		nchar;		// next command character (optional)
!     int		ncharC1;	// first composing character (optional)
!     int		ncharC2;	// second composing character (optional)
!     int		extra_char;	// yet another character (optional)
!     long	opcount;	// count before an operator
!     long	count0;		// count before command, default 0
!     long	count1;		// count before command, default 1
!     int		arg;		// extra argument from nv_cmds[]
!     int		retval;		// return: CA_* values
!     char_u	*searchbuf;	// return: pointer to search pattern or NULL
  } cmdarg_T;
  
! // values for retval:
! #define CA_COMMAND_BUSY	    1	// skip restarting edit() once
! #define CA_NO_ADJ_OP_END    2	// don't adjust operator end
  
  #ifdef CURSOR_SHAPE
  /*
   * struct to store values from 'guicursor' and 'mouseshape'
   */
  /* Indexes in shape_table[] */
! #define SHAPE_IDX_N	0	// Normal mode
! #define SHAPE_IDX_V	1	// Visual mode
! #define SHAPE_IDX_I	2	// Insert mode
! #define SHAPE_IDX_R	3	// Replace mode
! #define SHAPE_IDX_C	4	// Command line Normal mode
! #define SHAPE_IDX_CI	5	// Command line Insert mode
! #define SHAPE_IDX_CR	6	// Command line Replace mode
! #define SHAPE_IDX_O	7	// Operator-pending mode
! #define SHAPE_IDX_VE	8	// Visual mode with 'selection' exclusive
! #define SHAPE_IDX_CLINE	9	// On command line
! #define SHAPE_IDX_STATUS 10	// A status line
! #define SHAPE_IDX_SDRAG 11	// dragging a status line
! #define SHAPE_IDX_VSEP	12	// A vertical separator line
! #define SHAPE_IDX_VDRAG 13	// dragging a vertical separator line
! #define SHAPE_IDX_MORE	14	// Hit-return or More
! #define SHAPE_IDX_MOREL	15	// Hit-return or More in last line
! #define SHAPE_IDX_SM	16	// showing matching paren
  #define SHAPE_IDX_COUNT	17
  
! #define SHAPE_BLOCK	0	// block cursor
! #define SHAPE_HOR	1	// horizontal bar cursor
! #define SHAPE_VER	2	// vertical bar cursor
  
! #define MSHAPE_NUMBERED	1000	// offset for shapes identified by number
! #define MSHAPE_HIDE	1	// hide mouse pointer
  
! #define SHAPE_MOUSE	1	// used for mouse pointer shape
! #define SHAPE_CURSOR	2	// used for text cursor shape
  
  typedef struct cursor_entry
  {
!     int		shape;		// one of the SHAPE_ defines
!     int		mshape;		// one of the MSHAPE defines
!     int		percentage;	// percentage of cell for bar
!     long	blinkwait;	// blinking, wait time before blinking starts
!     long	blinkon;	// blinking, on time
!     long	blinkoff;	// blinking, off time
!     int		id;		// highlight group ID
!     int		id_lm;		// highlight group ID for :lmap mode
!     char	*name;		// mode name (fixed)
!     char	used_for;	// SHAPE_MOUSE and/or SHAPE_CURSOR
  } cursorentry_T;
! #endif // CURSOR_SHAPE
  
  #ifdef FEAT_MENU
  
! // Indices into vimmenu_T->strings[] and vimmenu_T->noremap[] for each mode
  #define MENU_INDEX_INVALID	-1
  #define MENU_INDEX_NORMAL	0
  #define MENU_INDEX_VISUAL	1
***************
*** 3293,3299 ****
  #define MENU_INDEX_TIP		7
  #define MENU_MODES		8
  
! /* Menu modes */
  #define MENU_NORMAL_MODE	(1 << MENU_INDEX_NORMAL)
  #define MENU_VISUAL_MODE	(1 << MENU_INDEX_VISUAL)
  #define MENU_SELECT_MODE	(1 << MENU_INDEX_SELECT)
--- 3300,3306 ----
  #define MENU_INDEX_TIP		7
  #define MENU_MODES		8
  
! // Menu modes
  #define MENU_NORMAL_MODE	(1 << MENU_INDEX_NORMAL)
  #define MENU_VISUAL_MODE	(1 << MENU_INDEX_VISUAL)
  #define MENU_SELECT_MODE	(1 << MENU_INDEX_SELECT)
***************
*** 3303,3376 ****
  #define MENU_TERMINAL_MODE	(1 << MENU_INDEX_TERMINAL)
  #define MENU_TIP_MODE		(1 << MENU_INDEX_TIP)
  #define MENU_ALL_MODES		((1 << MENU_INDEX_TIP) - 1)
! /*note MENU_INDEX_TIP is not a 'real' mode*/
  
! /* Start a menu name with this to not include it on the main menu bar */
  #define MNU_HIDDEN_CHAR		']'
  
  struct VimMenu
  {
!     int		modes;		    /* Which modes is this menu visible for? */
!     int		enabled;	    /* for which modes the menu is enabled */
!     char_u	*name;		    /* Name of menu, possibly translated */
!     char_u	*dname;		    /* Displayed Name ("name" without '&') */
  #ifdef FEAT_MULTI_LANG
!     char_u	*en_name;	    /* "name" untranslated, NULL when "name"
! 				     * was not translated */
!     char_u	*en_dname;	    /* "dname" untranslated, NULL when "dname"
! 				     * was not translated */
! #endif
!     int		mnemonic;	    /* mnemonic key (after '&') */
!     char_u	*actext;	    /* accelerator text (after TAB) */
!     int		priority;	    /* Menu order priority */
  #ifdef FEAT_GUI
!     void	(*cb)(vimmenu_T *);	    /* Call-back routine */
  #endif
  #ifdef FEAT_TOOLBAR
!     char_u	*iconfile;	    /* name of file for icon or NULL */
!     int		iconidx;	    /* icon index (-1 if not set) */
!     int		icon_builtin;	    /* icon names is BuiltIn{nr} */
! #endif
!     char_u	*strings[MENU_MODES]; /* Mapped string for each mode */
!     int		noremap[MENU_MODES]; /* A REMAP_ flag for each mode */
!     char	silent[MENU_MODES]; /* A silent flag for each mode */
!     vimmenu_T	*children;	    /* Children of sub-menu */
!     vimmenu_T	*parent;	    /* Parent of menu */
!     vimmenu_T	*next;		    /* Next item in menu */
  #ifdef FEAT_GUI_X11
!     Widget	id;		    /* Manage this to enable item */
!     Widget	submenu_id;	    /* If this is submenu, add children here */
  #endif
  #ifdef FEAT_GUI_GTK
!     GtkWidget	*id;		    /* Manage this to enable item */
!     GtkWidget	*submenu_id;	    /* If this is submenu, add children here */
  # if defined(GTK_CHECK_VERSION) && !GTK_CHECK_VERSION(3,4,0)
      GtkWidget	*tearoff_handle;
  # endif
!     GtkWidget   *label;		    /* Used by "set wak=" code. */
  #endif
  #ifdef FEAT_GUI_MOTIF
!     int		sensitive;	    /* turn button on/off */
!     char	**xpm;		    /* pixmap data */
!     char	*xpm_fname;	    /* file with pixmap data */
  #endif
  #ifdef FEAT_GUI_ATHENA
!     Pixmap	image;		    /* Toolbar image */
  #endif
  #ifdef FEAT_BEVAL_TIP
!     BalloonEval *tip;		    /* tooltip for this menu item */
  #endif
  #ifdef FEAT_GUI_MSWIN
!     UINT	id;		    /* Id of menu item */
!     HMENU	submenu_id;	    /* If this is submenu, add children here */
!     HWND	tearoff_handle;	    /* hWnd of tearoff if created */
  #endif
  #ifdef FEAT_GUI_MAC
! /*  MenuHandle	id; */
! /*  short	index;	*/	    /* the item index within the father menu */
!     short	menu_id;	    /* the menu id to which this item belong */
!     short	submenu_id;	    /* the menu id of the children (could be
! 				       get through some tricks) */
      MenuHandle	menu_handle;
      MenuHandle	submenu_handle;
  #endif
--- 3310,3383 ----
  #define MENU_TERMINAL_MODE	(1 << MENU_INDEX_TERMINAL)
  #define MENU_TIP_MODE		(1 << MENU_INDEX_TIP)
  #define MENU_ALL_MODES		((1 << MENU_INDEX_TIP) - 1)
! // note MENU_INDEX_TIP is not a 'real' mode
  
! // Start a menu name with this to not include it on the main menu bar
  #define MNU_HIDDEN_CHAR		']'
  
  struct VimMenu
  {
!     int		modes;		    // Which modes is this menu visible for?
!     int		enabled;	    // for which modes the menu is enabled
!     char_u	*name;		    // Name of menu, possibly translated
!     char_u	*dname;		    // Displayed Name ("name" without '&')
  #ifdef FEAT_MULTI_LANG
!     char_u	*en_name;	    // "name" untranslated, NULL when "name"
! 				    // was not translated
!     char_u	*en_dname;	    // "dname" untranslated, NULL when "dname"
! 				    // was not translated
! #endif
!     int		mnemonic;	    // mnemonic key (after '&')
!     char_u	*actext;	    // accelerator text (after TAB)
!     int		priority;	    // Menu order priority
  #ifdef FEAT_GUI
!     void	(*cb)(vimmenu_T *); // Call-back function
  #endif
  #ifdef FEAT_TOOLBAR
!     char_u	*iconfile;	    // name of file for icon or NULL
!     int		iconidx;	    // icon index (-1 if not set)
!     int		icon_builtin;	    // icon names is BuiltIn{nr}
! #endif
!     char_u	*strings[MENU_MODES]; // Mapped string for each mode
!     int		noremap[MENU_MODES]; // A REMAP_ flag for each mode
!     char	silent[MENU_MODES]; // A silent flag for each mode
!     vimmenu_T	*children;	    // Children of sub-menu
!     vimmenu_T	*parent;	    // Parent of menu
!     vimmenu_T	*next;		    // Next item in menu
  #ifdef FEAT_GUI_X11
!     Widget	id;		    // Manage this to enable item
!     Widget	submenu_id;	    // If this is submenu, add children here
  #endif
  #ifdef FEAT_GUI_GTK
!     GtkWidget	*id;		    // Manage this to enable item
!     GtkWidget	*submenu_id;	    // If this is submenu, add children here
  # if defined(GTK_CHECK_VERSION) && !GTK_CHECK_VERSION(3,4,0)
      GtkWidget	*tearoff_handle;
  # endif
!     GtkWidget   *label;		    // Used by "set wak=" code.
  #endif
  #ifdef FEAT_GUI_MOTIF
!     int		sensitive;	    // turn button on/off
!     char	**xpm;		    // pixmap data
!     char	*xpm_fname;	    // file with pixmap data
  #endif
  #ifdef FEAT_GUI_ATHENA
!     Pixmap	image;		    // Toolbar image
  #endif
  #ifdef FEAT_BEVAL_TIP
!     BalloonEval *tip;		    // tooltip for this menu item
  #endif
  #ifdef FEAT_GUI_MSWIN
!     UINT	id;		    // Id of menu item
!     HMENU	submenu_id;	    // If this is submenu, add children here
!     HWND	tearoff_handle;	    // hWnd of tearoff if created
  #endif
  #ifdef FEAT_GUI_MAC
! //  MenuHandle	id;
! //  short	index;		    // the item index within the father menu
!     short	menu_id;	    // the menu id to which this item belong
!     short	submenu_id;	    // the menu id of the children (could be
! 				    // get through some tricks)
      MenuHandle	menu_handle;
      MenuHandle	submenu_handle;
  #endif
***************
*** 3380,3389 ****
  #endif
  };
  #else
! /* For generating prototypes when FEAT_MENU isn't defined. */
  typedef int vimmenu_T;
  
! #endif /* FEAT_MENU */
  
  /*
   * Struct to save values in before executing autocommands for a buffer that is
--- 3387,3396 ----
  #endif
  };
  #else
! // For generating prototypes when FEAT_MENU isn't defined.
  typedef int vimmenu_T;
  
! #endif // FEAT_MENU
  
  /*
   * Struct to save values in before executing autocommands for a buffer that is
***************
*** 3391,3403 ****
   */
  typedef struct
  {
!     buf_T	*save_curbuf;	/* saved curbuf */
!     int		use_aucmd_win;	/* using aucmd_win */
!     win_T	*save_curwin;	/* saved curwin */
!     win_T	*new_curwin;	/* new curwin */
!     win_T	*save_prevwin;	/* saved prevwin */
!     bufref_T	new_curbuf;	/* new curbuf */
!     char_u	*globaldir;	/* saved value of globaldir */
  } aco_save_T;
  
  /*
--- 3398,3410 ----
   */
  typedef struct
  {
!     buf_T	*save_curbuf;	// saved curbuf
!     int		use_aucmd_win;	// using aucmd_win
!     win_T	*save_curwin;	// saved curwin
!     win_T	*new_curwin;	// new curwin
!     win_T	*save_prevwin;	// saved prevwin
!     bufref_T	new_curbuf;	// new curbuf
!     char_u	*globaldir;	// saved value of globaldir
  } aco_save_T;
  
  /*
***************
*** 3408,3414 ****
      const char	*name;
      int		hasnum;
      long	number;
!     char_u	*string;	/* points into option string */
      int		strlen;
      int		present;
  } option_table_T;
--- 3415,3421 ----
      const char	*name;
      int		hasnum;
      long	number;
!     char_u	*string;	// points into option string
      int		strlen;
      int		present;
  } option_table_T;
***************
*** 3457,3466 ****
   */
  typedef struct
  {
!     char_u	*pum_text;	/* main menu text */
!     char_u	*pum_kind;	/* extra kind text (may be truncated) */
!     char_u	*pum_extra;	/* extra menu text (may be truncated) */
!     char_u	*pum_info;	/* extra info */
  } pumitem_T;
  
  /*
--- 3464,3473 ----
   */
  typedef struct
  {
!     char_u	*pum_text;	// main menu text
!     char_u	*pum_kind;	// extra kind text (may be truncated)
!     char_u	*pum_extra;	// extra menu text (may be truncated)
!     char_u	*pum_info;	// extra info
  } pumitem_T;
  
  /*
***************
*** 3468,3475 ****
   */
  typedef struct
  {
!     char_u	*tn_tags;	/* value of 'tags' when starting */
!     char_u	*tn_np;		/* current position in tn_tags */
      int		tn_did_filefind_init;
      int		tn_hf_idx;
      void	*tn_search_ctx;
--- 3475,3482 ----
   */
  typedef struct
  {
!     char_u	*tn_tags;	// value of 'tags' when starting
!     char_u	*tn_np;		// current position in tn_tags
      int		tn_did_filefind_init;
      int		tn_hf_idx;
      void	*tn_search_ctx;
***************
*** 3502,3580 ****
   */
  struct js_reader
  {
!     char_u	*js_buf;	/* text to be decoded */
!     char_u	*js_end;	/* NUL in js_buf */
!     int		js_used;	/* bytes used from js_buf */
      int		(*js_fill)(struct js_reader *);
! 				/* function to fill the buffer or NULL;
! 				 * return TRUE when the buffer was filled */
!     void	*js_cookie;	/* can be used by js_fill */
!     int		js_cookie_arg;	/* can be used by js_fill */
  };
  typedef struct js_reader js_read_T;
  
! /* Maximum number of commands from + or -c arguments. */
  #define MAX_ARG_CMDS 10
  
! /* values for "window_layout" */
! #define WIN_HOR	    1	    /* "-o" horizontally split windows */
! #define	WIN_VER	    2	    /* "-O" vertically split windows */
! #define	WIN_TABS    3	    /* "-p" windows on tab pages */
  
! /* Struct for various parameters passed between main() and other functions. */
  typedef struct
  {
      int		argc;
      char	**argv;
  
!     char_u	*fname;			/* first file to edit */
  
!     int		evim_mode;		/* started as "evim" */
!     char_u	*use_vimrc;		/* vimrc from -u argument */
!     int		clean;			/* --clean argument */
! 
!     int		n_commands;		     /* no. of commands from + or -c */
!     char_u	*commands[MAX_ARG_CMDS];     /* commands from + or -c arg. */
!     char_u	cmds_tofree[MAX_ARG_CMDS];   /* commands that need free() */
!     int		n_pre_commands;		     /* no. of commands from --cmd */
!     char_u	*pre_commands[MAX_ARG_CMDS]; /* commands from --cmd argument */
  
!     int		edit_type;		/* type of editing to do */
!     char_u	*tagname;		/* tag from -t argument */
  #ifdef FEAT_QUICKFIX
!     char_u	*use_ef;		/* 'errorfile' from -q argument */
  #endif
  
      int		want_full_screen;
!     int		not_a_term;		/* no warning for missing term? */
!     int		tty_fail;		/* exit if not a tty */
!     char_u	*term;			/* specified terminal name */
  #ifdef FEAT_CRYPT
!     int		ask_for_key;		/* -x argument */
  #endif
!     int		no_swap_file;		/* "-n" argument used */
  #ifdef FEAT_EVAL
      int		use_debug_break_level;
  #endif
!     int		window_count;		/* number of windows to use */
!     int		window_layout;		/* 0, WIN_HOR, WIN_VER or WIN_TABS */
  
  #ifdef FEAT_CLIENTSERVER
!     int		serverArg;		/* TRUE when argument for a server */
!     char_u	*serverName_arg;	/* cmdline arg for server name */
!     char_u	*serverStr;		/* remote server command */
!     char_u	*serverStrEnc;		/* encoding of serverStr */
!     char_u	*servername;		/* allocated name for our server */
  #endif
  #if !defined(UNIX)
  # define EXPAND_FILENAMES
!     int		literal;		/* don't expand file names */
  #endif
  #ifdef MSWIN
!     int		full_path;		/* file name argument was full path */
  #endif
  #ifdef FEAT_DIFF
!     int		diff_mode;		/* start with 'diff' set */
  #endif
  } mparm_T;
  
--- 3509,3587 ----
   */
  struct js_reader
  {
!     char_u	*js_buf;	// text to be decoded
!     char_u	*js_end;	// NUL in js_buf
!     int		js_used;	// bytes used from js_buf
      int		(*js_fill)(struct js_reader *);
! 				// function to fill the buffer or NULL;
! 				// return TRUE when the buffer was filled
!     void	*js_cookie;	// can be used by js_fill
!     int		js_cookie_arg;	// can be used by js_fill
  };
  typedef struct js_reader js_read_T;
  
! // Maximum number of commands from + or -c arguments.
  #define MAX_ARG_CMDS 10
  
! // values for "window_layout"
! #define WIN_HOR	    1	    // "-o" horizontally split windows
! #define	WIN_VER	    2	    // "-O" vertically split windows
! #define	WIN_TABS    3	    // "-p" windows on tab pages
  
! // Struct for various parameters passed between main() and other functions.
  typedef struct
  {
      int		argc;
      char	**argv;
  
!     char_u	*fname;			// first file to edit
  
!     int		evim_mode;		// started as "evim"
!     char_u	*use_vimrc;		// vimrc from -u argument
!     int		clean;			// --clean argument
! 
!     int		n_commands;		     // no. of commands from + or -c
!     char_u	*commands[MAX_ARG_CMDS];     // commands from + or -c arg.
!     char_u	cmds_tofree[MAX_ARG_CMDS];   // commands that need free()
!     int		n_pre_commands;		     // no. of commands from --cmd
!     char_u	*pre_commands[MAX_ARG_CMDS]; // commands from --cmd argument
  
!     int		edit_type;		// type of editing to do
!     char_u	*tagname;		// tag from -t argument
  #ifdef FEAT_QUICKFIX
!     char_u	*use_ef;		// 'errorfile' from -q argument
  #endif
  
      int		want_full_screen;
!     int		not_a_term;		// no warning for missing term?
!     int		tty_fail;		// exit if not a tty
!     char_u	*term;			// specified terminal name
  #ifdef FEAT_CRYPT
!     int		ask_for_key;		// -x argument
  #endif
!     int		no_swap_file;		// "-n" argument used
  #ifdef FEAT_EVAL
      int		use_debug_break_level;
  #endif
!     int		window_count;		// number of windows to use
!     int		window_layout;		// 0, WIN_HOR, WIN_VER or WIN_TABS
  
  #ifdef FEAT_CLIENTSERVER
!     int		serverArg;		// TRUE when argument for a server
!     char_u	*serverName_arg;	// cmdline arg for server name
!     char_u	*serverStr;		// remote server command
!     char_u	*serverStrEnc;		// encoding of serverStr
!     char_u	*servername;		// allocated name for our server
  #endif
  #if !defined(UNIX)
  # define EXPAND_FILENAMES
!     int		literal;		// don't expand file names
  #endif
  #ifdef MSWIN
!     int		full_path;		// file name argument was full path
  #endif
  #ifdef FEAT_DIFF
!     int		diff_mode;		// start with 'diff' set
  #endif
  } mparm_T;
  
***************
*** 3607,3631 ****
   */
  typedef struct lval_S
  {
!     char_u	*ll_name;	/* start of variable name (can be NULL) */
!     char_u	*ll_exp_name;	/* NULL or expanded name in allocated memory. */
!     typval_T	*ll_tv;		/* Typeval of item being used.  If "newkey"
! 				   isn't NULL it's the Dict to which to add
! 				   the item. */
!     listitem_T	*ll_li;		/* The list item or NULL. */
!     list_T	*ll_list;	/* The list or NULL. */
!     int		ll_range;	/* TRUE when a [i:j] range was used */
!     long	ll_n1;		/* First index for list */
!     long	ll_n2;		/* Second index for list range */
!     int		ll_empty2;	/* Second index is empty: [i:] */
!     dict_T	*ll_dict;	/* The Dictionary or NULL */
!     dictitem_T	*ll_di;		/* The dictitem or NULL */
!     char_u	*ll_newkey;	/* New key for Dict in alloc. mem or NULL. */
!     blob_T	*ll_blob;	/* The Blob or NULL */
  } lval_T;
  
! /* Structure used to save the current state.  Used when executing Normal mode
!  * commands while in any other mode. */
  typedef struct {
      int		save_msg_scroll;
      int		save_restart_edit;
--- 3614,3638 ----
   */
  typedef struct lval_S
  {
!     char_u	*ll_name;	// start of variable name (can be NULL)
!     char_u	*ll_exp_name;	// NULL or expanded name in allocated memory.
!     typval_T	*ll_tv;		// Typeval of item being used.  If "newkey"
! 				// isn't NULL it's the Dict to which to add
! 				// the item.
!     listitem_T	*ll_li;		// The list item or NULL.
!     list_T	*ll_list;	// The list or NULL.
!     int		ll_range;	// TRUE when a [i:j] range was used
!     long	ll_n1;		// First index for list
!     long	ll_n2;		// Second index for list range
!     int		ll_empty2;	// Second index is empty: [i:]
!     dict_T	*ll_dict;	// The Dictionary or NULL
!     dictitem_T	*ll_di;		// The dictitem or NULL
!     char_u	*ll_newkey;	// New key for Dict in alloc. mem or NULL.
!     blob_T	*ll_blob;	// The Blob or NULL
  } lval_T;
  
! // Structure used to save the current state.  Used when executing Normal mode
! // commands while in any other mode.
  typedef struct {
      int		save_msg_scroll;
      int		save_restart_edit;
*** ../vim-8.1.1626/src/version.c	2019-07-04 15:39:23.823385977 +0200
--- src/version.c	2019-07-04 15:42:01.178314492 +0200
***************
*** 779,780 ****
--- 779,782 ----
  {   /* Add new patch number below this line */
+ /**/
+     1627,
  /**/

-- 
Not too long ago, a keyboard was something to make music with...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
