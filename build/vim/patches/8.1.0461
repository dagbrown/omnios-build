To: vim_dev@googlegroups.com
Subject: Patch 8.1.0461
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.1.0461
Problem:    Quickfix code uses too many /* */ comments.
Solution:   Change to // comments. (Yegappan Lakshmanan)
Files:	    src/quickfix.c


*** ../vim-8.1.0460/src/quickfix.c	2018-10-07 14:38:43.714247899 +0200
--- src/quickfix.c	2018-10-07 20:20:56.652633675 +0200
***************
*** 27,46 ****
  typedef struct qfline_S qfline_T;
  struct qfline_S
  {
!     qfline_T	*qf_next;	/* pointer to next error in the list */
!     qfline_T	*qf_prev;	/* pointer to previous error in the list */
!     linenr_T	qf_lnum;	/* line number where the error occurred */
!     int		qf_fnum;	/* file number for the line */
!     int		qf_col;		/* column where the error occurred */
!     int		qf_nr;		/* error number */
!     char_u	*qf_module;	/* module name for this error */
!     char_u	*qf_pattern;	/* search pattern for the error */
!     char_u	*qf_text;	/* description of the error */
!     char_u	qf_viscol;	/* set to TRUE if qf_col is screen column */
!     char_u	qf_cleared;	/* set to TRUE if line has been deleted */
!     char_u	qf_type;	/* type of the error (mostly 'E'); 1 for
! 				   :helpgrep */
!     char_u	qf_valid;	/* valid error message detected */
  };
  
  /*
--- 27,46 ----
  typedef struct qfline_S qfline_T;
  struct qfline_S
  {
!     qfline_T	*qf_next;	// pointer to next error in the list
!     qfline_T	*qf_prev;	// pointer to previous error in the list
!     linenr_T	qf_lnum;	// line number where the error occurred
!     int		qf_fnum;	// file number for the line
!     int		qf_col;		// column where the error occurred
!     int		qf_nr;		// error number
!     char_u	*qf_module;	// module name for this error
!     char_u	*qf_pattern;	// search pattern for the error
!     char_u	*qf_text;	// description of the error
!     char_u	qf_viscol;	// set to TRUE if qf_col is screen column
!     char_u	qf_cleared;	// set to TRUE if line has been deleted
!     char_u	qf_type;	// type of the error (mostly 'E'); 1 for
! 				// :helpgrep
!     char_u	qf_valid;	// valid error message detected
  };
  
  /*
***************
*** 60,75 ****
   */
  typedef struct qf_list_S
  {
!     int_u	qf_id;		/* Unique identifier for this list */
!     qfline_T	*qf_start;	/* pointer to the first error */
!     qfline_T	*qf_last;	/* pointer to the last error */
!     qfline_T	*qf_ptr;	/* pointer to the current error */
!     int		qf_count;	/* number of errors (0 means empty list) */
!     int		qf_index;	/* current index in the error list */
!     int		qf_nonevalid;	/* TRUE if not a single valid entry found */
!     char_u	*qf_title;	/* title derived from the command that created
! 				 * the error list or set by setqflist */
!     typval_T	*qf_ctx;	/* context set by setqflist/setloclist */
  
      struct dir_stack_T	*qf_dir_stack;
      char_u		*qf_directory;
--- 60,75 ----
   */
  typedef struct qf_list_S
  {
!     int_u	qf_id;		// Unique identifier for this list
!     qfline_T	*qf_start;	// pointer to the first error
!     qfline_T	*qf_last;	// pointer to the last error
!     qfline_T	*qf_ptr;	// pointer to the current error
!     int		qf_count;	// number of errors (0 means empty list)
!     int		qf_index;	// current index in the error list
!     int		qf_nonevalid;	// TRUE if not a single valid entry found
!     char_u	*qf_title;	// title derived from the command that created
! 				// the error list or set by setqflist
!     typval_T	*qf_ctx;	// context set by setqflist/setloclist
  
      struct dir_stack_T	*qf_dir_stack;
      char_u		*qf_directory;
***************
*** 87,108 ****
   */
  struct qf_info_S
  {
!     /*
!      * Count of references to this list. Used only for location lists.
!      * When a location list window reference this list, qf_refcount
!      * will be 2. Otherwise, qf_refcount will be 1. When qf_refcount
!      * reaches 0, the list is freed.
!      */
      int		qf_refcount;
!     int		qf_listcount;	    /* current number of lists */
!     int		qf_curlist;	    /* current error list */
      qf_list_T	qf_lists[LISTCOUNT];
  };
  
! static qf_info_T ql_info;	/* global quickfix list */
! static int_u last_qf_id = 0;	/* Last used quickfix list id */
  
! #define FMT_PATTERNS 11		/* maximum number of % recognized */
  
  /*
   * Structure used to hold the info of one part of 'errorformat'
--- 87,106 ----
   */
  struct qf_info_S
  {
!     // Count of references to this list. Used only for location lists.
!     // When a location list window reference this list, qf_refcount
!     // will be 2. Otherwise, qf_refcount will be 1. When qf_refcount
!     // reaches 0, the list is freed.
      int		qf_refcount;
!     int		qf_listcount;	    // current number of lists
!     int		qf_curlist;	    // current error list
      qf_list_T	qf_lists[LISTCOUNT];
  };
  
! static qf_info_T ql_info;	// global quickfix list
! static int_u last_qf_id = 0;	// Last used quickfix list id
  
! #define FMT_PATTERNS 11		// maximum number of % recognized
  
  /*
   * Structure used to hold the info of one part of 'errorformat'
***************
*** 110,138 ****
  typedef struct efm_S efm_T;
  struct efm_S
  {
!     regprog_T	    *prog;	/* pre-formatted part of 'errorformat' */
!     efm_T	    *next;	/* pointer to next (NULL if last) */
!     char_u	    addr[FMT_PATTERNS]; /* indices of used % patterns */
!     char_u	    prefix;	/* prefix of this format line: */
! 				/*   'D' enter directory */
! 				/*   'X' leave directory */
! 				/*   'A' start of multi-line message */
! 				/*   'E' error message */
! 				/*   'W' warning message */
! 				/*   'I' informational message */
! 				/*   'C' continuation line */
! 				/*   'Z' end of multi-line message */
! 				/*   'G' general, unspecific message */
! 				/*   'P' push file (partial) message */
! 				/*   'Q' pop/quit file (partial) message */
! 				/*   'O' overread (partial) message */
!     char_u	    flags;	/* additional flags given in prefix */
! 				/*   '-' do not include this line */
! 				/*   '+' include whole line in message */
!     int		    conthere;	/* %> used */
  };
  
! static efm_T	*fmt_start = NULL; /* cached across qf_parse_line() calls */
  
  static void	qf_new_list(qf_info_T *qi, char_u *qf_title);
  static int	qf_add_entry(qf_info_T *qi, int qf_idx, char_u *dir, char_u *fname, char_u *module, int bufnum, char_u *mesg, long lnum, int col, int vis_col, char_u *pattern, int nr, int type, int valid);
--- 108,136 ----
  typedef struct efm_S efm_T;
  struct efm_S
  {
!     regprog_T	    *prog;	// pre-formatted part of 'errorformat'
!     efm_T	    *next;	// pointer to next (NULL if last)
!     char_u	    addr[FMT_PATTERNS]; // indices of used % patterns
!     char_u	    prefix;	// prefix of this format line:
! 				//   'D' enter directory
! 				//   'X' leave directory
! 				//   'A' start of multi-line message
! 				//   'E' error message
! 				//   'W' warning message
! 				//   'I' informational message
! 				//   'C' continuation line
! 				//   'Z' end of multi-line message
! 				//   'G' general, unspecific message
! 				//   'P' push file (partial) message
! 				//   'Q' pop/quit file (partial) message
! 				//   'O' overread (partial) message
!     char_u	    flags;	// additional flags given in prefix
! 				//   '-' do not include this line
! 				//   '+' include whole line in message
!     int		    conthere;	// %> used
  };
  
! static efm_T	*fmt_start = NULL; // cached across qf_parse_line() calls
  
  static void	qf_new_list(qf_info_T *qi, char_u *qf_title);
  static int	qf_add_entry(qf_info_T *qi, int qf_idx, char_u *dir, char_u *fname, char_u *module, int bufnum, char_u *mesg, long lnum, int col, int vis_col, char_u *pattern, int nr, int type, int valid);
***************
*** 153,161 ****
  static void	unload_dummy_buffer(buf_T *buf, char_u *dirname_start);
  static qf_info_T *ll_get_or_alloc_list(win_T *);
  
! /* Quickfix window check helper macro */
  #define IS_QF_WINDOW(wp) (bt_quickfix(wp->w_buffer) && wp->w_llist_ref == NULL)
! /* Location list window check helper macro */
  #define IS_LL_WINDOW(wp) (bt_quickfix(wp->w_buffer) && wp->w_llist_ref != NULL)
  
  // Quickfix and location list stack check helper macros
--- 151,159 ----
  static void	unload_dummy_buffer(buf_T *buf, char_u *dirname_start);
  static qf_info_T *ll_get_or_alloc_list(win_T *);
  
! // Quickfix window check helper macro
  #define IS_QF_WINDOW(wp) (bt_quickfix(wp->w_buffer) && wp->w_llist_ref == NULL)
! // Location list window check helper macro
  #define IS_LL_WINDOW(wp) (bt_quickfix(wp->w_buffer) && wp->w_llist_ref != NULL)
  
  // Quickfix and location list stack check helper macros
***************
*** 189,195 ****
      char	*pattern;
  } fmt_pat[FMT_PATTERNS] =
      {
! 	{'f', ".\\+"},	    /* only used when at end */
  	{'n', "\\d\\+"},
  	{'l', "\\d\\+"},
  	{'c', "\\d\\+"},
--- 187,193 ----
      char	*pattern;
  } fmt_pat[FMT_PATTERNS] =
      {
! 	{'f', ".\\+"},	    // only used when at end
  	{'n', "\\d\\+"},
  	{'l', "\\d\\+"},
  	{'c', "\\d\\+"},
***************
*** 221,227 ****
  
      if (efminfo->addr[idx])
      {
! 	/* Each errorformat pattern can occur only once */
  	sprintf((char *)errmsg,
  		_("E372: Too many %%%c in format string"), *efmpat);
  	EMSG(errmsg);
--- 219,225 ----
  
      if (efminfo->addr[idx])
      {
! 	// Each errorformat pattern can occur only once
  	sprintf((char *)errmsg,
  		_("E372: Too many %%%c in format string"), *efmpat);
  	EMSG(errmsg);
***************
*** 243,251 ****
  #ifdef BACKSLASH_IN_FILENAME
      if (*efmpat == 'f')
      {
! 	/* Also match "c:" in the file name, even when
! 	 * checking for a colon next: "%f:".
! 	 * "\%(\a:\)\=" */
  	STRCPY(regpat, "\\%(\\a:\\)\\=");
  	regpat += 10;
      }
--- 241,249 ----
  #ifdef BACKSLASH_IN_FILENAME
      if (*efmpat == 'f')
      {
! 	// Also match "c:" in the file name, even when
! 	// checking for a colon next: "%f:".
! 	// "\%(\a:\)\="
  	STRCPY(regpat, "\\%(\\a:\\)\\=");
  	regpat += 10;
      }
***************
*** 254,271 ****
      {
  	if (efmpat[1] != '\\' && efmpat[1] != '%')
  	{
! 	    /* A file name may contain spaces, but this isn't
! 	     * in "\f".  For "%f:%l:%m" there may be a ":" in
! 	     * the file name.  Use ".\{-1,}x" instead (x is
! 	     * the next character), the requirement that :999:
! 	     * follows should work. */
  	    STRCPY(regpat, ".\\{-1,}");
  	    regpat += 7;
  	}
  	else
  	{
! 	    /* File name followed by '\\' or '%': include as
! 	     * many file name chars as possible. */
  	    STRCPY(regpat, "\\f\\+");
  	    regpat += 4;
  	}
--- 252,269 ----
      {
  	if (efmpat[1] != '\\' && efmpat[1] != '%')
  	{
! 	    // A file name may contain spaces, but this isn't
! 	    // in "\f".  For "%f:%l:%m" there may be a ":" in
! 	    // the file name.  Use ".\{-1,}x" instead (x is
! 	    // the next character), the requirement that :999:
! 	    // follows should work.
  	    STRCPY(regpat, ".\\{-1,}");
  	    regpat += 7;
  	}
  	else
  	{
! 	    // File name followed by '\\' or '%': include as
! 	    // many file name chars as possible.
  	    STRCPY(regpat, "\\f\\+");
  	    regpat += 4;
  	}
***************
*** 298,313 ****
  
      if (*efmp == '[' || *efmp == '\\')
      {
! 	if ((*regpat++ = *efmp) == '[')	/* %*[^a-z0-9] etc. */
  	{
  	    if (efmp[1] == '^')
  		*regpat++ = *++efmp;
  	    if (efmp < efm + len)
  	    {
! 		*regpat++ = *++efmp;	    /* could be ']' */
  		while (efmp < efm + len
  			&& (*regpat++ = *++efmp) != ']')
! 		    /* skip */;
  		if (efmp == efm + len)
  		{
  		    EMSG(_("E374: Missing ] in format string"));
--- 296,311 ----
  
      if (*efmp == '[' || *efmp == '\\')
      {
! 	if ((*regpat++ = *efmp) == '[')	// %*[^a-z0-9] etc.
  	{
  	    if (efmp[1] == '^')
  		*regpat++ = *++efmp;
  	    if (efmp < efm + len)
  	    {
! 		*regpat++ = *++efmp;	    // could be ']'
  		while (efmp < efm + len
  			&& (*regpat++ = *++efmp) != ']')
! 		    // skip ;
  		if (efmp == efm + len)
  		{
  		    EMSG(_("E374: Missing ] in format string"));
***************
*** 315,328 ****
  		}
  	    }
  	}
! 	else if (efmp < efm + len)	/* %*\D, %*\s etc. */
  	    *regpat++ = *++efmp;
  	*regpat++ = '\\';
  	*regpat++ = '+';
      }
      else
      {
! 	/* TODO: scanf()-like: %*ud, %*3c, %*f, ... ? */
  	sprintf((char *)errmsg,
  		_("E375: Unsupported %%%c in format string"), *efmp);
  	EMSG(errmsg);
--- 313,326 ----
  		}
  	    }
  	}
! 	else if (efmp < efm + len)	// %*\D, %*\s etc.
  	    *regpat++ = *++efmp;
  	*regpat++ = '\\';
  	*regpat++ = '+';
      }
      else
      {
! 	// TODO: scanf()-like: %*ud, %*3c, %*f, ... ?
  	sprintf((char *)errmsg,
  		_("E375: Unsupported %%%c in format string"), *efmp);
  	EMSG(errmsg);
***************
*** 374,382 ****
      int		round;
      int		idx = 0;
  
!     /*
!      * Build a regexp pattern for a 'errorformat' option part
!      */
      ptr = regpat;
      *ptr++ = '^';
      round = 0;
--- 372,378 ----
      int		round;
      int		idx = 0;
  
!     // Build a regexp pattern for a 'errorformat' option part
      ptr = regpat;
      *ptr++ = '^';
      round = 0;
***************
*** 404,420 ****
  		    return FAIL;
  	    }
  	    else if (vim_strchr((char_u *)"%\\.^$~[", *efmp) != NULL)
! 		*ptr++ = *efmp;		/* regexp magic characters */
  	    else if (*efmp == '#')
  		*ptr++ = '*';
  	    else if (*efmp == '>')
  		fmt_ptr->conthere = TRUE;
! 	    else if (efmp == efm + 1)		/* analyse prefix */
  	    {
! 		/*
! 		 * prefix is allowed only at the beginning of the errorformat
! 		 * option part
! 		 */
  		efmp = efm_analyze_prefix(efmp, fmt_ptr, errmsg);
  		if (efmp == NULL)
  		    return FAIL;
--- 400,414 ----
  		    return FAIL;
  	    }
  	    else if (vim_strchr((char_u *)"%\\.^$~[", *efmp) != NULL)
! 		*ptr++ = *efmp;		// regexp magic characters
  	    else if (*efmp == '#')
  		*ptr++ = '*';
  	    else if (*efmp == '>')
  		fmt_ptr->conthere = TRUE;
! 	    else if (efmp == efm + 1)		// analyse prefix
  	    {
! 		// prefix is allowed only at the beginning of the errorformat
! 		// option part
  		efmp = efm_analyze_prefix(efmp, fmt_ptr, errmsg);
  		if (efmp == NULL)
  		    return FAIL;
***************
*** 427,438 ****
  		return FAIL;
  	    }
  	}
! 	else			/* copy normal character */
  	{
  	    if (*efmp == '\\' && efmp + 1 < efm + len)
  		++efmp;
  	    else if (vim_strchr((char_u *)".*^$~[", *efmp) != NULL)
! 		*ptr++ = '\\';	/* escape regexp atoms */
  	    if (*efmp)
  		*ptr++ = *efmp;
  	}
--- 421,432 ----
  		return FAIL;
  	    }
  	}
! 	else			// copy normal character
  	{
  	    if (*efmp == '\\' && efmp + 1 < efm + len)
  		++efmp;
  	    else if (vim_strchr((char_u *)".*^$~[", *efmp) != NULL)
! 		*ptr++ = '\\';	// escape regexp atoms
  	    if (*efmp)
  		*ptr++ = *efmp;
  	}
***************
*** 474,482 ****
      for (i = FMT_PATTERNS; i > 0; )
  	sz += (int)STRLEN(fmt_pat[--i].pattern);
  #ifdef BACKSLASH_IN_FILENAME
!     sz += 12; /* "%f" can become twelve chars longer (see efm_to_regpat) */
  #else
!     sz += 2; /* "%f" can become two chars longer */
  #endif
  
      return sz;
--- 468,476 ----
      for (i = FMT_PATTERNS; i > 0; )
  	sz += (int)STRLEN(fmt_pat[--i].pattern);
  #ifdef BACKSLASH_IN_FILENAME
!     sz += 12; // "%f" can become twelve chars longer (see efm_to_regpat)
  #else
!     sz += 2; // "%f" can become two chars longer
  #endif
  
      return sz;
***************
*** 519,566 ****
      if (errmsg == NULL)
  	goto parse_efm_end;
  
!     /*
!      * Each part of the format string is copied and modified from errorformat
!      * to regex prog.  Only a few % characters are allowed.
!      */
! 
!     /*
!      * Get some space to modify the format string into.
!      */
      sz = efm_regpat_bufsz(efm);
      if ((fmtstr = alloc(sz)) == NULL)
  	goto parse_efm_error;
  
      while (efm[0] != NUL)
      {
! 	/*
! 	 * Allocate a new eformat structure and put it at the end of the list
! 	 */
  	fmt_ptr = (efm_T *)alloc_clear((unsigned)sizeof(efm_T));
  	if (fmt_ptr == NULL)
  	    goto parse_efm_error;
! 	if (fmt_first == NULL)	    /* first one */
  	    fmt_first = fmt_ptr;
  	else
  	    fmt_last->next = fmt_ptr;
  	fmt_last = fmt_ptr;
  
! 	/*
! 	 * Isolate one part in the 'errorformat' option
! 	 */
  	len = efm_option_part_len(efm);
  
  	if (efm_to_regpat(efm, len, fmt_ptr, fmtstr, errmsg) == FAIL)
  	    goto parse_efm_error;
  	if ((fmt_ptr->prog = vim_regcomp(fmtstr, RE_MAGIC + RE_STRING)) == NULL)
  	    goto parse_efm_error;
! 	/*
! 	 * Advance to next part
! 	 */
! 	efm = skip_to_option_part(efm + len);	/* skip comma and spaces */
      }
  
!     if (fmt_first == NULL)	/* nothing found */
  	EMSG(_("E378: 'errorformat' contains no pattern"));
  
      goto parse_efm_end;
--- 513,550 ----
      if (errmsg == NULL)
  	goto parse_efm_end;
  
!     // Each part of the format string is copied and modified from errorformat
!     // to regex prog.  Only a few % characters are allowed.
! 
!     // Get some space to modify the format string into.
      sz = efm_regpat_bufsz(efm);
      if ((fmtstr = alloc(sz)) == NULL)
  	goto parse_efm_error;
  
      while (efm[0] != NUL)
      {
! 	// Allocate a new eformat structure and put it at the end of the list
  	fmt_ptr = (efm_T *)alloc_clear((unsigned)sizeof(efm_T));
  	if (fmt_ptr == NULL)
  	    goto parse_efm_error;
! 	if (fmt_first == NULL)	    // first one
  	    fmt_first = fmt_ptr;
  	else
  	    fmt_last->next = fmt_ptr;
  	fmt_last = fmt_ptr;
  
! 	// Isolate one part in the 'errorformat' option
  	len = efm_option_part_len(efm);
  
  	if (efm_to_regpat(efm, len, fmt_ptr, fmtstr, errmsg) == FAIL)
  	    goto parse_efm_error;
  	if ((fmt_ptr->prog = vim_regcomp(fmtstr, RE_MAGIC + RE_STRING)) == NULL)
  	    goto parse_efm_error;
! 	// Advance to next part
! 	efm = skip_to_option_part(efm + len);	// skip comma and spaces
      }
  
!     if (fmt_first == NULL)	// nothing found
  	EMSG(_("E378: 'errorformat' contains no pattern"));
  
      goto parse_efm_end;
***************
*** 611,620 ****
  {
      char_u	*p;
  
!     /*
!      * If the line exceeds LINE_MAXLEN exclude the last
!      * byte since it's not a NL character.
!      */
      state->linelen = newsz > LINE_MAXLEN ? LINE_MAXLEN - 1 : newsz;
      if (state->growbuf == NULL)
      {
--- 595,602 ----
  {
      char_u	*p;
  
!     // If the line exceeds LINE_MAXLEN exclude the last
!     // byte since it's not a NL character.
      state->linelen = newsz > LINE_MAXLEN ? LINE_MAXLEN - 1 : newsz;
      if (state->growbuf == NULL)
      {
***************
*** 639,650 ****
      static int
  qf_get_next_str_line(qfstate_T *state)
  {
!     /* Get the next line from the supplied string */
      char_u	*p_str = state->p_str;
      char_u	*p;
      int		len;
  
!     if (*p_str == NUL) /* Reached the end of the string */
  	return QF_END_OF_INPUT;
  
      p = vim_strchr(p_str, '\n');
--- 621,632 ----
      static int
  qf_get_next_str_line(qfstate_T *state)
  {
!     // Get the next line from the supplied string
      char_u	*p_str = state->p_str;
      char_u	*p;
      int		len;
  
!     if (*p_str == NUL) // Reached the end of the string
  	return QF_END_OF_INPUT;
  
      p = vim_strchr(p_str, '\n');
***************
*** 666,675 ****
      }
      vim_strncpy(state->linebuf, p_str, state->linelen);
  
!     /*
!      * Increment using len in order to discard the rest of the
!      * line if it exceeds LINE_MAXLEN.
!      */
      p_str += len;
      state->p_str = p_str;
  
--- 648,655 ----
      }
      vim_strncpy(state->linebuf, p_str, state->linelen);
  
!     // Increment using len in order to discard the rest of the
!     // line if it exceeds LINE_MAXLEN.
      p_str += len;
      state->p_str = p_str;
  
***************
*** 688,696 ****
      while (p_li != NULL
  	    && (p_li->li_tv.v_type != VAR_STRING
  		|| p_li->li_tv.vval.v_string == NULL))
! 	p_li = p_li->li_next;	/* Skip non-string items */
  
!     if (p_li == NULL)		/* End of the list */
      {
  	state->p_li = NULL;
  	return QF_END_OF_INPUT;
--- 668,676 ----
      while (p_li != NULL
  	    && (p_li->li_tv.v_type != VAR_STRING
  		|| p_li->li_tv.vval.v_string == NULL))
! 	p_li = p_li->li_next;	// Skip non-string items
  
!     if (p_li == NULL)		// End of the list
      {
  	state->p_li = NULL;
  	return QF_END_OF_INPUT;
***************
*** 711,717 ****
  
      vim_strncpy(state->linebuf, p_li->li_tv.vval.v_string, state->linelen);
  
!     state->p_li = p_li->li_next;	/* next item */
      return QF_OK;
  }
  
--- 691,697 ----
  
      vim_strncpy(state->linebuf, p_li->li_tv.vval.v_string, state->linelen);
  
!     state->p_li = p_li->li_next;	// next item
      return QF_OK;
  }
  
***************
*** 724,730 ****
      char_u	*p_buf = NULL;
      int		len;
  
!     /* Get the next line from the supplied buffer */
      if (state->buflnum > state->lnumlast)
  	return QF_END_OF_INPUT;
  
--- 704,710 ----
      char_u	*p_buf = NULL;
      int		len;
  
!     // Get the next line from the supplied buffer
      if (state->buflnum > state->lnumlast)
  	return QF_END_OF_INPUT;
  
***************
*** 764,773 ****
      state->linelen = (int)STRLEN(IObuff);
      if (state->linelen == IOSIZE - 1 && !(IObuff[state->linelen - 1] == '\n'))
      {
! 	/*
! 	 * The current line exceeds IObuff, continue reading using
! 	 * growbuf until EOL or LINE_MAXLEN bytes is read.
! 	 */
  	if (state->growbuf == NULL)
  	{
  	    state->growbufsiz = 2 * (IOSIZE - 1);
--- 744,751 ----
      state->linelen = (int)STRLEN(IObuff);
      if (state->linelen == IOSIZE - 1 && !(IObuff[state->linelen - 1] == '\n'))
      {
! 	// The current line exceeds IObuff, continue reading using
! 	// growbuf until EOL or LINE_MAXLEN bytes is read.
  	if (state->growbuf == NULL)
  	{
  	    state->growbufsiz = 2 * (IOSIZE - 1);
***************
*** 776,782 ****
  		return QF_NOMEM;
  	}
  
! 	/* Copy the read part of the line, excluding null-terminator */
  	memcpy(state->growbuf, IObuff, IOSIZE - 1);
  	growbuflen = state->linelen;
  
--- 754,760 ----
  		return QF_NOMEM;
  	}
  
! 	// Copy the read part of the line, excluding null-terminator
  	memcpy(state->growbuf, IObuff, IOSIZE - 1);
  	growbuflen = state->linelen;
  
***************
*** 806,816 ****
  
  	while (discard)
  	{
! 	    /*
! 	     * The current line is longer than LINE_MAXLEN, continue
! 	     * reading but discard everything until EOL or EOF is
! 	     * reached.
! 	     */
  	    if (fgets((char *)IObuff, IOSIZE, state->fd) == NULL
  		    || (int)STRLEN(IObuff) < IOSIZE - 1
  		    || IObuff[IOSIZE - 1] == '\n')
--- 784,792 ----
  
  	while (discard)
  	{
! 	    // The current line is longer than LINE_MAXLEN, continue
! 	    // reading but discard everything until EOL or EOF is
! 	    // reached.
  	    if (fgets((char *)IObuff, IOSIZE, state->fd) == NULL
  		    || (int)STRLEN(IObuff) < IOSIZE - 1
  		    || IObuff[IOSIZE - 1] == '\n')
***************
*** 824,830 ****
  	state->linebuf = IObuff;
  
  #ifdef FEAT_MBYTE
!     /* Convert a line if it contains a non-ASCII character. */
      if (state->vc.vc_type != CONV_NONE && has_non_ascii(state->linebuf))
      {
  	char_u	*line;
--- 800,806 ----
  	state->linebuf = IObuff;
  
  #ifdef FEAT_MBYTE
!     // Convert a line if it contains a non-ASCII character.
      if (state->vc.vc_type != CONV_NONE && has_non_ascii(state->linebuf))
      {
  	char_u	*line;
***************
*** 864,887 ****
  	if (state->tv != NULL)
  	{
  	    if (state->tv->v_type == VAR_STRING)
! 		/* Get the next line from the supplied string */
  		status = qf_get_next_str_line(state);
  	    else if (state->tv->v_type == VAR_LIST)
! 		/* Get the next line from the supplied list */
  		status = qf_get_next_list_line(state);
  	}
  	else
! 	    /* Get the next line from the supplied buffer */
  	    status = qf_get_next_buf_line(state);
      }
      else
! 	/* Get the next line from the supplied file */
  	status = qf_get_next_file_line(state);
  
      if (status != QF_OK)
  	return status;
  
!     /* remove newline/CR from the line */
      if (state->linelen > 0 && state->linebuf[state->linelen - 1] == '\n')
      {
  	state->linebuf[state->linelen - 1] = NUL;
--- 840,863 ----
  	if (state->tv != NULL)
  	{
  	    if (state->tv->v_type == VAR_STRING)
! 		// Get the next line from the supplied string
  		status = qf_get_next_str_line(state);
  	    else if (state->tv->v_type == VAR_LIST)
! 		// Get the next line from the supplied list
  		status = qf_get_next_list_line(state);
  	}
  	else
! 	    // Get the next line from the supplied buffer
  	    status = qf_get_next_buf_line(state);
      }
      else
! 	// Get the next line from the supplied file
  	status = qf_get_next_file_line(state);
  
      if (status != QF_OK)
  	return status;
  
!     // remove newline/CR from the line
      if (state->linelen > 0 && state->linebuf[state->linelen - 1] == '\n')
      {
  	state->linebuf[state->linelen - 1] = NUL;
***************
*** 924,939 ****
      if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)
  	return QF_FAIL;
  
!     /* Expand ~/file and $HOME/file to full path. */
      c = *rmp->endp[midx];
      *rmp->endp[midx] = NUL;
      expand_env(rmp->startp[midx], fields->namebuf, CMDBUFFSIZE);
      *rmp->endp[midx] = c;
  
!     /*
!      * For separate filename patterns (%O, %P and %Q), the specified file
!      * should exist.
!      */
      if (vim_strchr((char_u *)"OPQ", prefix) != NULL
  	    && mch_getperm(fields->namebuf) == -1)
  	return QF_FAIL;
--- 900,913 ----
      if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)
  	return QF_FAIL;
  
!     // Expand ~/file and $HOME/file to full path.
      c = *rmp->endp[midx];
      *rmp->endp[midx] = NUL;
      expand_env(rmp->startp[midx], fields->namebuf, CMDBUFFSIZE);
      *rmp->endp[midx] = c;
  
!     // For separate filename patterns (%O, %P and %Q), the specified file
!     // should exist.
      if (vim_strchr((char_u *)"OPQ", prefix) != NULL
  	    && mch_getperm(fields->namebuf) == -1)
  	return QF_FAIL;
***************
*** 1004,1010 ****
  
      if (linelen >= fields->errmsglen)
      {
! 	/* linelen + null terminator */
  	if ((p = vim_realloc(fields->errmsg, linelen + 1)) == NULL)
  	    return QF_NOMEM;
  	fields->errmsg = p;
--- 978,984 ----
  
      if (linelen >= fields->errmsglen)
      {
! 	// linelen + null terminator
  	if ((p = vim_realloc(fields->errmsg, linelen + 1)) == NULL)
  	    return QF_NOMEM;
  	fields->errmsg = p;
***************
*** 1029,1035 ****
      len = (int)(rmp->endp[midx] - rmp->startp[midx]);
      if (len >= fields->errmsglen)
      {
! 	/* len + null terminator */
  	if ((p = vim_realloc(fields->errmsg, len + 1)) == NULL)
  	    return QF_NOMEM;
  	fields->errmsg = p;
--- 1003,1009 ----
      len = (int)(rmp->endp[midx] - rmp->startp[midx]);
      if (len >= fields->errmsglen)
      {
! 	// len + null terminator
  	if ((p = vim_realloc(fields->errmsg, len + 1)) == NULL)
  	    return QF_NOMEM;
  	fields->errmsg = p;
***************
*** 1181,1207 ****
  	fields->type = idx;
      else
  	fields->type = 0;
!     /*
!      * Extract error message data from matched line.
!      * We check for an actual submatch, because "\[" and "\]" in
!      * the 'errorformat' may cause the wrong submatch to be used.
!      */
      for (i = 0; i < FMT_PATTERNS; i++)
      {
  	status = QF_OK;
  	midx = (int)fmt_ptr->addr[i];
! 	if (i == 0 && midx > 0)				/* %f */
  	    status = qf_parse_fmt_f(regmatch, midx, fields, idx);
  	else if (i == 5)
  	{
! 	    if (fmt_ptr->flags == '+' && !qf_multiscan)	/* %+ */
  		status = qf_parse_fmt_plus(linebuf, linelen, fields);
! 	    else if (midx > 0)				/* %m */
  		status = qf_parse_fmt_m(regmatch, midx, fields);
  	}
! 	else if (i == 6 && midx > 0)			/* %r */
  	    status = qf_parse_fmt_r(regmatch, midx, tail);
! 	else if (midx > 0)				/* others */
  	    status = (qf_parse_fmt[i])(regmatch, midx, fields);
  
  	if (status != QF_OK)
--- 1155,1180 ----
  	fields->type = idx;
      else
  	fields->type = 0;
! 
!     // Extract error message data from matched line.
!     // We check for an actual submatch, because "\[" and "\]" in
!     // the 'errorformat' may cause the wrong submatch to be used.
      for (i = 0; i < FMT_PATTERNS; i++)
      {
  	status = QF_OK;
  	midx = (int)fmt_ptr->addr[i];
! 	if (i == 0 && midx > 0)				// %f
  	    status = qf_parse_fmt_f(regmatch, midx, fields, idx);
  	else if (i == 5)
  	{
! 	    if (fmt_ptr->flags == '+' && !qf_multiscan)	// %+
  		status = qf_parse_fmt_plus(linebuf, linelen, fields);
! 	    else if (midx > 0)				// %m
  		status = qf_parse_fmt_m(regmatch, midx, fields);
  	}
! 	else if (i == 6 && midx > 0)			// %r
  	    status = qf_parse_fmt_r(regmatch, midx, tail);
! 	else if (midx > 0)				// others
  	    status = (qf_parse_fmt[i])(regmatch, midx, fields);
  
  	if (status != QF_OK)
***************
*** 1247,1253 ****
      fields->type = 0;
      *tail = NULL;
  
!     /* Always ignore case when looking for a matching error. */
      regmatch.rm_ic = TRUE;
      regmatch.regprog = fmt_ptr->prog;
      r = vim_regexec(&regmatch, linebuf, (colnr_T)0);
--- 1220,1226 ----
      fields->type = 0;
      *tail = NULL;
  
!     // Always ignore case when looking for a matching error.
      regmatch.rm_ic = TRUE;
      regmatch.regprog = fmt_ptr->prog;
      r = vim_regexec(&regmatch, linebuf, (colnr_T)0);
***************
*** 1267,1273 ****
      static int
  qf_parse_dir_pfx(int idx, qffields_T *fields, qf_list_T *qfl)
  {
!     if (idx == 'D')				/* enter directory */
      {
  	if (*fields->namebuf == NUL)
  	{
--- 1240,1246 ----
      static int
  qf_parse_dir_pfx(int idx, qffields_T *fields, qf_list_T *qfl)
  {
!     if (idx == 'D')				// enter directory
      {
  	if (*fields->namebuf == NUL)
  	{
***************
*** 1279,1285 ****
  	if (qfl->qf_directory == NULL)
  	    return QF_FAIL;
      }
!     else if (idx == 'X')			/* leave directory */
  	qfl->qf_directory = qf_pop_dir(&qfl->qf_dir_stack);
  
      return QF_OK;
--- 1252,1258 ----
  	if (qfl->qf_directory == NULL)
  	    return QF_FAIL;
      }
!     else if (idx == 'X')			// leave directory
  	qfl->qf_directory = qf_pop_dir(&qfl->qf_dir_stack);
  
      return QF_OK;
***************
*** 1324,1341 ****
  {
      char_u	*p;
  
!     fields->namebuf[0] = NUL;	/* no match found, remove file name */
!     fields->lnum = 0;			/* don't jump to this line */
      fields->valid = FALSE;
      if (linelen >= fields->errmsglen)
      {
! 	/* linelen + null terminator */
  	if ((p = vim_realloc(fields->errmsg, linelen + 1)) == NULL)
  	    return QF_NOMEM;
  	fields->errmsg = p;
  	fields->errmsglen = linelen + 1;
      }
!     /* copy whole line to error message */
      vim_strncpy(fields->errmsg, linebuf, linelen);
  
      return QF_OK;
--- 1297,1314 ----
  {
      char_u	*p;
  
!     fields->namebuf[0] = NUL;	// no match found, remove file name
!     fields->lnum = 0;		// don't jump to this line
      fields->valid = FALSE;
      if (linelen >= fields->errmsglen)
      {
! 	// linelen + null terminator
  	if ((p = vim_realloc(fields->errmsg, linelen + 1)) == NULL)
  	    return QF_NOMEM;
  	fields->errmsg = p;
  	fields->errmsglen = linelen + 1;
      }
!     // copy whole line to error message
      vim_strncpy(fields->errmsg, linebuf, linelen);
  
      return QF_OK;
***************
*** 1376,1382 ****
  	if (qfprev->qf_nr == -1)
  	    qfprev->qf_nr = fields->enr;
  	if (vim_isprintc(fields->type) && !qfprev->qf_type)
! 	    /* only printable chars allowed */
  	    qfprev->qf_type = fields->type;
  
  	if (!qfprev->qf_lnum)
--- 1349,1355 ----
  	if (qfprev->qf_nr == -1)
  	    qfprev->qf_nr = fields->enr;
  	if (vim_isprintc(fields->type) && !qfprev->qf_type)
! 	    // only printable chars allowed
  	    qfprev->qf_type = fields->type;
  
  	if (!qfprev->qf_lnum)
***************
*** 1419,1438 ****
      int			status;
  
  restofline:
!     /* If there was no %> item start at the first pattern */
      if (fmt_start == NULL)
  	fmt_ptr = fmt_first;
      else
      {
! 	/* Otherwise start from the last used pattern */
  	fmt_ptr = fmt_start;
  	fmt_start = NULL;
      }
  
!     /*
!      * Try to match each part of 'errorformat' until we find a complete
!      * match or no match.
!      */
      fields->valid = TRUE;
      for ( ; fmt_ptr != NULL; fmt_ptr = fmt_ptr->next)
      {
--- 1392,1409 ----
      int			status;
  
  restofline:
!     // If there was no %> item start at the first pattern
      if (fmt_start == NULL)
  	fmt_ptr = fmt_first;
      else
      {
! 	// Otherwise start from the last used pattern
  	fmt_ptr = fmt_start;
  	fmt_start = NULL;
      }
  
!     // Try to match each part of 'errorformat' until we find a complete
!     // match or no match.
      fields->valid = TRUE;
      for ( ; fmt_ptr != NULL; fmt_ptr = fmt_ptr->next)
      {
***************
*** 1450,1456 ****
      {
  	if (fmt_ptr != NULL)
  	{
! 	    /* 'D' and 'X' directory specifiers */
  	    status = qf_parse_dir_pfx(idx, fields, qfl);
  	    if (status != QF_OK)
  		return status;
--- 1421,1427 ----
      {
  	if (fmt_ptr != NULL)
  	{
! 	    // 'D' and 'X' directory specifiers
  	    status = qf_parse_dir_pfx(idx, fields, qfl);
  	    if (status != QF_OK)
  		return status;
***************
*** 1465,1495 ****
      }
      else if (fmt_ptr != NULL)
      {
! 	/* honor %> item */
  	if (fmt_ptr->conthere)
  	    fmt_start = fmt_ptr;
  
  	if (vim_strchr((char_u *)"AEWI", idx) != NULL)
  	{
! 	    qfl->qf_multiline = TRUE;	/* start of a multi-line message */
! 	    qfl->qf_multiignore = FALSE;/* reset continuation */
  	}
  	else if (vim_strchr((char_u *)"CZ", idx) != NULL)
! 	{				/* continuation of multi-line msg */
  	    status = qf_parse_multiline_pfx(qi, qf_idx, idx, qfl, fields);
  	    if (status != QF_OK)
  		return status;
  	}
  	else if (vim_strchr((char_u *)"OPQ", idx) != NULL)
! 	{				/* global file names */
  	    status = qf_parse_file_pfx(idx, fields, qfl, tail);
  	    if (status == QF_MULTISCAN)
  		goto restofline;
  	}
! 	if (fmt_ptr->flags == '-')	/* generally exclude this line */
  	{
  	    if (qfl->qf_multiline)
! 		/* also exclude continuation lines */
  		qfl->qf_multiignore = TRUE;
  	    return QF_IGNORE_LINE;
  	}
--- 1436,1466 ----
      }
      else if (fmt_ptr != NULL)
      {
! 	// honor %> item
  	if (fmt_ptr->conthere)
  	    fmt_start = fmt_ptr;
  
  	if (vim_strchr((char_u *)"AEWI", idx) != NULL)
  	{
! 	    qfl->qf_multiline = TRUE;	// start of a multi-line message
! 	    qfl->qf_multiignore = FALSE;// reset continuation
  	}
  	else if (vim_strchr((char_u *)"CZ", idx) != NULL)
! 	{				// continuation of multi-line msg
  	    status = qf_parse_multiline_pfx(qi, qf_idx, idx, qfl, fields);
  	    if (status != QF_OK)
  		return status;
  	}
  	else if (vim_strchr((char_u *)"OPQ", idx) != NULL)
! 	{				// global file names
  	    status = qf_parse_file_pfx(idx, fields, qfl, tail);
  	    if (status == QF_MULTISCAN)
  		goto restofline;
  	}
! 	if (fmt_ptr->flags == '-')	// generally exclude this line
  	{
  	    if (qfl->qf_multiline)
! 		// also exclude continuation lines
  		qfl->qf_multiignore = TRUE;
  	    return QF_IGNORE_LINE;
  	}
***************
*** 1624,1632 ****
      buf_T	    *buf,
      typval_T	    *tv,
      char_u	    *errorformat,
!     int		    newlist,		/* TRUE: start a new error list */
!     linenr_T	    lnumfirst,		/* first line number to use */
!     linenr_T	    lnumlast,		/* last line number to use */
      char_u	    *qf_title,
      char_u	    *enc)
  {
--- 1595,1603 ----
      buf_T	    *buf,
      typval_T	    *tv,
      char_u	    *errorformat,
!     int		    newlist,		// TRUE: start a new error list
!     linenr_T	    lnumfirst,		// first line number to use
!     linenr_T	    lnumlast,		// last line number to use
      char_u	    *qf_title,
      char_u	    *enc)
  {
***************
*** 1638,1647 ****
      static efm_T    *fmt_first = NULL;
      char_u	    *efm;
      static char_u   *last_efm = NULL;
!     int		    retval = -1;	/* default: return error flag */
      int		    status;
  
!     /* Do not used the cached buffer, it may have been wiped out. */
      VIM_CLEAR(qf_last_bufname);
  
      vim_memset(&state, 0, sizeof(state));
--- 1609,1618 ----
      static efm_T    *fmt_first = NULL;
      char_u	    *efm;
      static char_u   *last_efm = NULL;
!     int		    retval = -1;	// default: return error flag
      int		    status;
  
!     // Do not used the cached buffer, it may have been wiped out.
      VIM_CLEAR(qf_last_bufname);
  
      vim_memset(&state, 0, sizeof(state));
***************
*** 1653,1665 ****
  
      if (newlist || qf_idx == qi->qf_listcount)
      {
! 	/* make place for a new list */
  	qf_new_list(qi, qf_title);
  	qf_idx = qi->qf_curlist;
      }
      else
      {
! 	/* Adding to existing list, use last entry. */
  	adding = TRUE;
  	if (!qf_list_empty(qi, qf_idx))
  	    old_last = qi->qf_lists[qf_idx].qf_last;
--- 1624,1636 ----
  
      if (newlist || qf_idx == qi->qf_listcount)
      {
! 	// make place for a new list
  	qf_new_list(qi, qf_title);
  	qf_idx = qi->qf_curlist;
      }
      else
      {
! 	// Adding to existing list, use last entry.
  	adding = TRUE;
  	if (!qf_list_empty(qi, qf_idx))
  	    old_last = qi->qf_lists[qf_idx].qf_last;
***************
*** 1667,1714 ****
  
      qfl = &qi->qf_lists[qf_idx];
  
!     /* Use the local value of 'errorformat' if it's set. */
      if (errorformat == p_efm && tv == NULL && *buf->b_p_efm != NUL)
  	efm = buf->b_p_efm;
      else
  	efm = errorformat;
  
!     /*
!      * If the errorformat didn't change between calls, then reuse the
!      * previously parsed values.
!      */
      if (last_efm == NULL || (STRCMP(last_efm, efm) != 0))
      {
! 	/* free the previously parsed data */
  	VIM_CLEAR(last_efm);
  	free_efm_list(&fmt_first);
  
! 	/* parse the current 'efm' */
  	fmt_first = parse_efm_option(efm);
  	if (fmt_first != NULL)
  	    last_efm = vim_strsave(efm);
      }
  
!     if (fmt_first == NULL)	/* nothing found */
  	goto error2;
  
!     /*
!      * got_int is reset here, because it was probably set when killing the
!      * ":make" command, but we still want to read the errorfile then.
!      */
      got_int = FALSE;
  
!     /*
!      * Read the lines in the error file one by one.
!      * Try to recognize one of the error formats in each line.
!      */
      while (!got_int)
      {
! 	/* Get the next line from a file/buffer/list/string */
  	status = qf_get_nextline(&state);
! 	if (status == QF_NOMEM)		/* memory alloc failure */
  	    goto qf_init_end;
! 	if (status == QF_END_OF_INPUT)	/* end of input */
  	    break;
  
  	status = qf_parse_line(qi, qf_idx, state.linebuf, state.linelen,
--- 1638,1679 ----
  
      qfl = &qi->qf_lists[qf_idx];
  
!     // Use the local value of 'errorformat' if it's set.
      if (errorformat == p_efm && tv == NULL && *buf->b_p_efm != NUL)
  	efm = buf->b_p_efm;
      else
  	efm = errorformat;
  
!     // If the errorformat didn't change between calls, then reuse the
!     // previously parsed values.
      if (last_efm == NULL || (STRCMP(last_efm, efm) != 0))
      {
! 	// free the previously parsed data
  	VIM_CLEAR(last_efm);
  	free_efm_list(&fmt_first);
  
! 	// parse the current 'efm'
  	fmt_first = parse_efm_option(efm);
  	if (fmt_first != NULL)
  	    last_efm = vim_strsave(efm);
      }
  
!     if (fmt_first == NULL)	// nothing found
  	goto error2;
  
!     // got_int is reset here, because it was probably set when killing the
!     // ":make" command, but we still want to read the errorfile then.
      got_int = FALSE;
  
!     // Read the lines in the error file one by one.
!     // Try to recognize one of the error formats in each line.
      while (!got_int)
      {
! 	// Get the next line from a file/buffer/list/string
  	status = qf_get_nextline(&state);
! 	if (status == QF_NOMEM)		// memory alloc failure
  	    goto qf_init_end;
! 	if (status == QF_END_OF_INPUT)	// end of input
  	    break;
  
  	status = qf_parse_line(qi, qf_idx, state.linebuf, state.linelen,
***************
*** 1744,1750 ****
      {
  	if (qfl->qf_index == 0)
  	{
! 	    /* no valid entry found */
  	    qfl->qf_ptr = qfl->qf_start;
  	    qfl->qf_index = 1;
  	    qfl->qf_nonevalid = TRUE;
--- 1709,1715 ----
      {
  	if (qfl->qf_index == 0)
  	{
! 	    // no valid entry found
  	    qfl->qf_ptr = qfl->qf_start;
  	    qfl->qf_index = 1;
  	    qfl->qf_nonevalid = TRUE;
***************
*** 1755,1761 ****
  	    if (qfl->qf_ptr == NULL)
  		qfl->qf_ptr = qfl->qf_start;
  	}
! 	/* return number of matches */
  	retval = qfl->qf_count;
  	goto qf_init_end;
      }
--- 1720,1726 ----
  	    if (qfl->qf_ptr == NULL)
  		qfl->qf_ptr = qfl->qf_start;
  	}
! 	// return number of matches
  	retval = qfl->qf_count;
  	goto qf_init_end;
      }
***************
*** 1763,1769 ****
  error2:
      if (!adding)
      {
! 	/* Error when creating a new list. Free the new list */
  	qf_free(&qi->qf_lists[qi->qf_curlist]);
  	qi->qf_listcount--;
  	if (qi->qf_curlist > 0)
--- 1728,1734 ----
  error2:
      if (!adding)
      {
! 	// Error when creating a new list. Free the new list
  	qf_free(&qi->qf_lists[qi->qf_curlist]);
  	qi->qf_listcount--;
  	if (qi->qf_curlist > 0)
***************
*** 1787,1793 ****
  qf_init(win_T	    *wp,
  	char_u	    *efile,
  	char_u	    *errorformat,
! 	int	    newlist,		/* TRUE: start a new error list */
  	char_u	    *qf_title,
  	char_u	    *enc)
  {
--- 1752,1758 ----
  qf_init(win_T	    *wp,
  	char_u	    *efile,
  	char_u	    *errorformat,
! 	int	    newlist,		// TRUE: start a new error list
  	char_u	    *qf_title,
  	char_u	    *enc)
  {
***************
*** 1848,1865 ****
  {
      int		i;
  
!     /*
!      * If the current entry is not the last entry, delete entries beyond
!      * the current entry.  This makes it possible to browse in a tree-like
!      * way with ":grep'.
!      */
      while (qi->qf_listcount > qi->qf_curlist + 1)
  	qf_free(&qi->qf_lists[--qi->qf_listcount]);
  
!     /*
!      * When the stack is full, remove to oldest entry
!      * Otherwise, add a new entry.
!      */
      if (qi->qf_listcount == LISTCOUNT)
      {
  	qf_free(&qi->qf_lists[0]);
--- 1813,1826 ----
  {
      int		i;
  
!     // If the current entry is not the last entry, delete entries beyond
!     // the current entry.  This makes it possible to browse in a tree-like
!     // way with ":grep'.
      while (qi->qf_listcount > qi->qf_curlist + 1)
  	qf_free(&qi->qf_lists[--qi->qf_listcount]);
  
!     // When the stack is full, remove to oldest entry
!     // Otherwise, add a new entry.
      if (qi->qf_listcount == LISTCOUNT)
      {
  	qf_free(&qi->qf_lists[0]);
***************
*** 1886,1897 ****
      qi = *pqi;
      if (qi == NULL)
  	return;
!     *pqi = NULL;	/* Remove reference to this list */
  
      qi->qf_refcount--;
      if (qi->qf_refcount < 1)
      {
! 	/* No references to this location list */
  	for (i = 0; i < qi->qf_listcount; ++i)
  	    qf_free(&qi->qf_lists[i]);
  	vim_free(qi);
--- 1847,1858 ----
      qi = *pqi;
      if (qi == NULL)
  	return;
!     *pqi = NULL;	// Remove reference to this list
  
      qi->qf_refcount--;
      if (qi->qf_refcount < 1)
      {
! 	// No references to this location list
  	for (i = 0; i < qi->qf_listcount; ++i)
  	    qf_free(&qi->qf_lists[i]);
  	vim_free(qi);
***************
*** 1909,1920 ****
  
      if (wp != NULL)
      {
! 	/* location list */
  	ll_free_all(&wp->w_llist);
  	ll_free_all(&wp->w_llist_ref);
      }
      else
! 	/* quickfix list */
  	for (i = 0; i < qi->qf_listcount; ++i)
  	    qf_free(&qi->qf_lists[i]);
  }
--- 1870,1881 ----
  
      if (wp != NULL)
      {
! 	// location list
  	ll_free_all(&wp->w_llist);
  	ll_free_all(&wp->w_llist_ref);
      }
      else
! 	// quickfix list
  	for (i = 0; i < qi->qf_listcount; ++i)
  	    qf_free(&qi->qf_lists[i]);
  }
***************
*** 1925,1948 ****
   */
      static int
  qf_add_entry(
!     qf_info_T	*qi,		/* quickfix list */
!     int		qf_idx,		/* list index */
!     char_u	*dir,		/* optional directory name */
!     char_u	*fname,		/* file name or NULL */
!     char_u	*module,	/* module name or NULL */
!     int		bufnum,		/* buffer number or zero */
!     char_u	*mesg,		/* message */
!     long	lnum,		/* line number */
!     int		col,		/* column */
!     int		vis_col,	/* using visual column */
!     char_u	*pattern,	/* search pattern */
!     int		nr,		/* error number */
!     int		type,		/* type character */
!     int		valid)		/* valid entry */
  {
      qf_list_T	*qfl = &qi->qf_lists[qf_idx];
      qfline_T	*qfp;
!     qfline_T	**lastp;	/* pointer to qf_last or NULL */
  
      if ((qfp = (qfline_T *)alloc((unsigned)sizeof(qfline_T))) == NULL)
  	return FAIL;
--- 1886,1909 ----
   */
      static int
  qf_add_entry(
!     qf_info_T	*qi,		// quickfix list
!     int		qf_idx,		// list index
!     char_u	*dir,		// optional directory name
!     char_u	*fname,		// file name or NULL
!     char_u	*module,	// module name or NULL
!     int		bufnum,		// buffer number or zero
!     char_u	*mesg,		// message
!     long	lnum,		// line number
!     int		col,		// column
!     int		vis_col,	// using visual column
!     char_u	*pattern,	// search pattern
!     int		nr,		// error number
!     int		type,		// type character
!     int		valid)		// valid entry
  {
      qf_list_T	*qfl = &qi->qf_lists[qf_idx];
      qfline_T	*qfp;
!     qfline_T	**lastp;	// pointer to qf_last or NULL
  
      if ((qfp = (qfline_T *)alloc((unsigned)sizeof(qfline_T))) == NULL)
  	return FAIL;
***************
*** 1983,1995 ****
  	return FAIL;
      }
      qfp->qf_nr = nr;
!     if (type != 1 && !vim_isprintc(type)) /* only printable chars allowed */
  	type = 0;
      qfp->qf_type = type;
      qfp->qf_valid = valid;
  
      lastp = &qfl->qf_last;
!     if (qf_list_empty(qi, qf_idx))	/* first element in the list */
      {
  	qfl->qf_start = qfp;
  	qfl->qf_ptr = qfp;
--- 1944,1956 ----
  	return FAIL;
      }
      qfp->qf_nr = nr;
!     if (type != 1 && !vim_isprintc(type)) // only printable chars allowed
  	type = 0;
      qfp->qf_type = type;
      qfp->qf_valid = valid;
  
      lastp = &qfl->qf_last;
!     if (qf_list_empty(qi, qf_idx))	// first element in the list
      {
  	qfl->qf_start = qfp;
  	qfl->qf_ptr = qfp;
***************
*** 2005,2012 ****
      qfp->qf_cleared = FALSE;
      *lastp = qfp;
      ++qfl->qf_count;
!     if (qfl->qf_index == 0 && qfp->qf_valid)
! 				/* first valid entry */
      {
  	qfl->qf_index = qfl->qf_count;
  	qfl->qf_ptr = qfp;
--- 1966,1972 ----
      qfp->qf_cleared = FALSE;
      *lastp = qfp;
      ++qfl->qf_count;
!     if (qfl->qf_index == 0 && qfp->qf_valid)	// first valid entry
      {
  	qfl->qf_index = qfl->qf_count;
  	qfl->qf_ptr = qfp;
***************
*** 2037,2053 ****
  ll_get_or_alloc_list(win_T *wp)
  {
      if (IS_LL_WINDOW(wp))
! 	/* For a location list window, use the referenced location list */
  	return wp->w_llist_ref;
  
!     /*
!      * For a non-location list window, w_llist_ref should not point to a
!      * location list.
!      */
      ll_free_all(&wp->w_llist_ref);
  
      if (wp->w_llist == NULL)
! 	wp->w_llist = ll_new_list();	    /* new location list */
      return wp->w_llist;
  }
  
--- 1997,2011 ----
  ll_get_or_alloc_list(win_T *wp)
  {
      if (IS_LL_WINDOW(wp))
! 	// For a location list window, use the referenced location list
  	return wp->w_llist_ref;
  
!     // For a non-location list window, w_llist_ref should not point to a
!     // location list.
      ll_free_all(&wp->w_llist_ref);
  
      if (wp->w_llist == NULL)
! 	wp->w_llist = ll_new_list();	    // new location list
      return wp->w_llist;
  }
  
***************
*** 2195,2201 ****
      buf_T	*buf;
      char_u	*bufname;
  
!     if (fname == NULL || *fname == NUL)		/* no file name */
  	return 0;
  
  #ifdef VMS
--- 2153,2159 ----
      buf_T	*buf;
      char_u	*bufname;
  
!     if (fname == NULL || *fname == NUL)		// no file name
  	return 0;
  
  #ifdef VMS
***************
*** 2209,2220 ****
      if (directory != NULL && !vim_isAbsName(fname)
  	    && (ptr = concat_fnames(directory, fname, TRUE)) != NULL)
      {
! 	/*
! 	 * Here we check if the file really exists.
! 	 * This should normally be true, but if make works without
! 	 * "leaving directory"-messages we might have missed a
! 	 * directory change.
! 	 */
  	if (mch_getperm(ptr) < 0)
  	{
  	    vim_free(ptr);
--- 2167,2176 ----
      if (directory != NULL && !vim_isAbsName(fname)
  	    && (ptr = concat_fnames(directory, fname, TRUE)) != NULL)
      {
! 	// Here we check if the file really exists.
! 	// This should normally be true, but if make works without
! 	// "leaving directory"-messages we might have missed a
! 	// directory change.
  	if (mch_getperm(ptr) < 0)
  	{
  	    vim_free(ptr);
***************
*** 2224,2230 ****
  	    else
  		ptr = vim_strsave(fname);
  	}
! 	/* Use concatenated directory name and file name */
  	bufname = ptr;
      }
      else
--- 2180,2186 ----
  	    else
  		ptr = vim_strsave(fname);
  	}
! 	// Use concatenated directory name and file name
  	bufname = ptr;
      }
      else
***************
*** 2264,2270 ****
      struct dir_stack_T  *ds_new;
      struct dir_stack_T  *ds_ptr;
  
!     /* allocate new stack element and hook it in */
      ds_new = (struct dir_stack_T *)alloc((unsigned)sizeof(struct dir_stack_T));
      if (ds_new == NULL)
  	return NULL;
--- 2220,2226 ----
      struct dir_stack_T  *ds_new;
      struct dir_stack_T  *ds_ptr;
  
!     // allocate new stack element and hook it in
      ds_new = (struct dir_stack_T *)alloc((unsigned)sizeof(struct dir_stack_T));
      if (ds_new == NULL)
  	return NULL;
***************
*** 2272,2288 ****
      ds_new->next = *stackptr;
      *stackptr = ds_new;
  
!     /* store directory on the stack */
      if (vim_isAbsName(dirbuf)
  	    || (*stackptr)->next == NULL
  	    || (*stackptr && is_file_stack))
  	(*stackptr)->dirname = vim_strsave(dirbuf);
      else
      {
! 	/* Okay we don't have an absolute path.
! 	 * dirbuf must be a subdir of one of the directories on the stack.
! 	 * Let's search...
! 	 */
  	ds_new = (*stackptr)->next;
  	(*stackptr)->dirname = NULL;
  	while (ds_new)
--- 2228,2243 ----
      ds_new->next = *stackptr;
      *stackptr = ds_new;
  
!     // store directory on the stack
      if (vim_isAbsName(dirbuf)
  	    || (*stackptr)->next == NULL
  	    || (*stackptr && is_file_stack))
  	(*stackptr)->dirname = vim_strsave(dirbuf);
      else
      {
! 	// Okay we don't have an absolute path.
! 	// dirbuf must be a subdir of one of the directories on the stack.
! 	// Let's search...
  	ds_new = (*stackptr)->next;
  	(*stackptr)->dirname = NULL;
  	while (ds_new)
***************
*** 2296,2302 ****
  	    ds_new = ds_new->next;
  	}
  
! 	/* clean up all dirs we already left */
  	while ((*stackptr)->next != ds_new)
  	{
  	    ds_ptr = (*stackptr)->next;
--- 2251,2257 ----
  	    ds_new = ds_new->next;
  	}
  
! 	// clean up all dirs we already left
  	while ((*stackptr)->next != ds_new)
  	{
  	    ds_ptr = (*stackptr)->next;
***************
*** 2305,2311 ****
  	    vim_free(ds_ptr);
  	}
  
! 	/* Nothing found -> it must be on top level */
  	if (ds_new == NULL)
  	{
  	    vim_free((*stackptr)->dirname);
--- 2260,2266 ----
  	    vim_free(ds_ptr);
  	}
  
! 	// Nothing found -> it must be on top level
  	if (ds_new == NULL)
  	{
  	    vim_free((*stackptr)->dirname);
***************
*** 2333,2342 ****
  {
      struct dir_stack_T  *ds_ptr;
  
!     /* TODO: Should we check if dirbuf is the directory on top of the stack?
!      * What to do if it isn't? */
  
!     /* pop top element and free it */
      if (*stackptr != NULL)
      {
  	ds_ptr = *stackptr;
--- 2288,2297 ----
  {
      struct dir_stack_T  *ds_ptr;
  
!     // TODO: Should we check if dirbuf is the directory on top of the stack?
!     // What to do if it isn't?
  
!     // pop top element and free it
      if (*stackptr != NULL)
      {
  	ds_ptr = *stackptr;
***************
*** 2345,2351 ****
  	vim_free(ds_ptr);
      }
  
!     /* return NEW top element as current dir or NULL if stack is empty*/
      return *stackptr ? (*stackptr)->dirname : NULL;
  }
  
--- 2300,2306 ----
  	vim_free(ds_ptr);
      }
  
!     // return NEW top element as current dir or NULL if stack is empty
      return *stackptr ? (*stackptr)->dirname : NULL;
  }
  
***************
*** 2392,2398 ****
      struct dir_stack_T     *ds_tmp;
      char_u		   *fullname;
  
!     /* no dirs on the stack - there's nothing we can do */
      if (qfl->qf_dir_stack == NULL)
  	return NULL;
  
--- 2347,2353 ----
      struct dir_stack_T     *ds_tmp;
      char_u		   *fullname;
  
!     // no dirs on the stack - there's nothing we can do
      if (qfl->qf_dir_stack == NULL)
  	return NULL;
  
***************
*** 2403,2411 ****
  	vim_free(fullname);
  	fullname = concat_fnames(ds_ptr->dirname, filename, TRUE);
  
! 	/* If concat_fnames failed, just go on. The worst thing that can happen
! 	 * is that we delete the entire stack.
! 	 */
  	if ((fullname != NULL) && (mch_getperm(fullname) >= 0))
  	    break;
  
--- 2358,2365 ----
  	vim_free(fullname);
  	fullname = concat_fnames(ds_ptr->dirname, filename, TRUE);
  
! 	// If concat_fnames failed, just go on. The worst thing that can happen
! 	// is that we delete the entire stack.
  	if ((fullname != NULL) && (mch_getperm(fullname) >= 0))
  	    break;
  
***************
*** 2414,2420 ****
  
      vim_free(fullname);
  
!     /* clean up all dirs we already left */
      while (qfl->qf_dir_stack->next != ds_ptr)
      {
  	ds_tmp = qfl->qf_dir_stack->next;
--- 2368,2374 ----
  
      vim_free(fullname);
  
!     // clean up all dirs we already left
      while (qfl->qf_dir_stack->next != ds_ptr)
      {
  	ds_tmp = qfl->qf_dir_stack->next;
***************
*** 2437,2443 ****
  
      if (wp != NULL)
      {
! 	qi = GET_LOC_LIST(wp);	    /* Location list */
  	if (qi == NULL)
  	    return FALSE;
      }
--- 2391,2397 ----
  
      if (wp != NULL)
      {
! 	qi = GET_LOC_LIST(wp);	    // Location list
  	if (qi == NULL)
  	    return FALSE;
      }
***************
*** 2461,2473 ****
      qfline_T	*qfp;
      int		i;
  
!     /* Search for the entry in the current list */
      for (i = 0, qfp = qfl->qf_start; i < qfl->qf_count;
  	    ++i, qfp = qfp->qf_next)
  	if (qfp == NULL || qfp == qf_ptr)
  	    break;
  
!     if (i == qfl->qf_count) /* Entry is not found */
  	return FALSE;
  
      return TRUE;
--- 2415,2427 ----
      qfline_T	*qfp;
      int		i;
  
!     // Search for the entry in the current list
      for (i = 0, qfp = qfl->qf_start; i < qfl->qf_count;
  	    ++i, qfp = qfp->qf_next)
  	if (qfp == NULL || qfp == qf_ptr)
  	    break;
  
!     if (i == qfl->qf_count) // Entry is not found
  	return FALSE;
  
      return TRUE;
***************
*** 2667,2682 ****
  	win_enter(wp, TRUE);
      else
      {
! 	/*
! 	 * Split off help window; put it at far top if no position
! 	 * specified, the current window is vertically split and narrow.
! 	 */
  	flags = WSP_HELP;
  	if (cmdmod.split == 0 && curwin->w_width != Columns
  		&& curwin->w_width < 80)
  	    flags |= WSP_TOP;
  	if (IS_LL_STACK(qi))
! 	    flags |= WSP_NEWLOC;  /* don't copy the location list */
  
  	if (win_split(0, flags) == FAIL)
  	    return FAIL;
--- 2621,2634 ----
  	win_enter(wp, TRUE);
      else
      {
! 	// Split off help window; put it at far top if no position
! 	// specified, the current window is vertically split and narrow.
  	flags = WSP_HELP;
  	if (cmdmod.split == 0 && curwin->w_width != Columns
  		&& curwin->w_width < 80)
  	    flags |= WSP_TOP;
  	if (IS_LL_STACK(qi))
! 	    flags |= WSP_NEWLOC;  // don't copy the location list
  
  	if (win_split(0, flags) == FAIL)
  	    return FAIL;
***************
*** 2688,2701 ****
  
  	if (IS_LL_STACK(qi))		// not a quickfix list
  	{
! 	    /* The new window should use the supplied location list */
  	    curwin->w_llist = qi;
  	    qi->qf_refcount++;
  	}
      }
  
      if (!p_im)
! 	restart_edit = 0;	    /* don't want insert mode in help file */
  
      return OK;
  }
--- 2640,2653 ----
  
  	if (IS_LL_STACK(qi))		// not a quickfix list
  	{
! 	    // The new window should use the supplied location list
  	    curwin->w_llist = qi;
  	    qi->qf_refcount++;
  	}
      }
  
      if (!p_im)
! 	restart_edit = 0;	    // don't want insert mode in help file
  
      return OK;
  }
***************
*** 2764,2777 ****
      if (ll_ref != NULL)
  	flags |= WSP_NEWLOC;
      if (win_split(0, flags) == FAIL)
! 	return FAIL;		/* not enough room for window */
!     p_swb = empty_option;	/* don't split again */
      swb_flags = 0;
      RESET_BINDING(curwin);
      if (ll_ref != NULL)
      {
! 	/* The new window should use the location list from the
! 	 * location list window */
  	curwin->w_llist = ll_ref;
  	ll_ref->qf_refcount++;
      }
--- 2716,2729 ----
      if (ll_ref != NULL)
  	flags |= WSP_NEWLOC;
      if (win_split(0, flags) == FAIL)
! 	return FAIL;		// not enough room for window
!     p_swb = empty_option;	// don't split again
      swb_flags = 0;
      RESET_BINDING(curwin);
      if (ll_ref != NULL)
      {
! 	// The new window should use the location list from the
! 	// location list window
  	curwin->w_llist = ll_ref;
  	ll_ref->qf_refcount++;
      }
***************
*** 2791,2819 ****
  
      if (win == NULL)
      {
! 	/* Find the window showing the selected file */
  	FOR_ALL_WINDOWS(win)
  	    if (win->w_buffer->b_fnum == qf_fnum)
  		break;
  	if (win == NULL)
  	{
! 	    /* Find a previous usable window */
  	    win = curwin;
  	    do
  	    {
  		if (bt_normal(win->w_buffer))
  		    break;
  		if (win->w_prev == NULL)
! 		    win = lastwin;	/* wrap around the top */
  		else
! 		    win = win->w_prev; /* go to previous window */
  	    } while (win != curwin);
  	}
      }
      win_goto(win);
  
!     /* If the location list for the window is not set, then set it
!      * to the location list from the location window */
      if (win->w_llist == NULL)
      {
  	win->w_llist = ll_ref;
--- 2743,2771 ----
  
      if (win == NULL)
      {
! 	// Find the window showing the selected file
  	FOR_ALL_WINDOWS(win)
  	    if (win->w_buffer->b_fnum == qf_fnum)
  		break;
  	if (win == NULL)
  	{
! 	    // Find a previous usable window
  	    win = curwin;
  	    do
  	    {
  		if (bt_normal(win->w_buffer))
  		    break;
  		if (win->w_prev == NULL)
! 		    win = lastwin;	// wrap around the top
  		else
! 		    win = win->w_prev; // go to previous window
  	    } while (win != curwin);
  	}
      }
      win_goto(win);
  
!     // If the location list for the window is not set, then set it
!     // to the location list from the location window
      if (win->w_llist == NULL)
      {
  	win->w_llist = ll_ref;
***************
*** 2841,2854 ****
  	if (win->w_buffer->b_fnum == qf_fnum)
  	    break;
  	if (win->w_prev == NULL)
! 	    win = lastwin;	/* wrap around the top */
  	else
! 	    win = win->w_prev;	/* go to previous window */
  
  	if (IS_QF_WINDOW(win))
  	{
! 	    /* Didn't find it, go to the window before the quickfix
! 	     * window. */
  	    if (altwin != NULL)
  		win = altwin;
  	    else if (curwin->w_prev != NULL)
--- 2793,2806 ----
  	if (win->w_buffer->b_fnum == qf_fnum)
  	    break;
  	if (win->w_prev == NULL)
! 	    win = lastwin;	// wrap around the top
  	else
! 	    win = win->w_prev;	// go to previous window
  
  	if (IS_QF_WINDOW(win))
  	{
! 	    // Didn't find it, go to the window before the quickfix
! 	    // window.
  	    if (altwin != NULL)
  		win = altwin;
  	    else if (curwin->w_prev != NULL)
***************
*** 2858,2864 ****
  	    break;
  	}
  
! 	/* Remember a usable window. */
  	if (altwin == NULL && !win->w_p_pvw && bt_normal(win->w_buffer))
  	    altwin = win;
      }
--- 2810,2816 ----
  	    break;
  	}
  
! 	// Remember a usable window.
  	if (altwin == NULL && !win->w_p_pvw && bt_normal(win->w_buffer))
  	    altwin = win;
      }
***************
*** 2885,2891 ****
      ll_ref = curwin->w_llist_ref;
      if (ll_ref != NULL)
      {
! 	/* Find a non-quickfix window with this location list */
  	usable_win_ptr = qf_find_win_with_loclist(ll_ref);
  	if (usable_win_ptr != NULL)
  	    usable_win = 1;
--- 2837,2843 ----
      ll_ref = curwin->w_llist_ref;
      if (ll_ref != NULL)
      {
! 	// Find a non-quickfix window with this location list
  	usable_win_ptr = qf_find_win_with_loclist(ll_ref);
  	if (usable_win_ptr != NULL)
  	    usable_win = 1;
***************
*** 2893,2926 ****
  
      if (!usable_win)
      {
! 	/* Locate a window showing a normal buffer */
  	win = qf_find_win_with_normal_buf();
  	if (win != NULL)
  	    usable_win = 1;
      }
  
!     /*
!      * If no usable window is found and 'switchbuf' contains "usetab"
!      * then search in other tabs.
!      */
      if (!usable_win && (swb_flags & SWB_USETAB))
  	usable_win = qf_goto_tabwin_with_file(qf_fnum);
  
!     /*
!      * If there is only one window and it is the quickfix window, create a
!      * new one above the quickfix window.
!      */
      if ((ONE_WINDOW && bt_quickfix(curbuf)) || !usable_win)
      {
  	if (qf_open_new_file_win(ll_ref) != OK)
  	    return FAIL;
! 	*opened_window = TRUE;	/* close it when fail */
      }
      else
      {
! 	if (curwin->w_llist_ref != NULL)	/* In a location window */
  	    qf_goto_win_with_ll_file(usable_win_ptr, qf_fnum, ll_ref);
! 	else					/* In a quickfix window */
  	    qf_goto_win_with_qfl_file(qf_fnum);
      }
  
--- 2845,2874 ----
  
      if (!usable_win)
      {
! 	// Locate a window showing a normal buffer
  	win = qf_find_win_with_normal_buf();
  	if (win != NULL)
  	    usable_win = 1;
      }
  
!     // If no usable window is found and 'switchbuf' contains "usetab"
!     // then search in other tabs.
      if (!usable_win && (swb_flags & SWB_USETAB))
  	usable_win = qf_goto_tabwin_with_file(qf_fnum);
  
!     // If there is only one window and it is the quickfix window, create a
!     // new one above the quickfix window.
      if ((ONE_WINDOW && bt_quickfix(curbuf)) || !usable_win)
      {
  	if (qf_open_new_file_win(ll_ref) != OK)
  	    return FAIL;
! 	*opened_window = TRUE;	// close it when fail
      }
      else
      {
! 	if (curwin->w_llist_ref != NULL)	// In a location window
  	    qf_goto_win_with_ll_file(usable_win_ptr, qf_fnum, ll_ref);
! 	else					// In a quickfix window
  	    qf_goto_win_with_qfl_file(qf_fnum);
      }
  
***************
*** 2946,2953 ****
  
      if (qf_ptr->qf_type == 1)
      {
! 	/* Open help file (do_ecmd() will set b_help flag, readfile() will
! 	 * set b_p_ro flag). */
  	if (!can_abandon(curbuf, forceit))
  	{
  	    no_write_message();
--- 2894,2901 ----
  
      if (qf_ptr->qf_type == 1)
      {
! 	// Open help file (do_ecmd() will set b_help flag, readfile() will
! 	// set b_p_ro flag).
  	if (!can_abandon(curbuf, forceit))
  	{
  	    no_write_message();
***************
*** 2968,2977 ****
  
  	if (IS_LL_STACK(qi))
  	{
! 	    /*
! 	     * Location list. Check whether the associated window is still
! 	     * present and the list is still valid.
! 	     */
  	    if (!win_valid_any_tab(oldwin))
  	    {
  		EMSG(_("E924: Current window was closed"));
--- 2916,2923 ----
  
  	if (IS_LL_STACK(qi))
  	{
! 	    // Location list. Check whether the associated window is still
! 	    // present and the list is still valid.
  	    if (!win_valid_any_tab(oldwin))
  	    {
  		EMSG(_("E924: Current window was closed"));
***************
*** 3016,3024 ****
  
      if (qf_pattern == NULL)
      {
! 	/*
! 	 * Go to line with error, unless qf_lnum is 0.
! 	 */
  	i = qf_lnum;
  	if (i > 0)
  	{
--- 2962,2968 ----
  
      if (qf_pattern == NULL)
      {
! 	// Go to line with error, unless qf_lnum is 0.
  	i = qf_lnum;
  	if (i > 0)
  	{
***************
*** 3034,3045 ****
  #endif
  	    if (qf_viscol == TRUE)
  	    {
! 		/*
! 		 * Check each character from the beginning of the error
! 		 * line up to the error column.  For each tab character
! 		 * found, reduce the error column value by the length of
! 		 * a tab character.
! 		 */
  		line = ml_get_curline();
  		screen_col = 0;
  		for (char_col = 0; char_col < curwin->w_cursor.col; ++char_col)
--- 2978,2987 ----
  #endif
  	    if (qf_viscol == TRUE)
  	    {
! 		// Check each character from the beginning of the error
! 		// line up to the error column.  For each tab character
! 		// found, reduce the error column value by the length of
! 		// a tab character.
  		line = ml_get_curline();
  		screen_col = 0;
  		for (char_col = 0; char_col < curwin->w_cursor.col; ++char_col)
***************
*** 3065,3071 ****
      {
  	pos_T save_cursor;
  
! 	/* Move the cursor to the first line in the buffer */
  	save_cursor = curwin->w_cursor;
  	curwin->w_cursor.lnum = 0;
  	if (!do_search(NULL, '/', qf_pattern, (long)1,
--- 3007,3013 ----
      {
  	pos_T save_cursor;
  
! 	// Move the cursor to the first line in the buffer
  	save_cursor = curwin->w_cursor;
  	curwin->w_cursor.lnum = 0;
  	if (!do_search(NULL, '/', qf_pattern, (long)1,
***************
*** 3088,3108 ****
      linenr_T		i;
      int			len;
  
!     /* Update the screen before showing the message, unless the screen
!      * scrolled up. */
      if (!msg_scrolled)
  	update_topline_redraw();
      sprintf((char *)IObuff, _("(%d of %d)%s%s: "), qf_index,
  	    qi->qf_lists[qi->qf_curlist].qf_count,
  	    qf_ptr->qf_cleared ? _(" (line deleted)") : "",
  	    (char *)qf_types(qf_ptr->qf_type, qf_ptr->qf_nr));
!     /* Add the message, skipping leading whitespace and newlines. */
      len = (int)STRLEN(IObuff);
      qf_fmt_text(skipwhite(qf_ptr->qf_text), IObuff + len, IOSIZE - len);
  
!     /* Output the message.  Overwrite to avoid scrolling when the 'O'
!      * flag is present in 'shortmess'; But when not jumping, print the
!      * whole message. */
      i = msg_scroll;
      if (curbuf == old_curbuf && curwin->w_cursor.lnum == old_lnum)
  	msg_scroll = TRUE;
--- 3030,3050 ----
      linenr_T		i;
      int			len;
  
!     // Update the screen before showing the message, unless the screen
!     // scrolled up.
      if (!msg_scrolled)
  	update_topline_redraw();
      sprintf((char *)IObuff, _("(%d of %d)%s%s: "), qf_index,
  	    qi->qf_lists[qi->qf_curlist].qf_count,
  	    qf_ptr->qf_cleared ? _(" (line deleted)") : "",
  	    (char *)qf_types(qf_ptr->qf_type, qf_ptr->qf_nr));
!     // Add the message, skipping leading whitespace and newlines.
      len = (int)STRLEN(IObuff);
      qf_fmt_text(skipwhite(qf_ptr->qf_text), IObuff + len, IOSIZE - len);
  
!     // Output the message.  Overwrite to avoid scrolling when the 'O'
!     // flag is present in 'shortmess'; But when not jumping, print the
!     // whole message.
      i = msg_scroll;
      if (curbuf == old_curbuf && curwin->w_cursor.lnum == old_lnum)
  	msg_scroll = TRUE;
***************
*** 3304,3312 ****
      }
  }
  
! /*
!  * Highlight attributes used for displaying entries from the quickfix list.
!  */
  static int	qfFileAttr;
  static int	qfSepAttr;
  static int	qfLineAttr;
--- 3246,3252 ----
      }
  }
  
! // Highlight attributes used for displaying entries from the quickfix list.
  static int	qfFileAttr;
  static int	qfSepAttr;
  static int	qfLineAttr;
***************
*** 3333,3339 ****
  		&& (buf = buflist_findnr(qfp->qf_fnum)) != NULL)
  	{
  	    fname = buf->b_fname;
! 	    if (qfp->qf_type == 1)	/* :helpgrep */
  		fname = gettail(fname);
  	}
  	if (fname == NULL)
--- 3273,3279 ----
  		&& (buf = buflist_findnr(qfp->qf_fnum)) != NULL)
  	{
  	    fname = buf->b_fname;
! 	    if (qfp->qf_type == 1)	// :helpgrep
  		fname = gettail(fname);
  	}
  	if (fname == NULL)
***************
*** 3382,3395 ****
      }
      msg_puts((char_u *)" ");
  
!     /* Remove newlines and leading whitespace from the text.  For an
!      * unrecognized line keep the indent, the compiler may mark a word
!      * with ^^^^. */
      qf_fmt_text((fname != NULL || qfp->qf_lnum != 0)
  				? skipwhite(qfp->qf_text) : qfp->qf_text,
  				IObuff, IOSIZE);
      msg_prt_line(IObuff, FALSE);
!     out_flush();		/* show one line at a time */
  }
  
  /*
--- 3322,3335 ----
      }
      msg_puts((char_u *)" ");
  
!     // Remove newlines and leading whitespace from the text.  For an
!     // unrecognized line keep the indent, the compiler may mark a word
!     // with ^^^^.
      qf_fmt_text((fname != NULL || qfp->qf_lnum != 0)
  				? skipwhite(qfp->qf_text) : qfp->qf_text,
  				IObuff, IOSIZE);
      msg_prt_line(IObuff, FALSE);
!     out_flush();		// show one line at a time
  }
  
  /*
***************
*** 3406,3413 ****
      int		idx2 = -1;
      char_u	*arg = eap->arg;
      int		plus = FALSE;
!     int		all = eap->forceit;	/* if not :cl!, only show
! 						   recognised errors */
      qf_info_T	*qi = &ql_info;
  
      if (is_loclist_cmd(eap->cmdidx))
--- 3346,3353 ----
      int		idx2 = -1;
      char_u	*arg = eap->arg;
      int		plus = FALSE;
!     int		all = eap->forceit;	// if not :cl!, only show
! 					// recognised errors
      qf_info_T	*qi = &ql_info;
  
      if (is_loclist_cmd(eap->cmdidx))
***************
*** 3451,3463 ****
  	    idx2 = (-idx2 > i) ? 0 : idx2 + i + 1;
      }
  
!     /* Shorten all the file names, so that it is easy to read */
      shorten_fnames(FALSE);
  
!     /*
!      * Get the attributes for the different quickfix highlight items.  Note
!      * that this depends on syntax items defined in the qf.vim syntax file
!      */
      qfFileAttr = syn_name2attr((char_u *)"qfFileName");
      if (qfFileAttr == 0)
  	qfFileAttr = HL_ATTR(HLF_D);
--- 3391,3401 ----
  	    idx2 = (-idx2 > i) ? 0 : idx2 + i + 1;
      }
  
!     // Shorten all the file names, so that it is easy to read
      shorten_fnames(FALSE);
  
!     // Get the attributes for the different quickfix highlight items.  Note
!     // that this depends on syntax items defined in the qf.vim syntax file
      qfFileAttr = syn_name2attr((char_u *)"qfFileName");
      if (qfFileAttr == 0)
  	qfFileAttr = HL_ATTR(HLF_D);
***************
*** 3638,3646 ****
  	    stop = (qfp == qfpnext);
  	    vim_free(qfp);
  	    if (stop)
! 		/* Somehow qf_count may have an incorrect value, set it to 1
! 		 * to avoid crashing when it's wrong.
! 		 * TODO: Avoid qf_count being incorrect. */
  		qfl->qf_count = 1;
  	}
  	qfl->qf_start = qfpnext;
--- 3576,3584 ----
  	    stop = (qfp == qfpnext);
  	    vim_free(qfp);
  	    if (stop)
! 		// Somehow qf_count may have an incorrect value, set it to 1
! 		// to avoid crashing when it's wrong.
! 		// TODO: Avoid qf_count being incorrect.
  		qfl->qf_count = 1;
  	}
  	qfl->qf_start = qfpnext;
***************
*** 3828,3841 ****
  	    return;
      }
  
!     /* Look for an existing quickfix window.  */
      win = qf_find_win(qi);
  
!     /*
!      * If a quickfix window is open but we have no errors to display,
!      * close the window.  If a quickfix window is not open, then open
!      * it if we have errors; otherwise, leave it closed.
!      */
      if (qf_stack_empty(qi)
  	    || qi->qf_lists[qi->qf_curlist].qf_nonevalid
  	    || qf_list_empty(qi, qi->qf_curlist))
--- 3766,3777 ----
  	    return;
      }
  
!     // Look for an existing quickfix window.
      win = qf_find_win(qi);
  
!     // If a quickfix window is open but we have no errors to display,
!     // close the window.  If a quickfix window is not open, then open
!     // it if we have errors; otherwise, leave it closed.
      if (qf_stack_empty(qi)
  	    || qi->qf_lists[qi->qf_curlist].qf_nonevalid
  	    || qf_list_empty(qi, qi->qf_curlist))
***************
*** 3864,3870 ****
  	    return;
      }
  
!     /* Find existing quickfix window and close it. */
      win = qf_find_win(qi);
      if (win != NULL)
  	win_close(win, FALSE);
--- 3800,3806 ----
  	    return;
      }
  
!     // Find existing quickfix window and close it.
      win = qf_find_win(qi);
      if (win != NULL)
  	win_close(win, FALSE);
***************
*** 4052,4060 ****
      curwin->w_cursor.coladd = 0;
  #endif
      curwin->w_curswant = 0;
!     update_topline();		/* scroll to show the line */
      redraw_later(VALID);
!     curwin->w_redr_status = TRUE;	/* update ruler */
      curwin = old_curwin;
      curbuf = curwin->w_buffer;
  }
--- 3988,3996 ----
      curwin->w_cursor.coladd = 0;
  #endif
      curwin->w_curswant = 0;
!     update_topline();		// scroll to show the line
      redraw_later(VALID);
!     curwin->w_redr_status = TRUE;	// update ruler
      curwin = old_curwin;
      curbuf = curwin->w_buffer;
  }
***************
*** 4093,4099 ****
      qf_info_T	*qi = &ql_info;
  
      if (IS_LL_WINDOW(wp))
! 	/* In the location list window, use the referenced location list */
  	qi = wp->w_llist_ref;
  
      return qi->qf_lists[qi->qf_curlist].qf_index;
--- 4029,4035 ----
      qf_info_T	*qi = &ql_info;
  
      if (IS_LL_WINDOW(wp))
! 	// In the location list window, use the referenced location list
  	qi = wp->w_llist_ref;
  
      return qi->qf_lists[qi->qf_curlist].qf_index;
***************
*** 4106,4120 ****
      static int
  qf_win_pos_update(
      qf_info_T	*qi,
!     int		old_qf_index)	/* previous qf_index or zero */
  {
      win_T	*win;
      int		qf_index = qi->qf_lists[qi->qf_curlist].qf_index;
  
!     /*
!      * Put the cursor on the current error in the quickfix window, so that
!      * it's viewable.
!      */
      win = qf_find_win(qi);
      if (win != NULL
  	    && qf_index <= win->w_buffer->b_ml.ml_line_count
--- 4042,4054 ----
      static int
  qf_win_pos_update(
      qf_info_T	*qi,
!     int		old_qf_index)	// previous qf_index or zero
  {
      win_T	*win;
      int		qf_index = qi->qf_lists[qi->qf_curlist].qf_index;
  
!     // Put the cursor on the current error in the quickfix window, so that
!     // it's viewable.
      win = qf_find_win(qi);
      if (win != NULL
  	    && qf_index <= win->w_buffer->b_ml.ml_line_count
***************
*** 4142,4153 ****
      static int
  is_qf_win(win_T *win, qf_info_T *qi)
  {
!     /*
!      * A window displaying the quickfix buffer will have the w_llist_ref field
!      * set to NULL.
!      * A window displaying a location list buffer will have the w_llist_ref
!      * pointing to the location list.
!      */
      if (bt_quickfix(win->w_buffer))
  	if ((IS_QF_STACK(qi) && win->w_llist_ref == NULL)
  		|| (IS_LL_STACK(qi) && win->w_llist_ref == qi))
--- 4076,4085 ----
      static int
  is_qf_win(win_T *win, qf_info_T *qi)
  {
!     // A window displaying the quickfix buffer will have the w_llist_ref field
!     // set to NULL.
!     // A window displaying a location list buffer will have the w_llist_ref
!     // pointing to the location list.
      if (bt_quickfix(win->w_buffer))
  	if ((IS_QF_STACK(qi) && win->w_llist_ref == NULL)
  		|| (IS_LL_STACK(qi) && win->w_llist_ref == qi))
***************
*** 4216,4229 ****
      win_T	*win;
      aco_save_T	aco;
  
!     /* Check if a buffer for the quickfix list exists.  Update it. */
      buf = qf_find_buf(qi);
      if (buf != NULL)
      {
  	linenr_T	old_line_count = buf->b_ml.ml_line_count;
  
  	if (old_last == NULL)
! 	    /* set curwin/curbuf to buf and save a few things */
  	    aucmd_prepbuf(&aco, buf);
  
  	qf_update_win_titlevar(qi);
--- 4148,4161 ----
      win_T	*win;
      aco_save_T	aco;
  
!     // Check if a buffer for the quickfix list exists.  Update it.
      buf = qf_find_buf(qi);
      if (buf != NULL)
      {
  	linenr_T	old_line_count = buf->b_ml.ml_line_count;
  
  	if (old_last == NULL)
! 	    // set curwin/curbuf to buf and save a few things
  	    aucmd_prepbuf(&aco, buf);
  
  	qf_update_win_titlevar(qi);
***************
*** 4235,4246 ****
  	{
  	    (void)qf_win_pos_update(qi, 0);
  
! 	    /* restore curwin/curbuf and a few other things */
  	    aucmd_restbuf(&aco);
  	}
  
! 	/* Only redraw when added lines are visible.  This avoids flickering
! 	 * when the added lines are not visible. */
  	if ((win = qf_find_win(qi)) != NULL && old_line_count < win->w_botline)
  	    redraw_buf_later(buf, NOT_VALID);
      }
--- 4167,4178 ----
  	{
  	    (void)qf_win_pos_update(qi, 0);
  
! 	    // restore curwin/curbuf and a few other things
  	    aucmd_restbuf(&aco);
  	}
  
! 	// Only redraw when added lines are visible.  This avoids flickering
! 	// when the added lines are not visible.
  	if ((win = qf_find_win(qi)) != NULL && old_line_count < win->w_botline)
  	    redraw_buf_later(buf, NOT_VALID);
      }
***************
*** 4264,4274 ****
  	    && (errbuf = buflist_findnr(qfp->qf_fnum)) != NULL
  	    && errbuf->b_fname != NULL)
      {
! 	if (qfp->qf_type == 1)	/* :helpgrep */
  	    STRCPY(IObuff, gettail(errbuf->b_fname));
  	else
  	{
! 	    /* shorten the file name if not done already */
  	    if (errbuf->b_sfname == NULL
  		    || mch_isFullName(errbuf->b_sfname))
  	    {
--- 4196,4206 ----
  	    && (errbuf = buflist_findnr(qfp->qf_fnum)) != NULL
  	    && errbuf->b_fname != NULL)
      {
! 	if (qfp->qf_type == 1)	// :helpgrep
  	    STRCPY(IObuff, gettail(errbuf->b_fname));
  	else
  	{
! 	    // shorten the file name if not done already
  	    if (errbuf->b_sfname == NULL
  		    || mch_isFullName(errbuf->b_sfname))
  	    {
***************
*** 4307,4315 ****
      IObuff[len++] = '|';
      IObuff[len++] = ' ';
  
!     /* Remove newlines and leading whitespace from the text.
!      * For an unrecognized line keep the indent, the compiler may
!      * mark a word with ^^^^. */
      qf_fmt_text(len > 3 ? skipwhite(qfp->qf_text) : qfp->qf_text,
  	    IObuff + len, IOSIZE - len);
  
--- 4239,4247 ----
      IObuff[len++] = '|';
      IObuff[len++] = ' ';
  
!     // Remove newlines and leading whitespace from the text.
!     // For an unrecognized line keep the indent, the compiler may
!     // mark a word with ^^^^.
      qf_fmt_text(len > 3 ? skipwhite(qfp->qf_text) : qfp->qf_text,
  	    IObuff + len, IOSIZE - len);
  
***************
*** 4342,4360 ****
  	    return;
  	}
  
! 	/* delete all existing lines */
  	while ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0)
  	    (void)ml_delete((linenr_T)1, FALSE);
      }
  
!     /* Check if there is anything to display */
      if (!qf_stack_empty(qi))
      {
  	char_u	dirname[MAXPATHL];
  
  	*dirname = NUL;
  
! 	/* Add one line for each error */
  	if (old_last == NULL)
  	{
  	    qfp = qi->qf_lists[qi->qf_curlist].qf_start;
--- 4274,4292 ----
  	    return;
  	}
  
! 	// delete all existing lines
  	while ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0)
  	    (void)ml_delete((linenr_T)1, FALSE);
      }
  
!     // Check if there is anything to display
      if (!qf_stack_empty(qi))
      {
  	char_u	dirname[MAXPATHL];
  
  	*dirname = NUL;
  
! 	// Add one line for each error
  	if (old_last == NULL)
  	{
  	    qfp = qi->qf_lists[qi->qf_curlist].qf_start;
***************
*** 4377,4399 ****
  	}
  
  	if (old_last == NULL)
! 	    /* Delete the empty line which is now at the end */
  	    (void)ml_delete(lnum + 1, FALSE);
      }
  
!     /* correct cursor position */
      check_lnums(TRUE);
  
      if (old_last == NULL)
      {
! 	/* Set the 'filetype' to "qf" each time after filling the buffer.
! 	 * This resembles reading a file into a buffer, it's more logical when
! 	 * using autocommands. */
  	++curbuf_lock;
  	set_option_value((char_u *)"ft", 0L, (char_u *)"qf", OPT_LOCAL);
  	curbuf->b_p_ma = FALSE;
  
! 	keep_filetype = TRUE;		/* don't detect 'filetype' */
  	apply_autocmds(EVENT_BUFREADPOST, (char_u *)"quickfix", NULL,
  							       FALSE, curbuf);
  	apply_autocmds(EVENT_BUFWINENTER, (char_u *)"quickfix", NULL,
--- 4309,4331 ----
  	}
  
  	if (old_last == NULL)
! 	    // Delete the empty line which is now at the end
  	    (void)ml_delete(lnum + 1, FALSE);
      }
  
!     // correct cursor position
      check_lnums(TRUE);
  
      if (old_last == NULL)
      {
! 	// Set the 'filetype' to "qf" each time after filling the buffer.
! 	// This resembles reading a file into a buffer, it's more logical when
! 	// using autocommands.
  	++curbuf_lock;
  	set_option_value((char_u *)"ft", 0L, (char_u *)"qf", OPT_LOCAL);
  	curbuf->b_p_ma = FALSE;
  
! 	keep_filetype = TRUE;		// don't detect 'filetype'
  	apply_autocmds(EVENT_BUFREADPOST, (char_u *)"quickfix", NULL,
  							       FALSE, curbuf);
  	apply_autocmds(EVENT_BUFWINENTER, (char_u *)"quickfix", NULL,
***************
*** 4401,4411 ****
  	keep_filetype = FALSE;
  	--curbuf_lock;
  
! 	/* make sure it will be redrawn */
  	redraw_curbuf_later(NOT_VALID);
      }
  
!     /* Restore KeyTyped, setting 'filetype' may reset it. */
      KeyTyped = old_KeyTyped;
  }
  
--- 4333,4343 ----
  	keep_filetype = FALSE;
  	--curbuf_lock;
  
! 	// make sure it will be redrawn
  	redraw_curbuf_later(NOT_VALID);
      }
  
!     // Restore KeyTyped, setting 'filetype' may reset it.
      KeyTyped = old_KeyTyped;
  }
  
***************
*** 4694,4700 ****
  
      if (is_loclist_cmd(eap->cmdidx))
      {
! 	/* Location list */
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	    return 0;
--- 4626,4632 ----
  
      if (is_loclist_cmd(eap->cmdidx))
      {
! 	// Location list
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	    return 0;
***************
*** 4707,4716 ****
  	if (qfp->qf_valid)
  	{
  	    if (eap->cmdidx == CMD_cdo || eap->cmdidx == CMD_ldo)
! 		sz++;	/* Count all valid entries */
  	    else if (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)
  	    {
! 		/* Count the number of files */
  		sz++;
  		prev_fnum = qfp->qf_fnum;
  	    }
--- 4639,4648 ----
  	if (qfp->qf_valid)
  	{
  	    if (eap->cmdidx == CMD_cdo || eap->cmdidx == CMD_ldo)
! 		sz++;	// Count all valid entries
  	    else if (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)
  	    {
! 		// Count the number of files
  		sz++;
  		prev_fnum = qfp->qf_fnum;
  	    }
***************
*** 4731,4737 ****
  
      if (is_loclist_cmd(eap->cmdidx))
      {
! 	/* Location list */
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	    return 0;
--- 4663,4669 ----
  
      if (is_loclist_cmd(eap->cmdidx))
      {
! 	// Location list
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	    return 0;
***************
*** 4755,4761 ****
  
      if (is_loclist_cmd(eap->cmdidx))
      {
! 	/* Location list */
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	    return 1;
--- 4687,4693 ----
  
      if (is_loclist_cmd(eap->cmdidx))
      {
! 	// Location list
  	qi = GET_LOC_LIST(curwin);
  	if (qi == NULL)
  	    return 1;
***************
*** 4764,4770 ****
      qfl = &qi->qf_lists[qi->qf_curlist];
      qfp = qfl->qf_start;
  
!     /* check if the list has valid errors */
      if (qfl->qf_count <= 0 || qfl->qf_nonevalid)
  	return 1;
  
--- 4696,4702 ----
      qfl = &qi->qf_lists[qi->qf_curlist];
      qfp = qfl->qf_start;
  
!     // check if the list has valid errors
      if (qfl->qf_count <= 0 || qfl->qf_nonevalid)
  	return 1;
  
***************
*** 4776,4782 ****
  	    {
  		if (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)
  		{
! 		    /* Count the number of files */
  		    eidx++;
  		    prev_fnum = qfp->qf_fnum;
  		}
--- 4708,4714 ----
  	    {
  		if (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)
  		{
! 		    // Count the number of files
  		    eidx++;
  		    prev_fnum = qfp->qf_fnum;
  		}
***************
*** 4802,4808 ****
      int		i, eidx;
      int		prev_fnum = 0;
  
!     /* check if the list has valid errors */
      if (qfl->qf_count <= 0 || qfl->qf_nonevalid)
  	return 1;
  
--- 4734,4740 ----
      int		i, eidx;
      int		prev_fnum = 0;
  
!     // check if the list has valid errors
      if (qfl->qf_count <= 0 || qfl->qf_nonevalid)
  	return 1;
  
***************
*** 4815,4821 ****
  	    {
  		if (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)
  		{
! 		    /* Count the number of files */
  		    eidx++;
  		    prev_fnum = qfp->qf_fnum;
  		}
--- 4747,4753 ----
  	    {
  		if (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)
  		{
! 		    // Count the number of files
  		    eidx++;
  		    prev_fnum = qfp->qf_fnum;
  		}
***************
*** 4873,4881 ****
  	}
      }
  
!     /* For cdo and ldo commands, jump to the nth valid error.
!      * For cfdo and lfdo commands, jump to the nth valid file entry.
!      */
      if (eap->cmdidx == CMD_cdo || eap->cmdidx == CMD_ldo
  	    || eap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo)
  	errornr = qf_get_nth_valid_entry(&qi->qf_lists[qi->qf_curlist],
--- 4805,4812 ----
  	}
      }
  
!     // For cdo and ldo commands, jump to the nth valid error.
!     // For cfdo and lfdo commands, jump to the nth valid file entry.
      if (eap->cmdidx == CMD_cdo || eap->cmdidx == CMD_ldo
  	    || eap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo)
  	errornr = qf_get_nth_valid_entry(&qi->qf_lists[qi->qf_curlist],
***************
*** 4949,4955 ****
      win_T	*wp = NULL;
      qf_info_T	*qi = &ql_info;
      char_u	*au_name = NULL;
!     int_u	save_qfid = 0;		/* init for gcc */
      int		res;
  
      switch (eap->cmdidx)
--- 4880,4886 ----
      win_T	*wp = NULL;
      qf_info_T	*qi = &ql_info;
      char_u	*au_name = NULL;
!     int_u	save_qfid = 0;		// init for gcc
      int		res;
  
      switch (eap->cmdidx)
***************
*** 4986,5001 ****
      if (is_loclist_cmd(eap->cmdidx))
  	wp = curwin;
  
!     /*
!      * This function is used by the :cfile, :cgetfile and :caddfile
!      * commands.
!      * :cfile always creates a new quickfix list and jumps to the
!      * first error.
!      * :cgetfile creates a new quickfix list but doesn't jump to the
!      * first error.
!      * :caddfile adds to an existing quickfix list. If there is no
!      * quickfix list then a new list is created.
!      */
      res = qf_init(wp, p_ef, p_efm, (eap->cmdidx != CMD_caddfile
  			&& eap->cmdidx != CMD_laddfile),
  			qf_cmdtitle(*eap->cmdlinep), enc);
--- 4917,4930 ----
      if (is_loclist_cmd(eap->cmdidx))
  	wp = curwin;
  
!     // This function is used by the :cfile, :cgetfile and :caddfile
!     // commands.
!     // :cfile always creates a new quickfix list and jumps to the
!     // first error.
!     // :cgetfile creates a new quickfix list but doesn't jump to the
!     // first error.
!     // :caddfile adds to an existing quickfix list. If there is no
!     // quickfix list then a new list is created.
      res = qf_init(wp, p_ef, p_efm, (eap->cmdidx != CMD_caddfile
  			&& eap->cmdidx != CMD_laddfile),
  			qf_cmdtitle(*eap->cmdlinep), enc);
***************
*** 5045,5056 ****
      static void
  vgr_init_regmatch(regmmatch_T *regmatch, char_u *s)
  {
!     /* Get the search pattern: either white-separated or enclosed in // */
      regmatch->regprog = NULL;
  
      if (s == NULL || *s == NUL)
      {
! 	/* Pattern is empty, use last search pattern. */
  	if (last_search_pat() == NULL)
  	{
  	    EMSG(_(e_noprevre));
--- 4974,4985 ----
      static void
  vgr_init_regmatch(regmmatch_T *regmatch, char_u *s)
  {
!     // Get the search pattern: either white-separated or enclosed in //
      regmatch->regprog = NULL;
  
      if (s == NULL || *s == NUL)
      {
! 	// Pattern is empty, use last search pattern.
  	if (last_search_pat() == NULL)
  	{
  	    EMSG(_(e_noprevre));
***************
*** 5083,5090 ****
  	vim_free(p);
      }
      msg_clr_eos();
!     msg_didout = FALSE;	    /* overwrite this message */
!     msg_nowait = TRUE;	    /* don't wait for this message */
      msg_col = 0;
      out_flush();
  }
--- 5012,5019 ----
  	vim_free(p);
      }
      msg_clr_eos();
!     msg_didout = FALSE;	    // overwrite this message
!     msg_nowait = TRUE;	    // don't wait for this message
      msg_col = 0;
      out_flush();
  }
***************
*** 5105,5120 ****
      buf_T	*buf;
  
  #if defined(FEAT_SYN_HL)
!     /* Don't do Filetype autocommands to avoid loading syntax and
!      * indent scripts, a great speed improvement. */
      save_ei = au_event_disable(",Filetype");
  #endif
!     /* Don't use modelines here, it's useless. */
      save_mls = p_mls;
      p_mls = 0;
  
!     /* Load file into a buffer, so that 'fileencoding' is detected,
!      * autocommands applied, etc. */
      buf = load_dummy_buffer(fname, dirname_start, dirname_now);
  
      p_mls = save_mls;
--- 5034,5049 ----
      buf_T	*buf;
  
  #if defined(FEAT_SYN_HL)
!     // Don't do Filetype autocommands to avoid loading syntax and
!     // indent scripts, a great speed improvement.
      save_ei = au_event_disable(",Filetype");
  #endif
!     // Don't use modelines here, it's useless.
      save_mls = p_mls;
      p_mls = 0;
  
!     // Load file into a buffer, so that 'fileencoding' is detected,
!     // autocommands applied, etc.
      buf = load_dummy_buffer(fname, dirname_start, dirname_now);
  
      p_mls = save_mls;
***************
*** 5137,5154 ****
  	int_u	    qfid,
  	char_u	    *title)
  {
!     /* Verify that the quickfix/location list was not freed by an autocmd */
      if (!qflist_valid(wp, qfid))
      {
  	if (wp != NULL)
  	{
! 	    /* An autocmd has freed the location list. */
  	    EMSG(_(e_loc_list_changed));
  	    return FALSE;
  	}
  	else
  	{
! 	    /* Quickfix list is not found, create a new one. */
  	    qf_new_list(qi, title);
  	    return TRUE;
  	}
--- 5066,5083 ----
  	int_u	    qfid,
  	char_u	    *title)
  {
!     // Verify that the quickfix/location list was not freed by an autocmd
      if (!qflist_valid(wp, qfid))
      {
  	if (wp != NULL)
  	{
! 	    // An autocmd has freed the location list.
  	    EMSG(_(e_loc_list_changed));
  	    return FALSE;
  	}
  	else
  	{
! 	    // Quickfix list is not found, create a new one.
  	    qf_new_list(qi, title);
  	    return TRUE;
  	}
***************
*** 5184,5195 ****
  	while (vim_regexec_multi(regmatch, curwin, buf, lnum,
  		    col, NULL, NULL) > 0)
  	{
! 	    /* Pass the buffer number so that it gets used even for a
! 	     * dummy buffer, unless duplicate_name is set, then the
! 	     * buffer will be wiped out below. */
  	    if (qf_add_entry(qi,
  			qi->qf_curlist,
! 			NULL,       /* dir */
  			fname,
  			NULL,
  			duplicate_name ? 0 : buf->b_fnum,
--- 5113,5124 ----
  	while (vim_regexec_multi(regmatch, curwin, buf, lnum,
  		    col, NULL, NULL) > 0)
  	{
! 	    // Pass the buffer number so that it gets used even for a
! 	    // dummy buffer, unless duplicate_name is set, then the
! 	    // buffer will be wiped out below.
  	    if (qf_add_entry(qi,
  			qi->qf_curlist,
! 			NULL,       // dir
  			fname,
  			NULL,
  			duplicate_name ? 0 : buf->b_fnum,
***************
*** 5197,5207 ****
  			    regmatch->startpos[0].lnum + lnum, FALSE),
  			regmatch->startpos[0].lnum + lnum,
  			regmatch->startpos[0].col + 1,
! 			FALSE,      /* vis_col */
! 			NULL,	    /* search pattern */
! 			0,	    /* nr */
! 			0,	    /* type */
! 			TRUE	    /* valid */
  			) == FAIL)
  	    {
  		got_int = TRUE;
--- 5126,5136 ----
  			    regmatch->startpos[0].lnum + lnum, FALSE),
  			regmatch->startpos[0].lnum + lnum,
  			regmatch->startpos[0].col + 1,
! 			FALSE,      // vis_col
! 			NULL,	    // search pattern
! 			0,	    // nr
! 			0,	    // type
! 			TRUE	    // valid
  			) == FAIL)
  	    {
  		got_int = TRUE;
***************
*** 5242,5252 ****
      buf = curbuf;
      qf_jump(qi, 0, 0, forceit);
      if (buf != curbuf)
! 	/* If we jumped to another buffer redrawing will already be
! 	 * taken care of. */
  	*redraw_for_dummy = FALSE;
  
!     /* Jump to the directory used after loading the buffer. */
      if (curbuf == first_match_buf && target_dir != NULL)
      {
  	exarg_T ea;
--- 5171,5181 ----
      buf = curbuf;
      qf_jump(qi, 0, 0, forceit);
      if (buf != curbuf)
! 	// If we jumped to another buffer redrawing will already be
! 	// taken care of.
  	*redraw_for_dummy = FALSE;
  
!     // Jump to the directory used after loading the buffer.
      if (curbuf == first_match_buf && target_dir != NULL)
      {
  	exarg_T ea;
***************
*** 5315,5321 ****
      else
  	tomatch = MAXLNUM;
  
!     /* Get the search pattern: either white-separated or enclosed in // */
      regmatch.regprog = NULL;
      title = vim_strsave(qf_cmdtitle(*eap->cmdlinep));
      p = skip_vimgrep_pat(eap->arg, &s, &flags);
--- 5244,5250 ----
      else
  	tomatch = MAXLNUM;
  
!     // Get the search pattern: either white-separated or enclosed in //
      regmatch.regprog = NULL;
      title = vim_strsave(qf_cmdtitle(*eap->cmdlinep));
      p = skip_vimgrep_pat(eap->arg, &s, &flags);
***************
*** 5340,5349 ****
  		&& eap->cmdidx != CMD_vimgrepadd
  		&& eap->cmdidx != CMD_lvimgrepadd)
  					|| qf_stack_empty(qi))
! 	/* make place for a new list */
  	qf_new_list(qi, title != NULL ? title : qf_cmdtitle(*eap->cmdlinep));
  
!     /* parse the list of arguments */
      if (get_arglist_exp(p, &fcount, &fnames, TRUE) == FAIL)
  	goto theend;
      if (fcount == 0)
--- 5269,5278 ----
  		&& eap->cmdidx != CMD_vimgrepadd
  		&& eap->cmdidx != CMD_lvimgrepadd)
  					|| qf_stack_empty(qi))
! 	// make place for a new list
  	qf_new_list(qi, title != NULL ? title : qf_cmdtitle(*eap->cmdlinep));
  
!     // parse the list of arguments
      if (get_arglist_exp(p, &fcount, &fnames, TRUE) == FAIL)
  	goto theend;
      if (fcount == 0)
***************
*** 5360,5371 ****
  	goto theend;
      }
  
!     /* Remember the current directory, because a BufRead autocommand that does
!      * ":lcd %:p:h" changes the meaning of short path names. */
      mch_dirname(dirname_start, MAXPATHL);
  
!      /* Remember the current quickfix list identifier, so that we can check for
!       * autocommands changing the current quickfix list. */
      save_qfid = qi->qf_lists[qi->qf_curlist].qf_id;
  
      seconds = (time_t)0;
--- 5289,5300 ----
  	goto theend;
      }
  
!     // Remember the current directory, because a BufRead autocommand that does
!     // ":lcd %:p:h" changes the meaning of short path names.
      mch_dirname(dirname_start, MAXPATHL);
  
!     // Remember the current quickfix list identifier, so that we can check for
!     // autocommands changing the current quickfix list.
      save_qfid = qi->qf_lists[qi->qf_curlist].qf_id;
  
      seconds = (time_t)0;
***************
*** 5374,5381 ****
  	fname = shorten_fname1(fnames[fi]);
  	if (time(NULL) > seconds)
  	{
! 	    /* Display the file name every second or so, show the user we are
! 	     * working on it. */
  	    seconds = time(NULL);
  	    vgr_display_fname(fname);
  	}
--- 5303,5310 ----
  	fname = shorten_fname1(fnames[fi]);
  	if (time(NULL) > seconds)
  	{
! 	    // Display the file name every second or so, show the user we are
! 	    // working on it.
  	    seconds = time(NULL);
  	    vgr_display_fname(fname);
  	}
***************
*** 5383,5389 ****
  	buf = buflist_findname_exp(fnames[fi]);
  	if (buf == NULL || buf->b_ml.ml_mfp == NULL)
  	{
! 	    /* Remember that a buffer with this name already exists. */
  	    duplicate_name = (buf != NULL);
  	    using_dummy = TRUE;
  	    redraw_for_dummy = TRUE;
--- 5312,5318 ----
  	buf = buflist_findname_exp(fnames[fi]);
  	if (buf == NULL || buf->b_ml.ml_mfp == NULL)
  	{
! 	    // Remember that a buffer with this name already exists.
  	    duplicate_name = (buf != NULL);
  	    using_dummy = TRUE;
  	    redraw_for_dummy = TRUE;
***************
*** 5391,5401 ****
  	    buf = vgr_load_dummy_buf(fname, dirname_start, dirname_now);
  	}
  	else
! 	    /* Use existing, loaded buffer. */
  	    using_dummy = FALSE;
  
! 	/* Check whether the quickfix list is still valid. When loading a
! 	 * buffer above, autocommands might have changed the quickfix list. */
  	if (!vgr_qflist_valid(wp, qi, save_qfid, qf_cmdtitle(*eap->cmdlinep)))
  	{
  	    FreeWild(fcount, fnames);
--- 5320,5330 ----
  	    buf = vgr_load_dummy_buf(fname, dirname_start, dirname_now);
  	}
  	else
! 	    // Use existing, loaded buffer.
  	    using_dummy = FALSE;
  
! 	// Check whether the quickfix list is still valid. When loading a
! 	// buffer above, autocommands might have changed the quickfix list.
  	if (!vgr_qflist_valid(wp, qi, save_qfid, qf_cmdtitle(*eap->cmdlinep)))
  	{
  	    FreeWild(fcount, fnames);
***************
*** 5410,5417 ****
  	}
  	else
  	{
! 	    /* Try for a match in all lines of the buffer.
! 	     * For ":1vimgrep" look for first match only. */
  	    found_match = vgr_match_buflines(qi, fname, buf, &regmatch,
  		    tomatch, duplicate_name, flags);
  
--- 5339,5346 ----
  	}
  	else
  	{
! 	    // Try for a match in all lines of the buffer.
! 	    // For ":1vimgrep" look for first match only.
  	    found_match = vgr_match_buflines(qi, fname, buf, &regmatch,
  		    tomatch, duplicate_name, flags);
  
***************
*** 5421,5442 ****
  		    first_match_buf = buf;
  		if (duplicate_name)
  		{
! 		    /* Never keep a dummy buffer if there is another buffer
! 		     * with the same name. */
  		    wipe_dummy_buffer(buf, dirname_start);
  		    buf = NULL;
  		}
  		else if (!cmdmod.hide
! 			    || buf->b_p_bh[0] == 'u'	/* "unload" */
! 			    || buf->b_p_bh[0] == 'w'	/* "wipe" */
! 			    || buf->b_p_bh[0] == 'd')	/* "delete" */
  		{
! 		    /* When no match was found we don't need to remember the
! 		     * buffer, wipe it out.  If there was a match and it
! 		     * wasn't the first one or we won't jump there: only
! 		     * unload the buffer.
! 		     * Ignore 'hidden' here, because it may lead to having too
! 		     * many swap files. */
  		    if (!found_match)
  		    {
  			wipe_dummy_buffer(buf, dirname_start);
--- 5350,5371 ----
  		    first_match_buf = buf;
  		if (duplicate_name)
  		{
! 		    // Never keep a dummy buffer if there is another buffer
! 		    // with the same name.
  		    wipe_dummy_buffer(buf, dirname_start);
  		    buf = NULL;
  		}
  		else if (!cmdmod.hide
! 			    || buf->b_p_bh[0] == 'u'	// "unload"
! 			    || buf->b_p_bh[0] == 'w'	// "wipe"
! 			    || buf->b_p_bh[0] == 'd')	// "delete"
  		{
! 		    // When no match was found we don't need to remember the
! 		    // buffer, wipe it out.  If there was a match and it
! 		    // wasn't the first one or we won't jump there: only
! 		    // unload the buffer.
! 		    // Ignore 'hidden' here, because it may lead to having too
! 		    // many swap files.
  		    if (!found_match)
  		    {
  			wipe_dummy_buffer(buf, dirname_start);
***************
*** 5445,5451 ****
  		    else if (buf != first_match_buf || (flags & VGR_NOJUMP))
  		    {
  			unload_dummy_buffer(buf, dirname_start);
! 			/* Keeping the buffer, remove the dummy flag. */
  			buf->b_flags &= ~BF_DUMMY;
  			buf = NULL;
  		    }
--- 5374,5380 ----
  		    else if (buf != first_match_buf || (flags & VGR_NOJUMP))
  		    {
  			unload_dummy_buffer(buf, dirname_start);
! 			// Keeping the buffer, remove the dummy flag.
  			buf->b_flags &= ~BF_DUMMY;
  			buf = NULL;
  		    }
***************
*** 5453,5472 ****
  
  		if (buf != NULL)
  		{
! 		    /* Keeping the buffer, remove the dummy flag. */
  		    buf->b_flags &= ~BF_DUMMY;
  
! 		    /* If the buffer is still loaded we need to use the
! 		     * directory we jumped to below. */
  		    if (buf == first_match_buf
  			    && target_dir == NULL
  			    && STRCMP(dirname_start, dirname_now) != 0)
  			target_dir = vim_strsave(dirname_now);
  
! 		    /* The buffer is still loaded, the Filetype autocommands
! 		     * need to be done now, in that buffer.  And the modelines
! 		     * need to be done (again).  But not the window-local
! 		     * options! */
  		    aucmd_prepbuf(&aco, buf);
  #if defined(FEAT_SYN_HL)
  		    apply_autocmds(EVENT_FILETYPE, buf->b_p_ft,
--- 5382,5401 ----
  
  		if (buf != NULL)
  		{
! 		    // Keeping the buffer, remove the dummy flag.
  		    buf->b_flags &= ~BF_DUMMY;
  
! 		    // If the buffer is still loaded we need to use the
! 		    // directory we jumped to below.
  		    if (buf == first_match_buf
  			    && target_dir == NULL
  			    && STRCMP(dirname_start, dirname_now) != 0)
  			target_dir = vim_strsave(dirname_now);
  
! 		    // The buffer is still loaded, the Filetype autocommands
! 		    // need to be done now, in that buffer.  And the modelines
! 		    // need to be done (again).  But not the window-local
! 		    // options!
  		    aucmd_prepbuf(&aco, buf);
  #if defined(FEAT_SYN_HL)
  		    apply_autocmds(EVENT_FILETYPE, buf->b_p_ft,
***************
*** 5491,5500 ****
      if (au_name != NULL)
  	apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,
  					       curbuf->b_fname, TRUE, curbuf);
!     /*
!      * The QuickFixCmdPost autocmd may free the quickfix list. Check the list
!      * is still valid.
!      */
      if (!qflist_valid(wp, save_qfid))
  	goto theend;
  
--- 5420,5427 ----
      if (au_name != NULL)
  	apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,
  					       curbuf->b_fname, TRUE, curbuf);
!     // The QuickFixCmdPost autocmd may free the quickfix list. Check the list
!     // is still valid.
      if (!qflist_valid(wp, save_qfid))
  	goto theend;
  
***************
*** 5511,5518 ****
      else
  	EMSG2(_(e_nomatch2), s);
  
!     /* If we loaded a dummy buffer into the current window, the autocommands
!      * may have messed up things, need to redraw and recompute folds. */
      if (redraw_for_dummy)
      {
  #ifdef FEAT_FOLDING
--- 5438,5445 ----
      else
  	EMSG2(_(e_nomatch2), s);
  
!     // If we loaded a dummy buffer into the current window, the autocommands
!     // may have messed up things, need to redraw and recompute folds.
      if (redraw_for_dummy)
      {
  #ifdef FEAT_FOLDING
***************
*** 5544,5551 ****
  	mch_dirname(dirname_now, MAXPATHL);
  	if (STRCMP(dirname_start, dirname_now) != 0)
  	{
! 	    /* If the directory has changed, change it back by building up an
! 	     * appropriate ex command and executing it. */
  	    exarg_T ea;
  
  	    ea.arg = dirname_start;
--- 5471,5478 ----
  	mch_dirname(dirname_now, MAXPATHL);
  	if (STRCMP(dirname_start, dirname_now) != 0)
  	{
! 	    // If the directory has changed, change it back by building up an
! 	    // appropriate ex command and executing it.
  	    exarg_T ea;
  
  	    ea.arg = dirname_start;
***************
*** 5571,5578 ****
      static buf_T *
  load_dummy_buffer(
      char_u	*fname,
!     char_u	*dirname_start,  /* in: old directory */
!     char_u	*resulting_dir)  /* out: new directory */
  {
      buf_T	*newbuf;
      bufref_T	newbufref;
--- 5498,5505 ----
      static buf_T *
  load_dummy_buffer(
      char_u	*fname,
!     char_u	*dirname_start,  // in: old directory
!     char_u	*resulting_dir)  // out: new directory
  {
      buf_T	*newbuf;
      bufref_T	newbufref;
***************
*** 5581,5612 ****
      aco_save_T	aco;
      int		readfile_result;
  
!     /* Allocate a buffer without putting it in the buffer list. */
      newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);
      if (newbuf == NULL)
  	return NULL;
      set_bufref(&newbufref, newbuf);
  
!     /* Init the options. */
      buf_copy_options(newbuf, BCO_ENTER | BCO_NOHELP);
  
!     /* need to open the memfile before putting the buffer in a window */
      if (ml_open(newbuf) == OK)
      {
! 	/* Make sure this buffer isn't wiped out by autocommands. */
  	++newbuf->b_locked;
  
! 	/* set curwin/curbuf to buf and save a few things */
  	aucmd_prepbuf(&aco, newbuf);
  
! 	/* Need to set the filename for autocommands. */
  	(void)setfname(curbuf, fname, NULL, FALSE);
  
! 	/* Create swap file now to avoid the ATTENTION message. */
  	check_need_swap(TRUE);
  
! 	/* Remove the "dummy" flag, otherwise autocommands may not
! 	 * work. */
  	curbuf->b_flags &= ~BF_DUMMY;
  
  	newbuf_to_wipe.br_buf = NULL;
--- 5508,5539 ----
      aco_save_T	aco;
      int		readfile_result;
  
!     // Allocate a buffer without putting it in the buffer list.
      newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);
      if (newbuf == NULL)
  	return NULL;
      set_bufref(&newbufref, newbuf);
  
!     // Init the options.
      buf_copy_options(newbuf, BCO_ENTER | BCO_NOHELP);
  
!     // need to open the memfile before putting the buffer in a window
      if (ml_open(newbuf) == OK)
      {
! 	// Make sure this buffer isn't wiped out by autocommands.
  	++newbuf->b_locked;
  
! 	// set curwin/curbuf to buf and save a few things
  	aucmd_prepbuf(&aco, newbuf);
  
! 	// Need to set the filename for autocommands.
  	(void)setfname(curbuf, fname, NULL, FALSE);
  
! 	// Create swap file now to avoid the ATTENTION message.
  	check_need_swap(TRUE);
  
! 	// Remove the "dummy" flag, otherwise autocommands may not
! 	// work.
  	curbuf->b_flags &= ~BF_DUMMY;
  
  	newbuf_to_wipe.br_buf = NULL;
***************
*** 5621,5650 ****
  	    failed = FALSE;
  	    if (curbuf != newbuf)
  	    {
! 		/* Bloody autocommands changed the buffer!  Can happen when
! 		 * using netrw and editing a remote file.  Use the current
! 		 * buffer instead, delete the dummy one after restoring the
! 		 * window stuff. */
  		set_bufref(&newbuf_to_wipe, newbuf);
  		newbuf = curbuf;
  	    }
  	}
  
! 	/* restore curwin/curbuf and a few other things */
  	aucmd_restbuf(&aco);
  	if (newbuf_to_wipe.br_buf != NULL && bufref_valid(&newbuf_to_wipe))
  	    wipe_buffer(newbuf_to_wipe.br_buf, FALSE);
  
! 	/* Add back the "dummy" flag, otherwise buflist_findname_stat() won't
! 	 * skip it. */
  	newbuf->b_flags |= BF_DUMMY;
      }
  
!     /*
!      * When autocommands/'autochdir' option changed directory: go back.
!      * Let the caller know what the resulting dir was first, in case it is
!      * important.
!      */
      mch_dirname(resulting_dir, MAXPATHL);
      restore_start_dir(dirname_start);
  
--- 5548,5575 ----
  	    failed = FALSE;
  	    if (curbuf != newbuf)
  	    {
! 		// Bloody autocommands changed the buffer!  Can happen when
! 		// using netrw and editing a remote file.  Use the current
! 		// buffer instead, delete the dummy one after restoring the
! 		// window stuff.
  		set_bufref(&newbuf_to_wipe, newbuf);
  		newbuf = curbuf;
  	    }
  	}
  
! 	// restore curwin/curbuf and a few other things
  	aucmd_restbuf(&aco);
  	if (newbuf_to_wipe.br_buf != NULL && bufref_valid(&newbuf_to_wipe))
  	    wipe_buffer(newbuf_to_wipe.br_buf, FALSE);
  
! 	// Add back the "dummy" flag, otherwise buflist_findname_stat() won't
! 	// skip it.
  	newbuf->b_flags |= BF_DUMMY;
      }
  
!     // When autocommands/'autochdir' option changed directory: go back.
!     // Let the caller know what the resulting dir was first, in case it is
!     // important.
      mch_dirname(resulting_dir, MAXPATHL);
      restore_start_dir(dirname_start);
  
***************
*** 5666,5690 ****
      static void
  wipe_dummy_buffer(buf_T *buf, char_u *dirname_start)
  {
!     if (curbuf != buf)		/* safety check */
      {
  #if defined(FEAT_EVAL)
  	cleanup_T   cs;
  
! 	/* Reset the error/interrupt/exception state here so that aborting()
! 	 * returns FALSE when wiping out the buffer.  Otherwise it doesn't
! 	 * work when got_int is set. */
  	enter_cleanup(&cs);
  #endif
  
  	wipe_buffer(buf, FALSE);
  
  #if defined(FEAT_EVAL)
! 	/* Restore the error/interrupt/exception state if not discarded by a
! 	 * new aborting error, interrupt, or uncaught exception. */
  	leave_cleanup(&cs);
  #endif
! 	/* When autocommands/'autochdir' option changed directory: go back. */
  	restore_start_dir(dirname_start);
      }
  }
--- 5591,5615 ----
      static void
  wipe_dummy_buffer(buf_T *buf, char_u *dirname_start)
  {
!     if (curbuf != buf)		// safety check
      {
  #if defined(FEAT_EVAL)
  	cleanup_T   cs;
  
! 	// Reset the error/interrupt/exception state here so that aborting()
! 	// returns FALSE when wiping out the buffer.  Otherwise it doesn't
! 	// work when got_int is set.
  	enter_cleanup(&cs);
  #endif
  
  	wipe_buffer(buf, FALSE);
  
  #if defined(FEAT_EVAL)
! 	// Restore the error/interrupt/exception state if not discarded by a
! 	// new aborting error, interrupt, or uncaught exception.
  	leave_cleanup(&cs);
  #endif
! 	// When autocommands/'autochdir' option changed directory: go back.
  	restore_start_dir(dirname_start);
      }
  }
***************
*** 5697,5707 ****
      static void
  unload_dummy_buffer(buf_T *buf, char_u *dirname_start)
  {
!     if (curbuf != buf)		/* safety check */
      {
  	close_buffer(NULL, buf, DOBUF_UNLOAD, FALSE);
  
! 	/* When autocommands/'autochdir' option changed directory: go back. */
  	restore_start_dir(dirname_start);
      }
  }
--- 5622,5632 ----
      static void
  unload_dummy_buffer(buf_T *buf, char_u *dirname_start)
  {
!     if (curbuf != buf)		// safety check
      {
  	close_buffer(NULL, buf, DOBUF_UNLOAD, FALSE);
  
! 	// When autocommands/'autochdir' option changed directory: go back.
  	restore_start_dir(dirname_start);
      }
  }
***************
*** 5741,5747 ****
      qfp = qi->qf_lists[qf_idx].qf_start;
      for (i = 1; !got_int && i <= qi->qf_lists[qf_idx].qf_count; ++i)
      {
! 	/* Handle entries with a non-existing buffer number. */
  	bufnum = qfp->qf_fnum;
  	if (bufnum != 0 && (buflist_findnr(bufnum) == NULL))
  	    bufnum = 0;
--- 5666,5672 ----
      qfp = qi->qf_lists[qf_idx].qf_start;
      for (i = 1; !got_int && i <= qi->qf_lists[qf_idx].qf_count; ++i)
      {
! 	// Handle entries with a non-existing buffer number.
  	bufnum = qfp->qf_fnum;
  	if (bufnum != 0 && (buflist_findnr(bufnum) == NULL))
  	    bufnum = 0;
***************
*** 5772,5780 ****
      return OK;
  }
  
! /*
!  * Flags used by getqflist()/getloclist() to determine which fields to return.
!  */
  enum {
      QF_GETLIST_NONE	= 0x0,
      QF_GETLIST_TITLE	= 0x1,
--- 5697,5703 ----
      return OK;
  }
  
! // Flags used by getqflist()/getloclist() to determine which fields to return.
  enum {
      QF_GETLIST_NONE	= 0x0,
      QF_GETLIST_TITLE	= 0x1,
***************
*** 5803,5814 ****
      dictitem_T	*efm_di;
      list_T	*l;
  
!     /* Only a List value is supported */
      if (di->di_tv.v_type == VAR_LIST && di->di_tv.vval.v_list != NULL)
      {
! 	/* If errorformat is supplied then use it, otherwise use the 'efm'
! 	 * option setting
! 	 */
  	if ((efm_di = dict_find(what, (char_u *)"efm", -1)) != NULL)
  	{
  	    if (efm_di->di_tv.v_type != VAR_STRING ||
--- 5726,5736 ----
      dictitem_T	*efm_di;
      list_T	*l;
  
!     // Only a List value is supported
      if (di->di_tv.v_type == VAR_LIST && di->di_tv.vval.v_list != NULL)
      {
! 	// If errorformat is supplied then use it, otherwise use the 'efm'
! 	// option setting
  	if ((efm_di = dict_find(what, (char_u *)"efm", -1)) != NULL)
  	{
  	    if (efm_di->di_tv.v_type != VAR_STRING ||
***************
*** 5847,5854 ****
  {
      win_T	*win;
  
!     /* The quickfix window can be opened even if the quickfix list is not set
!      * using ":copen". This is not true for location lists.  */
      if (qi == NULL)
  	return 0;
      win = qf_find_win(qi);
--- 5769,5776 ----
  {
      win_T	*win;
  
!     // The quickfix window can be opened even if the quickfix list is not set
!     // using ":copen". This is not true for location lists.
      if (qi == NULL)
  	return 0;
      win = qf_find_win(qi);
***************
*** 5922,5934 ****
      int		qf_idx;
      dictitem_T	*di;
  
!     qf_idx = qi->qf_curlist;	/* default is the current list */
      if ((di = dict_find(what, (char_u *)"nr", -1)) != NULL)
      {
! 	/* Use the specified quickfix/location list */
  	if (di->di_tv.v_type == VAR_NUMBER)
  	{
! 	    /* for zero use the current list */
  	    if (di->di_tv.vval.v_number != 0)
  	    {
  		qf_idx = di->di_tv.vval.v_number - 1;
--- 5844,5856 ----
      int		qf_idx;
      dictitem_T	*di;
  
!     qf_idx = qi->qf_curlist;	// default is the current list
      if ((di = dict_find(what, (char_u *)"nr", -1)) != NULL)
      {
! 	// Use the specified quickfix/location list
  	if (di->di_tv.v_type == VAR_NUMBER)
  	{
! 	    // for zero use the current list
  	    if (di->di_tv.vval.v_number != 0)
  	    {
  		qf_idx = di->di_tv.vval.v_number - 1;
***************
*** 5939,5945 ****
  	else if (di->di_tv.v_type == VAR_STRING
  		&& di->di_tv.vval.v_string != NULL
  		&& STRCMP(di->di_tv.vval.v_string, "$") == 0)
! 	    /* Get the last quickfix list number */
  	    qf_idx = qi->qf_listcount - 1;
  	else
  	    qf_idx = INVALID_QFIDX;
--- 5861,5867 ----
  	else if (di->di_tv.v_type == VAR_STRING
  		&& di->di_tv.vval.v_string != NULL
  		&& STRCMP(di->di_tv.vval.v_string, "$") == 0)
! 	    // Get the last quickfix list number
  	    qf_idx = qi->qf_listcount - 1;
  	else
  	    qf_idx = INVALID_QFIDX;
***************
*** 5947,5958 ****
  
      if ((di = dict_find(what, (char_u *)"id", -1)) != NULL)
      {
! 	/* Look for a list with the specified id */
  	if (di->di_tv.v_type == VAR_NUMBER)
  	{
! 	    /*
! 	     * For zero, use the current list or the list specified by 'nr'
! 	     */
  	    if (di->di_tv.vval.v_number != 0)
  		qf_idx = qf_id2nr(qi, di->di_tv.vval.v_number);
  	}
--- 5869,5878 ----
  
      if ((di = dict_find(what, (char_u *)"id", -1)) != NULL)
      {
! 	// Look for a list with the specified id
  	if (di->di_tv.v_type == VAR_NUMBER)
  	{
! 	    // For zero, use the current list or the list specified by 'nr'
  	    if (di->di_tv.vval.v_number != 0)
  		qf_idx = qf_id2nr(qi, di->di_tv.vval.v_number);
  	}
***************
*** 6085,6091 ****
  {
      int idx = qi->qf_lists[qf_idx].qf_index;
      if (qf_list_empty(qi, qf_idx))
! 	/* For empty lists, qf_index is set to 1 */
  	idx = 0;
      return dict_add_number(retdict, "idx", idx);
  }
--- 6005,6011 ----
  {
      int idx = qi->qf_lists[qf_idx].qf_index;
      if (qf_list_empty(qi, qf_idx))
! 	// For empty lists, qf_index is set to 1
  	idx = 0;
      return dict_add_number(retdict, "idx", idx);
  }
***************
*** 6116,6122 ****
      if (!qf_stack_empty(qi))
  	qf_idx = qf_getprop_qfidx(qi, what);
  
!     /* List is not present or is empty */
      if (qf_stack_empty(qi) || qf_idx == INVALID_QFIDX)
  	return qf_getprop_defaults(qi, flags, retdict);
  
--- 6036,6042 ----
      if (!qf_stack_empty(qi))
  	qf_idx = qf_getprop_qfidx(qi, what);
  
!     // List is not present or is empty
      if (qf_stack_empty(qi) || qf_idx == INVALID_QFIDX)
  	return qf_getprop_defaults(qi, flags, retdict);
  
***************
*** 6243,6255 ****
  
      if (action == ' ' || qf_idx == qi->qf_listcount)
      {
! 	/* make place for a new list */
  	qf_new_list(qi, title);
  	qf_idx = qi->qf_curlist;
  	qfl = &qi->qf_lists[qf_idx];
      }
      else if (action == 'a' && !qf_list_empty(qi, qf_idx))
! 	/* Adding to existing list, use last entry. */
  	old_last = qfl->qf_last;
      else if (action == 'r')
      {
--- 6163,6175 ----
  
      if (action == ' ' || qf_idx == qi->qf_listcount)
      {
! 	// make place for a new list
  	qf_new_list(qi, title);
  	qf_idx = qi->qf_curlist;
  	qfl = &qi->qf_lists[qf_idx];
      }
      else if (action == 'a' && !qf_list_empty(qi, qf_idx))
! 	// Adding to existing list, use last entry.
  	old_last = qfl->qf_last;
      else if (action == 'r')
      {
***************
*** 6260,6266 ****
      for (li = list->lv_first; li != NULL; li = li->li_next)
      {
  	if (li->li_tv.v_type != VAR_DICT)
! 	    continue; /* Skip non-dict items */
  
  	d = li->li_tv.vval.v_dict;
  	if (d == NULL)
--- 6180,6186 ----
      for (li = list->lv_first; li != NULL; li = li->li_next)
      {
  	if (li->li_tv.v_type != VAR_DICT)
! 	    continue; // Skip non-dict items
  
  	d = li->li_tv.vval.v_dict;
  	if (d == NULL)
***************
*** 6272,6278 ****
      }
  
      if (qfl->qf_index == 0)
! 	/* no valid entry */
  	qfl->qf_nonevalid = TRUE;
      else
  	qfl->qf_nonevalid = FALSE;
--- 6192,6198 ----
      }
  
      if (qfl->qf_index == 0)
! 	// no valid entry
  	qfl->qf_nonevalid = TRUE;
      else
  	qfl->qf_nonevalid = FALSE;
***************
*** 6283,6289 ****
  	    qfl->qf_index = 1;
      }
  
!     /* Don't update the cursor in quickfix window when appending entries */
      qf_update_buffer(qi, old_last);
  
      return retval;
--- 6203,6209 ----
  	    qfl->qf_index = 1;
      }
  
!     // Don't update the cursor in quickfix window when appending entries
      qf_update_buffer(qi, old_last);
  
      return retval;
***************
*** 6300,6330 ****
  	int		*newlist)
  {
      dictitem_T	*di;
!     int		qf_idx = qi->qf_curlist;    /* default is the current list */
  
      if ((di = dict_find(what, (char_u *)"nr", -1)) != NULL)
      {
! 	/* Use the specified quickfix/location list */
  	if (di->di_tv.v_type == VAR_NUMBER)
  	{
! 	    /* for zero use the current list */
  	    if (di->di_tv.vval.v_number != 0)
  		qf_idx = di->di_tv.vval.v_number - 1;
  
  	    if ((action == ' ' || action == 'a') && qf_idx == qi->qf_listcount)
  	    {
! 		/*
! 		 * When creating a new list, accept qf_idx pointing to the next
! 		 * non-available list and add the new list at the end of the
! 		 * stack.
! 		 */
  		*newlist = TRUE;
  		qf_idx = qf_stack_empty(qi) ? 0 : qi->qf_listcount - 1;
  	    }
  	    else if (qf_idx < 0 || qf_idx >= qi->qf_listcount)
  		return INVALID_QFIDX;
  	    else if (action != ' ')
! 		*newlist = FALSE;	/* use the specified list */
  	}
  	else if (di->di_tv.v_type == VAR_STRING
  		&& di->di_tv.vval.v_string != NULL
--- 6220,6248 ----
  	int		*newlist)
  {
      dictitem_T	*di;
!     int		qf_idx = qi->qf_curlist;    // default is the current list
  
      if ((di = dict_find(what, (char_u *)"nr", -1)) != NULL)
      {
! 	// Use the specified quickfix/location list
  	if (di->di_tv.v_type == VAR_NUMBER)
  	{
! 	    // for zero use the current list
  	    if (di->di_tv.vval.v_number != 0)
  		qf_idx = di->di_tv.vval.v_number - 1;
  
  	    if ((action == ' ' || action == 'a') && qf_idx == qi->qf_listcount)
  	    {
! 		// When creating a new list, accept qf_idx pointing to the next
! 		// non-available list and add the new list at the end of the
! 		// stack.
  		*newlist = TRUE;
  		qf_idx = qf_stack_empty(qi) ? 0 : qi->qf_listcount - 1;
  	    }
  	    else if (qf_idx < 0 || qf_idx >= qi->qf_listcount)
  		return INVALID_QFIDX;
  	    else if (action != ' ')
! 		*newlist = FALSE;	// use the specified list
  	}
  	else if (di->di_tv.v_type == VAR_STRING
  		&& di->di_tv.vval.v_string != NULL
***************
*** 6343,6349 ****
  
      if (!*newlist && (di = dict_find(what, (char_u *)"id", -1)) != NULL)
      {
! 	/* Use the quickfix/location list with the specified id */
  	if (di->di_tv.v_type != VAR_NUMBER)
  	    return INVALID_QFIDX;
  
--- 6261,6267 ----
  
      if (!*newlist && (di = dict_find(what, (char_u *)"id", -1)) != NULL)
      {
! 	// Use the quickfix/location list with the specified id
  	if (di->di_tv.v_type != VAR_NUMBER)
  	    return INVALID_QFIDX;
  
***************
*** 6406,6412 ****
      dictitem_T	*efm_di;
      int		retval = FAIL;
  
!     /* Use the user supplied errorformat settings (if present) */
      if ((efm_di = dict_find(what, (char_u *)"efm", -1)) != NULL)
      {
  	if (efm_di->di_tv.v_type != VAR_STRING ||
--- 6324,6330 ----
      dictitem_T	*efm_di;
      int		retval = FAIL;
  
!     // Use the user supplied errorformat settings (if present)
      if ((efm_di = dict_find(what, (char_u *)"efm", -1)) != NULL)
      {
  	if (efm_di->di_tv.v_type != VAR_STRING ||
***************
*** 6415,6421 ****
  	errorformat = efm_di->di_tv.vval.v_string;
      }
  
!     /* Only a List value is supported */
      if (di->di_tv.v_type != VAR_LIST || di->di_tv.vval.v_list == NULL)
  	return FAIL;
  
--- 6333,6339 ----
  	errorformat = efm_di->di_tv.vval.v_string;
      }
  
!     // Only a List value is supported
      if (di->di_tv.v_type != VAR_LIST || di->di_tv.vval.v_list == NULL)
  	return FAIL;
  
***************
*** 6462,6468 ****
  	newlist = TRUE;
  
      qf_idx = qf_setprop_get_qfidx(qi, what, action, &newlist);
!     if (qf_idx == INVALID_QFIDX)	/* List not found */
  	return FAIL;
  
      if (newlist)
--- 6380,6386 ----
  	newlist = TRUE;
  
      qf_idx = qf_setprop_get_qfidx(qi, what, action, &newlist);
!     if (qf_idx == INVALID_QFIDX)	// List not found
  	return FAIL;
  
      if (newlist)
***************
*** 6516,6522 ****
  
      if (qfwin != NULL)
      {
! 	/* If the quickfix/location list window is open, then clear it */
  	if (qi->qf_curlist < qi->qf_listcount)
  	    qf_free(&qi->qf_lists[qi->qf_curlist]);
  	qf_update_buffer(qi, NULL);
--- 6434,6440 ----
  
      if (qfwin != NULL)
      {
! 	// If the quickfix/location list window is open, then clear it
  	if (qi->qf_curlist < qi->qf_listcount)
  	    qf_free(&qi->qf_lists[qi->qf_curlist]);
  	qf_update_buffer(qi, NULL);
***************
*** 6524,6532 ****
  
      if (wp != NULL && IS_LL_WINDOW(wp))
      {
! 	/* If in the location list window, then use the non-location list
! 	 * window with this location list (if present)
! 	 */
  	llwin = find_win_with_ll(qi);
  	if (llwin != NULL)
  	    wp = llwin;
--- 6442,6449 ----
  
      if (wp != NULL && IS_LL_WINDOW(wp))
      {
! 	// If in the location list window, then use the non-location list
! 	// window with this location list (if present)
  	llwin = find_win_with_ll(qi);
  	if (llwin != NULL)
  	    wp = llwin;
***************
*** 6535,6551 ****
      qf_free_all(wp);
      if (wp == NULL)
      {
! 	/* quickfix list */
  	qi->qf_curlist = 0;
  	qi->qf_listcount = 0;
      }
      else if (IS_LL_WINDOW(orig_wp))
      {
! 	/* If the location list window is open, then create a new empty
! 	 * location list */
  	qf_info_T *new_ll = ll_new_list();
  
! 	/* first free the list reference in the location list window */
  	ll_free_all(&orig_wp->w_llist_ref);
  
  	orig_wp->w_llist_ref = new_ll;
--- 6452,6468 ----
      qf_free_all(wp);
      if (wp == NULL)
      {
! 	// quickfix list
  	qi->qf_curlist = 0;
  	qi->qf_listcount = 0;
      }
      else if (IS_LL_WINDOW(orig_wp))
      {
! 	// If the location list window is open, then create a new empty
! 	// location list
  	qf_info_T *new_ll = ll_new_list();
  
! 	// first free the list reference in the location list window
  	ll_free_all(&orig_wp->w_llist_ref);
  
  	orig_wp->w_llist_ref = new_ll;
***************
*** 6582,6588 ****
  
      if (action == 'f')
      {
! 	/* Free the entire quickfix or location list stack */
  	qf_free_stack(wp, qi);
      }
      else if (what != NULL)
--- 6499,6505 ----
  
      if (action == 'f')
      {
! 	// Free the entire quickfix or location list stack
  	qf_free_stack(wp, qi);
      }
      else if (what != NULL)
***************
*** 6643,6652 ****
  	}
  	if (IS_LL_WINDOW(win) && (win->w_llist_ref->qf_refcount == 1))
  	{
! 	    /* In a location list window and none of the other windows is
! 	     * referring to this location list. Mark the location list
! 	     * context as still in use.
! 	     */
  	    abort = mark_quickfix_ctx(win->w_llist_ref, copyID);
  	    if (abort)
  		return abort;
--- 6560,6568 ----
  	}
  	if (IS_LL_WINDOW(win) && (win->w_llist_ref->qf_refcount == 1))
  	{
! 	    // In a location list window and none of the other windows is
! 	    // referring to this location list. Mark the location list
! 	    // context as still in use.
  	    abort = mark_quickfix_ctx(win->w_llist_ref, copyID);
  	    if (abort)
  		return abort;
***************
*** 6694,6700 ****
  #endif
      }
  
!     /* Must come after autocommands. */
      if (is_loclist_cmd(eap->cmdidx))
      {
  	qi = ll_get_or_alloc_list(curwin);
--- 6610,6616 ----
  #endif
      }
  
!     // Must come after autocommands.
      if (is_loclist_cmd(eap->cmdidx))
      {
  	qi = ll_get_or_alloc_list(curwin);
***************
*** 6807,6814 ****
  	wp = curwin;
      }
  
!     /* Evaluate the expression.  When the result is a string or a list we can
!      * use it to fill the errorlist. */
      tv = eval_expr(eap->arg, NULL);
      if (tv != NULL)
      {
--- 6723,6730 ----
  	wp = curwin;
      }
  
!     // Evaluate the expression.  When the result is a string or a list we can
!     // use it to fill the errorlist.
      tv = eval_expr(eap->arg, NULL);
      if (tv != NULL)
      {
***************
*** 6854,6874 ****
      win_T	*wp;
      qf_info_T	*qi;
  
!     /* If the current window is a help window, then use it */
      if (bt_help(curwin->w_buffer))
  	wp = curwin;
      else
! 	/* Find an existing help window */
  	wp = qf_find_help_win();
  
!     if (wp == NULL)	    /* Help window not found */
  	qi = NULL;
      else
  	qi = wp->w_llist;
  
      if (qi == NULL)
      {
! 	/* Allocate a new location list for help text matches */
  	if ((qi = ll_new_list()) == NULL)
  	    return NULL;
  	*new_ll = TRUE;
--- 6770,6790 ----
      win_T	*wp;
      qf_info_T	*qi;
  
!     // If the current window is a help window, then use it
      if (bt_help(curwin->w_buffer))
  	wp = curwin;
      else
! 	// Find an existing help window
  	wp = qf_find_help_win();
  
!     if (wp == NULL)	    // Help window not found
  	qi = NULL;
      else
  	qi = wp->w_llist;
  
      if (qi == NULL)
      {
! 	// Allocate a new location list for help text matches
  	if ((qi = ll_new_list()) == NULL)
  	    return NULL;
  	*new_ll = TRUE;
***************
*** 6901,6908 ****
      {
  	char_u    *line = IObuff;
  #ifdef FEAT_MBYTE
! 	/* Convert a line if 'encoding' is not utf-8 and
! 	 * the line contains a non-ASCII character. */
  	if (p_vc->vc_type != CONV_NONE
  		&& has_non_ascii(IObuff))
  	{
--- 6817,6824 ----
      {
  	char_u    *line = IObuff;
  #ifdef FEAT_MBYTE
! 	// Convert a line if 'encoding' is not utf-8 and
! 	// the line contains a non-ASCII character.
  	if (p_vc->vc_type != CONV_NONE
  		&& has_non_ascii(IObuff))
  	{
***************
*** 6916,6940 ****
  	{
  	    int	l = (int)STRLEN(line);
  
! 	    /* remove trailing CR, LF, spaces, etc. */
  	    while (l > 0 && line[l - 1] <= ' ')
  		line[--l] = NUL;
  
  	    if (qf_add_entry(qi,
  			qi->qf_curlist,
! 			NULL,	/* dir */
  			fname,
  			NULL,
  			0,
  			line,
  			lnum,
  			(int)(p_regmatch->startp[0] - line)
! 			+ 1, /* col */
! 			FALSE,	/* vis_col */
! 			NULL,	/* search pattern */
! 			0,		/* nr */
! 			1,		/* type */
! 			TRUE	/* valid */
  			) == FAIL)
  	    {
  		got_int = TRUE;
--- 6832,6856 ----
  	{
  	    int	l = (int)STRLEN(line);
  
! 	    // remove trailing CR, LF, spaces, etc.
  	    while (l > 0 && line[l - 1] <= ' ')
  		line[--l] = NUL;
  
  	    if (qf_add_entry(qi,
  			qi->qf_curlist,
! 			NULL,	// dir
  			fname,
  			NULL,
  			0,
  			line,
  			lnum,
  			(int)(p_regmatch->startp[0] - line)
! 			+ 1,	// col
! 			FALSE,	// vis_col
! 			NULL,	// search pattern
! 			0,	// nr
! 			1,	// type
! 			TRUE	// valid
  			) == FAIL)
  	    {
  		got_int = TRUE;
***************
*** 6976,6982 ****
      char_u	**fnames;
      int		fi;
  
!     /* Find all "*.txt" and "*.??x" files in the "doc" directory. */
      add_pathsep(dirname);
      STRCAT(dirname, "doc/*.\\(txt\\|??x\\)");
      if (gen_expand_wildcards(1, &dirname, &fcount,
--- 6892,6898 ----
      char_u	**fnames;
      int		fi;
  
!     // Find all "*.txt" and "*.??x" files in the "doc" directory.
      add_pathsep(dirname);
      STRCAT(dirname, "doc/*.\\(txt\\|??x\\)");
      if (gen_expand_wildcards(1, &dirname, &fcount,
***************
*** 6986,6992 ****
  	for (fi = 0; fi < fcount && !got_int; ++fi)
  	{
  #ifdef FEAT_MULTI_LANG
! 	    /* Skip files for a different language. */
  	    if (lang != NULL
  		    && STRNICMP(lang, fnames[fi]
  				    + STRLEN(fnames[fi]) - 3, 2) != 0
--- 6902,6908 ----
  	for (fi = 0; fi < fcount && !got_int; ++fi)
  	{
  #ifdef FEAT_MULTI_LANG
! 	    // Skip files for a different language.
  	    if (lang != NULL
  		    && STRNICMP(lang, fnames[fi]
  				    + STRLEN(fnames[fi]) - 3, 2) != 0
***************
*** 7020,7034 ****
  #ifdef FEAT_MBYTE
      vimconv_T	vc;
  
!     /* Help files are in utf-8 or latin1, convert lines when 'encoding'
!      * differs. */
      vc.vc_type = CONV_NONE;
      if (!enc_utf8)
  	convert_setup(&vc, (char_u *)"utf-8", p_enc);
  #endif
  
  
!     /* Go through all the directories in 'runtimepath' */
      p = p_rtp;
      while (*p != NUL && !got_int)
      {
--- 6936,6950 ----
  #ifdef FEAT_MBYTE
      vimconv_T	vc;
  
!     // Help files are in utf-8 or latin1, convert lines when 'encoding'
!     // differs.
      vc.vc_type = CONV_NONE;
      if (!enc_utf8)
  	convert_setup(&vc, (char_u *)"utf-8", p_enc);
  #endif
  
  
!     // Go through all the directories in 'runtimepath'
      p = p_rtp;
      while (*p != NUL && !got_int)
      {
***************
*** 7124,7134 ****
  	apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,
  					       curbuf->b_fname, TRUE, curbuf);
  	if (!new_qi && IS_LL_STACK(qi) && qf_find_buf(qi) == NULL)
! 	    /* autocommands made "qi" invalid */
  	    return;
      }
  
!     /* Jump to first match. */
      if (!qf_list_empty(qi, qi->qf_curlist))
  	qf_jump(qi, 0, 0, FALSE);
      else
--- 7040,7050 ----
  	apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,
  					       curbuf->b_fname, TRUE, curbuf);
  	if (!new_qi && IS_LL_STACK(qi) && qf_find_buf(qi) == NULL)
! 	    // autocommands made "qi" invalid
  	    return;
      }
  
!     // Jump to first match.
      if (!qf_list_empty(qi, qi->qf_curlist))
  	qf_jump(qi, 0, 0, FALSE);
      else
*** ../vim-8.1.0460/src/version.c	2018-10-07 20:14:53.091279680 +0200
--- src/version.c	2018-10-07 20:25:44.858426041 +0200
***************
*** 794,795 ****
--- 794,797 ----
  {   /* Add new patch number below this line */
+ /**/
+     461,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
169. You hire a housekeeper for your home page.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
