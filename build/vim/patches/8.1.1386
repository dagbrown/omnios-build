To: vim_dev@googlegroups.com
Subject: Patch 8.1.1386
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.1.1386
Problem:    Unessesary type casts for lalloc().
Solution:   Remove type casts.  Change lalloc(size, TRUE) to alloc(size).
Files:	    src/buffer.c, src/change.c, src/channel.c, src/diff.c, src/edit.c,
            src/eval.c, src/ex_cmds.c, src/ex_getln.c, src/fileio.c,
            src/getchar.c, src/gui_mac.c, src/insexpand.c, src/gui_w32.c,
            src/gui_x11.c, src/menu.c, src/netbeans.c, src/ops.c,
            src/os_mswin.c, src/os_amiga.c, src/os_qnx.c, src/os_unix.c,
            src/os_win32.c, src/popupmnu.c, src/quickfix.c, src/regexp.c,
            src/regexp_nfa.c, src/screen.c, src/search.c, src/sign.c,
            src/spell.c, src/spellfile.c, src/syntax.c, src/tag.c,
            src/terminal.c, src/textprop.c, src/ui.c, src/undo.c,
            src/userfunc.c, src/winclip.c, src/window.c


*** ../vim-8.1.1385/src/buffer.c	2019-05-24 18:48:36.750128544 +0200
--- src/buffer.c	2019-05-24 19:28:49.952814515 +0200
***************
*** 1958,1964 ****
      }
      if (buf != curbuf || curbuf == NULL)
      {
! 	buf = (buf_T *)alloc_clear((unsigned)sizeof(buf_T));
  	if (buf == NULL)
  	{
  	    vim_free(ffname);
--- 1958,1964 ----
      }
      if (buf != curbuf || curbuf == NULL)
      {
! 	buf = (buf_T *)alloc_clear(sizeof(buf_T));
  	if (buf == NULL)
  	{
  	    vim_free(ffname);
***************
*** 1985,1991 ****
      }
  
      clear_wininfo(buf);
!     buf->b_wininfo = (wininfo_T *)alloc_clear((unsigned)sizeof(wininfo_T));
  
      if ((ffname != NULL && (buf->b_ffname == NULL || buf->b_sfname == NULL))
  	    || buf->b_wininfo == NULL)
--- 1985,1991 ----
      }
  
      clear_wininfo(buf);
!     buf->b_wininfo = (wininfo_T *)alloc_clear(sizeof(wininfo_T));
  
      if ((ffname != NULL && (buf->b_ffname == NULL || buf->b_sfname == NULL))
  	    || buf->b_wininfo == NULL)
***************
*** 2771,2777 ****
      if (wip == NULL)
      {
  	/* allocate a new entry */
! 	wip = (wininfo_T *)alloc_clear((unsigned)sizeof(wininfo_T));
  	if (wip == NULL)
  	    return;
  	wip->wi_win = win;
--- 2771,2777 ----
      if (wip == NULL)
      {
  	/* allocate a new entry */
! 	wip = (wininfo_T *)alloc_clear(sizeof(wininfo_T));
  	if (wip == NULL)
  	    return;
  	wip->wi_win = win;
***************
*** 4911,4917 ****
      setpcmark();
  
      opened_len = ARGCOUNT;
!     opened = alloc_clear((unsigned)opened_len);
      if (opened == NULL)
  	return;
  
--- 4911,4917 ----
      setpcmark();
  
      opened_len = ARGCOUNT;
!     opened = alloc_clear(opened_len);
      if (opened == NULL)
  	return;
  
*** ../vim-8.1.1385/src/change.c	2019-05-24 18:48:36.746128566 +0200
--- src/change.c	2019-05-24 19:29:13.808683462 +0200
***************
*** 282,288 ****
  	    return;
      }
  
!     lnr = (listener_T *)alloc_clear((sizeof(listener_T)));
      if (lnr == NULL)
      {
  	free_callback(callback, partial);
--- 282,288 ----
  	    return;
      }
  
!     lnr = (listener_T *)alloc_clear(sizeof(listener_T));
      if (lnr == NULL)
      {
  	free_callback(callback, partial);
*** ../vim-8.1.1385/src/channel.c	2019-05-24 18:48:36.750128544 +0200
--- src/channel.c	2019-05-24 19:29:27.016610892 +0200
***************
*** 294,300 ****
  add_channel(void)
  {
      ch_part_T	part;
!     channel_T	*channel = (channel_T *)alloc_clear((int)sizeof(channel_T));
  
      if (channel == NULL)
  	return NULL;
--- 294,300 ----
  add_channel(void)
  {
      ch_part_T	part;
!     channel_T	*channel = (channel_T *)alloc_clear(sizeof(channel_T));
  
      if (channel == NULL)
  	return NULL;
***************
*** 1728,1734 ****
      // Concatenate everything into one buffer.
      for (node = head->rq_next; node != NULL; node = node->rq_next)
  	len += node->rq_buflen;
!     res = lalloc(len + 1, TRUE);
      if (res == NULL)
  	return NULL;
      p = res;
--- 1728,1734 ----
      // Concatenate everything into one buffer.
      for (node = head->rq_next; node != NULL; node = node->rq_next)
  	len += node->rq_buflen;
!     res = alloc(len + 1);
      if (res == NULL)
  	return NULL;
      p = res;
*** ../vim-8.1.1385/src/diff.c	2019-05-24 18:48:36.750128544 +0200
--- src/diff.c	2019-05-24 19:17:31.868547867 +0200
***************
*** 710,716 ****
      // xdiff requires one big block of memory with all the text.
      for (lnum = 1; lnum <= buf->b_ml.ml_line_count; ++lnum)
  	len += (long)STRLEN(ml_get_buf(buf, lnum, FALSE)) + 1;
!     ptr = lalloc(len, TRUE);
      if (ptr == NULL)
      {
  	// Allocating memory failed.  This can happen, because we try to read
--- 710,716 ----
      // xdiff requires one big block of memory with all the text.
      for (lnum = 1; lnum <= buf->b_ml.ml_line_count; ++lnum)
  	len += (long)STRLEN(ml_get_buf(buf, lnum, FALSE)) + 1;
!     ptr = alloc(len);
      if (ptr == NULL)
      {
  	// Allocating memory failed.  This can happen, because we try to read
*** ../vim-8.1.1385/src/edit.c	2019-05-24 18:48:36.750128544 +0200
--- src/edit.c	2019-05-24 19:17:47.568461117 +0200
***************
*** 3859,3865 ****
      if (replace_stack_len <= replace_stack_nr)
      {
  	replace_stack_len += 50;
! 	p = lalloc(sizeof(char_u) * replace_stack_len, TRUE);
  	if (p == NULL)	    /* out of memory */
  	{
  	    replace_stack_len -= 50;
--- 3859,3865 ----
      if (replace_stack_len <= replace_stack_nr)
      {
  	replace_stack_len += 50;
! 	p = alloc(sizeof(char_u) * replace_stack_len);
  	if (p == NULL)	    /* out of memory */
  	{
  	    replace_stack_len -= 50;
*** ../vim-8.1.1385/src/eval.c	2019-05-24 18:48:36.754128525 +0200
--- src/eval.c	2019-05-24 19:29:53.452465676 +0200
***************
*** 491,497 ****
      if (redir_varname == NULL)
  	return FAIL;
  
!     redir_lval = (lval_T *)alloc_clear((unsigned)sizeof(lval_T));
      if (redir_lval == NULL)
      {
  	var_redir_stop();
--- 491,497 ----
      if (redir_varname == NULL)
  	return FAIL;
  
!     redir_lval = (lval_T *)alloc_clear(sizeof(lval_T));
      if (redir_lval == NULL)
      {
  	var_redir_stop();
***************
*** 7288,7294 ****
      typval_T *
  alloc_tv(void)
  {
!     return (typval_T *)alloc_clear((unsigned)sizeof(typval_T));
  }
  
  /*
--- 7288,7294 ----
      typval_T *
  alloc_tv(void)
  {
!     return (typval_T *)alloc_clear(sizeof(typval_T));
  }
  
  /*
*** ../vim-8.1.1385/src/ex_cmds.c	2019-05-24 18:48:36.750128544 +0200
--- src/ex_cmds.c	2019-05-24 19:24:40.866183581 +0200
***************
*** 397,403 ****
      sortbuf1 = NULL;
      sortbuf2 = NULL;
      regmatch.regprog = NULL;
!     nrs = (sorti_T *)lalloc((long_u)(count * sizeof(sorti_T)), TRUE);
      if (nrs == NULL)
  	goto sortend;
  
--- 397,403 ----
      sortbuf1 = NULL;
      sortbuf2 = NULL;
      regmatch.regprog = NULL;
!     nrs = (sorti_T *)alloc(count * sizeof(sorti_T));
      if (nrs == NULL)
  	goto sortend;
  
***************
*** 793,800 ****
  			/* len is actual number of white characters used */
  			len = num_spaces + num_tabs;
  			old_len = (long)STRLEN(ptr);
! 			new_line = lalloc(old_len - col + start_col + len + 1,
! 									TRUE);
  			if (new_line == NULL)
  			    break;
  			if (start_col > 0)
--- 793,799 ----
  			/* len is actual number of white characters used */
  			len = num_spaces + num_tabs;
  			old_len = (long)STRLEN(ptr);
! 			new_line = alloc(old_len - col + start_col + len + 1);
  			if (new_line == NULL)
  			    break;
  			if (start_col > 0)
***************
*** 1745,1751 ****
  	len += (long_u)STRLEN(itmp) + 9;		/* " { < " + " } " */
      if (otmp != NULL)
  	len += (long_u)STRLEN(otmp) + (long_u)STRLEN(p_srr) + 2; /* "  " */
!     buf = lalloc(len, TRUE);
      if (buf == NULL)
  	return NULL;
  
--- 1744,1750 ----
  	len += (long_u)STRLEN(itmp) + 9;		/* " { < " + " } " */
      if (otmp != NULL)
  	len += (long_u)STRLEN(otmp) + (long_u)STRLEN(p_srr) + 2; /* "  " */
!     buf = alloc(len);
      if (buf == NULL)
  	return NULL;
  
***************
*** 2536,2542 ****
      if (virp->vir_line[off] == Ctrl_V && vim_isdigit(virp->vir_line[off + 1]))
      {
  	len = atol((char *)virp->vir_line + off + 1);
! 	retval = lalloc(len, TRUE);
  	if (retval == NULL)
  	{
  	    /* Line too long?  File messed up?  Skip next line. */
--- 2535,2541 ----
      if (virp->vir_line[off] == Ctrl_V && vim_isdigit(virp->vir_line[off + 1]))
      {
  	len = atol((char *)virp->vir_line + off + 1);
! 	retval = alloc(len);
  	if (retval == NULL)
  	{
  	    /* Line too long?  File messed up?  Skip next line. */
*** ../vim-8.1.1385/src/ex_getln.c	2019-05-24 18:48:36.758128504 +0200
--- src/ex_getln.c	2019-05-24 19:24:57.374092786 +0200
***************
*** 4166,4172 ****
  	len = 0;
  	for (i = 0; i < xp->xp_numfiles; ++i)
  	    len += (long_u)STRLEN(xp->xp_files[i]) + 1;
! 	ss = lalloc(len, TRUE);
  	if (ss != NULL)
  	{
  	    *ss = NUL;
--- 4166,4172 ----
  	len = 0;
  	for (i = 0; i < xp->xp_numfiles; ++i)
  	    len += (long_u)STRLEN(xp->xp_files[i]) + 1;
! 	ss = alloc(len);
  	if (ss != NULL)
  	{
  	    *ss = NUL;
***************
*** 5914,5921 ****
  	{
  	    if (newlen)
  	    {
! 		temp = (histentry_T *)lalloc(
! 				(long_u)(newlen * sizeof(histentry_T)), TRUE);
  		if (temp == NULL)   /* out of memory! */
  		{
  		    if (type == 0)  /* first one: just keep the old length */
--- 5914,5921 ----
  	{
  	    if (newlen)
  	    {
! 		temp = (histentry_T *)alloc(
! 				       (long_u)(newlen * sizeof(histentry_T)));
  		if (temp == NULL)   /* out of memory! */
  		{
  		    if (type == 0)  /* first one: just keep the old length */
***************
*** 6688,6694 ****
  	    {
  		/* Need to re-allocate to append the separator byte. */
  		len = STRLEN(val);
! 		p = lalloc(len + 2, TRUE);
  		if (p != NULL)
  		{
  		    if (type == HIST_SEARCH)
--- 6688,6694 ----
  	    {
  		/* Need to re-allocate to append the separator byte. */
  		len = STRLEN(val);
! 		p = alloc(len + 2);
  		if (p != NULL)
  		{
  		    if (type == HIST_SEARCH)
***************
*** 6774,6780 ****
  		{
  		    /* Need to re-allocate to append the separator byte. */
  		    len = vp[3].bv_len;
! 		    p = lalloc(len + 2, TRUE);
  		}
  		else
  		    len = 0; /* for picky compilers */
--- 6774,6780 ----
  		{
  		    /* Need to re-allocate to append the separator byte. */
  		    len = vp[3].bv_len;
! 		    p = alloc(len + 2);
  		}
  		else
  		    len = 0; /* for picky compilers */
*** ../vim-8.1.1385/src/fileio.c	2019-05-24 19:04:25.644941435 +0200
--- src/fileio.c	2019-05-24 19:19:28.315904932 +0200
***************
*** 89,95 ****
      int		bw_restlen;	/* nr of bytes in bw_rest[] */
      int		bw_first;	/* first write call */
      char_u	*bw_conv_buf;	/* buffer for writing converted chars */
!     int		bw_conv_buflen; /* size of bw_conv_buf */
      int		bw_conv_error;	/* set for conversion error */
      linenr_T	bw_conv_error_lnum;  /* first line with error or zero */
      linenr_T	bw_start_lnum;  /* line number at start of buffer */
--- 89,95 ----
      int		bw_restlen;	/* nr of bytes in bw_rest[] */
      int		bw_first;	/* first write call */
      char_u	*bw_conv_buf;	/* buffer for writing converted chars */
!     size_t	bw_conv_buflen; /* size of bw_conv_buf */
      int		bw_conv_error;	/* set for conversion error */
      linenr_T	bw_conv_error_lnum;  /* first line with error or zero */
      linenr_T	bw_start_lnum;  /* line number at start of buffer */
***************
*** 1189,1195 ****
  	    {
  		for ( ; size >= 10; size = (long)((long_u)size >> 1))
  		{
! 		    if ((new_buffer = lalloc((long_u)(size + linerest + 1),
  							      FALSE)) != NULL)
  			break;
  		}
--- 1189,1195 ----
  	    {
  		for ( ; size >= 10; size = (long)((long_u)size >> 1))
  		{
! 		    if ((new_buffer = lalloc(size + linerest + 1,
  							      FALSE)) != NULL)
  			break;
  		}
***************
*** 4168,4175 ****
  		write_info.bw_conv_buflen = bufsize * 2;
  	    else /* FIO_UCS4 */
  		write_info.bw_conv_buflen = bufsize * 4;
! 	    write_info.bw_conv_buf
! 			   = lalloc((long_u)write_info.bw_conv_buflen, TRUE);
  	    if (write_info.bw_conv_buf == NULL)
  		end = 0;
  	}
--- 4168,4174 ----
  		write_info.bw_conv_buflen = bufsize * 2;
  	    else /* FIO_UCS4 */
  		write_info.bw_conv_buflen = bufsize * 4;
! 	    write_info.bw_conv_buf = alloc(write_info.bw_conv_buflen);
  	    if (write_info.bw_conv_buf == NULL)
  		end = 0;
  	}
***************
*** 4180,4187 ****
      {
  	/* Convert UTF-8 -> UCS-2 and UCS-2 -> DBCS.  Worst-case * 4: */
  	write_info.bw_conv_buflen = bufsize * 4;
! 	write_info.bw_conv_buf
! 			    = lalloc((long_u)write_info.bw_conv_buflen, TRUE);
  	if (write_info.bw_conv_buf == NULL)
  	    end = 0;
      }
--- 4179,4185 ----
      {
  	/* Convert UTF-8 -> UCS-2 and UCS-2 -> DBCS.  Worst-case * 4: */
  	write_info.bw_conv_buflen = bufsize * 4;
! 	write_info.bw_conv_buf = alloc(write_info.bw_conv_buflen);
  	if (write_info.bw_conv_buf == NULL)
  	    end = 0;
      }
***************
*** 4191,4198 ****
      if (converted && wb_flags == 0 && (wb_flags = get_mac_fio_flags(fenc)) != 0)
      {
  	write_info.bw_conv_buflen = bufsize * 3;
! 	write_info.bw_conv_buf
! 			    = lalloc((long_u)write_info.bw_conv_buflen, TRUE);
  	if (write_info.bw_conv_buf == NULL)
  	    end = 0;
      }
--- 4189,4195 ----
      if (converted && wb_flags == 0 && (wb_flags = get_mac_fio_flags(fenc)) != 0)
      {
  	write_info.bw_conv_buflen = bufsize * 3;
! 	write_info.bw_conv_buf = alloc(write_info.bw_conv_buflen);
  	if (write_info.bw_conv_buf == NULL)
  	    end = 0;
      }
***************
*** 4212,4219 ****
  	{
  	    /* We're going to use iconv(), allocate a buffer to convert in. */
  	    write_info.bw_conv_buflen = bufsize * ICONV_MULT;
! 	    write_info.bw_conv_buf
! 			   = lalloc((long_u)write_info.bw_conv_buflen, TRUE);
  	    if (write_info.bw_conv_buf == NULL)
  		end = 0;
  	    write_info.bw_first = TRUE;
--- 4209,4215 ----
  	{
  	    /* We're going to use iconv(), allocate a buffer to convert in. */
  	    write_info.bw_conv_buflen = bufsize * ICONV_MULT;
! 	    write_info.bw_conv_buf = alloc(write_info.bw_conv_buflen);
  	    if (write_info.bw_conv_buf == NULL)
  		end = 0;
  	    write_info.bw_first = TRUE;
*** ../vim-8.1.1385/src/getchar.c	2019-05-24 18:48:36.758128504 +0200
--- src/getchar.c	2019-05-24 19:19:44.215817204 +0200
***************
*** 156,162 ****
      for (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)
  	count += (long_u)STRLEN(bp->b_str);
  
!     if ((count || dozero) && (p = lalloc(count + 1, TRUE)) != NULL)
      {
  	p2 = p;
  	for (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)
--- 156,162 ----
      for (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)
  	count += (long_u)STRLEN(bp->b_str);
  
!     if ((count || dozero) && (p = alloc(count + 1)) != NULL)
      {
  	p2 = p;
  	for (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)
***************
*** 258,265 ****
  	    len = MINIMAL_SIZE;
  	else
  	    len = slen;
! 	p = (buffblock_T *)lalloc((long_u)(sizeof(buffblock_T) + len),
! 									TRUE);
  	if (p == NULL)
  	    return; /* no space, just forget it */
  	buf->bh_space = (int)(len - slen);
--- 258,264 ----
  	    len = MINIMAL_SIZE;
  	else
  	    len = slen;
! 	p = (buffblock_T *)alloc(sizeof(buffblock_T) + len);
  	if (p == NULL)
  	    return; /* no space, just forget it */
  	buf->bh_space = (int)(len - slen);
*** ../vim-8.1.1385/src/gui_mac.c	2019-03-30 18:46:57.352077376 +0100
--- src/gui_mac.c	2019-05-24 19:20:01.515721782 +0200
***************
*** 4476,4482 ****
      /* In CARBON we don't need a Handle, a pointer is good */
      textOfClip = NewHandle(scrapSize);
  
!     /* tempclip = lalloc(scrapSize+1, TRUE); */
      HLock(textOfClip);
      error = GetScrapFlavorData(scrap,
  	    flavor ? VIMSCRAPFLAVOR : SCRAPTEXTFLAVOR,
--- 4476,4482 ----
      /* In CARBON we don't need a Handle, a pointer is good */
      textOfClip = NewHandle(scrapSize);
  
!     /* tempclip = alloc(scrapSize+1); */
      HLock(textOfClip);
      error = GetScrapFlavorData(scrap,
  	    flavor ? VIMSCRAPFLAVOR : SCRAPTEXTFLAVOR,
***************
*** 4488,4494 ****
      else
  	type = MAUTO;
  
!     tempclip = lalloc(scrapSize + 1, TRUE);
      mch_memmove(tempclip, *textOfClip + flavor, scrapSize);
      tempclip[scrapSize] = 0;
  
--- 4488,4494 ----
      else
  	type = MAUTO;
  
!     tempclip = alloc(scrapSize + 1);
      mch_memmove(tempclip, *textOfClip + flavor, scrapSize);
      tempclip[scrapSize] = 0;
  
*** ../vim-8.1.1385/src/insexpand.c	2019-05-24 18:48:36.762128482 +0200
--- src/insexpand.c	2019-05-24 19:30:38.272219536 +0200
***************
*** 611,617 ****
  
      // Allocate a new match structure.
      // Copy the values to the new match structure.
!     match = (compl_T *)alloc_clear((unsigned)sizeof(compl_T));
      if (match == NULL)
  	return FAIL;
      match->cp_number = -1;
--- 611,617 ----
  
      // Allocate a new match structure.
      // Copy the values to the new match structure.
!     match = (compl_T *)alloc_clear(sizeof(compl_T));
      if (match == NULL)
  	return FAIL;
      match->cp_number = -1;
***************
*** 1071,1078 ****
  	if (compl_match_arraysize == 0)
  	    return;
  	compl_match_array = (pumitem_T *)alloc_clear(
! 				    (unsigned)(sizeof(pumitem_T)
! 						    * compl_match_arraysize));
  	if (compl_match_array != NULL)
  	{
  	    // If the current match is the original text don't find the first
--- 1071,1077 ----
  	if (compl_match_arraysize == 0)
  	    return;
  	compl_match_array = (pumitem_T *)alloc_clear(
! 				    sizeof(pumitem_T) * compl_match_arraysize);
  	if (compl_match_array != NULL)
  	{
  	    // If the current match is the original text don't find the first
*** ../vim-8.1.1385/src/gui_w32.c	2019-05-24 18:48:36.762128482 +0200
--- src/gui_w32.c	2019-05-24 19:20:34.115542034 +0200
***************
*** 6803,6814 ****
  	dfltbutton = -1;
  
      /* Allocate array to hold the width of each button */
!     buttonWidths = (int *)lalloc(numButtons * sizeof(int), TRUE);
      if (buttonWidths == NULL)
  	return -1;
  
      /* Allocate array to hold the X position of each button */
!     buttonPositions = (int *)lalloc(numButtons * sizeof(int), TRUE);
      if (buttonPositions == NULL)
  	return -1;
  
--- 6803,6814 ----
  	dfltbutton = -1;
  
      /* Allocate array to hold the width of each button */
!     buttonWidths = (int *)alloc(numButtons * sizeof(int));
      if (buttonWidths == NULL)
  	return -1;
  
      /* Allocate array to hold the X position of each button */
!     buttonPositions = (int *)alloc(numButtons * sizeof(int));
      if (buttonPositions == NULL)
  	return -1;
  
*** ../vim-8.1.1385/src/gui_x11.c	2019-03-30 18:46:57.352077376 +0100
--- src/gui_x11.c	2019-05-24 19:09:16.775299442 +0200
***************
*** 1167,1173 ****
       * Move all the entries in argv which are relevant to X into gui_argv.
       */
      gui_argc = 0;
!     gui_argv = (char **)lalloc((long_u)(*argc * sizeof(char *)), FALSE);
      if (gui_argv == NULL)
  	return;
      gui_argv[gui_argc++] = argv[0];
--- 1167,1173 ----
       * Move all the entries in argv which are relevant to X into gui_argv.
       */
      gui_argc = 0;
!     gui_argv = (char **)lalloc(*argc * sizeof(char *), FALSE);
      if (gui_argv == NULL)
  	return;
      gui_argv[gui_argc++] = argv[0];
*** ../vim-8.1.1385/src/menu.c	2019-05-24 18:48:36.766128461 +0200
--- src/menu.c	2019-05-24 19:30:49.932155506 +0200
***************
*** 583,589 ****
  	    }
  
  	    /* Not already there, so lets add it */
! 	    menu = (vimmenu_T *)alloc_clear((unsigned)sizeof(vimmenu_T));
  	    if (menu == NULL)
  		goto erret;
  
--- 583,589 ----
  	    }
  
  	    /* Not already there, so lets add it */
! 	    menu = (vimmenu_T *)alloc_clear(sizeof(vimmenu_T));
  	    if (menu == NULL)
  		goto erret;
  
*** ../vim-8.1.1385/src/netbeans.c	2019-05-24 18:48:36.750128544 +0200
--- src/netbeans.c	2019-05-24 19:31:40.839875984 +0200
***************
*** 863,869 ****
      int done = 0;
  
      /* result is never longer than input */
!     result = (char *)alloc_clear((unsigned)STRLEN(p) + 1);
      if (result == NULL)
  	return NULL;
  
--- 863,869 ----
      int done = 0;
  
      /* result is never longer than input */
!     result = (char *)alloc_clear(STRLEN(p) + 1);
      if (result == NULL)
  	return NULL;
  
***************
*** 3210,3216 ****
  	    if (globalsignmaplen == 0) /* first allocation */
  	    {
  		globalsignmaplen = 20;
! 		globalsignmap = (char **)alloc_clear(globalsignmaplen*sizeof(char *));
  	    }
  	    else    /* grow it */
  	    {
--- 3210,3217 ----
  	    if (globalsignmaplen == 0) /* first allocation */
  	    {
  		globalsignmaplen = 20;
! 		globalsignmap = (char **)alloc_clear(
! 					    globalsignmaplen * sizeof(char *));
  	    }
  	    else    /* grow it */
  	    {
*** ../vim-8.1.1385/src/ops.c	2019-05-24 18:48:36.766128461 +0200
--- src/ops.c	2019-05-24 19:31:58.387779642 +0200
***************
*** 1160,1166 ****
      if (y_append && y_current->y_array != NULL)
      {
  	pp = &(y_current->y_array[y_current->y_size - 1]);
! 	lp = lalloc((long_u)(STRLEN(*pp) + STRLEN(p) + 1), TRUE);
  	if (lp == NULL)
  	{
  	    vim_free(p);
--- 1160,1166 ----
      if (y_append && y_current->y_array != NULL)
      {
  	pp = &(y_current->y_array[y_current->y_size - 1]);
! 	lp = alloc(STRLEN(*pp) + STRLEN(p) + 1);
  	if (lp == NULL)
  	{
  	    vim_free(p);
***************
*** 3057,3064 ****
      y_current->y_size = yanklines;
      y_current->y_type = yanktype;   /* set the yank register type */
      y_current->y_width = 0;
!     y_current->y_array = (char_u **)lalloc_clear((long_u)(sizeof(char_u *) *
! 							    yanklines), TRUE);
      if (y_current->y_array == NULL)
      {
  	y_current = curr;
--- 3057,3064 ----
      y_current->y_size = yanklines;
      y_current->y_type = yanktype;   /* set the yank register type */
      y_current->y_width = 0;
!     y_current->y_array = (char_u **)lalloc_clear(sizeof(char_u *) * yanklines,
! 									 TRUE);
      if (y_current->y_array == NULL)
      {
  	y_current = curr;
***************
*** 3171,3178 ****
  
      if (curr != y_current)	/* append the new block to the old block */
      {
! 	new_ptr = (char_u **)lalloc((long_u)(sizeof(char_u *) *
! 				   (curr->y_size + y_current->y_size)), TRUE);
  	if (new_ptr == NULL)
  	    goto fail;
  	for (j = 0; j < curr->y_size; ++j)
--- 3171,3178 ----
  
      if (curr != y_current)	/* append the new block to the old block */
      {
! 	new_ptr = (char_u **)alloc(sizeof(char_u *) *
! 					   (curr->y_size + y_current->y_size));
  	if (new_ptr == NULL)
  	    goto fail;
  	for (j = 0; j < curr->y_size; ++j)
***************
*** 3190,3197 ****
  	 * the new block, unless being Vi compatible. */
  	if (curr->y_type == MCHAR && vim_strchr(p_cpo, CPO_REGAPPEND) == NULL)
  	{
! 	    pnew = lalloc((long_u)(STRLEN(curr->y_array[curr->y_size - 1])
! 			      + STRLEN(y_current->y_array[0]) + 1), TRUE);
  	    if (pnew == NULL)
  	    {
  		y_idx = y_current->y_size - 1;
--- 3190,3197 ----
  	 * the new block, unless being Vi compatible. */
  	if (curr->y_type == MCHAR && vim_strchr(p_cpo, CPO_REGAPPEND) == NULL)
  	{
! 	    pnew = alloc(STRLEN(curr->y_array[curr->y_size - 1])
! 					  + STRLEN(y_current->y_array[0]) + 1);
  	    if (pnew == NULL)
  	    {
  		y_idx = y_current->y_size - 1;
***************
*** 4453,4465 ****
      /* Allocate an array to store the number of spaces inserted before each
       * line.  We will use it to pre-compute the length of the new line and the
       * proper placement of each original line in the new one. */
!     spaces = lalloc_clear((long_u)count, TRUE);
      if (spaces == NULL)
  	return FAIL;
  #if defined(FEAT_COMMENTS) || defined(PROTO)
      if (remove_comments)
      {
! 	comments = (int *)lalloc_clear((long_u)count * sizeof(int), TRUE);
  	if (comments == NULL)
  	{
  	    vim_free(spaces);
--- 4453,4465 ----
      /* Allocate an array to store the number of spaces inserted before each
       * line.  We will use it to pre-compute the length of the new line and the
       * proper placement of each original line in the new one. */
!     spaces = lalloc_clear(count, TRUE);
      if (spaces == NULL)
  	return FAIL;
  #if defined(FEAT_COMMENTS) || defined(PROTO)
      if (remove_comments)
      {
! 	comments = (int *)lalloc_clear(count * sizeof(int), TRUE);
  	if (comments == NULL)
  	{
  	    vim_free(spaces);
***************
*** 4571,4578 ****
  	// Allocate an array to copy the text properties of joined lines into.
  	// And another array to store the number of properties in each line.
  	prop_lines = (textprop_T **)alloc_clear(
! 				      (int)(count - 1) * sizeof(textprop_T *));
! 	prop_lengths = (int *)alloc_clear((int)(count - 1) * sizeof(int));
  	if (prop_lengths == NULL)
  	    VIM_CLEAR(prop_lines);
      }
--- 4571,4578 ----
  	// Allocate an array to copy the text properties of joined lines into.
  	// And another array to store the number of properties in each line.
  	prop_lines = (textprop_T **)alloc_clear(
! 					   (count - 1) * sizeof(textprop_T *));
! 	prop_lengths = (int *)alloc_clear((count - 1) * sizeof(int));
  	if (prop_lengths == NULL)
  	    VIM_CLEAR(prop_lines);
      }
***************
*** 6600,6606 ****
      if (y_ptr->y_type == MCHAR && *len >= eolsize)
  	*len -= eolsize;
  
!     p = *str = lalloc(*len + 1, TRUE);	/* add one to avoid zero */
      if (p == NULL)
  	return -1;
      lnum = 0;
--- 6600,6606 ----
      if (y_ptr->y_type == MCHAR && *len >= eolsize)
  	*len -= eolsize;
  
!     p = *str = alloc(*len + 1);	// add one to avoid zero
      if (p == NULL)
  	return -1;
      lnum = 0;
***************
*** 6818,6824 ****
  	    ++len;
      }
  
!     retval = lalloc(len + 1, TRUE);
  
      /*
       * Copy the lines of the yank register into the string.
--- 6818,6824 ----
  	    ++len;
      }
  
!     retval = alloc(len + 1);
  
      /*
       * Copy the lines of the yank register into the string.
*** ../vim-8.1.1385/src/os_mswin.c	2019-05-24 18:48:36.766128461 +0200
--- src/os_mswin.c	2019-05-24 19:21:29.175238574 +0200
***************
*** 890,896 ****
  	else if (retval_str != NULL
  		&& (len = check_str_len(retval_str)) > 0)
  	{
! 	    *string_result = lalloc((long_u)len, TRUE);
  	    if (*string_result != NULL)
  		mch_memmove(*string_result, retval_str, len);
  	}
--- 890,896 ----
  	else if (retval_str != NULL
  		&& (len = check_str_len(retval_str)) > 0)
  	{
! 	    *string_result = alloc(len);
  	    if (*string_result != NULL)
  		mch_memmove(*string_result, retval_str, len);
  	}
*** ../vim-8.1.1385/src/os_amiga.c	2019-05-24 18:48:36.766128461 +0200
--- src/os_amiga.c	2019-05-24 19:32:31.267599120 +0200
***************
*** 1448,1454 ****
  #ifdef __amigaos4__
      Anchor = AllocDosObject(DOS_ANCHORPATH, AnchorTags);
  #else
!     Anchor = (struct AnchorPath *)alloc_clear((unsigned)ANCHOR_SIZE);
  #endif
      if (Anchor == NULL)
  	return 0;
--- 1448,1454 ----
  #ifdef __amigaos4__
      Anchor = AllocDosObject(DOS_ANCHORPATH, AnchorTags);
  #else
!     Anchor = (struct AnchorPath *)alloc_clear(ANCHOR_SIZE);
  #endif
      if (Anchor == NULL)
  	return 0;
*** ../vim-8.1.1385/src/os_qnx.c	2019-03-30 18:46:57.360077328 +0100
--- src/os_qnx.c	2019-05-24 19:21:47.639136844 +0200
***************
*** 120,126 ****
      type = clip_convert_selection(&str, &len, cbd);
      if (type >= 0)
      {
! 	text_clip = lalloc(len + 1, TRUE); /* Normal text */
  
  	if (text_clip && vim_clip)
  	{
--- 120,126 ----
      type = clip_convert_selection(&str, &len, cbd);
      if (type >= 0)
      {
! 	text_clip = alloc(len + 1); // Normal text
  
  	if (text_clip && vim_clip)
  	{
*** ../vim-8.1.1385/src/os_unix.c	2019-05-24 18:48:36.770128440 +0200
--- src/os_unix.c	2019-05-24 19:26:47.437487719 +0200
***************
*** 4459,4467 ****
  	else
  	    x = system((char *)cmd);
  # else
! 	newcmd = lalloc(STRLEN(p_sh)
  		+ (extra_shell_arg == NULL ? 0 : STRLEN(extra_shell_arg))
! 		+ STRLEN(p_shcf) + STRLEN(cmd) + 4, TRUE);
  	if (newcmd == NULL)
  	    x = 0;
  	else
--- 4459,4467 ----
  	else
  	    x = system((char *)cmd);
  # else
! 	newcmd = alloc(STRLEN(p_sh)
  		+ (extra_shell_arg == NULL ? 0 : STRLEN(extra_shell_arg))
! 		+ STRLEN(p_shcf) + STRLEN(cmd) + 4);
  	if (newcmd == NULL)
  	    x = 0;
  	else
*** ../vim-8.1.1385/src/os_win32.c	2019-05-24 18:48:36.770128440 +0200
--- src/os_win32.c	2019-05-24 19:32:43.335532850 +0200
***************
*** 3394,3400 ****
      struct my_acl   *p = NULL;
      DWORD   err;
  
!     p = (struct my_acl *)alloc_clear((unsigned)sizeof(struct my_acl));
      if (p != NULL)
      {
  	WCHAR	*wn;
--- 3394,3400 ----
      struct my_acl   *p = NULL;
      DWORD   err;
  
!     p = (struct my_acl *)alloc_clear(sizeof(struct my_acl));
      if (p != NULL)
      {
  	WCHAR	*wn;
***************
*** 4533,4539 ****
  	cmdlen = STRLEN(p_sh) + 1;
      else
  	cmdlen = STRLEN(p_sh) + STRLEN(p_shcf) + STRLEN(cmd) + 10;
!     newcmd = lalloc(cmdlen, TRUE);
      if (newcmd == NULL)
  	return 255;
      if (cmd == NULL)
--- 4533,4539 ----
  	cmdlen = STRLEN(p_sh) + 1;
      else
  	cmdlen = STRLEN(p_sh) + STRLEN(p_shcf) + STRLEN(cmd) + 10;
!     newcmd = alloc(cmdlen);
      if (newcmd == NULL)
  	return 255;
      if (cmd == NULL)
***************
*** 4772,4778 ****
  		{
  		    /* make "cmd.exe /c arguments" */
  		    cmdlen = STRLEN(cmd_shell) + STRLEN(subcmd) + 5;
! 		    newcmd = lalloc(cmdlen, TRUE);
  		    if (newcmd != NULL)
  			vim_snprintf((char *)newcmd, cmdlen, "%s /c %s",
  						       cmd_shell, subcmd);
--- 4772,4778 ----
  		{
  		    /* make "cmd.exe /c arguments" */
  		    cmdlen = STRLEN(cmd_shell) + STRLEN(subcmd) + 5;
! 		    newcmd = alloc(cmdlen);
  		    if (newcmd != NULL)
  			vim_snprintf((char *)newcmd, cmdlen, "%s /c %s",
  						       cmd_shell, subcmd);
***************
*** 4827,4833 ****
  #endif
  		STRLEN(p_sh) + STRLEN(p_shcf) + STRLEN(cmd) + 10;
  
! 	    newcmd = lalloc(cmdlen, TRUE);
  	    if (newcmd != NULL)
  	    {
  #if defined(FEAT_GUI_MSWIN)
--- 4827,4833 ----
  #endif
  		STRLEN(p_sh) + STRLEN(p_shcf) + STRLEN(cmd) + 10;
  
! 	    newcmd = alloc(cmdlen);
  	    if (newcmd != NULL)
  	    {
  #if defined(FEAT_GUI_MSWIN)
*** ../vim-8.1.1385/src/popupmnu.c	2019-05-09 13:50:13.362401997 +0200
--- src/popupmnu.c	2019-05-24 19:33:15.451300742 +0200
***************
*** 1071,1077 ****
       * position. */
      if (height > max_height)
  	height = max_height;
!     *array = (pumitem_T *)alloc_clear((unsigned)sizeof(pumitem_T) * height);
      if (*array == NULL)
  	goto failed;
  
--- 1071,1077 ----
       * position. */
      if (height > max_height)
  	height = max_height;
!     *array = (pumitem_T *)alloc_clear(sizeof(pumitem_T) * height);
      if (*array == NULL)
  	goto failed;
  
***************
*** 1165,1171 ****
  
  	balloon_arraysize = list->lv_len;
  	balloon_array = (pumitem_T *)alloc_clear(
! 				   (unsigned)sizeof(pumitem_T) * list->lv_len);
  	if (balloon_array == NULL)
  	    return;
  	for (idx = 0, li = list->lv_first; li != NULL; li = li->li_next, ++idx)
--- 1165,1171 ----
  
  	balloon_arraysize = list->lv_len;
  	balloon_array = (pumitem_T *)alloc_clear(
! 					     sizeof(pumitem_T) * list->lv_len);
  	if (balloon_array == NULL)
  	    return;
  	for (idx = 0, li = list->lv_first; li != NULL; li = li->li_next, ++idx)
***************
*** 1271,1277 ****
  	return;
      }
  
!     array = (pumitem_T *)alloc_clear((unsigned)sizeof(pumitem_T) * pum_size);
      if (array == NULL)
  	return;
  
--- 1271,1277 ----
  	return;
      }
  
!     array = (pumitem_T *)alloc_clear(sizeof(pumitem_T) * pum_size);
      if (array == NULL)
  	return;
  
*** ../vim-8.1.1385/src/quickfix.c	2019-05-24 18:48:36.770128440 +0200
--- src/quickfix.c	2019-05-24 19:33:34.435134342 +0200
***************
*** 540,546 ****
      while (efm[0] != NUL)
      {
  	// Allocate a new eformat structure and put it at the end of the list
! 	fmt_ptr = (efm_T *)alloc_clear((unsigned)sizeof(efm_T));
  	if (fmt_ptr == NULL)
  	    goto parse_efm_error;
  	if (fmt_first == NULL)	    // first one
--- 540,546 ----
      while (efm[0] != NUL)
      {
  	// Allocate a new eformat structure and put it at the end of the list
! 	fmt_ptr = (efm_T *)alloc_clear(sizeof(efm_T));
  	if (fmt_ptr == NULL)
  	    goto parse_efm_error;
  	if (fmt_first == NULL)	    // first one
***************
*** 2141,2147 ****
  {
      qf_info_T *qi;
  
!     qi = (qf_info_T *)alloc_clear((unsigned)sizeof(qf_info_T));
      if (qi != NULL)
      {
  	qi->qf_refcount++;
--- 2141,2147 ----
  {
      qf_info_T *qi;
  
!     qi = (qf_info_T *)alloc_clear(sizeof(qf_info_T));
      if (qi != NULL)
      {
  	qi->qf_refcount++;
*** ../vim-8.1.1385/src/regexp.c	2019-05-24 18:48:36.770128440 +0200
--- src/regexp.c	2019-05-24 19:33:42.583063544 +0200
***************
*** 1319,1325 ****
  	return NULL;
  
      /* Allocate space. */
!     r = (bt_regprog_T *)lalloc(sizeof(bt_regprog_T) + regsize, TRUE);
      if (r == NULL)
  	return NULL;
      r->re_in_use = FALSE;
--- 1319,1325 ----
  	return NULL;
  
      /* Allocate space. */
!     r = (bt_regprog_T *)alloc(sizeof(bt_regprog_T) + regsize);
      if (r == NULL)
  	return NULL;
      r->re_in_use = FALSE;
***************
*** 3932,3938 ****
  {
      reg_extmatch_T	*em;
  
!     em = (reg_extmatch_T *)alloc_clear((unsigned)sizeof(reg_extmatch_T));
      if (em != NULL)
  	em->refcnt = 1;
      return em;
--- 3932,3938 ----
  {
      reg_extmatch_T	*em;
  
!     em = (reg_extmatch_T *)alloc_clear(sizeof(reg_extmatch_T));
      if (em != NULL)
  	em->refcnt = 1;
      return em;
***************
*** 7830,7836 ****
  
  	    if (retval == NULL)
  	    {
! 		retval = lalloc((long_u)len, TRUE);
  		if (retval == NULL)
  		    return NULL;
  	    }
--- 7830,7836 ----
  
  	    if (retval == NULL)
  	    {
! 		retval = alloc(len);
  		if (retval == NULL)
  		    return NULL;
  	    }
*** ../vim-8.1.1385/src/regexp_nfa.c	2019-05-03 11:21:01.645784762 +0200
--- src/regexp_nfa.c	2019-05-24 19:23:30.982568018 +0200
***************
*** 300,306 ****
      /* Size for postfix representation of expr. */
      postfix_size = sizeof(int) * nstate_max;
  
!     post_start = (int *)lalloc(postfix_size, TRUE);
      if (post_start == NULL)
  	return FAIL;
      post_ptr = post_start;
--- 300,306 ----
      /* Size for postfix representation of expr. */
      postfix_size = sizeof(int) * nstate_max;
  
!     post_start = (int *)alloc(postfix_size);
      if (post_start == NULL)
  	return FAIL;
      post_ptr = post_start;
***************
*** 516,522 ****
      // For weird patterns the number of states can be very high. Increasing by
      // 50% seems a reasonable compromise between memory use and speed.
      new_max = nstate_max * 3 / 2;
!     new_start = (int *)lalloc(new_max * sizeof(int), TRUE);
      if (new_start == NULL)
  	return FAIL;
      mch_memmove(new_start, post_start, nstate_max * sizeof(int));
--- 516,522 ----
      // For weird patterns the number of states can be very high. Increasing by
      // 50% seems a reasonable compromise between memory use and speed.
      new_max = nstate_max * 3 / 2;
!     new_start = (int *)alloc(new_max * sizeof(int));
      if (new_start == NULL)
  	return FAIL;
      mch_memmove(new_start, post_start, nstate_max * sizeof(int));
***************
*** 3214,3220 ****
      if (nfa_calc_size == FALSE)
      {
  	// Allocate space for the stack. Max states on the stack: "nstate'.
! 	stack = (Frag_T *)lalloc((nstate + 1) * sizeof(Frag_T), TRUE);
  	if (stack == NULL)
  	    return NULL;
  	stackp = stack;
--- 3214,3220 ----
      if (nfa_calc_size == FALSE)
      {
  	// Allocate space for the stack. Max states on the stack: "nstate'.
! 	stack = (Frag_T *)alloc((nstate + 1) * sizeof(Frag_T));
  	if (stack == NULL)
  	    return NULL;
  	stackp = stack;
***************
*** 5184,5190 ****
  	if (*listids == NULL || *listids_len < prog->nstate)
  	{
  	    vim_free(*listids);
! 	    *listids = (int *)lalloc(sizeof(int) * prog->nstate, TRUE);
  	    if (*listids == NULL)
  	    {
  		emsg(_("E878: (NFA) Could not allocate memory for branch traversal!"));
--- 5184,5190 ----
  	if (*listids == NULL || *listids_len < prog->nstate)
  	{
  	    vim_free(*listids);
! 	    *listids = (int *)alloc(sizeof(int) * prog->nstate);
  	    if (*listids == NULL)
  	    {
  		emsg(_("E878: (NFA) Could not allocate memory for branch traversal!"));
***************
*** 5567,5575 ****
      /* Allocate memory for the lists of nodes. */
      size = (prog->nstate + 1) * sizeof(nfa_thread_T);
  
!     list[0].t = (nfa_thread_T *)lalloc(size, TRUE);
      list[0].len = prog->nstate + 1;
!     list[1].t = (nfa_thread_T *)lalloc(size, TRUE);
      list[1].len = prog->nstate + 1;
      if (list[0].t == NULL || list[1].t == NULL)
  	goto theend;
--- 5567,5575 ----
      /* Allocate memory for the lists of nodes. */
      size = (prog->nstate + 1) * sizeof(nfa_thread_T);
  
!     list[0].t = (nfa_thread_T *)alloc(size);
      list[0].len = prog->nstate + 1;
!     list[1].t = (nfa_thread_T *)alloc(size);
      list[1].len = prog->nstate + 1;
      if (list[0].t == NULL || list[1].t == NULL)
  	goto theend;
***************
*** 7276,7282 ****
  
      /* allocate the regprog with space for the compiled regexp */
      prog_size = sizeof(nfa_regprog_T) + sizeof(nfa_state_T) * (nstate - 1);
!     prog = (nfa_regprog_T *)lalloc(prog_size, TRUE);
      if (prog == NULL)
  	goto fail;
      state_ptr = prog->state;
--- 7276,7282 ----
  
      /* allocate the regprog with space for the compiled regexp */
      prog_size = sizeof(nfa_regprog_T) + sizeof(nfa_state_T) * (nstate - 1);
!     prog = (nfa_regprog_T *)alloc(prog_size);
      if (prog == NULL)
  	goto fail;
      state_ptr = prog->state;
*** ../vim-8.1.1385/src/screen.c	2019-05-24 18:48:36.770128440 +0200
--- src/screen.c	2019-05-24 19:33:55.618950986 +0200
***************
*** 8782,8807 ****
      if (aucmd_win != NULL)
  	win_free_lsize(aucmd_win);
  
!     new_ScreenLines = (schar_T *)lalloc((long_u)(
! 			      (Rows + 1) * Columns * sizeof(schar_T)), FALSE);
      vim_memset(new_ScreenLinesC, 0, sizeof(u8char_T *) * MAX_MCO);
      if (enc_utf8)
      {
! 	new_ScreenLinesUC = (u8char_T *)lalloc((long_u)(
! 			     (Rows + 1) * Columns * sizeof(u8char_T)), FALSE);
  	for (i = 0; i < p_mco; ++i)
! 	    new_ScreenLinesC[i] = (u8char_T *)lalloc_clear((long_u)(
! 			     (Rows + 1) * Columns * sizeof(u8char_T)), FALSE);
      }
      if (enc_dbcs == DBCS_JPNU)
! 	new_ScreenLines2 = (schar_T *)lalloc((long_u)(
! 			     (Rows + 1) * Columns * sizeof(schar_T)), FALSE);
!     new_ScreenAttrs = (sattr_T *)lalloc((long_u)(
! 			      (Rows + 1) * Columns * sizeof(sattr_T)), FALSE);
!     new_LineOffset = (unsigned *)lalloc((long_u)(
! 					 Rows * sizeof(unsigned)), FALSE);
!     new_LineWraps = (char_u *)lalloc((long_u)(Rows * sizeof(char_u)), FALSE);
!     new_TabPageIdxs = (short *)lalloc((long_u)(Columns * sizeof(short)), FALSE);
  
      FOR_ALL_TAB_WINDOWS(tp, wp)
      {
--- 8782,8806 ----
      if (aucmd_win != NULL)
  	win_free_lsize(aucmd_win);
  
!     new_ScreenLines = (schar_T *)lalloc(
! 			      (Rows + 1) * Columns * sizeof(schar_T), FALSE);
      vim_memset(new_ScreenLinesC, 0, sizeof(u8char_T *) * MAX_MCO);
      if (enc_utf8)
      {
! 	new_ScreenLinesUC = (u8char_T *)lalloc(
! 			     (Rows + 1) * Columns * sizeof(u8char_T), FALSE);
  	for (i = 0; i < p_mco; ++i)
! 	    new_ScreenLinesC[i] = (u8char_T *)lalloc_clear(
! 			     (Rows + 1) * Columns * sizeof(u8char_T), FALSE);
      }
      if (enc_dbcs == DBCS_JPNU)
! 	new_ScreenLines2 = (schar_T *)lalloc(
! 			     (Rows + 1) * Columns * sizeof(schar_T), FALSE);
!     new_ScreenAttrs = (sattr_T *)lalloc(
! 			      (Rows + 1) * Columns * sizeof(sattr_T), FALSE);
!     new_LineOffset = (unsigned *)lalloc(Rows * sizeof(unsigned), FALSE);
!     new_LineWraps = (char_u *)lalloc(Rows * sizeof(char_u), FALSE);
!     new_TabPageIdxs = (short *)lalloc(Columns * sizeof(short), FALSE);
  
      FOR_ALL_TAB_WINDOWS(tp, wp)
      {
***************
*** 10741,10747 ****
      for (menu = wp->w_winbar->children; menu != NULL; menu = menu->next)
  	++item_count;
      wp->w_winbar_items = (winbar_item_T *)alloc_clear(
! 			   (unsigned)sizeof(winbar_item_T) * (item_count + 1));
  
      /* TODO: use fewer spaces if there is not enough room */
      for (menu = wp->w_winbar->children;
--- 10740,10746 ----
      for (menu = wp->w_winbar->children; menu != NULL; menu = menu->next)
  	++item_count;
      wp->w_winbar_items = (winbar_item_T *)alloc_clear(
! 				     sizeof(winbar_item_T) * (item_count + 1));
  
      /* TODO: use fewer spaces if there is not enough room */
      for (menu = wp->w_winbar->children;
*** ../vim-8.1.1385/src/search.c	2019-05-24 17:55:47.511425702 +0200
--- src/search.c	2019-05-24 19:27:24.273285286 +0200
***************
*** 5137,5144 ****
  	    goto fpip_end;
  	def_regmatch.rm_ic = FALSE;	/* don't ignore case in define pat. */
      }
!     files = (SearchedFile *)lalloc_clear((long_u)
! 			       (max_path_depth * sizeof(SearchedFile)), TRUE);
      if (files == NULL)
  	goto fpip_end;
      old_files = max_path_depth;
--- 5137,5144 ----
  	    goto fpip_end;
  	def_regmatch.rm_ic = FALSE;	/* don't ignore case in define pat. */
      }
!     files = (SearchedFile *)lalloc_clear(
! 				  max_path_depth * sizeof(SearchedFile), TRUE);
      if (files == NULL)
  	goto fpip_end;
      old_files = max_path_depth;
***************
*** 5298,5305 ****
  		/* Push the new file onto the file stack */
  		if (depth + 1 == old_files)
  		{
! 		    bigger = (SearchedFile *)lalloc((long_u)(
! 			    max_path_depth * 2 * sizeof(SearchedFile)), TRUE);
  		    if (bigger != NULL)
  		    {
  			for (i = 0; i <= depth; i++)
--- 5298,5305 ----
  		/* Push the new file onto the file stack */
  		if (depth + 1 == old_files)
  		{
! 		    bigger = (SearchedFile *)alloc(
! 				    max_path_depth * 2 * sizeof(SearchedFile));
  		    if (bigger != NULL)
  		    {
  			for (i = 0; i <= depth; i++)
*** ../vim-8.1.1385/src/sign.c	2019-02-17 14:50:22.434125846 +0100
--- src/sign.c	2019-05-24 19:12:17.974288051 +0200
***************
*** 202,209 ****
  {
      signlist_T	*newsign;
  
!     newsign = (signlist_T *)lalloc_id((long_u)sizeof(signlist_T), FALSE,
! 							aid_insert_sign);
      if (newsign != NULL)
      {
  	newsign->id = id;
--- 202,209 ----
  {
      signlist_T	*newsign;
  
!     newsign = (signlist_T *)lalloc_id(sizeof(signlist_T), FALSE,
! 							      aid_insert_sign);
      if (newsign != NULL)
      {
  	newsign->id = id;
***************
*** 1057,1063 ****
  	    emsg(_("E934: Cannot jump to a buffer that does not have a name"));
  	    return -1;
  	}
! 	cmd = alloc((unsigned)STRLEN(buf->b_fname) + 25);
  	if (cmd == NULL)
  	    return -1;
  	sprintf((char *)cmd, "e +%ld %s", (long)lnum, buf->b_fname);
--- 1057,1063 ----
  	    emsg(_("E934: Cannot jump to a buffer that does not have a name"));
  	    return -1;
  	}
! 	cmd = alloc(STRLEN(buf->b_fname) + 25);
  	if (cmd == NULL)
  	    return -1;
  	sprintf((char *)cmd, "e +%ld %s", (long)lnum, buf->b_fname);
*** ../vim-8.1.1385/src/spell.c	2019-05-24 18:48:36.770128440 +0200
--- src/spell.c	2019-05-24 19:23:44.546493376 +0200
***************
*** 7820,7827 ****
  
      /* We use "cnt" as an array: CNT(badword_idx, goodword_idx). */
  #define CNT(a, b)   cnt[(a) + (b) * (badlen + 1)]
!     cnt = (int *)lalloc((long_u)(sizeof(int) * (badlen + 1) * (goodlen + 1)),
! 									TRUE);
      if (cnt == NULL)
  	return 0;	/* out of memory */
  
--- 7820,7826 ----
  
      /* We use "cnt" as an array: CNT(badword_idx, goodword_idx). */
  #define CNT(a, b)   cnt[(a) + (b) * (badlen + 1)]
!     cnt = (int *)alloc(sizeof(int) * (badlen + 1) * (goodlen + 1));
      if (cnt == NULL)
  	return 0;	/* out of memory */
  
*** ../vim-8.1.1385/src/spellfile.c	2019-05-24 18:48:36.770128440 +0200
--- src/spellfile.c	2019-05-24 19:34:19.294748935 +0200
***************
*** 892,899 ****
      if (cnt <= 0)
  	return SP_FORMERROR;
  
!     lp->sl_prefprog = (regprog_T **)alloc_clear(
! 					 (unsigned)sizeof(regprog_T *) * cnt);
      if (lp->sl_prefprog == NULL)
  	return SP_OTHERERROR;
      lp->sl_prefixcnt = cnt;
--- 892,898 ----
      if (cnt <= 0)
  	return SP_FORMERROR;
  
!     lp->sl_prefprog = (regprog_T **)alloc_clear(sizeof(regprog_T *) * cnt);
      if (lp->sl_prefprog == NULL)
  	return SP_OTHERERROR;
      lp->sl_prefixcnt = cnt;
***************
*** 1580,1592 ****
      if (len > 0)
      {
  	/* Allocate the byte array. */
! 	bp = lalloc((long_u)len, TRUE);
  	if (bp == NULL)
  	    return SP_OTHERERROR;
  	*bytsp = bp;
  
  	/* Allocate the index array. */
! 	ip = (idx_T *)lalloc_clear((long_u)(len * sizeof(int)), TRUE);
  	if (ip == NULL)
  	    return SP_OTHERERROR;
  	*idxsp = ip;
--- 1579,1591 ----
      if (len > 0)
      {
  	/* Allocate the byte array. */
! 	bp = alloc(len);
  	if (bp == NULL)
  	    return SP_OTHERERROR;
  	*bytsp = bp;
  
  	/* Allocate the index array. */
! 	ip = (idx_T *)lalloc_clear(len * sizeof(int), TRUE);
  	if (ip == NULL)
  	    return SP_OTHERERROR;
  	*idxsp = ip;
***************
*** 4272,4279 ****
  	    bl = NULL;
  	else
  	    /* Allocate a block of memory. It is not freed until much later. */
! 	    bl = (sblock_T *)alloc_clear(
! 				   (unsigned)(sizeof(sblock_T) + SBLOCKSIZE));
  	if (bl == NULL)
  	{
  	    if (!spin->si_did_emsg)
--- 4271,4277 ----
  	    bl = NULL;
  	else
  	    /* Allocate a block of memory. It is not freed until much later. */
! 	    bl = (sblock_T *)alloc_clear(sizeof(sblock_T) + SBLOCKSIZE);
  	if (bl == NULL)
  	{
  	    if (!spin->si_did_emsg)
*** ../vim-8.1.1385/src/syntax.c	2019-05-24 18:48:36.770128440 +0200
--- src/syntax.c	2019-05-24 19:34:47.590511163 +0200
***************
*** 1215,1221 ****
  		len = syn_block->b_sst_len - syn_block->b_sst_freecount + 2;
  	}
  
! 	sstp = (synstate_T *)alloc_clear((unsigned)(len * sizeof(synstate_T)));
  	if (sstp == NULL)	/* out of memory! */
  	    return;
  
--- 1215,1221 ----
  		len = syn_block->b_sst_len - syn_block->b_sst_freecount + 2;
  	}
  
! 	sstp = (synstate_T *)alloc_clear(len * sizeof(synstate_T));
  	if (sstp == NULL)	/* out of memory! */
  	    return;
  
***************
*** 5216,5222 ****
  	    }
  	    ppp->pp_next = pat_ptrs[item];
  	    pat_ptrs[item] = ppp;
! 	    ppp->pp_synp = (synpat_T *)alloc_clear((unsigned)sizeof(synpat_T));
  	    if (ppp->pp_synp == NULL)
  	    {
  		rest = NULL;
--- 5216,5222 ----
  	    }
  	    ppp->pp_next = pat_ptrs[item];
  	    pat_ptrs[item] = ppp;
! 	    ppp->pp_synp = (synpat_T *)alloc_clear(sizeof(synpat_T));
  	    if (ppp->pp_synp == NULL)
  	    {
  		rest = NULL;
*** ../vim-8.1.1385/src/tag.c	2019-05-23 21:35:44.459922615 +0200
--- src/tag.c	2019-05-24 19:24:03.026391715 +0200
***************
*** 2789,2796 ****
  	match_count = 0;
  
      if (match_count > 0)
! 	matches = (char_u **)lalloc((long_u)(match_count * sizeof(char_u *)),
! 									TRUE);
      else
  	matches = NULL;
      match_count = 0;
--- 2789,2795 ----
  	match_count = 0;
  
      if (match_count > 0)
! 	matches = (char_u **)alloc(match_count * sizeof(char_u *));
      else
  	matches = NULL;
      match_count = 0;
*** ../vim-8.1.1385/src/terminal.c	2019-05-13 20:27:19.216311194 +0200
--- src/terminal.c	2019-05-24 19:35:10.778319166 +0200
***************
*** 3925,3931 ****
      static void *
  vterm_malloc(size_t size, void *data UNUSED)
  {
!     return alloc_clear((unsigned) size);
  }
  
      static void
--- 3925,3931 ----
      static void *
  vterm_malloc(size_t size, void *data UNUSED)
  {
!     return alloc_clear(size);
  }
  
      static void
*** ../vim-8.1.1385/src/textprop.c	2019-05-24 13:22:17.863644567 +0200
--- src/textprop.c	2019-05-24 19:35:25.382199528 +0200
***************
*** 678,684 ****
  	    semsg(_("E969: Property type %s already defined"), name);
  	    return;
  	}
! 	prop = (proptype_T *)alloc_clear((int)(sizeof(proptype_T) + STRLEN(name)));
  	if (prop == NULL)
  	    return;
  	STRCPY(prop->pt_name, name);
--- 678,684 ----
  	    semsg(_("E969: Property type %s already defined"), name);
  	    return;
  	}
! 	prop = (proptype_T *)alloc_clear(sizeof(proptype_T) + STRLEN(name));
  	if (prop == NULL)
  	    return;
  	STRCPY(prop->pt_name, name);
*** ../vim-8.1.1385/src/ui.c	2019-04-28 19:46:17.034060084 +0200
--- src/ui.c	2019-05-24 19:24:10.754349196 +0200
***************
*** 1514,1520 ****
  	len *= 2;	/* max. 2 bytes per display cell */
      else if (enc_utf8)
  	len *= MB_MAXBYTES;
!     buffer = lalloc((long_u)len, TRUE);
      if (buffer == NULL)	    /* out of memory */
  	return;
  
--- 1514,1520 ----
  	len *= 2;	/* max. 2 bytes per display cell */
      else if (enc_utf8)
  	len *= MB_MAXBYTES;
!     buffer = alloc(len);
      if (buffer == NULL)	    /* out of memory */
  	return;
  
***************
*** 1897,1907 ****
      garray_T	*gap;
  
      /* We use a growarray to store the data pointer and the length. */
!     gap = (garray_T *)alloc((unsigned)sizeof(garray_T));
      if (gap != NULL)
      {
  	/* Add one to avoid a zero size. */
! 	gap->ga_data = alloc((unsigned)inbufcount + 1);
  	if (gap->ga_data != NULL)
  	    mch_memmove(gap->ga_data, inbuf, (size_t)inbufcount);
  	gap->ga_len = inbufcount;
--- 1897,1907 ----
      garray_T	*gap;
  
      /* We use a growarray to store the data pointer and the length. */
!     gap = (garray_T *)alloc(sizeof(garray_T));
      if (gap != NULL)
      {
  	/* Add one to avoid a zero size. */
! 	gap->ga_data = alloc(inbufcount + 1);
  	if (gap->ga_data != NULL)
  	    mch_memmove(gap->ga_data, inbuf, (size_t)inbufcount);
  	gap->ga_len = inbufcount;
*** ../vim-8.1.1385/src/undo.c	2019-05-24 18:48:36.774128421 +0200
--- src/undo.c	2019-05-24 19:35:38.430093446 +0200
***************
*** 124,130 ****
  static void unserialize_visualinfo(bufinfo_T *bi, visualinfo_T *info);
  #endif
  
! #define U_ALLOC_LINE(size) lalloc((long_u)(size), FALSE)
  
  /* used in undo_end() to report number of added and deleted lines */
  static long	u_newcount, u_oldcount;
--- 124,130 ----
  static void unserialize_visualinfo(bufinfo_T *bi, visualinfo_T *info);
  #endif
  
! #define U_ALLOC_LINE(size) lalloc(size, FALSE)
  
  /* used in undo_end() to report number of added and deleted lines */
  static long	u_newcount, u_oldcount;
***************
*** 2013,2020 ****
      }
  
  #ifdef U_DEBUG
!     uhp_table_used = (int *)alloc_clear(
! 				     (unsigned)(sizeof(int) * num_head + 1));
  # define SET_FLAG(j) ++uhp_table_used[j]
  #else
  # define SET_FLAG(j)
--- 2013,2019 ----
      }
  
  #ifdef U_DEBUG
!     uhp_table_used = (int *)alloc_clear(sizeof(int) * num_head + 1);
  # define SET_FLAG(j) ++uhp_table_used[j]
  #else
  # define SET_FLAG(j)
*** ../vim-8.1.1385/src/userfunc.c	2019-05-24 18:48:36.774128421 +0200
--- src/userfunc.c	2019-05-24 19:36:30.305678918 +0200
***************
*** 292,301 ****
  
  	sprintf((char*)name, "<lambda>%d", ++lambda_no);
  
! 	fp = (ufunc_T *)alloc_clear((unsigned)(sizeof(ufunc_T) + STRLEN(name)));
  	if (fp == NULL)
  	    goto errret;
! 	pt = (partial_T *)alloc_clear((unsigned)sizeof(partial_T));
  	if (pt == NULL)
  	    goto errret;
  
--- 292,301 ----
  
  	sprintf((char*)name, "<lambda>%d", ++lambda_no);
  
! 	fp = (ufunc_T *)alloc_clear(sizeof(ufunc_T) + STRLEN(name));
  	if (fp == NULL)
  	    goto errret;
! 	pt = (partial_T *)alloc_clear(sizeof(partial_T));
  	if (pt == NULL)
  	    goto errret;
  
***************
*** 2580,2586 ****
  	    }
  	}
  
! 	fp = (ufunc_T *)alloc_clear((unsigned)(sizeof(ufunc_T) + STRLEN(name)));
  	if (fp == NULL)
  	    goto erret;
  
--- 2580,2586 ----
  	    }
  	}
  
! 	fp = (ufunc_T *)alloc_clear(sizeof(ufunc_T) + STRLEN(name));
  	if (fp == NULL)
  	    goto erret;
  
***************
*** 2751,2764 ****
  	profile_zero(&fp->uf_tm_self);
  	profile_zero(&fp->uf_tm_total);
  	if (fp->uf_tml_count == NULL)
! 	    fp->uf_tml_count = (int *)alloc_clear(
! 					       (unsigned)(sizeof(int) * len));
  	if (fp->uf_tml_total == NULL)
  	    fp->uf_tml_total = (proftime_T *)alloc_clear(
! 					 (unsigned)(sizeof(proftime_T) * len));
  	if (fp->uf_tml_self == NULL)
  	    fp->uf_tml_self = (proftime_T *)alloc_clear(
! 					 (unsigned)(sizeof(proftime_T) * len));
  	fp->uf_tml_idx = -1;
  	if (fp->uf_tml_count == NULL || fp->uf_tml_total == NULL
  						    || fp->uf_tml_self == NULL)
--- 2751,2763 ----
  	profile_zero(&fp->uf_tm_self);
  	profile_zero(&fp->uf_tm_total);
  	if (fp->uf_tml_count == NULL)
! 	    fp->uf_tml_count = (int *)alloc_clear(sizeof(int) * len);
  	if (fp->uf_tml_total == NULL)
  	    fp->uf_tml_total = (proftime_T *)alloc_clear(
! 						     sizeof(proftime_T) * len);
  	if (fp->uf_tml_self == NULL)
  	    fp->uf_tml_self = (proftime_T *)alloc_clear(
! 						     sizeof(proftime_T) * len);
  	fp->uf_tml_idx = -1;
  	if (fp->uf_tml_count == NULL || fp->uf_tml_total == NULL
  						    || fp->uf_tml_self == NULL)
*** ../vim-8.1.1385/src/winclip.c	2019-05-24 18:48:36.774128421 +0200
--- src/winclip.c	2019-05-24 19:24:19.274302321 +0200
***************
*** 244,250 ****
      char_u	*retp;
  
      /* Avoid allocating zero bytes, it generates an error message. */
!     ret = lalloc((long_u)(str_len == 0 ? 1 : str_len), TRUE);
      if (ret != NULL)
      {
  	retp = ret;
--- 244,250 ----
      char_u	*retp;
  
      /* Avoid allocating zero bytes, it generates an error message. */
!     ret = alloc(str_len == 0 ? 1 : str_len);
      if (ret != NULL)
      {
  	retp = ret;
*** ../vim-8.1.1385/src/window.c	2019-05-18 15:36:06.493897710 +0200
--- src/window.c	2019-05-24 19:37:03.001423202 +0200
***************
*** 1065,1071 ****
      if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)
      {
  	/* Need to create a new frame in the tree to make a branch. */
! 	frp = (frame_T *)alloc_clear((unsigned)sizeof(frame_T));
  	*frp = *curfrp;
  	curfrp->fr_layout = layout;
  	frp->fr_parent = curfrp;
--- 1065,1071 ----
      if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)
      {
  	/* Need to create a new frame in the tree to make a branch. */
! 	frp = (frame_T *)alloc_clear(sizeof(frame_T));
  	*frp = *curfrp;
  	curfrp->fr_layout = layout;
  	frp->fr_parent = curfrp;
***************
*** 3549,3555 ****
      static void
  new_frame(win_T *wp)
  {
!     frame_T *frp = (frame_T *)alloc_clear((unsigned)sizeof(frame_T));
  
      wp->w_frame = frp;
      if (frp != NULL)
--- 3549,3555 ----
      static void
  new_frame(win_T *wp)
  {
!     frame_T *frp = (frame_T *)alloc_clear(sizeof(frame_T));
  
      wp->w_frame = frp;
      if (frp != NULL)
***************
*** 3584,3590 ****
  # endif
  
  
!     tp = (tabpage_T *)alloc_clear((unsigned)sizeof(tabpage_T));
      if (tp == NULL)
  	return NULL;
  
--- 3584,3590 ----
  # endif
  
  
!     tp = (tabpage_T *)alloc_clear(sizeof(tabpage_T));
      if (tp == NULL)
  	return NULL;
  
***************
*** 4597,4603 ****
      /*
       * allocate window structure and linesizes arrays
       */
!     new_wp = (win_T *)alloc_clear((unsigned)sizeof(win_T));
      if (new_wp == NULL)
  	return NULL;
  
--- 4597,4603 ----
      /*
       * allocate window structure and linesizes arrays
       */
!     new_wp = (win_T *)alloc_clear(sizeof(win_T));
      if (new_wp == NULL)
  	return NULL;
  
***************
*** 4898,4904 ****
  win_alloc_lines(win_T *wp)
  {
      wp->w_lines_valid = 0;
!     wp->w_lines = (wline_T *)alloc_clear((unsigned)(Rows * sizeof(wline_T)));
      if (wp->w_lines == NULL)
  	return FAIL;
      return OK;
--- 4898,4904 ----
  win_alloc_lines(win_T *wp)
  {
      wp->w_lines_valid = 0;
!     wp->w_lines = (wline_T *)alloc_clear(Rows * sizeof(wline_T));
      if (wp->w_lines == NULL)
  	return FAIL;
      return OK;
***************
*** 6280,6286 ****
      static void
  make_snapshot_rec(frame_T *fr, frame_T **frp)
  {
!     *frp = (frame_T *)alloc_clear((unsigned)sizeof(frame_T));
      if (*frp == NULL)
  	return;
      (*frp)->fr_layout = fr->fr_layout;
--- 6280,6286 ----
      static void
  make_snapshot_rec(frame_T *fr, frame_T **frp)
  {
!     *frp = (frame_T *)alloc_clear(sizeof(frame_T));
      if (*frp == NULL)
  	return;
      (*frp)->fr_layout = fr->fr_layout;
*** ../vim-8.1.1385/src/version.c	2019-05-24 19:04:25.644941435 +0200
--- src/version.c	2019-05-24 19:28:07.861045768 +0200
***************
*** 769,770 ****
--- 769,772 ----
  {   /* Add new patch number below this line */
+ /**/
+     1386,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
16. Have your coworkers address you by your wrestling name, Rock Hard Kim.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
